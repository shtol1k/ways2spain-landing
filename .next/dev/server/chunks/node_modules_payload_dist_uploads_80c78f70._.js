module.exports = [
"[project]/node_modules/payload/dist/uploads/fetchAPI-multipart/isEligibleRequest.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "isEligibleRequest",
    ()=>isEligibleRequest
]);
// eslint-disable-next-line regexp/no-super-linear-backtracking, regexp/no-obscure-range
const ACCEPTABLE_CONTENT_TYPE = /multipart\/['"()+-_]+(?:; ?['"()+-_]*)+$/i;
const UNACCEPTABLE_METHODS = new Set([
    'CONNECT',
    'DELETE',
    'GET',
    'HEAD',
    'OPTIONS',
    'TRACE'
]);
const hasBody = (req)=>{
    return Boolean(req.headers.get('transfer-encoding') || req.headers.get('content-length') && req.headers.get('content-length') !== '0');
};
const hasAcceptableMethod = (req)=>!UNACCEPTABLE_METHODS.has(req.method);
const hasAcceptableContentType = (req)=>{
    const contType = req.headers.get('content-type');
    return contType.includes('boundary=') && ACCEPTABLE_CONTENT_TYPE.test(contType);
};
const isEligibleRequest = (req)=>{
    try {
        return hasBody(req) && hasAcceptableMethod(req) && hasAcceptableContentType(req);
    } catch (ignore) {
        return false;
    }
}; //# sourceMappingURL=isEligibleRequest.js.map
}),
"[project]/node_modules/payload/dist/uploads/fetchAPI-multipart/utilities.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "buildFields",
    ()=>buildFields,
    "checkAndMakeDir",
    ()=>checkAndMakeDir,
    "debugLog",
    ()=>debugLog,
    "deleteFile",
    ()=>deleteFile,
    "getTempFilename",
    ()=>getTempFilename,
    "isFunc",
    ()=>isFunc,
    "isSafeFromPollution",
    ()=>isSafeFromPollution,
    "moveFile",
    ()=>moveFile,
    "parseFileName",
    ()=>parseFileName,
    "parseFileNameExtension",
    ()=>parseFileNameExtension,
    "promiseCallback",
    ()=>promiseCallback,
    "saveBufferToFile",
    ()=>saveBufferToFile
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/fs [external] (fs, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/path [external] (path, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/stream [external] (stream, cjs)");
;
;
;
// Parameters for safe file name parsing.
const SAFE_FILE_NAME_REGEX = /[^\w-]/g;
const MAX_EXTENSION_LENGTH = 3;
// Parameters to generate unique temporary file names:
const TEMP_COUNTER_MAX = 65536;
const TEMP_PREFIX = 'tmp';
let tempCounter = 0;
const debugLog = (options, msg)=>{
    const opts = options || {};
    if (!opts.debug) {
        return false;
    }
    console.log(`Next-file-upload: ${msg}`); // eslint-disable-line
    return true;
};
const getTempFilename = (prefix = TEMP_PREFIX)=>{
    tempCounter = tempCounter >= TEMP_COUNTER_MAX ? 1 : tempCounter + 1;
    return `${prefix}-${tempCounter}-${Date.now()}`;
};
const isFunc = (value)=>{
    return typeof value === 'function';
};
const errorFunc = (resolve, reject)=>isFunc(reject) ? reject : resolve;
const promiseCallback = (resolve, reject)=>{
    let hasFired = false;
    return (err)=>{
        if (hasFired) {
            return;
        }
        hasFired = true;
        return err ? errorFunc(resolve, reject)(err) : resolve();
    };
};
// The default prototypes for both objects and arrays.
// Used by isSafeFromPollution
const OBJECT_PROTOTYPE_KEYS = Object.getOwnPropertyNames(Object.prototype);
const ARRAY_PROTOTYPE_KEYS = Object.getOwnPropertyNames(Array.prototype);
const isSafeFromPollution = (base, key)=>{
    // We perform an instanceof check instead of Array.isArray as the former is more
    // permissive for cases in which the object as an Array prototype but was not constructed
    // via an Array constructor or literal.
    const TOUCHES_ARRAY_PROTOTYPE = base instanceof Array && ARRAY_PROTOTYPE_KEYS.includes(key);
    const TOUCHES_OBJECT_PROTOTYPE = OBJECT_PROTOTYPE_KEYS.includes(key);
    return !TOUCHES_ARRAY_PROTOTYPE && !TOUCHES_OBJECT_PROTOTYPE;
};
const buildFields = (instance, field, value)=>{
    // Do nothing if value is not set.
    if (value === null || value === undefined) {
        return instance;
    }
    instance = instance || Object.create(null);
    if (!isSafeFromPollution(instance, field)) {
        return instance;
    }
    // Non-array fields
    if (!instance[field]) {
        instance[field] = value;
        return instance;
    }
    // Array fields
    if (instance[field] instanceof Array) {
        instance[field].push(value);
    } else {
        instance[field] = [
            instance[field],
            value
        ];
    }
    return instance;
};
const checkAndMakeDir = (fileUploadOptions, filePath)=>{
    if (!fileUploadOptions.createParentPath) {
        return false;
    }
    // Check whether folder for the file exists.
    const parentPath = __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].dirname(filePath);
    // Create folder if it doesn't exist.
    if (!__TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"].existsSync(parentPath)) {
        __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"].mkdirSync(parentPath, {
            recursive: true
        });
    }
    // Checks folder again and return a results.
    return __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"].existsSync(parentPath);
};
const deleteFile = (filePath, callback)=>__TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"].unlink(filePath, callback);
const copyFile = (src, dst, callback)=>{
    // cbCalled flag and runCb helps to run cb only once.
    let cbCalled = false;
    const runCb = (err)=>{
        if (cbCalled) {
            return;
        }
        cbCalled = true;
        callback(err);
    };
    // Create read stream
    const readable = __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"].createReadStream(src);
    readable.on('error', runCb);
    // Create write stream
    const writable = __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"].createWriteStream(dst);
    writable.on('error', (err)=>{
        readable.destroy();
        runCb(err);
    });
    writable.on('close', ()=>runCb());
    // Copy file via piping streams.
    readable.pipe(writable);
};
const moveFile = (src, dst, callback)=>__TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"].rename(src, dst, (err)=>{
        if (err) {
            // Try to copy file if rename didn't work.
            copyFile(src, dst, (cpErr)=>cpErr ? callback(cpErr) : deleteFile(src, callback));
            return;
        }
        // File was renamed successfully: Add true to the callback to indicate that.
        callback(null, true);
    });
const saveBufferToFile = (buffer, filePath, callback)=>{
    if (!Buffer.isBuffer(buffer)) {
        return callback(new Error('buffer variable should be type of Buffer!'));
    }
    // Setup readable stream from buffer.
    let streamData = buffer;
    const readStream = new __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__["Readable"]();
    readStream._read = ()=>{
        readStream.push(streamData);
        streamData = null;
    };
    // Setup file system writable stream.
    const fstream = __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"].createWriteStream(filePath);
    // console.log("Calling saveBuffer");
    fstream.on('error', (err)=>{
        // console.log("err cb")
        callback(err);
    });
    fstream.on('close', ()=>{
        // console.log("close cb");
        callback();
    });
    // Copy file via piping streams.
    readStream.pipe(fstream);
};
/**
 * Decodes uriEncoded file names.
 * @param {Object} opts - middleware options.
 * @param fileName {String} - file name to decode.
 * @returns {String}
 */ const uriDecodeFileName = (opts, fileName)=>{
    if (!opts || !opts.uriDecodeFileNames) {
        return fileName;
    }
    // Decode file name from URI with checking URI malformed errors.
    // See Issue https://github.com/richardgirges/express-fileupload/issues/342.
    try {
        return decodeURIComponent(fileName);
    } catch (ignore) {
        const matcher = /(%[a-f\d]{2})/gi;
        return fileName.split(matcher).map((str)=>{
            try {
                return decodeURIComponent(str);
            } catch (ignore) {
                return '';
            }
        }).join('');
    }
};
const parseFileNameExtension = (preserveExtension, fileName)=>{
    const defaultResult = {
        name: fileName,
        extension: ''
    };
    if (!preserveExtension) {
        return defaultResult;
    }
    // Define maximum extension length
    const maxExtLength = typeof preserveExtension === 'boolean' ? MAX_EXTENSION_LENGTH : preserveExtension;
    const nameParts = fileName.split('.');
    if (nameParts.length < 2) {
        return defaultResult;
    }
    let extension = nameParts.pop();
    if (extension.length > maxExtLength && maxExtLength > 0) {
        nameParts[nameParts.length - 1] += '.' + extension.substr(0, extension.length - maxExtLength);
        extension = extension.substr(-maxExtLength);
    }
    return {
        name: nameParts.join('.'),
        extension: maxExtLength ? extension : ''
    };
};
const parseFileName = (opts, fileName)=>{
    // Check fileName argument
    if (!fileName || typeof fileName !== 'string') {
        return getTempFilename();
    }
    // Cut off file name if it's length more then 255.
    let parsedName = fileName.length <= 255 ? fileName : fileName.substr(0, 255);
    // Decode file name if uriDecodeFileNames option set true.
    parsedName = uriDecodeFileName(opts, parsedName);
    // Stop parsing file name if safeFileNames options hasn't been set.
    if (!opts.safeFileNames) {
        return parsedName;
    }
    // Set regular expression for the file name.
    const nameRegex = typeof opts.safeFileNames === 'object' && opts.safeFileNames instanceof RegExp ? opts.safeFileNames : SAFE_FILE_NAME_REGEX;
    // Parse file name extension.
    const parsedFileName = parseFileNameExtension(opts.preserveExtension, parsedName);
    if (parsedFileName.extension.length) {
        parsedFileName.extension = '.' + parsedFileName.extension.replace(nameRegex, '');
    }
    return parsedFileName.name.replace(nameRegex, '').concat(parsedFileName.extension);
}; //# sourceMappingURL=utilities.js.map
}),
"[project]/node_modules/payload/dist/uploads/fetchAPI-multipart/fileFactory.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "fileFactory",
    ()=>fileFactory
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$fetchAPI$2d$multipart$2f$utilities$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/payload/dist/uploads/fetchAPI-multipart/utilities.js [app-route] (ecmascript)");
;
/**
 * Returns Local function that moves the file to a different location on the filesystem
 * which takes two function arguments to make it compatible w/ Promise or Callback APIs
 */ const moveFromTemp = (filePath, options, fileUploadOptions)=>(resolve, reject)=>{
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$fetchAPI$2d$multipart$2f$utilities$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["debugLog"])(fileUploadOptions, `Moving temporary file ${options.tempFilePath} to ${filePath}`);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$fetchAPI$2d$multipart$2f$utilities$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["moveFile"])(options.tempFilePath, filePath, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$fetchAPI$2d$multipart$2f$utilities$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["promiseCallback"])(resolve, reject));
    };
/**
 * Returns Local function that moves the file from buffer to a different location on the filesystem
 * which takes two function arguments to make it compatible w/ Promise or Callback APIs
 */ const moveFromBuffer = (filePath, options, fileUploadOptions)=>(resolve, reject)=>{
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$fetchAPI$2d$multipart$2f$utilities$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["debugLog"])(fileUploadOptions, `Moving uploaded buffer to ${filePath}`);
        // @ts-expect-error - vestiges of when tsconfig was not strict. Feel free to improve
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$fetchAPI$2d$multipart$2f$utilities$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["saveBufferToFile"])(options.buffer, filePath, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$fetchAPI$2d$multipart$2f$utilities$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["promiseCallback"])(resolve, reject));
    };
const fileFactory = (options, fileUploadOptions)=>{
    // see: https://github.com/richardgirges/express-fileupload/issues/14
    // firefox uploads empty file in case of cache miss when f5ing page.
    // resulting in unexpected behavior. if there is no file data, the file is invalid.
    // if (!fileUploadOptions.useTempFiles && !options.buffer.length) return;
    // Create and return file object.
    return {
        name: options.name,
        data: options.buffer,
        encoding: options.encoding,
        md5: options.hash,
        mimetype: options.mimetype,
        mv: (filePath, callback)=>{
            // Define a proper move function.
            const moveFunc = fileUploadOptions.useTempFiles ? moveFromTemp(filePath, options, fileUploadOptions) : moveFromBuffer(filePath, options, fileUploadOptions);
            // Create a folder for a file.
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$fetchAPI$2d$multipart$2f$utilities$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["checkAndMakeDir"])(fileUploadOptions, filePath);
            // If callback is passed in, use the callback API, otherwise return a promise.
            const defaultReject = ()=>undefined;
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$fetchAPI$2d$multipart$2f$utilities$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isFunc"])(callback) ? moveFunc(callback, defaultReject) : new Promise(moveFunc);
        },
        size: options.size,
        tempFilePath: options.tempFilePath,
        truncated: options.truncated
    };
}; //# sourceMappingURL=fileFactory.js.map
}),
"[project]/node_modules/payload/dist/uploads/fetchAPI-multipart/handlers.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "memHandler",
    ()=>memHandler,
    "tempFileHandler",
    ()=>tempFileHandler
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$crypto__$5b$external$5d$__$28$crypto$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/crypto [external] (crypto, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/fs [external] (fs, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/path [external] (path, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$fetchAPI$2d$multipart$2f$utilities$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/payload/dist/uploads/fetchAPI-multipart/utilities.js [app-route] (ecmascript)");
;
;
;
;
const tempFileHandler = (options, fieldname, filename)=>{
    const dir = __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].normalize(options.tempFileDir);
    const tempFilePath = __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].join(process.cwd(), dir, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$fetchAPI$2d$multipart$2f$utilities$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getTempFilename"])());
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$fetchAPI$2d$multipart$2f$utilities$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["checkAndMakeDir"])({
        createParentPath: true
    }, tempFilePath);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$fetchAPI$2d$multipart$2f$utilities$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["debugLog"])(options, `Temporary file path is ${tempFilePath}`);
    const hash = __TURBOPACK__imported__module__$5b$externals$5d2f$crypto__$5b$external$5d$__$28$crypto$2c$__cjs$29$__["default"].createHash('md5');
    let fileSize = 0;
    let completed = false;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$fetchAPI$2d$multipart$2f$utilities$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["debugLog"])(options, `Opening write stream for ${fieldname}->${filename}...`);
    const writeStream = __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"].createWriteStream(tempFilePath);
    const writePromise = new Promise((resolve, reject)=>{
        writeStream.on('finish', ()=>resolve(true));
        writeStream.on('error', (err)=>{
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$fetchAPI$2d$multipart$2f$utilities$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["debugLog"])(options, `Error write temp file: ${err}`);
            reject(err);
        });
    });
    return {
        cleanup: ()=>{
            completed = true;
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$fetchAPI$2d$multipart$2f$utilities$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["debugLog"])(options, `Cleaning up temporary file ${tempFilePath}...`);
            writeStream.end();
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$fetchAPI$2d$multipart$2f$utilities$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["deleteFile"])(tempFilePath, (err)=>err ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$fetchAPI$2d$multipart$2f$utilities$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["debugLog"])(options, `Cleaning up temporary file ${tempFilePath} failed: ${err}`) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$fetchAPI$2d$multipart$2f$utilities$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["debugLog"])(options, `Cleaning up temporary file ${tempFilePath} done.`));
        },
        complete: ()=>{
            completed = true;
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$fetchAPI$2d$multipart$2f$utilities$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["debugLog"])(options, `Upload ${fieldname}->${filename} completed, bytes:${fileSize}.`);
            if (writeStream instanceof __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["WriteStream"]) {
                writeStream.end();
            }
            // Return empty buff since data was uploaded into a temp file.
            return Buffer.concat([]);
        },
        dataHandler: (data)=>{
            if (completed === true) {
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$fetchAPI$2d$multipart$2f$utilities$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["debugLog"])(options, `Error: got ${fieldname}->${filename} data chunk for completed upload!`);
                return;
            }
            writeStream.write(data);
            hash.update(data);
            fileSize += data.length;
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$fetchAPI$2d$multipart$2f$utilities$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["debugLog"])(options, `Uploading ${fieldname}->${filename}, bytes:${fileSize}...`);
        },
        getFilePath: ()=>tempFilePath,
        getFileSize: ()=>fileSize,
        getHash: ()=>hash.digest('hex'),
        getWritePromise: ()=>writePromise
    };
};
const memHandler = (options, fieldname, filename)=>{
    const buffers = [];
    const hash = __TURBOPACK__imported__module__$5b$externals$5d2f$crypto__$5b$external$5d$__$28$crypto$2c$__cjs$29$__["default"].createHash('md5');
    let fileSize = 0;
    let completed = false;
    const getBuffer = ()=>Buffer.concat(buffers, fileSize);
    return {
        cleanup: ()=>{
            completed = true;
        },
        complete: ()=>{
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$fetchAPI$2d$multipart$2f$utilities$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["debugLog"])(options, `Upload ${fieldname}->${filename} completed, bytes:${fileSize}.`);
            completed = true;
            return getBuffer();
        },
        dataHandler: (data)=>{
            if (completed === true) {
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$fetchAPI$2d$multipart$2f$utilities$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["debugLog"])(options, `Error: got ${fieldname}->${filename} data chunk for completed upload!`);
                return;
            }
            buffers.push(data);
            hash.update(data);
            fileSize += data.length;
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$fetchAPI$2d$multipart$2f$utilities$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["debugLog"])(options, `Uploading ${fieldname}->${filename}, bytes:${fileSize}...`);
        },
        getFilePath: ()=>'',
        getFileSize: ()=>fileSize,
        getHash: ()=>hash.digest('hex'),
        getWritePromise: ()=>Promise.resolve(true)
    };
}; //# sourceMappingURL=handlers.js.map
}),
"[project]/node_modules/payload/dist/uploads/fetchAPI-multipart/processNested.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "processNested",
    ()=>processNested
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$fetchAPI$2d$multipart$2f$utilities$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/payload/dist/uploads/fetchAPI-multipart/utilities.js [app-route] (ecmascript)");
;
const processNested = function(data) {
    if (!data || data.length < 1) {
        return Object.create(null);
    }
    const d = Object.create(null), keys = Object.keys(data);
    for(let i = 0; i < keys.length; i++){
        const key = keys[i], keyParts = key?.replace(new RegExp(/\[/g), '.').replace(new RegExp(/\]/g), '').split('.'), value = data[key];
        let current = d;
        for(let index = 0; index < keyParts.length; index++){
            const k = keyParts[index];
            // Ensure we don't allow prototype pollution
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$fetchAPI$2d$multipart$2f$utilities$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isSafeFromPollution"])(current, k)) {
                continue;
            }
            if (index >= keyParts.length - 1) {
                current[k] = value;
            } else {
                if (!current[k]) {
                    current[k] = !keyParts[index + 1] ? [] : Object.create(null);
                }
                current = current[k];
            }
        }
    }
    return d;
}; //# sourceMappingURL=processNested.js.map
}),
"[project]/node_modules/payload/dist/uploads/fetchAPI-multipart/uploadTimer.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createUploadTimer",
    ()=>createUploadTimer
]);
const createUploadTimer = (timeout = 0, callback = ()=>{})=>{
    let timer = null;
    const clear = ()=>{
        clearTimeout(timer);
    };
    const set = ()=>{
        // Do not start a timer if zero timeout or it hasn't been set.
        if (!timeout) {
            return false;
        }
        clear();
        timer = setTimeout(callback, timeout);
        return true;
    };
    return {
        clear,
        set
    };
}; //# sourceMappingURL=uploadTimer.js.map
}),
"[project]/node_modules/payload/dist/uploads/fetchAPI-multipart/processMultipart.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "processMultipart",
    ()=>processMultipart
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$busboy$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/busboy/lib/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$http$2d$status$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/http-status/dist/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$http$2d$status$2f$dist$2f$chunk$2d$CUNVWAK5$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__a__as__status$3e$__ = __turbopack_context__.i("[project]/node_modules/http-status/dist/chunk-CUNVWAK5.js [app-route] (ecmascript) <export a as status>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$errors$2f$APIError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/payload/dist/errors/APIError.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$fetchAPI$2d$multipart$2f$fileFactory$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/payload/dist/uploads/fetchAPI-multipart/fileFactory.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$fetchAPI$2d$multipart$2f$handlers$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/payload/dist/uploads/fetchAPI-multipart/handlers.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$fetchAPI$2d$multipart$2f$processNested$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/payload/dist/uploads/fetchAPI-multipart/processNested.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$fetchAPI$2d$multipart$2f$uploadTimer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/payload/dist/uploads/fetchAPI-multipart/uploadTimer.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$fetchAPI$2d$multipart$2f$utilities$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/payload/dist/uploads/fetchAPI-multipart/utilities.js [app-route] (ecmascript)");
;
;
;
;
;
;
;
;
const waitFlushProperty = Symbol('wait flush property symbol');
const processMultipart = async ({ options, request })=>{
    let parsingRequest = true;
    let shouldAbortProccessing = false;
    let fileCount = 0;
    let filesCompleted = 0;
    let allFilesHaveResolved;
    let failedResolvingFiles;
    const allFilesComplete = new Promise((res, rej)=>{
        allFilesHaveResolved = res;
        failedResolvingFiles = rej;
    });
    const result = {
        fields: undefined,
        files: undefined
    };
    const headersObject = {};
    request.headers.forEach((value, name)=>{
        headersObject[name] = value;
    });
    const reader = request.body?.getReader();
    const busboy = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$busboy$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])({
        ...options,
        headers: headersObject
    });
    function abortAndDestroyFile(file, err) {
        file.destroy();
        shouldAbortProccessing = true;
        failedResolvingFiles(err);
    }
    // Build multipart req.body fields
    busboy.on('field', (field, val)=>{
        result.fields = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$fetchAPI$2d$multipart$2f$utilities$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["buildFields"])(result.fields, field, val);
    });
    // Build req.files fields
    busboy.on('file', (field, file, info)=>{
        fileCount += 1;
        // Parse file name(cutting huge names, decoding, etc..).
        const { encoding, filename: name, mimeType: mime } = info;
        const filename = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$fetchAPI$2d$multipart$2f$utilities$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parseFileName"])(options, name);
        const inferredMimeType = filename && filename.endsWith('.glb') && 'model/gltf-binary' || filename && filename.endsWith('.gltf') && 'model/gltf+json' || mime;
        // Define methods and handlers for upload process.
        const { cleanup, complete, dataHandler, getFilePath, getFileSize, getHash, getWritePromise } = options.useTempFiles ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$fetchAPI$2d$multipart$2f$handlers$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["tempFileHandler"])(options, field, filename) // Upload into temporary file.
         : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$fetchAPI$2d$multipart$2f$handlers$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["memHandler"])(options, field, filename) // Upload into RAM.
        ;
        const writePromise = options.useTempFiles ? getWritePromise().catch(()=>{
            busboy.end();
            cleanup();
        }) : getWritePromise();
        const uploadTimer = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$fetchAPI$2d$multipart$2f$uploadTimer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createUploadTimer"])(options.uploadTimeout, ()=>{
            return abortAndDestroyFile(file, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$errors$2f$APIError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"](`Upload timeout for ${field}->${filename}, bytes:${getFileSize()}`));
        });
        file.on('limit', ()=>{
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$fetchAPI$2d$multipart$2f$utilities$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["debugLog"])(options, `Size limit reached for ${field}->${filename}, bytes:${getFileSize()}`);
            uploadTimer.clear();
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$fetchAPI$2d$multipart$2f$utilities$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isFunc"])(options.limitHandler)) {
                options.limitHandler({
                    request,
                    size: getFileSize()
                });
            }
            // Return error and cleanup files if abortOnLimit set.
            if (options.abortOnLimit) {
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$fetchAPI$2d$multipart$2f$utilities$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["debugLog"])(options, `Upload file size limit reached ${field}->${filename}.`);
                cleanup();
                abortAndDestroyFile(file, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$errors$2f$APIError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"](options.responseOnLimit, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$http$2d$status$2f$dist$2f$chunk$2d$CUNVWAK5$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__a__as__status$3e$__["status"].REQUEST_ENTITY_TOO_LARGE, {
                    size: getFileSize()
                }));
            }
        });
        file.on('data', (data)=>{
            uploadTimer.set();
            dataHandler(data);
        });
        file.on('end', ()=>{
            const size = getFileSize();
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$fetchAPI$2d$multipart$2f$utilities$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["debugLog"])(options, `Upload finished ${field}->${filename}, bytes:${size}`);
            uploadTimer.clear();
            if (!name && size === 0) {
                fileCount -= 1;
                if (options.useTempFiles) {
                    cleanup();
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$fetchAPI$2d$multipart$2f$utilities$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["debugLog"])(options, `Removing the empty file ${field}->${filename}`);
                }
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$fetchAPI$2d$multipart$2f$utilities$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["debugLog"])(options, `Don't add file instance if original name and size are empty`);
            }
            filesCompleted += 1;
            result.files = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$fetchAPI$2d$multipart$2f$utilities$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["buildFields"])(result.files, field, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$fetchAPI$2d$multipart$2f$fileFactory$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["fileFactory"])({
                name: filename,
                buffer: complete(),
                encoding,
                hash: getHash(),
                mimetype: inferredMimeType,
                size,
                tempFilePath: getFilePath(),
                truncated: Boolean('truncated' in file && file.truncated) || false
            }, options));
            if (!request[waitFlushProperty]) {
                request[waitFlushProperty] = [];
            }
            request[waitFlushProperty].push(writePromise);
            if (filesCompleted === fileCount) {
                allFilesHaveResolved();
            }
        });
        file.on('error', (err)=>{
            uploadTimer.clear();
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$fetchAPI$2d$multipart$2f$utilities$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["debugLog"])(options, `File Error: ${err.message}`);
            cleanup();
            failedResolvingFiles(err);
        });
        // Start upload process.
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$fetchAPI$2d$multipart$2f$utilities$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["debugLog"])(options, `New upload started ${field}->${filename}, bytes:${getFileSize()}`);
        uploadTimer.set();
    });
    busboy.on('finish', async ()=>{
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$fetchAPI$2d$multipart$2f$utilities$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["debugLog"])(options, `Busboy finished parsing request.`);
        if (options.parseNested) {
            result.fields = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$fetchAPI$2d$multipart$2f$processNested$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["processNested"])(result.fields);
            result.files = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$fetchAPI$2d$multipart$2f$processNested$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["processNested"])(result.files);
        }
        if (request[waitFlushProperty]) {
            try {
                await Promise.all(request[waitFlushProperty]).then(()=>{
                    delete request[waitFlushProperty];
                });
            } catch (err) {
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$fetchAPI$2d$multipart$2f$utilities$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["debugLog"])(options, `Error waiting for file write promises: ${err}`);
            }
        }
        return result;
    });
    busboy.on('error', (err = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$errors$2f$APIError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"]('Busboy error parsing multipart request', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$http$2d$status$2f$dist$2f$chunk$2d$CUNVWAK5$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__a__as__status$3e$__["status"].BAD_REQUEST))=>{
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$fetchAPI$2d$multipart$2f$utilities$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["debugLog"])(options, `Busboy error`);
        throw err;
    });
    while(parsingRequest){
        const { done, value } = await reader.read();
        if (done) {
            parsingRequest = false;
        }
        if (value && !shouldAbortProccessing) {
            busboy.write(value);
        }
    }
    if (fileCount !== 0) {
        await allFilesComplete.catch((e)=>{
            throw e;
        });
    }
    return result;
}; //# sourceMappingURL=processMultipart.js.map
}),
"[project]/node_modules/payload/dist/uploads/fetchAPI-multipart/index.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "processMultipartFormdata",
    ()=>processMultipartFormdata
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/path [external] (path, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$errors$2f$APIError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/payload/dist/errors/APIError.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$fetchAPI$2d$multipart$2f$isEligibleRequest$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/payload/dist/uploads/fetchAPI-multipart/isEligibleRequest.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$fetchAPI$2d$multipart$2f$processMultipart$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/payload/dist/uploads/fetchAPI-multipart/processMultipart.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$fetchAPI$2d$multipart$2f$utilities$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/payload/dist/uploads/fetchAPI-multipart/utilities.js [app-route] (ecmascript)");
;
;
;
;
;
const DEFAULT_UPLOAD_OPTIONS = {
    abortOnLimit: false,
    createParentPath: false,
    debug: false,
    defParamCharset: 'utf8',
    limitHandler: false,
    parseNested: false,
    preserveExtension: false,
    responseOnLimit: 'File size limit has been reached',
    safeFileNames: false,
    tempFileDir: __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].join(process.cwd(), 'tmp'),
    uploadTimeout: 60000,
    uriDecodeFileNames: false,
    useTempFiles: false
};
const processMultipartFormdata = async ({ options: incomingOptions, request })=>{
    const options = {
        ...DEFAULT_UPLOAD_OPTIONS,
        ...incomingOptions
    };
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$fetchAPI$2d$multipart$2f$isEligibleRequest$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isEligibleRequest"])(request)) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$fetchAPI$2d$multipart$2f$utilities$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["debugLog"])(options, 'Request is not eligible for file upload!');
        return {
            error: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$errors$2f$APIError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"]('Request is not eligible for file upload', 500),
            fields: undefined,
            files: undefined
        };
    } else {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$fetchAPI$2d$multipart$2f$processMultipart$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["processMultipart"])({
            options,
            request
        });
    }
}; //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/payload/dist/uploads/checkFileAccess.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "checkFileAccess",
    ()=>checkFileAccess
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$auth$2f$executeAccess$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/payload/dist/auth/executeAccess.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$errors$2f$Forbidden$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/payload/dist/errors/Forbidden.js [app-route] (ecmascript)");
;
;
const checkFileAccess = async ({ collection, filename, req })=>{
    if (filename.includes('../') || filename.includes('..\\')) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$errors$2f$Forbidden$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Forbidden"](req.t);
    }
    const { config } = collection;
    const accessResult = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$auth$2f$executeAccess$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["executeAccess"])({
        data: {
            filename
        },
        isReadingStaticFile: true,
        req
    }, config.access.read);
    if (typeof accessResult === 'object') {
        const queryToBuild = {
            and: [
                {
                    or: [
                        {
                            filename: {
                                equals: filename
                            }
                        }
                    ]
                },
                accessResult
            ]
        };
        if (config.upload.imageSizes) {
            config.upload.imageSizes.forEach(({ name })=>{
                queryToBuild.and?.[0]?.or?.push({
                    [`sizes.${name}.filename`]: {
                        equals: filename
                    }
                });
            });
        }
        const doc = await req.payload.db.findOne({
            collection: config.slug,
            req,
            where: queryToBuild
        });
        if (!doc) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$errors$2f$Forbidden$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Forbidden"](req.t);
        }
        return doc;
    }
}; //# sourceMappingURL=checkFileAccess.js.map
}),
"[project]/node_modules/payload/dist/uploads/fetchAPI-stream-file/index.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "iteratorToStream",
    ()=>iteratorToStream,
    "nodeStreamToIterator",
    ()=>nodeStreamToIterator,
    "streamFile",
    ()=>streamFile
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/fs [external] (fs, cjs)");
;
function iteratorToStream(iterator) {
    return new ReadableStream({
        async pull (controller) {
            const { done, value } = await iterator.next();
            if (done) {
                controller.close();
            } else {
                controller.enqueue(value);
            }
        }
    });
}
async function* nodeStreamToIterator(stream) {
    for await (const chunk of stream){
        yield new Uint8Array(chunk);
    }
}
function streamFile({ filePath, options }) {
    const nodeStream = __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"].createReadStream(filePath, options);
    const data = iteratorToStream(nodeStreamToIterator(nodeStream));
    return data;
} //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/payload/dist/uploads/getFileTypeFallback.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getFileTypeFallback",
    ()=>getFileTypeFallback
]);
const extensionMap = {
    css: 'text/css',
    csv: 'text/csv',
    htm: 'text/html',
    html: 'text/html',
    js: 'application/javascript',
    json: 'application/json',
    md: 'text/markdown',
    svg: 'image/svg+xml',
    xml: 'application/xml',
    yml: 'application/x-yaml'
};
const getFileTypeFallback = (path)=>{
    const ext = path.split('.').pop() || 'txt';
    return {
        ext,
        mime: extensionMap[ext] || 'text/plain'
    };
}; //# sourceMappingURL=getFileTypeFallback.js.map
}),
"[project]/node_modules/payload/dist/uploads/parseRangeHeader.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "parseRangeHeader",
    ()=>parseRangeHeader
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$range$2d$parser$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/range-parser/index.js [app-route] (ecmascript)");
;
function parseRangeHeader({ fileSize, rangeHeader }) {
    // No Range header - serve full file
    if (!rangeHeader) {
        return {
            type: 'full',
            range: null
        };
    }
    const result = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$range$2d$parser$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(fileSize, rangeHeader);
    // Invalid range syntax or unsatisfiable range
    if (result === -1 || result === -2) {
        return {
            type: 'invalid',
            range: null
        };
    }
    // Must be bytes range type
    if (result.type !== 'bytes' || result.length === 0) {
        return {
            type: 'invalid',
            range: null
        };
    }
    // Multi-range requests: use first range only (standard simplification)
    const range = result[0];
    if (!range) {
        return {
            type: 'invalid',
            range: null
        };
    }
    return {
        type: 'partial',
        range: {
            end: range.end,
            start: range.start
        }
    };
} //# sourceMappingURL=parseRangeHeader.js.map
}),
"[project]/node_modules/payload/dist/uploads/endpoints/getFile.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getFileHandler",
    ()=>getFileHandler
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$file$2d$type$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/file-type/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$externals$5d2f$fs$2f$promises__$5b$external$5d$__$28$fs$2f$promises$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/fs/promises [external] (fs/promises, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$http$2d$status$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/http-status/dist/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$http$2d$status$2f$dist$2f$chunk$2d$CUNVWAK5$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__a__as__status$3e$__ = __turbopack_context__.i("[project]/node_modules/http-status/dist/chunk-CUNVWAK5.js [app-route] (ecmascript) <export a as status>");
var __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/path [external] (path, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$errors$2f$APIError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/payload/dist/errors/APIError.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$checkFileAccess$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/payload/dist/uploads/checkFileAccess.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$fetchAPI$2d$stream$2d$file$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/payload/dist/uploads/fetchAPI-stream-file/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$getFileTypeFallback$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/payload/dist/uploads/getFileTypeFallback.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$parseRangeHeader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/payload/dist/uploads/parseRangeHeader.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$utilities$2f$getRequestEntity$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/payload/dist/utilities/getRequestEntity.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$utilities$2f$headersWithCors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/payload/dist/utilities/headersWithCors.js [app-route] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
const getFileHandler = async (req)=>{
    const collection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$utilities$2f$getRequestEntity$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getRequestCollection"])(req);
    const filename = req.routeParams?.filename;
    if (!collection.config.upload) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$errors$2f$APIError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"](`This collection is not an upload collection: ${collection.config.slug}`, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$http$2d$status$2f$dist$2f$chunk$2d$CUNVWAK5$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__a__as__status$3e$__["status"].BAD_REQUEST);
    }
    const accessResult = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$checkFileAccess$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["checkFileAccess"])({
        collection,
        filename,
        req
    });
    if (accessResult instanceof Response) {
        return accessResult;
    }
    if (collection.config.upload.handlers?.length) {
        let customResponse = null;
        const headers = new Headers();
        for (const handler of collection.config.upload.handlers){
            customResponse = await handler(req, {
                doc: accessResult,
                headers,
                params: {
                    collection: collection.config.slug,
                    filename
                }
            });
            if (customResponse && customResponse instanceof Response) {
                break;
            }
        }
        if (customResponse instanceof Response) {
            return customResponse;
        }
    }
    const fileDir = collection.config.upload?.staticDir || collection.config.slug;
    const filePath = __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].resolve(`${fileDir}/${filename}`);
    let stats;
    try {
        stats = await __TURBOPACK__imported__module__$5b$externals$5d2f$fs$2f$promises__$5b$external$5d$__$28$fs$2f$promises$2c$__cjs$29$__["default"].stat(filePath);
    } catch (err) {
        if (err.code === 'ENOENT') {
            req.payload.logger.error(`File ${filename} for collection ${collection.config.slug} is missing on the disk. Expected path: ${filePath}`);
            // Omit going to the routeError handler by returning response instead of
            // throwing an error to cut down log noise. The response still matches what you get with APIError to not leak details to the user.
            return Response.json({
                errors: [
                    {
                        message: 'Something went wrong.'
                    }
                ]
            }, {
                headers: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$utilities$2f$headersWithCors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["headersWithCors"])({
                    headers: new Headers(),
                    req
                }),
                status: 500
            });
        }
        throw err;
    }
    const fileTypeResult = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$file$2d$type$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["fileTypeFromFile"])(filePath) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$getFileTypeFallback$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getFileTypeFallback"])(filePath);
    let mimeType = fileTypeResult.mime;
    if (filePath.endsWith('.svg') && fileTypeResult.mime === 'application/xml') {
        mimeType = 'image/svg+xml';
    }
    // Parse Range header for byte range requests
    const rangeHeader = req.headers.get('range');
    const rangeResult = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$parseRangeHeader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parseRangeHeader"])({
        fileSize: stats.size,
        rangeHeader
    });
    if (rangeResult.type === 'invalid') {
        let headers = new Headers();
        headers.set('Content-Range', `bytes */${stats.size}`);
        headers = collection.config.upload?.modifyResponseHeaders ? collection.config.upload.modifyResponseHeaders({
            headers
        }) || headers : headers;
        return new Response(null, {
            headers: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$utilities$2f$headersWithCors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["headersWithCors"])({
                headers,
                req
            }),
            status: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$http$2d$status$2f$dist$2f$chunk$2d$CUNVWAK5$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__a__as__status$3e$__["status"].REQUESTED_RANGE_NOT_SATISFIABLE
        });
    }
    let headers = new Headers();
    headers.set('Content-Type', mimeType);
    headers.set('Accept-Ranges', 'bytes');
    let data;
    let status;
    const isPartial = rangeResult.type === 'partial';
    const range = rangeResult.range;
    if (isPartial && range) {
        const contentLength = range.end - range.start + 1;
        headers.set('Content-Length', String(contentLength));
        headers.set('Content-Range', `bytes ${range.start}-${range.end}/${stats.size}`);
        data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$fetchAPI$2d$stream$2d$file$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["streamFile"])({
            filePath,
            options: {
                end: range.end,
                start: range.start
            }
        });
        status = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$http$2d$status$2f$dist$2f$chunk$2d$CUNVWAK5$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__a__as__status$3e$__["status"].PARTIAL_CONTENT;
    } else {
        headers.set('Content-Length', String(stats.size));
        data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$fetchAPI$2d$stream$2d$file$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["streamFile"])({
            filePath
        });
        status = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$http$2d$status$2f$dist$2f$chunk$2d$CUNVWAK5$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__a__as__status$3e$__["status"].OK;
    }
    headers = collection.config.upload?.modifyResponseHeaders ? collection.config.upload.modifyResponseHeaders({
        headers
    }) || headers : headers;
    return new Response(data, {
        headers: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$utilities$2f$headersWithCors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["headersWithCors"])({
            headers,
            req
        }),
        status
    });
}; //# sourceMappingURL=getFile.js.map
}),
"[project]/node_modules/payload/dist/uploads/endpoints/getFileFromURL.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getFileFromURLHandler",
    ()=>getFileFromURLHandler
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$auth$2f$executeAccess$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/payload/dist/auth/executeAccess.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$errors$2f$APIError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/payload/dist/errors/APIError.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$errors$2f$Forbidden$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/payload/dist/errors/Forbidden.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$utilities$2f$getRequestEntity$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/payload/dist/utilities/getRequestEntity.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$utilities$2f$isURLAllowed$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/payload/dist/utilities/isURLAllowed.js [app-route] (ecmascript)");
;
;
;
;
;
const getFileFromURLHandler = async (req)=>{
    const { id, collection } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$utilities$2f$getRequestEntity$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getRequestCollectionWithID"])(req, {
        optionalID: true
    });
    if (!req.user) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$errors$2f$Forbidden$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Forbidden"](req.t);
    }
    const config = collection?.config;
    if (id) {
        // updating doc
        const accessResult = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$auth$2f$executeAccess$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["executeAccess"])({
            req
        }, config.access.update);
        if (!accessResult) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$errors$2f$Forbidden$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Forbidden"](req.t);
        }
    } else {
        // creating doc
        const accessResult = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$auth$2f$executeAccess$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["executeAccess"])({
            req
        }, config.access?.create);
        if (!accessResult) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$errors$2f$Forbidden$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Forbidden"](req.t);
        }
    }
    try {
        if (!req.url) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$errors$2f$APIError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"]('Request URL is missing.', 400);
        }
        const { searchParams } = new URL(req.url);
        const src = searchParams.get('src');
        if (!src || typeof src !== 'string') {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$errors$2f$APIError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"]('A valid URL string is required.', 400);
        }
        const validatedUrl = new URL(src);
        if (typeof config.upload?.pasteURL === 'object' && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$utilities$2f$isURLAllowed$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isURLAllowed"])(validatedUrl.href, config.upload.pasteURL.allowList)) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$errors$2f$APIError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"](`The provided URL (${validatedUrl.href}) is not allowed.`, 400);
        }
        // Fetch the file with no compression
        const response = await fetch(validatedUrl.href, {
            headers: {
                'Accept-Encoding': 'identity'
            }
        });
        if (!response.ok) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$errors$2f$APIError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"](`Failed to fetch file from ${validatedUrl.href}`, response.status);
        }
        const decodedFileName = decodeURIComponent(validatedUrl.pathname.split('/').pop() || '');
        return new Response(response.body, {
            headers: {
                'Content-Disposition': `attachment; filename="${decodedFileName}"`,
                'Content-Length': response.headers.get('content-length') || '',
                'Content-Type': response.headers.get('content-type') || 'application/octet-stream'
            }
        });
    } catch (err) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$errors$2f$APIError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"](`Error fetching file: ${err instanceof Error ? err.message : 'Unknown error'}`, 500);
    }
}; //# sourceMappingURL=getFileFromURL.js.map
}),
"[project]/node_modules/payload/dist/uploads/endpoints/index.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "uploadCollectionEndpoints",
    ()=>uploadCollectionEndpoints
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$utilities$2f$wrapInternalEndpoints$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/payload/dist/utilities/wrapInternalEndpoints.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$endpoints$2f$getFile$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/payload/dist/uploads/endpoints/getFile.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$endpoints$2f$getFileFromURL$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/payload/dist/uploads/endpoints/getFileFromURL.js [app-route] (ecmascript)");
;
;
;
const uploadCollectionEndpoints = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$utilities$2f$wrapInternalEndpoints$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["wrapInternalEndpoints"])([
    {
        handler: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$endpoints$2f$getFileFromURL$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getFileFromURLHandler"],
        method: 'get',
        path: '/paste-url/:id?'
    },
    {
        handler: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$endpoints$2f$getFile$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getFileHandler"],
        method: 'get',
        path: '/file/:filename'
    }
]); //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/payload/dist/uploads/generateFilePathOrURL.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "generateFilePathOrURL",
    ()=>generateFilePathOrURL
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$utilities$2f$formatAdminURL$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/payload/dist/utilities/formatAdminURL.js [app-route] (ecmascript)");
;
function generateFilePathOrURL({ collectionSlug, config, filename, relative, serverURL, urlOrPath }) {
    if (urlOrPath) {
        if (!urlOrPath.startsWith('/') && !urlOrPath.startsWith(serverURL || '')) {
            // external url
            return urlOrPath;
        }
    }
    if (filename) {
        // local file url
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$utilities$2f$formatAdminURL$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["formatAdminURL"])({
            apiRoute: config.routes?.api || '',
            path: `/${collectionSlug}/file/${encodeURIComponent(filename)}`,
            relative,
            serverURL: config.serverURL
        });
    }
    return null;
} //# sourceMappingURL=generateFilePathOrURL.js.map
}),
"[project]/node_modules/payload/dist/uploads/mimeTypeValidator.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "mimeTypeValidator",
    ()=>mimeTypeValidator
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$utilities$2f$validateMimeType$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/payload/dist/utilities/validateMimeType.js [app-route] (ecmascript)");
;
const mimeTypeValidator = (mimeTypes)=>(val, { siblingData })=>{
        if (!siblingData.filename) {
            return true;
        }
        if (!val) {
            return 'Invalid file type';
        }
        const isValidMimeType = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$utilities$2f$validateMimeType$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["validateMimeType"])(val, mimeTypes);
        return isValidMimeType ? true : `Invalid file type: '${val}'`;
    }; //# sourceMappingURL=mimeTypeValidator.js.map
}),
"[project]/node_modules/payload/dist/uploads/getBaseFields.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getBaseUploadFields",
    ()=>getBaseUploadFields
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$generateFilePathOrURL$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/payload/dist/uploads/generateFilePathOrURL.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$mimeTypeValidator$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/payload/dist/uploads/mimeTypeValidator.js [app-route] (ecmascript)");
;
;
const getBaseUploadFields = ({ collection, config })=>{
    const uploadOptions = typeof collection.upload === 'object' ? collection.upload : {};
    const mimeType = {
        name: 'mimeType',
        type: 'text',
        admin: {
            hidden: true,
            readOnly: true
        },
        label: 'MIME Type'
    };
    const thumbnailURL = {
        name: 'thumbnailURL',
        type: 'text',
        admin: {
            hidden: true,
            readOnly: true
        },
        hooks: {
            afterRead: [
                ({ originalDoc, req })=>{
                    const adminThumbnail = typeof collection.upload !== 'boolean' ? collection.upload?.adminThumbnail : undefined;
                    if (typeof adminThumbnail === 'function') {
                        return adminThumbnail({
                            doc: originalDoc
                        });
                    }
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$generateFilePathOrURL$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["generateFilePathOrURL"])({
                        collectionSlug: collection.slug,
                        config,
                        filename: typeof adminThumbnail === 'string' ? originalDoc.sizes?.[adminThumbnail].filename : undefined,
                        relative: false,
                        serverURL: req.payload.config.serverURL,
                        urlOrPath: typeof adminThumbnail === 'string' ? originalDoc.sizes?.[adminThumbnail].url : undefined
                    });
                }
            ]
        },
        label: 'Thumbnail URL'
    };
    const width = {
        name: 'width',
        type: 'number',
        admin: {
            hidden: true,
            readOnly: true
        },
        label: ({ t })=>t('upload:width')
    };
    const height = {
        name: 'height',
        type: 'number',
        admin: {
            hidden: true,
            readOnly: true
        },
        label: ({ t })=>t('upload:height')
    };
    const filesize = {
        name: 'filesize',
        type: 'number',
        admin: {
            hidden: true,
            readOnly: true
        },
        label: ({ t })=>t('upload:fileSize')
    };
    const filename = {
        name: 'filename',
        type: 'text',
        admin: {
            disableBulkEdit: true,
            hidden: true,
            readOnly: true
        },
        index: true,
        label: ({ t })=>t('upload:fileName')
    };
    // Only set unique: true if the collection does not have a compound index
    if (collection.upload === true || typeof collection.upload === 'object' && !collection.upload.filenameCompoundIndex) {
        filename.unique = true;
    }
    const url = {
        name: 'url',
        type: 'text',
        admin: {
            hidden: true,
            readOnly: true
        },
        label: 'URL'
    };
    let uploadFields = [
        {
            ...url,
            hooks: {
                afterRead: [
                    ({ data, originalDoc, req, value })=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$generateFilePathOrURL$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["generateFilePathOrURL"])({
                            collectionSlug: collection.slug,
                            config,
                            filename: data?.filename || originalDoc?.filename,
                            relative: false,
                            serverURL: req.payload.config.serverURL,
                            urlOrPath: value
                        })
                ],
                beforeChange: [
                    ({ collection, data, originalDoc, req, value })=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$generateFilePathOrURL$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["generateFilePathOrURL"])({
                            collectionSlug: collection?.slug,
                            config,
                            filename: data?.filename || originalDoc?.filename,
                            relative: true,
                            serverURL: req.payload.config.serverURL,
                            urlOrPath: value
                        })
                ]
            }
        },
        thumbnailURL,
        filename,
        mimeType,
        filesize,
        width,
        height
    ];
    // Add focal point fields if not disabled
    if (uploadOptions.focalPoint !== false || uploadOptions.imageSizes || uploadOptions.resizeOptions) {
        uploadFields = uploadFields.concat([
            'focalX',
            'focalY'
        ].map((name)=>{
            return {
                name,
                type: 'number',
                admin: {
                    disableGroupBy: true,
                    disableListColumn: true,
                    disableListFilter: true,
                    hidden: true
                }
            };
        }));
    }
    if (uploadOptions.mimeTypes) {
        mimeType.validate = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$mimeTypeValidator$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["mimeTypeValidator"])(uploadOptions.mimeTypes);
    }
    // In Payload v4, image size subfields (`url`, `width`, `height`, etc.) should
    // default to `disableGroupBy: true`, `disableListColumn: true` and `disableListFilter: true`
    // to avoid cluttering the collection list view and filters by default.
    if (uploadOptions.imageSizes) {
        uploadFields = uploadFields.concat([
            {
                name: 'sizes',
                type: 'group',
                admin: {
                    hidden: true
                },
                fields: uploadOptions.imageSizes.map((size)=>({
                        name: size.name,
                        type: 'group',
                        admin: {
                            hidden: true,
                            ...size.admin?.disableGroupBy && {
                                disableGroupBy: true
                            },
                            ...size.admin?.disableListColumn && {
                                disableListColumn: true
                            },
                            ...size.admin?.disableListFilter && {
                                disableListFilter: true
                            }
                        },
                        fields: [
                            {
                                ...url,
                                admin: {
                                    ...url.admin,
                                    ...size.admin?.disableGroupBy && {
                                        disableGroupBy: true
                                    },
                                    ...size.admin?.disableListColumn && {
                                        disableListColumn: true
                                    },
                                    ...size.admin?.disableListFilter && {
                                        disableListFilter: true
                                    }
                                },
                                hooks: {
                                    afterRead: [
                                        ({ collection, data, originalDoc, req, value })=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$generateFilePathOrURL$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["generateFilePathOrURL"])({
                                                collectionSlug: collection?.slug,
                                                config,
                                                filename: data?.sizes?.[size.name]?.filename || originalDoc?.sizes?.[size.name]?.filename,
                                                relative: false,
                                                serverURL: req.payload.config.serverURL,
                                                urlOrPath: value
                                            })
                                    ],
                                    beforeChange: [
                                        ({ collection, data, originalDoc, req, value })=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$generateFilePathOrURL$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["generateFilePathOrURL"])({
                                                collectionSlug: collection?.slug,
                                                config,
                                                filename: data?.sizes?.[size.name]?.filename || originalDoc?.sizes?.[size.name]?.filename || data?.filename || originalDoc?.filename,
                                                relative: true,
                                                serverURL: req.payload.config.serverURL,
                                                urlOrPath: value
                                            })
                                    ]
                                }
                            },
                            {
                                ...width,
                                admin: {
                                    ...width.admin,
                                    ...size.admin?.disableGroupBy && {
                                        disableGroupBy: true
                                    },
                                    ...size.admin?.disableListColumn && {
                                        disableListColumn: true
                                    },
                                    ...size.admin?.disableListFilter && {
                                        disableListFilter: true
                                    }
                                }
                            },
                            {
                                ...height,
                                admin: {
                                    ...height.admin,
                                    ...size.admin?.disableGroupBy && {
                                        disableGroupBy: true
                                    },
                                    ...size.admin?.disableListColumn && {
                                        disableListColumn: true
                                    },
                                    ...size.admin?.disableListFilter && {
                                        disableListFilter: true
                                    }
                                }
                            },
                            {
                                ...mimeType,
                                admin: {
                                    ...mimeType.admin,
                                    ...size.admin?.disableGroupBy && {
                                        disableGroupBy: true
                                    },
                                    ...size.admin?.disableListColumn && {
                                        disableListColumn: true
                                    },
                                    ...size.admin?.disableListFilter && {
                                        disableListFilter: true
                                    }
                                }
                            },
                            {
                                ...filesize,
                                admin: {
                                    ...filesize.admin,
                                    ...size.admin?.disableGroupBy && {
                                        disableGroupBy: true
                                    },
                                    ...size.admin?.disableListColumn && {
                                        disableListColumn: true
                                    },
                                    ...size.admin?.disableListFilter && {
                                        disableListFilter: true
                                    }
                                }
                            },
                            {
                                ...filename,
                                admin: {
                                    ...filename.admin,
                                    ...size.admin?.disableGroupBy && {
                                        disableGroupBy: true
                                    },
                                    ...size.admin?.disableListColumn && {
                                        disableListColumn: true
                                    },
                                    ...size.admin?.disableListFilter && {
                                        disableListFilter: true
                                    }
                                },
                                unique: false
                            }
                        ],
                        label: size.name
                    })),
                label: ({ t })=>t('upload:sizes')
            }
        ]);
    }
    return uploadFields;
}; //# sourceMappingURL=getBaseFields.js.map
}),
"[project]/node_modules/payload/dist/uploads/canResizeImage.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "canResizeImage",
    ()=>canResizeImage
]);
function canResizeImage(mimeType) {
    return [
        'image/jpeg',
        'image/png',
        'image/gif',
        'image/webp',
        'image/tiff',
        'image/avif'
    ].indexOf(mimeType) > -1;
} //# sourceMappingURL=canResizeImage.js.map
}),
"[project]/node_modules/payload/dist/uploads/detectSvgFromXml.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Securely detect if an XML buffer contains a valid SVG document
 */ __turbopack_context__.s([
    "detectSvgFromXml",
    ()=>detectSvgFromXml
]);
function detectSvgFromXml(buffer) {
    try {
        // Limit buffer size to prevent processing large malicious files
        const maxSize = 2048;
        const content = buffer.toString('utf8', 0, Math.min(buffer.length, maxSize));
        // Check for XML declaration and extract encoding if present
        const xmlDeclMatch = content.match(/^<\?xml[^>]*encoding=["']([^"']+)["']/i);
        const declaredEncoding = xmlDeclMatch?.[1]?.toLowerCase();
        // Only support safe encodings
        if (declaredEncoding && ![
            'ascii',
            'utf-8',
            'utf8'
        ].includes(declaredEncoding)) {
            return false;
        }
        // Remove XML declarations, comments, and processing instructions
        const cleanContent = content.replace(/<\?xml[^>]*\?>/gi, '').replace(/<!--[\s\S]*?-->/g, '').replace(/<\?[^>]*\?>/g, '').trim();
        // Find the first actual element (root element)
        const rootElementMatch = cleanContent.match(/^<(\w+)(?:\s|>)/);
        if (!rootElementMatch || rootElementMatch[1] !== 'svg') {
            return false;
        }
        // Validate SVG namespace - must be present for valid SVG
        const svgNamespaceRegex = /xmlns=["']http:\/\/www\.w3\.org\/2000\/svg["']/;
        if (!svgNamespaceRegex.test(content)) {
            return false;
        }
        // Additional validation: ensure it's not malformed
        const svgOpenTag = content.match(/<svg[\s>]/);
        if (!svgOpenTag) {
            return false;
        }
        return true;
    } catch (_error) {
        // If any error occurs during parsing, treat as not SVG
        return false;
    }
} //# sourceMappingURL=detectSvgFromXml.js.map
}),
"[project]/node_modules/payload/dist/uploads/validateSvg.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Validate SVG content for security vulnerabilities
 * Detects and blocks malicious patterns commonly used in SVG-based attacks
 */ __turbopack_context__.s([
    "validateSvg",
    ()=>validateSvg
]);
function validateSvg(buffer) {
    try {
        const content = buffer.toString('utf8');
        const dangerousPatterns = [
            // Script tags
            /<script[\s>]/i,
            /<\/script>/i,
            // Event handlers (onclick, onload, onerror, etc.)
            /\son\w+\s*=/i,
            // JavaScript URLs
            /javascript:/i,
            /data:text\/html/i,
            // Foreign objects (can embed HTML)
            /<foreignObject[\s>]/i,
            // Embedded iframes
            /<iframe[\s>]/i,
            // Embedded objects and embeds
            /<object[\s>]/i,
            /<embed[\s>]/i,
            // Base64 encoded scripts (common obfuscation technique)
            /data:image\/svg\+xml;base64,[\w+/]*PHNjcmlwdA/i,
            // XLink href with javascript (deprecated but still dangerous)
            /xlink:href\s*=\s*["']javascript:/i,
            // Import statements
            /@import/i,
            // External resource references that could be dangerous
            /<!ENTITY/i,
            /<!DOCTYPE[^>]*\[/i,
            // Attempt to use CDATA to hide scripts
            /<!\[CDATA\[[\s\S]*<script/i
        ];
        for (const pattern of dangerousPatterns){
            if (pattern.test(content)) {
                return false;
            }
        }
        return true;
    } catch (_error) {
        return false;
    }
} //# sourceMappingURL=validateSvg.js.map
}),
"[project]/node_modules/payload/dist/uploads/checkFileRestrictions.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "RESTRICTED_FILE_EXT_AND_TYPES",
    ()=>RESTRICTED_FILE_EXT_AND_TYPES,
    "checkFileRestrictions",
    ()=>checkFileRestrictions
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$file$2d$type$2f$core$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/file-type/core.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$errors$2f$ValidationError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/payload/dist/errors/ValidationError.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$utilities$2f$validateMimeType$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/payload/dist/utilities/validateMimeType.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$utilities$2f$validatePDF$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/payload/dist/utilities/validatePDF.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$detectSvgFromXml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/payload/dist/uploads/detectSvgFromXml.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$getFileTypeFallback$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/payload/dist/uploads/getFileTypeFallback.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$validateSvg$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/payload/dist/uploads/validateSvg.js [app-route] (ecmascript)");
;
;
;
;
;
;
;
const RESTRICTED_FILE_EXT_AND_TYPES = [
    {
        extensions: [
            'exe',
            'dll'
        ],
        mimeType: 'application/x-msdownload'
    },
    {
        extensions: [
            'exe',
            'com',
            'app',
            'action'
        ],
        mimeType: 'application/x-executable'
    },
    {
        extensions: [
            'bat',
            'cmd'
        ],
        mimeType: 'application/x-msdos-program'
    },
    {
        extensions: [
            'exe',
            'com'
        ],
        mimeType: 'application/x-ms-dos-executable'
    },
    {
        extensions: [
            'dmg'
        ],
        mimeType: 'application/x-apple-diskimage'
    },
    {
        extensions: [
            'deb'
        ],
        mimeType: 'application/x-debian-package'
    },
    {
        extensions: [
            'rpm'
        ],
        mimeType: 'application/x-redhat-package-manager'
    },
    {
        extensions: [
            'exe',
            'dll'
        ],
        mimeType: 'application/vnd.microsoft.portable-executable'
    },
    {
        extensions: [
            'msi'
        ],
        mimeType: 'application/x-msi'
    },
    {
        extensions: [
            'jar',
            'ear',
            'war'
        ],
        mimeType: 'application/java-archive'
    },
    {
        extensions: [
            'desktop'
        ],
        mimeType: 'application/x-desktop'
    },
    {
        extensions: [
            'cpl'
        ],
        mimeType: 'application/x-cpl'
    },
    {
        extensions: [
            'lnk'
        ],
        mimeType: 'application/x-ms-shortcut'
    },
    {
        extensions: [
            'pkg'
        ],
        mimeType: 'application/x-apple-installer'
    },
    {
        extensions: [
            'htm',
            'html',
            'shtml',
            'xhtml'
        ],
        mimeType: 'text/html'
    },
    {
        extensions: [
            'php',
            'phtml'
        ],
        mimeType: 'application/x-httpd-php'
    },
    {
        extensions: [
            'js',
            'jse'
        ],
        mimeType: 'text/javascript'
    },
    {
        extensions: [
            'jsp'
        ],
        mimeType: 'application/x-jsp'
    },
    {
        extensions: [
            'py'
        ],
        mimeType: 'text/x-python'
    },
    {
        extensions: [
            'rb'
        ],
        mimeType: 'text/x-ruby'
    },
    {
        extensions: [
            'pl'
        ],
        mimeType: 'text/x-perl'
    },
    {
        extensions: [
            'ps1',
            'psc1',
            'psd1',
            'psh',
            'psm1'
        ],
        mimeType: 'application/x-powershell'
    },
    {
        extensions: [
            'vbe',
            'vbs'
        ],
        mimeType: 'application/x-vbscript'
    },
    {
        extensions: [
            'ws',
            'wsc',
            'wsf',
            'wsh'
        ],
        mimeType: 'application/x-ms-wsh'
    },
    {
        extensions: [
            'scr'
        ],
        mimeType: 'application/x-msdownload'
    },
    {
        extensions: [
            'asp',
            'aspx'
        ],
        mimeType: 'application/x-asp'
    },
    {
        extensions: [
            'hta'
        ],
        mimeType: 'application/x-hta'
    },
    {
        extensions: [
            'reg'
        ],
        mimeType: 'application/x-registry'
    },
    {
        extensions: [
            'url'
        ],
        mimeType: 'application/x-url'
    },
    {
        extensions: [
            'workflow'
        ],
        mimeType: 'application/x-workflow'
    },
    {
        extensions: [
            'command'
        ],
        mimeType: 'application/x-command'
    }
];
const checkFileRestrictions = async ({ collection, file, req })=>{
    const errors = [];
    const { upload: uploadConfig } = collection;
    const useTempFiles = req?.payload?.config?.upload?.useTempFiles ?? false;
    const configMimeTypes = uploadConfig && typeof uploadConfig === 'object' && 'mimeTypes' in uploadConfig && Array.isArray(uploadConfig.mimeTypes) ? uploadConfig.mimeTypes : [];
    const allowRestrictedFileTypes = uploadConfig && typeof uploadConfig === 'object' && 'allowRestrictedFileTypes' in uploadConfig ? uploadConfig.allowRestrictedFileTypes : false;
    const expectsDetectableType = (mimeType)=>{
        const textBasedTypes = [
            '/svg',
            'image/svg+xml',
            'image/x-xbitmap',
            'image/x-xpixmap'
        ];
        if (textBasedTypes.includes(mimeType)) {
            return false;
        }
        return mimeType.startsWith('image/') || mimeType.startsWith('video/') || mimeType.startsWith('audio/') || mimeType === 'application/pdf';
    };
    // Skip validation if `allowRestrictedFileTypes` is true
    if (allowRestrictedFileTypes) {
        return;
    }
    // Secondary mimetype check to assess file type from buffer
    if (configMimeTypes.length > 0) {
        let detected = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$file$2d$type$2f$core$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["fileTypeFromBuffer"])(file.data);
        const typeFromExtension = file.name.split('.').pop() || '';
        // Handle SVG files that are detected as XML due to <?xml declarations
        if (detected?.mime === 'application/xml' && configMimeTypes.some((type)=>type.includes('image/') && (type.includes('svg') || type === 'image/*'))) {
            const isSvg = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$detectSvgFromXml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["detectSvgFromXml"])(file.data);
            if (isSvg) {
                detected = {
                    ext: 'svg',
                    mime: 'image/svg+xml'
                };
            }
        }
        if (!detected && !useTempFiles) {
            const mimeTypeFromExtension = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$getFileTypeFallback$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getFileTypeFallback"])(file.name).mime;
            const extIsValid = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$utilities$2f$validateMimeType$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["validateMimeType"])(mimeTypeFromExtension, configMimeTypes);
            if (!extIsValid) {
                errors.push(`File type ${mimeTypeFromExtension} (from extension ${typeFromExtension}) is not allowed.`);
            } else {
                // SVG security check (text-based files not detectable by buffer)
                if (typeFromExtension.toLowerCase() === 'svg') {
                    const isSafeSvg = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$validateSvg$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["validateSvg"])(file.data);
                    if (!isSafeSvg) {
                        errors.push('SVG file contains potentially harmful content.');
                    }
                }
                // PDF validation
                if (mimeTypeFromExtension === 'application/pdf') {
                    const isValidPDF = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$utilities$2f$validatePDF$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["validatePDF"])(file.data);
                    if (!isValidPDF) {
                        errors.push('Invalid or corrupted PDF file.');
                    }
                }
            }
            if (expectsDetectableType(mimeTypeFromExtension)) {
                req.payload.logger.warn(`File buffer returned no detectable MIME type for ${file.name}. Falling back to extension-based validation.`);
            }
        }
        const passesMimeTypeCheck = detected?.mime && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$utilities$2f$validateMimeType$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["validateMimeType"])(detected.mime, configMimeTypes);
        if (passesMimeTypeCheck && detected?.mime === 'application/pdf') {
            const isValidPDF = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$utilities$2f$validatePDF$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["validatePDF"])(file?.data);
            if (!isValidPDF) {
                errors.push('Invalid PDF file.');
            }
        }
        if (detected && !passesMimeTypeCheck) {
            errors.push(`Invalid MIME type: ${detected.mime}.`);
        }
    } else {
        const isRestricted = RESTRICTED_FILE_EXT_AND_TYPES.some((type)=>{
            const hasRestrictedExt = type.extensions.some((ext)=>file.name.toLowerCase().endsWith(ext));
            const hasRestrictedMime = type.mimeType === file.mimetype;
            return hasRestrictedExt || hasRestrictedMime;
        });
        if (isRestricted) {
            errors.push(`File type '${file.mimetype}' not allowed ${file.name}: Restricted file type detected -- set 'allowRestrictedFileTypes' to true to skip this check for this Collection.`);
        }
    }
    if (errors.length > 0) {
        req.payload.logger.error(errors.join(', '));
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$errors$2f$ValidationError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ValidationError"]({
            errors: [
                {
                    message: errors.join(', '),
                    path: 'file'
                }
            ]
        });
    }
}; //# sourceMappingURL=checkFileRestrictions.js.map
}),
"[project]/node_modules/payload/dist/uploads/optionallyAppendMetadata.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "optionallyAppendMetadata",
    ()=>optionallyAppendMetadata
]);
async function optionallyAppendMetadata({ req, sharpFile, withMetadata }) {
    const metadata = await sharpFile.metadata();
    if (withMetadata === true) {
        return sharpFile.withMetadata();
    } else if (typeof withMetadata === 'function') {
        const useMetadata = await withMetadata({
            metadata,
            req
        });
        if (useMetadata) {
            return sharpFile.withMetadata();
        }
    }
    return sharpFile;
} //# sourceMappingURL=optionallyAppendMetadata.js.map
}),
"[project]/node_modules/payload/dist/uploads/cropImage.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "cropImage",
    ()=>cropImage
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$optionallyAppendMetadata$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/payload/dist/uploads/optionallyAppendMetadata.js [app-route] (ecmascript)");
;
const percentToPixel = (value, dimension)=>{
    return Math.floor(value / 100 * dimension);
};
async function cropImage({ cropData, dimensions, file: fileArg, heightInPixels, req, sharp, widthInPixels, withMetadata }) {
    try {
        const { x, y } = cropData;
        const file = fileArg;
        const fileIsAnimatedType = [
            'image/avif',
            'image/gif',
            'image/webp'
        ].includes(file.mimetype);
        const sharpOptions = {};
        if (fileIsAnimatedType) {
            sharpOptions.animated = true;
        }
        const { height: originalHeight, width: originalWidth } = dimensions;
        const newWidth = Number(widthInPixels);
        const newHeight = Number(heightInPixels);
        const dimensionsChanged = originalWidth !== newWidth || originalHeight !== newHeight;
        if (!dimensionsChanged) {
            let adjustedHeight = originalHeight;
            if (fileIsAnimatedType) {
                const animatedMetadata = await sharp(file.tempFilePath || file.data, sharpOptions).metadata();
                adjustedHeight = animatedMetadata.pages ? animatedMetadata.height : originalHeight;
            }
            return {
                data: file.data,
                info: {
                    height: adjustedHeight,
                    size: file.size,
                    width: originalWidth
                }
            };
        }
        const formattedCropData = {
            height: Number(heightInPixels),
            left: percentToPixel(x, dimensions.width),
            top: percentToPixel(y, dimensions.height),
            width: Number(widthInPixels)
        };
        let cropped = sharp(file.tempFilePath || file.data, sharpOptions).extract(formattedCropData);
        cropped = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$optionallyAppendMetadata$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["optionallyAppendMetadata"])({
            req: req,
            sharpFile: cropped,
            withMetadata: withMetadata
        });
        return await cropped.toBuffer({
            resolveWithObject: true
        });
    } catch (error) {
        console.error(`Error cropping image:`, error);
        throw error;
    }
} //# sourceMappingURL=cropImage.js.map
}),
"[project]/node_modules/payload/dist/uploads/safeFetch.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "_internal_safeFetchGlobal",
    ()=>_internal_safeFetchGlobal,
    "safeFetch",
    ()=>safeFetch
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$dns__$5b$external$5d$__$28$dns$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/dns [external] (dns, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$node_modules$2f$ipaddr$2e$js$2f$lib$2f$ipaddr$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/payload/node_modules/ipaddr.js/lib/ipaddr.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$undici$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/undici/index.js [app-route] (ecmascript)");
;
;
;
const _internal_safeFetchGlobal = {
    lookup: __TURBOPACK__imported__module__$5b$externals$5d2f$dns__$5b$external$5d$__$28$dns$2c$__cjs$29$__["lookup"]
};
const isSafeIp = (ip)=>{
    try {
        if (!ip) {
            return false;
        }
        if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$node_modules$2f$ipaddr$2e$js$2f$lib$2f$ipaddr$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].isValid(ip)) {
            return false;
        }
        const parsedIpAddress = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$node_modules$2f$ipaddr$2e$js$2f$lib$2f$ipaddr$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].parse(ip);
        const range = parsedIpAddress.range();
        if (range !== 'unicast') {
            return false // Private IP Range
            ;
        }
    } catch (ignore) {
        return false;
    }
    return true;
};
const ssrfFilterInterceptor = (hostname, options, callback)=>{
    _internal_safeFetchGlobal.lookup(hostname, options, (err, address, family)=>{
        if (err) {
            callback(err, address, family);
        } else {
            let ips = [];
            if (Array.isArray(address)) {
                ips = address.map((a)=>a.address);
            } else {
                ips = [
                    address
                ];
            }
            if (ips.some((ip)=>!isSafeIp(ip))) {
                callback(new Error(`Blocked unsafe attempt to ${hostname}`), address, family);
                return;
            }
            callback(null, address, family);
        }
    });
};
const safeDispatcher = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$undici$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Agent"]({
    connect: {
        lookup: ssrfFilterInterceptor
    }
});
const safeFetch = async (...args)=>{
    const [unverifiedUrl, options] = args;
    try {
        const url = new URL(unverifiedUrl);
        let hostname = url.hostname;
        // Strip brackets from IPv6 addresses (e.g., "[::1]" => "::1")
        if (hostname.startsWith('[') && hostname.endsWith(']')) {
            hostname = hostname.slice(1, -1);
        }
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$node_modules$2f$ipaddr$2e$js$2f$lib$2f$ipaddr$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].isValid(hostname)) {
            if (!isSafeIp(hostname)) {
                throw new Error(`Blocked unsafe attempt to ${hostname}`);
            }
        }
        return await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$undici$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["fetch"])(url, {
            ...options,
            dispatcher: safeDispatcher
        });
    } catch (error) {
        if (error instanceof Error) {
            if (error.cause instanceof Error && error.cause.message.includes('unsafe')) {
                // Errors thrown from within interceptors always have 'fetch error' as the message
                // The desired message we want to bubble up is in the cause
                throw new Error(error.cause.message);
            } else {
                let stringifiedUrl = undefined;
                if (typeof unverifiedUrl === 'string') {
                    stringifiedUrl = unverifiedUrl;
                } else if (unverifiedUrl instanceof URL) {
                    stringifiedUrl = unverifiedUrl.toString();
                } else if (unverifiedUrl instanceof Request) {
                    stringifiedUrl = unverifiedUrl.url;
                }
                throw new Error(`Failed to fetch from ${stringifiedUrl}, ${error.message}`);
            }
        }
        throw error;
    }
}; //# sourceMappingURL=safeFetch.js.map
}),
"[project]/node_modules/payload/dist/uploads/getExternalFile.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getExternalFile",
    ()=>getExternalFile
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$errors$2f$APIError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/payload/dist/errors/APIError.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$utilities$2f$isURLAllowed$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/payload/dist/utilities/isURLAllowed.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$safeFetch$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/payload/dist/uploads/safeFetch.js [app-route] (ecmascript)");
;
;
;
const getExternalFile = async ({ data, req, uploadConfig })=>{
    const { filename, url } = data;
    let trimAuthCookies = true;
    if (typeof url === 'string') {
        let fileURL = url;
        if (!url.startsWith('http')) {
            // URL points to the same server - we can send any cookies safely to our server.
            trimAuthCookies = false;
            const baseUrl = req.headers.get('origin') || `${req.protocol}://${req.headers.get('host')}`;
            fileURL = `${baseUrl}${url}`;
        }
        let cookies = (req.headers.get('cookie') ?? '').split(';');
        if (trimAuthCookies) {
            cookies = cookies.filter((cookie)=>!cookie.trim().startsWith(req.payload.config.cookiePrefix));
        }
        const headers = uploadConfig.externalFileHeaderFilter ? uploadConfig.externalFileHeaderFilter(Object.fromEntries(new Headers(req.headers))) : {
            cookie: cookies.join(';')
        };
        // Check if URL is allowed because of skipSafeFetch allowList
        const skipSafeFetch = uploadConfig.skipSafeFetch === true ? uploadConfig.skipSafeFetch : Array.isArray(uploadConfig.skipSafeFetch) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$utilities$2f$isURLAllowed$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isURLAllowed"])(fileURL, uploadConfig.skipSafeFetch);
        // Check if URL is allowed because of pasteURL allowList
        const isAllowedPasteUrl = uploadConfig.pasteURL && uploadConfig.pasteURL.allowList && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$utilities$2f$isURLAllowed$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isURLAllowed"])(fileURL, uploadConfig.pasteURL.allowList);
        let res;
        if (skipSafeFetch || isAllowedPasteUrl) {
            // Allowed
            res = await fetch(fileURL, {
                credentials: 'include',
                headers,
                method: 'GET'
            });
        } else {
            // Default
            res = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$safeFetch$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["safeFetch"])(fileURL, {
                credentials: 'include',
                headers,
                method: 'GET'
            });
        }
        if (!res.ok) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$errors$2f$APIError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"](`Failed to fetch file from ${fileURL}`, res.status);
        }
        const data = await res.arrayBuffer();
        return {
            name: filename,
            data: Buffer.from(data),
            mimetype: res.headers.get('content-type') || undefined,
            size: Number(res.headers.get('content-length')) || 0
        };
    }
    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$errors$2f$APIError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"]('Invalid file url', 400);
}; //# sourceMappingURL=getExternalFile.js.map
}),
"[project]/node_modules/payload/dist/uploads/getFileByPath.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getFileByPath",
    ()=>getFileByPath
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$file$2d$type$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/file-type/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$externals$5d2f$fs$2f$promises__$5b$external$5d$__$28$fs$2f$promises$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/fs/promises [external] (fs/promises, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/path [external] (path, cjs)");
;
;
;
const mimeTypeEstimate = {
    svg: 'image/svg+xml'
};
const getFileByPath = async (filePath)=>{
    if (typeof filePath !== 'string') {
        return undefined;
    }
    const name = __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].basename(filePath);
    const ext = __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].extname(filePath).slice(1);
    const [data, stat, type] = await Promise.all([
        __TURBOPACK__imported__module__$5b$externals$5d2f$fs$2f$promises__$5b$external$5d$__$28$fs$2f$promises$2c$__cjs$29$__["default"].readFile(filePath),
        __TURBOPACK__imported__module__$5b$externals$5d2f$fs$2f$promises__$5b$external$5d$__$28$fs$2f$promises$2c$__cjs$29$__["default"].stat(filePath),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$file$2d$type$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["fileTypeFromFile"])(filePath)
    ]);
    return {
        name,
        data,
        mimetype: type?.mime || mimeTypeEstimate[ext],
        size: stat.size
    };
}; //# sourceMappingURL=getFileByPath.js.map
}),
"[project]/node_modules/payload/dist/uploads/tempFile.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "temporaryFileTask",
    ()=>temporaryFileTask
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$fs$2f$promises__$5b$external$5d$__$28$fs$2f$promises$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/fs/promises [external] (fs/promises, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$os__$5b$external$5d$__$28$node$3a$os$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:os [external] (node:os, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:path [external] (node:path, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$node$2f$v4$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__default__as__v4$3e$__ = __turbopack_context__.i("[project]/node_modules/uuid/dist/esm-node/v4.js [app-route] (ecmascript) <export default as v4>");
;
;
;
;
async function runTask(temporaryPath, callback) {
    try {
        return await callback(temporaryPath);
    } finally{
        await __TURBOPACK__imported__module__$5b$externals$5d2f$fs$2f$promises__$5b$external$5d$__$28$fs$2f$promises$2c$__cjs$29$__["default"].rm(temporaryPath, {
            force: true,
            maxRetries: 2,
            recursive: true
        });
    }
}
const temporaryFileTask = async (callback, options = {})=>{
    const filePath = await temporaryFile(options);
    return runTask(filePath, callback);
};
async function temporaryFile(options) {
    if (options.name) {
        if (options.extension !== undefined && options.extension !== null) {
            throw new Error('The `name` and `extension` options are mutually exclusive');
        }
        return __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["default"].join(await temporaryDirectory(), options.name);
    }
    return await getPath() + (options.extension === undefined || options.extension === null ? '' : '.' + options.extension.replace(/^\./, ''));
}
async function temporaryDirectory({ prefix = '' } = {}) {
    const directory = await getPath(prefix);
    await __TURBOPACK__imported__module__$5b$externals$5d2f$fs$2f$promises__$5b$external$5d$__$28$fs$2f$promises$2c$__cjs$29$__["default"].mkdir(directory);
    return directory;
}
async function getPath(prefix = '') {
    const temporaryDirectory = await __TURBOPACK__imported__module__$5b$externals$5d2f$fs$2f$promises__$5b$external$5d$__$28$fs$2f$promises$2c$__cjs$29$__["default"].realpath(__TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$os__$5b$external$5d$__$28$node$3a$os$2c$__cjs$29$__["default"].tmpdir());
    return __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["default"].join(temporaryDirectory, prefix + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$node$2f$v4$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__default__as__v4$3e$__["v4"])());
} //# sourceMappingURL=tempFile.js.map
}),
"[project]/node_modules/payload/dist/uploads/getImageSize.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getImageSize",
    ()=>getImageSize
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$fs$2f$promises__$5b$external$5d$__$28$fs$2f$promises$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/fs/promises [external] (fs/promises, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$image$2d$size$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/image-size/dist/index.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$image$2d$size$2f$dist$2f$fromFile$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/image-size/dist/fromFile.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$tempFile$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/payload/dist/uploads/tempFile.js [app-route] (ecmascript)");
;
;
;
;
async function getImageSize(file) {
    if (file?.tempFilePath) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$image$2d$size$2f$dist$2f$fromFile$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["imageSizeFromFile"])(file.tempFilePath);
    }
    // Tiff file do not support buffers or streams, so we must write to file first
    // then retrieve dimensions. https://github.com/image-size/image-size/issues/103
    if (file?.mimetype === 'image/tiff') {
        const dimensions = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$tempFile$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["temporaryFileTask"])(async (filepath)=>{
            await __TURBOPACK__imported__module__$5b$externals$5d2f$fs$2f$promises__$5b$external$5d$__$28$fs$2f$promises$2c$__cjs$29$__["default"].writeFile(filepath, file.data);
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$image$2d$size$2f$dist$2f$fromFile$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["imageSizeFromFile"])(filepath);
        }, {
            extension: 'tiff'
        });
        return dimensions;
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$image$2d$size$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["imageSize"])(file.data);
} //# sourceMappingURL=getImageSize.js.map
}),
"[project]/node_modules/payload/dist/uploads/docWithFilenameExists.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "docWithFilenameExists",
    ()=>docWithFilenameExists
]);
const docWithFilenameExists = async ({ collectionSlug, filename, prefix, req })=>{
    const where = {
        filename: {
            equals: filename
        }
    };
    if (prefix) {
        where.prefix = {
            equals: prefix
        };
    }
    const doc = await req.payload.db.findOne({
        collection: collectionSlug,
        req,
        where
    });
    return !!doc;
}; //# sourceMappingURL=docWithFilenameExists.js.map
}),
"[project]/node_modules/payload/dist/uploads/fileExists.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "fileExists",
    ()=>fileExists
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$fs$2f$promises__$5b$external$5d$__$28$fs$2f$promises$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/fs/promises [external] (fs/promises, cjs)");
;
const fileExists = async (filename)=>{
    try {
        await __TURBOPACK__imported__module__$5b$externals$5d2f$fs$2f$promises__$5b$external$5d$__$28$fs$2f$promises$2c$__cjs$29$__["default"].stat(filename);
        return true;
    } catch (ignore) {
        return false;
    }
}; //# sourceMappingURL=fileExists.js.map
}),
"[project]/node_modules/payload/dist/uploads/getSafeFilename.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getSafeFileName",
    ()=>getSafeFileName,
    "incrementName",
    ()=>incrementName
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sanitize$2d$filename$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/sanitize-filename/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$docWithFilenameExists$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/payload/dist/uploads/docWithFilenameExists.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$fileExists$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/payload/dist/uploads/fileExists.js [app-route] (ecmascript)");
;
;
;
const incrementName = (name)=>{
    const extension = name.split('.').pop();
    const baseFilename = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sanitize$2d$filename$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(name.substring(0, name.lastIndexOf('.')) || name);
    let incrementedName = baseFilename;
    const regex = /(.*)-(\d+)$/;
    const found = baseFilename.match(regex);
    if (found === null) {
        incrementedName += '-1';
    } else {
        const matchedName = found[1];
        const matchedNumber = found[2];
        const incremented = Number(matchedNumber) + 1;
        incrementedName = `${matchedName}-${incremented}`;
    }
    return `${incrementedName}.${extension}`;
};
async function getSafeFileName({ collectionSlug, desiredFilename, prefix, req, staticPath }) {
    let modifiedFilename = desiredFilename;
    while(await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$docWithFilenameExists$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["docWithFilenameExists"])({
        collectionSlug,
        filename: modifiedFilename,
        path: staticPath,
        prefix,
        req
    }) || await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$fileExists$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["fileExists"])(`${staticPath}/${modifiedFilename}`)){
        modifiedFilename = incrementName(modifiedFilename);
    }
    return modifiedFilename;
} //# sourceMappingURL=getSafeFilename.js.map
}),
"[project]/node_modules/payload/dist/uploads/image-resizing/createImageSize.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Create the result object for the image resize operation based on the
 * provided parameters. If the name is not provided, an empty result object
 * is returned.
 *
 * @param filename - the filename of the image
 * @param width - the width of the image
 * @param height - the height of the image
 * @param filesize - the filesize of the image
 * @param mimeType - the mime type of the image
 * @returns a FileSize result object
 */ __turbopack_context__.s([
    "createImageSize",
    ()=>createImageSize
]);
const createImageSize = ({ filename = null, filesize = null, height = null, mimeType = null, url = null, width = null })=>{
    return {
        filename,
        filesize,
        height,
        mimeType,
        url,
        width
    };
}; //# sourceMappingURL=createImageSize.js.map
}),
"[project]/node_modules/payload/dist/uploads/image-resizing/extractHeightFromImage.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Used to extract height from images, animated or not.
 *
 * @param sharpMetadata - the sharp metadata
 * @returns the height of the image
 */ __turbopack_context__.s([
    "extractHeightFromImage",
    ()=>extractHeightFromImage
]);
function extractHeightFromImage(sharpMetadata) {
    if (sharpMetadata?.pages) {
        return sharpMetadata.height / sharpMetadata.pages;
    }
    return sharpMetadata.height;
} //# sourceMappingURL=extractHeightFromImage.js.map
}),
"[project]/node_modules/payload/dist/uploads/image-resizing/generateImageSizeFilename.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Create a new image name based on the output image name, the dimensions and
 * the extension.
 *
 * Ignore the fact that duplicate names could happen if the there is one
 * size with `width AND height` and one with only `height OR width`. Because
 * space is expensive, we will reuse the same image for both sizes.
 *
 * @param outputImageName - the sanitized image name
 * @param bufferInfo - the buffer info
 * @param extension - the extension to use
 * @returns the new image name that is not taken
 */ __turbopack_context__.s([
    "generateImageSizeFilename",
    ()=>generateImageSizeFilename
]);
const generateImageSizeFilename = ({ extension, height, outputImageName, width })=>{
    return `${outputImageName}-${width}x${height}.${extension}`;
}; //# sourceMappingURL=generateImageSizeFilename.js.map
}),
"[project]/node_modules/payload/dist/uploads/image-resizing/getImageResizeAction.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getImageResizeAction",
    ()=>getImageResizeAction
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$utilities$2f$isNumber$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/payload/dist/utilities/isNumber.js [app-route] (ecmascript)");
;
const getImageResizeAction = ({ dimensions: originalImage, hasFocalPoint, imageResizeConfig })=>{
    const { fit, withoutEnlargement, withoutReduction } = imageResizeConfig;
    const targetWidth = imageResizeConfig.width;
    const targetHeight = imageResizeConfig.height;
    // prevent upscaling by default when x and y are both smaller than target image size
    if (targetHeight && targetWidth) {
        const originalImageIsSmallerXAndY = originalImage.width < targetWidth && originalImage.height < targetHeight;
        if (withoutEnlargement === undefined && originalImageIsSmallerXAndY) {
            return 'omit' // prevent image size from being enlarged
            ;
        }
    }
    if (withoutEnlargement === undefined && (!targetWidth || !targetHeight)) {
        if (targetWidth && originalImage.width < targetWidth || targetHeight && originalImage.height < targetHeight) {
            return 'omit';
        }
    }
    const originalImageIsSmallerXOrY = originalImage.width < targetWidth || originalImage.height < targetHeight;
    if (fit === 'contain' || fit === 'inside') {
        return 'resize';
    }
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$utilities$2f$isNumber$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isNumber"])(targetHeight) && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$utilities$2f$isNumber$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isNumber"])(targetWidth)) {
        return 'resize';
    }
    const targetAspectRatio = targetWidth / targetHeight;
    const originalAspectRatio = originalImage.width / originalImage.height;
    if (originalAspectRatio === targetAspectRatio) {
        return 'resize';
    }
    if (withoutEnlargement && originalImageIsSmallerXOrY) {
        return 'resize';
    }
    if (withoutReduction && !originalImageIsSmallerXOrY) {
        return 'resize';
    }
    return hasFocalPoint ? 'resizeWithFocalPoint' : 'resize';
}; //# sourceMappingURL=getImageResizeAction.js.map
}),
"[project]/node_modules/payload/dist/uploads/image-resizing/parseFilename.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "parseFilename",
    ()=>parseFilename
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sanitize$2d$filename$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/sanitize-filename/index.js [app-route] (ecmascript)");
;
const parseFilename = (sourceImage)=>{
    const extension = sourceImage.split('.').pop();
    const name = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sanitize$2d$filename$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(sourceImage.substring(0, sourceImage.lastIndexOf('.')) || sourceImage);
    return {
        name,
        ext: extension
    };
}; //# sourceMappingURL=parseFilename.js.map
}),
"[project]/node_modules/payload/dist/uploads/image-resizing/sanitizeResizeConfig.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Sanitize the resize config. If the resize config has the `withoutReduction`
 * property set to true, the `fit` and `position` properties will be set to `contain`
 * and `top left` respectively.
 *
 * @param resizeConfig - the resize config
 * @returns a sanitized resize config
 */ __turbopack_context__.s([
    "sanitizeResizeConfig",
    ()=>sanitizeResizeConfig
]);
const sanitizeResizeConfig = (resizeConfig)=>{
    if (resizeConfig.withoutReduction) {
        return {
            ...resizeConfig,
            // Why fit `contain` should also be set to https://github.com/lovell/sharp/issues/3595
            fit: resizeConfig?.fit || 'contain',
            position: resizeConfig?.position || 'left top'
        };
    }
    return resizeConfig;
}; //# sourceMappingURL=sanitizeResizeConfig.js.map
}),
"[project]/node_modules/payload/dist/uploads/image-resizing/createImageSizes.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createImageSizes",
    ()=>createImageSizes
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$file$2d$type$2f$core$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/file-type/core.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$fs$2f$promises__$5b$external$5d$__$28$fs$2f$promises$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/fs/promises [external] (fs/promises, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$fileExists$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/payload/dist/uploads/fileExists.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$optionallyAppendMetadata$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/payload/dist/uploads/optionallyAppendMetadata.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$image$2d$resizing$2f$createImageSize$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/payload/dist/uploads/image-resizing/createImageSize.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$image$2d$resizing$2f$extractHeightFromImage$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/payload/dist/uploads/image-resizing/extractHeightFromImage.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$image$2d$resizing$2f$generateImageSizeFilename$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/payload/dist/uploads/image-resizing/generateImageSizeFilename.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$image$2d$resizing$2f$getImageResizeAction$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/payload/dist/uploads/image-resizing/getImageResizeAction.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$image$2d$resizing$2f$parseFilename$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/payload/dist/uploads/image-resizing/parseFilename.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$image$2d$resizing$2f$sanitizeResizeConfig$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/payload/dist/uploads/image-resizing/sanitizeResizeConfig.js [app-route] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
async function createImageSizes({ config, dimensions, file, focalPoint, mimeType, req, savedFilename, sharp, staticPath, withMetadata }) {
    const { imageSizes } = config.upload;
    if (!imageSizes || !sharp) {
        return {
            sizeData: {},
            sizesToSave: []
        };
    }
    // Determine if the file is animated
    const fileIsAnimatedType = [
        'image/avif',
        'image/gif',
        'image/webp'
    ].includes(file.mimetype);
    const sharpOptions = {};
    if (fileIsAnimatedType) {
        sharpOptions.animated = true;
    }
    const sharpBase = sharp(file.tempFilePath || file.data, sharpOptions).rotate() // pass rotate() to auto-rotate based on EXIF data. https://github.com/payloadcms/payload/pull/3081
    ;
    const originalImageMeta = await sharpBase.metadata();
    let adjustedDimensions = {
        ...dimensions
    };
    // Images with an exif orientation of 5, 6, 7, or 8 are auto-rotated by sharp
    // Need to adjust the dimensions to match the original image
    if ([
        5,
        6,
        7,
        8
    ].includes(originalImageMeta.orientation)) {
        adjustedDimensions = {
            ...dimensions,
            height: dimensions.width,
            width: dimensions.height
        };
    }
    const resizeImageMeta = {
        height: originalImageMeta.height,
        width: originalImageMeta.width
    };
    const sizes = {};
    const imageSizeFiles = [];
    await Promise.all(imageSizes.map(async (imageResizeConfig)=>{
        imageResizeConfig = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$image$2d$resizing$2f$sanitizeResizeConfig$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["sanitizeResizeConfig"])(imageResizeConfig);
        const resizeAction = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$image$2d$resizing$2f$getImageResizeAction$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getImageResizeAction"])({
            dimensions,
            hasFocalPoint: Boolean(focalPoint),
            imageResizeConfig
        });
        if (resizeAction === 'omit') {
            sizes[imageResizeConfig.name] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$image$2d$resizing$2f$createImageSize$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createImageSize"])({});
            return;
        }
        const imageToResize = sharpBase.clone();
        let resized = imageToResize;
        if (resizeAction === 'resizeWithFocalPoint') {
            let { height: resizeHeight, width: resizeWidth } = imageResizeConfig;
            const originalAspectRatio = adjustedDimensions.width / adjustedDimensions.height;
            // Calculate resizeWidth based on original aspect ratio if it's undefined
            if (resizeHeight && !resizeWidth) {
                resizeWidth = Math.round(resizeHeight * originalAspectRatio);
            }
            // Calculate resizeHeight based on original aspect ratio if it's undefined
            if (resizeWidth && !resizeHeight) {
                resizeHeight = Math.round(resizeWidth / originalAspectRatio);
            }
            if (!resizeHeight) {
                resizeHeight = resizeImageMeta.height;
            }
            if (!resizeWidth) {
                resizeWidth = resizeImageMeta.width;
            }
            const resizeAspectRatio = resizeWidth / resizeHeight;
            const prioritizeHeight = resizeAspectRatio < originalAspectRatio;
            // Scales the image before extracting from it
            resized = imageToResize.resize({
                fastShrinkOnLoad: false,
                height: prioritizeHeight ? resizeHeight : undefined,
                width: prioritizeHeight ? undefined : resizeWidth
            });
            const metadataAppendedFile = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$optionallyAppendMetadata$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["optionallyAppendMetadata"])({
                req,
                sharpFile: resized,
                withMetadata: withMetadata
            });
            // Must read from buffer, resized.metadata will return the original image metadata
            const { info } = await metadataAppendedFile.toBuffer({
                resolveWithObject: true
            });
            resizeImageMeta.height = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$image$2d$resizing$2f$extractHeightFromImage$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["extractHeightFromImage"])({
                ...originalImageMeta,
                height: info.height
            });
            resizeImageMeta.width = info.width;
            const halfResizeX = resizeWidth / 2;
            const xFocalCenter = resizeImageMeta.width * (focalPoint.x / 100);
            const calculatedRightPixelBound = xFocalCenter + halfResizeX;
            let leftBound = xFocalCenter - halfResizeX;
            // if the right bound is greater than the image width, adjust the left bound
            // keeping focus on the right
            if (calculatedRightPixelBound > resizeImageMeta.width) {
                leftBound = resizeImageMeta.width - resizeWidth;
            }
            // if the left bound is less than 0, adjust the left bound to 0
            // keeping the focus on the left
            if (leftBound < 0) {
                leftBound = 0;
            }
            const halfResizeY = resizeHeight / 2;
            const yFocalCenter = resizeImageMeta.height * (focalPoint.y / 100);
            const calculatedBottomPixelBound = yFocalCenter + halfResizeY;
            let topBound = yFocalCenter - halfResizeY;
            // if the bottom bound is greater than the image height, adjust the top bound
            // keeping the image as far right as possible
            if (calculatedBottomPixelBound > resizeImageMeta.height) {
                topBound = resizeImageMeta.height - resizeHeight;
            }
            // if the top bound is less than 0, adjust the top bound to 0
            // keeping the image focus near the top
            if (topBound < 0) {
                topBound = 0;
            }
            resized = resized.extract({
                height: resizeHeight,
                left: Math.floor(leftBound),
                top: Math.floor(topBound),
                width: resizeWidth
            });
        } else {
            resized = imageToResize.resize(imageResizeConfig);
        }
        if (imageResizeConfig.formatOptions) {
            resized = resized.toFormat(imageResizeConfig.formatOptions.format, imageResizeConfig.formatOptions.options);
        }
        if (imageResizeConfig.trimOptions) {
            resized = resized.trim(imageResizeConfig.trimOptions);
        }
        const metadataAppendedFile = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$optionallyAppendMetadata$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["optionallyAppendMetadata"])({
            req,
            sharpFile: resized,
            withMetadata: withMetadata
        });
        const { data: bufferData, info: bufferInfo } = await metadataAppendedFile.toBuffer({
            resolveWithObject: true
        });
        const { name, ext } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$image$2d$resizing$2f$parseFilename$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parseFilename"])(savedFilename);
        if (req.payloadUploadSizes) {
            req.payloadUploadSizes[imageResizeConfig.name] = bufferData;
        }
        const mimeInfo = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$file$2d$type$2f$core$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["fileTypeFromBuffer"])(bufferData);
        const imageNameWithDimensions = imageResizeConfig.generateImageName ? imageResizeConfig.generateImageName({
            extension: mimeInfo?.ext || ext,
            height: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$image$2d$resizing$2f$extractHeightFromImage$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["extractHeightFromImage"])({
                ...originalImageMeta,
                height: bufferInfo.height
            }),
            originalName: name,
            sizeName: imageResizeConfig.name,
            width: bufferInfo.width
        }) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$image$2d$resizing$2f$generateImageSizeFilename$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["generateImageSizeFilename"])({
            extension: mimeInfo?.ext || ext,
            height: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$image$2d$resizing$2f$extractHeightFromImage$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["extractHeightFromImage"])({
                ...originalImageMeta,
                height: bufferInfo.height
            }),
            outputImageName: name,
            width: bufferInfo.width
        });
        const imagePath = `${staticPath}/${imageNameWithDimensions}`;
        if (await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$fileExists$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["fileExists"])(imagePath)) {
            try {
                await __TURBOPACK__imported__module__$5b$externals$5d2f$fs$2f$promises__$5b$external$5d$__$28$fs$2f$promises$2c$__cjs$29$__["default"].unlink(imagePath);
            } catch  {
            // Ignore unlink errors
            }
        }
        const { height, size, width } = bufferInfo;
        sizes[imageResizeConfig.name] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$image$2d$resizing$2f$createImageSize$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createImageSize"])({
            filename: imageNameWithDimensions,
            filesize: size,
            height: fileIsAnimatedType && originalImageMeta.pages ? height / originalImageMeta.pages : height,
            mimeType: mimeInfo?.mime || mimeType,
            width
        });
        imageSizeFiles.push({
            buffer: bufferData,
            path: imagePath
        });
    }));
    return {
        sizeData: sizes,
        sizesToSave: imageSizeFiles
    };
} //# sourceMappingURL=createImageSizes.js.map
}),
"[project]/node_modules/payload/dist/uploads/isImage.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "isImage",
    ()=>isImage
]);
function isImage(mimeType) {
    return [
        'image/jpeg',
        'image/png',
        'image/gif',
        'image/svg+xml',
        'image/webp',
        'image/avif',
        'image/jxl'
    ].indexOf(mimeType) > -1;
} //# sourceMappingURL=isImage.js.map
}),
"[project]/node_modules/payload/dist/uploads/generateFileData.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "generateFileData",
    ()=>generateFileData
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$file$2d$type$2f$core$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/file-type/core.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$fs$2f$promises__$5b$external$5d$__$28$fs$2f$promises$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/fs/promises [external] (fs/promises, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sanitize$2d$filename$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/sanitize-filename/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$errors$2f$FileRetrievalError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/payload/dist/errors/FileRetrievalError.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$errors$2f$FileUploadError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/payload/dist/errors/FileUploadError.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$errors$2f$Forbidden$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/payload/dist/errors/Forbidden.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$errors$2f$MissingFile$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/payload/dist/errors/MissingFile.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$utilities$2f$isNumber$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/payload/dist/utilities/isNumber.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$canResizeImage$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/payload/dist/uploads/canResizeImage.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$checkFileRestrictions$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/payload/dist/uploads/checkFileRestrictions.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$cropImage$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/payload/dist/uploads/cropImage.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$getExternalFile$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/payload/dist/uploads/getExternalFile.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$getFileByPath$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/payload/dist/uploads/getFileByPath.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$getImageSize$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/payload/dist/uploads/getImageSize.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$getSafeFilename$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/payload/dist/uploads/getSafeFilename.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$image$2d$resizing$2f$createImageSizes$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/payload/dist/uploads/image-resizing/createImageSizes.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$isImage$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/payload/dist/uploads/isImage.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$optionallyAppendMetadata$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/payload/dist/uploads/optionallyAppendMetadata.js [app-route] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
const shouldReupload = (uploadEdits, fileData)=>{
    if (!fileData) {
        return false;
    }
    if (uploadEdits.crop || uploadEdits.heightInPixels || uploadEdits.widthInPixels) {
        return true;
    }
    // Since uploadEdits always has focalPoint, compare to the value in the data if it was changed
    if (uploadEdits.focalPoint) {
        const incomingFocalX = uploadEdits.focalPoint.x;
        const incomingFocalY = uploadEdits.focalPoint.y;
        const currentFocalX = 'focalX' in fileData && fileData.focalX;
        const currentFocalY = 'focalY' in fileData && fileData.focalY;
        const isEqual = incomingFocalX === currentFocalX && incomingFocalY === currentFocalY;
        return !isEqual;
    }
    return false;
};
const generateFileData = async ({ collection: { config: collectionConfig }, data, isDuplicating, operation, originalDoc, overwriteExistingFiles, req, throwOnMissingFile })=>{
    if (!collectionConfig.upload) {
        return {
            data,
            files: []
        };
    }
    const { serverURL, sharp } = req.payload.config;
    let file = req.file;
    const uploadEdits = parseUploadEditsFromReqOrIncomingData({
        data,
        isDuplicating,
        operation,
        originalDoc,
        req
    });
    const { constructorOptions, disableLocalStorage, focalPoint: focalPointEnabled = true, formatOptions, imageSizes, resizeOptions, staticDir, trimOptions, withMetadata } = collectionConfig.upload;
    const staticPath = staticDir;
    const incomingFileData = isDuplicating ? originalDoc : data;
    let isLocalFile = false;
    if (!file && (isDuplicating || shouldReupload(uploadEdits, incomingFileData))) {
        const { filename, url } = incomingFileData;
        if (filename && (filename.includes('../') || filename.includes('..\\'))) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$errors$2f$Forbidden$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Forbidden"](req.t);
        }
        if (serverURL && url?.startsWith(serverURL) || url?.startsWith('/')) {
            isLocalFile = true;
        }
        try {
            if (!disableLocalStorage && isLocalFile) {
                // File is stored locally
                const filePath = `${staticPath}/${filename}`;
                const response = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$getFileByPath$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getFileByPath"])(filePath);
                file = response;
                overwriteExistingFiles = true;
            } else if (filename && url) {
                // File is remote
                file = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$getExternalFile$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getExternalFile"])({
                    data: incomingFileData,
                    req,
                    uploadConfig: collectionConfig.upload
                });
                overwriteExistingFiles = true;
            }
        } catch (err) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$errors$2f$FileRetrievalError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["FileRetrievalError"](req.t, err instanceof Error ? err.message : undefined);
        }
    }
    if (isDuplicating) {
        overwriteExistingFiles = false;
    }
    if (!file) {
        if (throwOnMissingFile) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$errors$2f$MissingFile$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MissingFile"](req.t);
        }
        return {
            data: incomingFileData,
            files: []
        };
    }
    await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$checkFileRestrictions$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["checkFileRestrictions"])({
        collection: collectionConfig,
        file,
        req
    });
    if (!disableLocalStorage) {
        await __TURBOPACK__imported__module__$5b$externals$5d2f$fs$2f$promises__$5b$external$5d$__$28$fs$2f$promises$2c$__cjs$29$__["default"].mkdir(staticPath, {
            recursive: true
        });
    }
    let newData = incomingFileData;
    const filesToSave = [];
    const fileData = {};
    const fileIsAnimatedType = [
        'image/avif',
        'image/gif',
        'image/webp'
    ].includes(file.mimetype);
    const cropData = typeof uploadEdits === 'object' && 'crop' in uploadEdits ? uploadEdits.crop : undefined;
    try {
        const fileSupportsResize = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$canResizeImage$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["canResizeImage"])(file.mimetype);
        let fsSafeName;
        let sharpFile;
        let dimensions;
        let fileBuffer;
        let ext;
        let mime;
        const fileHasAdjustments = fileSupportsResize && Boolean(resizeOptions || formatOptions || trimOptions || constructorOptions || file.tempFilePath);
        const sharpOptions = {
            ...constructorOptions
        };
        if (fileIsAnimatedType) {
            sharpOptions.animated = true;
        }
        if (sharp && (fileIsAnimatedType || fileHasAdjustments)) {
            if (file.tempFilePath) {
                sharpFile = sharp(file.tempFilePath, sharpOptions).rotate(); // pass rotate() to auto-rotate based on EXIF data. https://github.com/payloadcms/payload/pull/3081
            } else {
                sharpFile = sharp(file.data, sharpOptions).rotate(); // pass rotate() to auto-rotate based on EXIF data. https://github.com/payloadcms/payload/pull/3081
            }
            if (fileHasAdjustments) {
                if (resizeOptions) {
                    sharpFile = sharpFile.resize(resizeOptions);
                }
                if (formatOptions) {
                    sharpFile = sharpFile.toFormat(formatOptions.format, formatOptions.options);
                }
                if (trimOptions) {
                    sharpFile = sharpFile.trim(trimOptions);
                }
            }
        }
        if (fileSupportsResize || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$isImage$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isImage"])(file.mimetype)) {
            dimensions = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$getImageSize$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getImageSize"])(file);
            fileData.width = dimensions.width;
            fileData.height = dimensions.height;
        }
        if (sharpFile) {
            const metadata = await sharpFile.metadata();
            sharpFile = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$optionallyAppendMetadata$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["optionallyAppendMetadata"])({
                req,
                sharpFile,
                withMetadata: withMetadata
            });
            fileBuffer = await sharpFile.toBuffer({
                resolveWithObject: true
            });
            ({ ext, mime } = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$file$2d$type$2f$core$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["fileTypeFromBuffer"])(fileBuffer.data) // This is getting an incorrect gif height back.
            );
            fileData.width = fileBuffer.info.width;
            fileData.height = fileBuffer.info.height;
            fileData.filesize = fileBuffer.info.size;
            // Animated GIFs + WebP aggregate the height from every frame, so we need to use divide by number of pages
            if (metadata.pages) {
                fileData.height = fileBuffer.info.height / metadata.pages;
                fileData.filesize = fileBuffer.data.length;
            }
        } else {
            mime = file.mimetype;
            fileData.filesize = file.size;
            if (file.name.includes('.')) {
                ext = file.name.split('.').pop()?.split('?')[0];
            } else {
                ext = '';
            }
        }
        // Adjust SVG mime type. fromBuffer modifies it.
        if (mime === 'application/xml' && ext === 'svg') {
            mime = 'image/svg+xml';
        }
        fileData.mimeType = mime;
        const baseFilename = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sanitize$2d$filename$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(file.name.substring(0, file.name.lastIndexOf('.')) || file.name);
        fsSafeName = `${baseFilename}${ext ? `.${ext}` : ''}`;
        if (!overwriteExistingFiles) {
            // Extract prefix if present (added by plugin-cloud-storage)
            const prefix = data?.prefix;
            fsSafeName = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$getSafeFilename$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getSafeFileName"])({
                collectionSlug: collectionConfig.slug,
                desiredFilename: fsSafeName,
                prefix,
                req,
                staticPath: staticPath
            });
        }
        fileData.filename = fsSafeName;
        let fileForResize = file;
        if (cropData && sharp) {
            const { data: croppedImage, info } = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$cropImage$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["cropImage"])({
                cropData,
                dimensions: dimensions,
                file,
                heightInPixels: uploadEdits.heightInPixels,
                req,
                sharp,
                widthInPixels: uploadEdits.widthInPixels,
                withMetadata
            });
            // Apply resize after cropping to ensure it conforms to resizeOptions
            if (resizeOptions && !resizeOptions.withoutEnlargement) {
                const resizedAfterCrop = await sharp(croppedImage).resize({
                    fit: resizeOptions?.fit || 'cover',
                    height: resizeOptions?.height,
                    position: resizeOptions?.position || 'center',
                    width: resizeOptions?.width
                }).toBuffer({
                    resolveWithObject: true
                });
                filesToSave.push({
                    buffer: resizedAfterCrop.data,
                    path: `${staticPath}/${fsSafeName}`
                });
                fileForResize = {
                    ...fileForResize,
                    data: resizedAfterCrop.data,
                    size: resizedAfterCrop.info.size
                };
                fileData.width = resizedAfterCrop.info.width;
                fileData.height = resizedAfterCrop.info.height;
                if (fileIsAnimatedType) {
                    const metadata = await sharpFile.metadata();
                    fileData.height = metadata.pages ? resizedAfterCrop.info.height / metadata.pages : resizedAfterCrop.info.height;
                }
                fileData.filesize = resizedAfterCrop.info.size;
            } else {
                // If resizeOptions is not present, just save the cropped image
                filesToSave.push({
                    buffer: croppedImage,
                    path: `${staticPath}/${fsSafeName}`
                });
                fileForResize = {
                    ...file,
                    data: croppedImage,
                    size: info.size
                };
                fileData.width = info.width;
                fileData.height = info.height;
                if (fileIsAnimatedType) {
                    const metadata = await sharpFile.metadata();
                    fileData.height = metadata.pages ? info.height / metadata.pages : info.height;
                }
                fileData.filesize = info.size;
            }
            if (file.tempFilePath) {
                await __TURBOPACK__imported__module__$5b$externals$5d2f$fs$2f$promises__$5b$external$5d$__$28$fs$2f$promises$2c$__cjs$29$__["default"].writeFile(file.tempFilePath, croppedImage); // write fileBuffer to the temp path
            } else {
                req.file = fileForResize;
            }
        } else {
            filesToSave.push({
                buffer: fileBuffer?.data || file.data,
                path: `${staticPath}/${fsSafeName}`
            });
            // If using temp files and the image is being resized, write the file to the temp path
            if (fileBuffer?.data || file.data.length > 0) {
                if (file.tempFilePath) {
                    await __TURBOPACK__imported__module__$5b$externals$5d2f$fs$2f$promises__$5b$external$5d$__$28$fs$2f$promises$2c$__cjs$29$__["default"].writeFile(file.tempFilePath, fileBuffer?.data || file.data); // write fileBuffer to the temp path
                } else {
                    // Assign the _possibly modified_ file to the request object
                    req.file = {
                        ...file,
                        data: fileBuffer?.data || file.data,
                        size: fileBuffer?.info.size
                    };
                }
            }
        }
        if (fileSupportsResize && (Array.isArray(imageSizes) || focalPointEnabled !== false)) {
            req.payloadUploadSizes = {};
            // Focal point adjustments
            const focalPoint = focalPointEnabled && uploadEdits?.focalPoint ? {
                x: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$utilities$2f$isNumber$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isNumber"])(uploadEdits.focalPoint.x) ? Math.round(uploadEdits.focalPoint.x) : 50,
                y: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$utilities$2f$isNumber$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isNumber"])(uploadEdits.focalPoint.y) ? Math.round(uploadEdits.focalPoint.y) : 50
            } : undefined;
            const { sizeData, sizesToSave } = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$image$2d$resizing$2f$createImageSizes$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createImageSizes"])({
                config: collectionConfig,
                dimensions: !cropData ? dimensions : {
                    ...dimensions,
                    height: fileData.height,
                    width: fileData.width
                },
                file: fileForResize,
                focalPoint,
                mimeType: fileData.mimeType,
                req,
                savedFilename: fsSafeName || file.name,
                sharp,
                staticPath: staticPath,
                withMetadata
            });
            fileData.sizes = sizeData;
            fileData.focalX = focalPoint?.x;
            fileData.focalY = focalPoint?.y;
            filesToSave.push(...sizesToSave);
        }
    } catch (err) {
        req.payload.logger.error(err);
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$errors$2f$FileUploadError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["FileUploadError"](req.t);
    }
    newData = {
        ...newData,
        ...fileData
    };
    return {
        data: newData,
        files: filesToSave
    };
};
/**
 * Parse upload edits from req or incoming data
 */ function parseUploadEditsFromReqOrIncomingData(args) {
    const { data, isDuplicating, operation, originalDoc, req } = args;
    // Get intended focal point change from query string or incoming data
    const uploadEdits = req.query?.uploadEdits && typeof req.query.uploadEdits === 'object' ? req.query.uploadEdits : {};
    if (uploadEdits.focalPoint) {
        return uploadEdits;
    }
    const incomingData = data;
    const origDoc = originalDoc;
    if (origDoc && 'focalX' in origDoc && 'focalY' in origDoc) {
        // If no change in focal point, return undefined.
        // This prevents a refocal operation triggered from admin, because it always sends the focal point.
        if (incomingData.focalX === origDoc.focalX && incomingData.focalY === origDoc.focalY) {
            return undefined;
        }
        if (isDuplicating) {
            uploadEdits.focalPoint = {
                x: incomingData?.focalX || origDoc.focalX,
                y: incomingData?.focalY || origDoc.focalY
            };
            return uploadEdits;
        }
    }
    if (incomingData?.focalX && incomingData?.focalY) {
        uploadEdits.focalPoint = {
            x: incomingData.focalX,
            y: incomingData.focalY
        };
        return uploadEdits;
    }
    // If no focal point is set, default to center
    if (operation === 'create') {
        uploadEdits.focalPoint = {
            x: 50,
            y: 50
        };
    }
    return uploadEdits;
} //# sourceMappingURL=generateFileData.js.map
}),
"[project]/node_modules/payload/dist/uploads/unlinkTempFiles.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "unlinkTempFiles",
    ()=>unlinkTempFiles
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$fs$2f$promises__$5b$external$5d$__$28$fs$2f$promises$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/fs/promises [external] (fs/promises, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$utilities$2f$mapAsync$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/payload/dist/utilities/mapAsync.js [app-route] (ecmascript)");
;
;
const unlinkTempFiles = async ({ collectionConfig, config, req })=>{
    if (config.upload?.useTempFiles && collectionConfig.upload) {
        const { file } = req;
        const fileArray = [
            {
                file
            }
        ];
        await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$utilities$2f$mapAsync$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["mapAsync"])(fileArray, async ({ file })=>{
            // Still need this check because this will not be populated if using local API
            if (file?.tempFilePath) {
                await __TURBOPACK__imported__module__$5b$externals$5d2f$fs$2f$promises__$5b$external$5d$__$28$fs$2f$promises$2c$__cjs$29$__["default"].unlink(file.tempFilePath);
            }
        });
    }
}; //# sourceMappingURL=unlinkTempFiles.js.map
}),
"[project]/node_modules/payload/dist/uploads/saveBufferToFile.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "saveBufferToFile",
    ()=>saveBufferToFile
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$fs$2f$promises__$5b$external$5d$__$28$fs$2f$promises$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/fs/promises [external] (fs/promises, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/stream [external] (stream, cjs)");
;
;
const saveBufferToFile = async (buffer, filePath)=>{
    // Setup readable stream from buffer.
    let streamData = buffer;
    const readStream = new __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__["Readable"]();
    readStream._read = ()=>{
        readStream.push(streamData);
        streamData = null;
    };
    // Setup file system writable stream.
    return await __TURBOPACK__imported__module__$5b$externals$5d2f$fs$2f$promises__$5b$external$5d$__$28$fs$2f$promises$2c$__cjs$29$__["default"].writeFile(filePath, buffer);
}; //# sourceMappingURL=saveBufferToFile.js.map
}),
"[project]/node_modules/payload/dist/uploads/uploadFiles.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "uploadFiles",
    ()=>uploadFiles
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$errors$2f$FileUploadError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/payload/dist/errors/FileUploadError.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$saveBufferToFile$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/payload/dist/uploads/saveBufferToFile.js [app-route] (ecmascript)");
;
;
const uploadFiles = async (payload, files, req)=>{
    try {
        await Promise.all(files.map(async ({ buffer, path })=>{
            await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$saveBufferToFile$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["saveBufferToFile"])(buffer, path);
        }));
    } catch (err) {
        payload.logger.error(err);
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$errors$2f$FileUploadError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["FileUploadError"](req.t);
    }
}; //# sourceMappingURL=uploadFiles.js.map
}),
"[project]/node_modules/payload/dist/uploads/deleteAssociatedFiles.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "deleteAssociatedFiles",
    ()=>deleteAssociatedFiles
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$fs$2f$promises__$5b$external$5d$__$28$fs$2f$promises$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/fs/promises [external] (fs/promises, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$errors$2f$ErrorDeletingFile$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/payload/dist/errors/ErrorDeletingFile.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$fileExists$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/payload/dist/uploads/fileExists.js [app-route] (ecmascript)");
;
;
;
const deleteAssociatedFiles = async ({ collectionConfig, doc, files = [], overrideDelete, req })=>{
    if (!collectionConfig.upload) {
        return;
    }
    if (overrideDelete || files.length > 0) {
        const { staticDir: staticPath } = collectionConfig.upload;
        const fileToDelete = `${staticPath}/${doc.filename}`;
        try {
            if (await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$fileExists$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["fileExists"])(fileToDelete)) {
                await __TURBOPACK__imported__module__$5b$externals$5d2f$fs$2f$promises__$5b$external$5d$__$28$fs$2f$promises$2c$__cjs$29$__["default"].unlink(fileToDelete);
            }
        } catch (ignore) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$errors$2f$ErrorDeletingFile$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorDeletingFile"](req.t);
        }
        if (doc.sizes) {
            const sizes = Object.values(doc.sizes);
            // Since forEach will not wait until unlink is finished it could
            // happen that two operations will try to delete the same file.
            // To avoid this it is recommended to use "sync" instead
            for (const size of sizes){
                const sizeToDelete = `${staticPath}/${size.filename}`;
                try {
                    if (await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$uploads$2f$fileExists$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["fileExists"])(sizeToDelete)) {
                        await __TURBOPACK__imported__module__$5b$externals$5d2f$fs$2f$promises__$5b$external$5d$__$28$fs$2f$promises$2c$__cjs$29$__["default"].unlink(sizeToDelete);
                    }
                } catch (ignore) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$payload$2f$dist$2f$errors$2f$ErrorDeletingFile$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorDeletingFile"](req.t);
                }
            }
        }
    }
}; //# sourceMappingURL=deleteAssociatedFiles.js.map
}),
];

//# sourceMappingURL=node_modules_payload_dist_uploads_80c78f70._.js.map