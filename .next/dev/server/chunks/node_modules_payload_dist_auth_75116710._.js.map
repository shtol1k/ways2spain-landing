{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/auth/getLoginOptions.ts"],"sourcesContent":["import type { Auth } from './types.js'\n\nexport const getLoginOptions = (\n  loginWithUsername: Auth['loginWithUsername'],\n): {\n  canLoginWithEmail: boolean\n  canLoginWithUsername: boolean\n} => {\n  return {\n    canLoginWithEmail: !loginWithUsername || loginWithUsername.allowEmailLogin!,\n    canLoginWithUsername: Boolean(loginWithUsername),\n  }\n}\n"],"names":["getLoginOptions","loginWithUsername","canLoginWithEmail","allowEmailLogin","canLoginWithUsername","Boolean"],"mappings":";;;;AAEO,MAAMA,kBAAkB,CAC7BC;IAKA,OAAO;QACLC,mBAAmB,CAACD,qBAAqBA,kBAAkBE,eAAe;QAC1EC,sBAAsBC,QAAQJ;IAChC;AACF,EAAC"}},
    {"offset": {"line": 18, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/auth/operations/forgotPassword.ts"],"sourcesContent":["import crypto from 'crypto'\nimport { status as httpStatus } from 'http-status'\nimport { URL } from 'url'\n\nimport type {\n  AuthOperationsFromCollectionSlug,\n  Collection,\n} from '../../collections/config/types.js'\nimport type { CollectionSlug } from '../../index.js'\nimport type { PayloadRequest, Where } from '../../types/index.js'\n\nimport { buildAfterOperation } from '../../collections/operations/utilities/buildAfterOperation.js'\nimport { buildBeforeOperation } from '../../collections/operations/utilities/buildBeforeOperation.js'\nimport { APIError } from '../../errors/index.js'\nimport { Forbidden } from '../../index.js'\nimport { appendNonTrashedFilter } from '../../utilities/appendNonTrashedFilter.js'\nimport { commitTransaction } from '../../utilities/commitTransaction.js'\nimport { formatAdminURL } from '../../utilities/formatAdminURL.js'\nimport { initTransaction } from '../../utilities/initTransaction.js'\nimport { killTransaction } from '../../utilities/killTransaction.js'\nimport { getLoginOptions } from '../getLoginOptions.js'\n\nexport type Arguments<TSlug extends CollectionSlug> = {\n  collection: Collection\n  data: {\n    [key: string]: unknown\n  } & AuthOperationsFromCollectionSlug<TSlug>['forgotPassword']\n  disableEmail?: boolean\n  expiration?: number\n  overrideAccess?: boolean\n  req: PayloadRequest\n}\n\nexport type Result = string\n\nexport const forgotPasswordOperation = async <TSlug extends CollectionSlug>(\n  incomingArgs: Arguments<TSlug>,\n): Promise<null | string> => {\n  const loginWithUsername = incomingArgs.collection.config.auth.loginWithUsername\n  const { data, overrideAccess } = incomingArgs\n\n  const { canLoginWithEmail, canLoginWithUsername } = getLoginOptions(loginWithUsername)\n\n  const sanitizedEmail =\n    (canLoginWithEmail && (incomingArgs.data.email || '').toLowerCase().trim()) || null\n  const sanitizedUsername =\n    'username' in data && typeof data?.username === 'string'\n      ? data.username.toLowerCase().trim()\n      : null\n\n  let args = incomingArgs\n\n  if (incomingArgs.collection.config.auth.disableLocalStrategy) {\n    throw new Forbidden(incomingArgs.req.t)\n  }\n  if (!sanitizedEmail && !sanitizedUsername) {\n    throw new APIError(\n      `Missing ${loginWithUsername ? 'username' : 'email'}.`,\n      httpStatus.BAD_REQUEST,\n    )\n  }\n\n  try {\n    const shouldCommit = await initTransaction(args.req)\n\n    // /////////////////////////////////////\n    // beforeOperation - Collection\n    // /////////////////////////////////////\n    args = await buildBeforeOperation({\n      args,\n      collection: args.collection.config,\n      operation: 'forgotPassword',\n      overrideAccess,\n    })\n\n    const {\n      collection: { config: collectionConfig },\n      disableEmail,\n      expiration,\n      req: {\n        payload: { config, email },\n        payload,\n      },\n      req,\n    } = args\n\n    // /////////////////////////////////////\n    // Forget password\n    // /////////////////////////////////////\n\n    let token: string = crypto.randomBytes(20).toString('hex')\n    type UserDoc = {\n      email?: string\n      id: number | string\n      resetPasswordExpiration?: string\n      resetPasswordToken?: string\n    }\n\n    if (!sanitizedEmail && !sanitizedUsername) {\n      throw new APIError(\n        `Missing ${loginWithUsername ? 'username' : 'email'}.`,\n        httpStatus.BAD_REQUEST,\n      )\n    }\n\n    let whereConstraint: Where = {}\n\n    if (canLoginWithEmail && sanitizedEmail) {\n      whereConstraint = {\n        email: {\n          equals: sanitizedEmail,\n        },\n      }\n    } else if (canLoginWithUsername && sanitizedUsername) {\n      whereConstraint = {\n        username: {\n          equals: sanitizedUsername,\n        },\n      }\n    }\n\n    // Exclude trashed users unless `trash: true`\n    whereConstraint = appendNonTrashedFilter({\n      enableTrash: collectionConfig.trash,\n      trash: false,\n      where: whereConstraint,\n    })\n\n    let user = await payload.db.findOne<UserDoc>({\n      collection: collectionConfig.slug,\n      req,\n      where: whereConstraint,\n    })\n\n    // We don't want to indicate specifically that an email was not found,\n    // as doing so could lead to the exposure of registered emails.\n    // Therefore, we prefer to fail silently.\n    if (!user) {\n      await commitTransaction(args.req)\n      return null\n    }\n\n    const resetPasswordExpiration = new Date(\n      Date.now() + (collectionConfig.auth?.forgotPassword?.expiration ?? expiration ?? 3600000),\n    ).toISOString()\n\n    user = await payload.update({\n      id: user.id,\n      collection: collectionConfig.slug,\n      data: {\n        resetPasswordExpiration,\n        resetPasswordToken: token,\n      },\n      req,\n    })\n\n    if (!disableEmail && user.email) {\n      const protocol = new URL(req.url!).protocol // includes the final :\n      const serverURL =\n        config.serverURL !== null && config.serverURL !== ''\n          ? config.serverURL\n          : `${protocol}//${req.headers.get('host')}`\n      const forgotURL = formatAdminURL({\n        adminRoute: config.routes.admin,\n        path: `${config.admin.routes.reset}/${token}`,\n        serverURL,\n      })\n      let html = `${req.t('authentication:youAreReceivingResetPassword')}\n    <a href=\"${forgotURL}\">${forgotURL}</a>\n    ${req.t('authentication:youDidNotRequestPassword')}`\n\n      if (typeof collectionConfig.auth.forgotPassword?.generateEmailHTML === 'function') {\n        html = await collectionConfig.auth.forgotPassword.generateEmailHTML({\n          req,\n          token,\n          user,\n        })\n      }\n\n      let subject = req.t('authentication:resetYourPassword')\n\n      if (typeof collectionConfig.auth.forgotPassword?.generateEmailSubject === 'function') {\n        subject = await collectionConfig.auth.forgotPassword.generateEmailSubject({\n          req,\n          token,\n          user,\n        })\n      }\n\n      await email.sendEmail({\n        from: `\"${email.defaultFromName}\" <${email.defaultFromAddress}>`,\n        html,\n        subject,\n        to: user.email,\n      })\n    }\n\n    // /////////////////////////////////////\n    // afterForgotPassword - Collection\n    // /////////////////////////////////////\n\n    if (collectionConfig.hooks?.afterForgotPassword?.length) {\n      for (const hook of collectionConfig.hooks.afterForgotPassword) {\n        await hook({ args, collection: args.collection?.config, context: req.context })\n      }\n    }\n\n    // /////////////////////////////////////\n    // afterOperation - Collection\n    // /////////////////////////////////////\n\n    token = await buildAfterOperation({\n      args,\n      collection: args.collection?.config,\n      operation: 'forgotPassword',\n      overrideAccess,\n      result: token,\n    })\n\n    if (shouldCommit) {\n      await commitTransaction(req)\n    }\n\n    return token\n  } catch (error: unknown) {\n    await killTransaction(args.req)\n    throw error\n  }\n}\n"],"names":["crypto","status","httpStatus","URL","buildAfterOperation","buildBeforeOperation","APIError","Forbidden","appendNonTrashedFilter","commitTransaction","formatAdminURL","initTransaction","killTransaction","getLoginOptions","forgotPasswordOperation","incomingArgs","loginWithUsername","collection","config","auth","data","overrideAccess","canLoginWithEmail","canLoginWithUsername","sanitizedEmail","email","toLowerCase","trim","sanitizedUsername","username","args","disableLocalStrategy","req","t","BAD_REQUEST","shouldCommit","operation","collectionConfig","disableEmail","expiration","payload","token","randomBytes","toString","whereConstraint","equals","enableTrash","trash","where","user","db","findOne","slug","resetPasswordExpiration","Date","now","forgotPassword","toISOString","update","id","resetPasswordToken","protocol","url","serverURL","headers","get","forgotURL","adminRoute","routes","admin","path","reset","html","generateEmailHTML","subject","generateEmailSubject","sendEmail","from","defaultFromName","defaultFromAddress","to","hooks","afterForgotPassword","length","hook","context","result","error"],"mappings":"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"}},
    {"offset": {"line": 192, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/auth/operations/local/forgotPassword.ts"],"sourcesContent":["import type { CollectionSlug, Payload, RequestContext } from '../../../index.js'\nimport type { PayloadRequest } from '../../../types/index.js'\nimport type { Result } from '../forgotPassword.js'\n\nimport { APIError } from '../../../errors/index.js'\nimport { createLocalReq } from '../../../utilities/createLocalReq.js'\nimport { forgotPasswordOperation } from '../forgotPassword.js'\n\nexport type Options<T extends CollectionSlug> = {\n  collection: T\n  context?: RequestContext\n  data: {\n    email: string\n  }\n  disableEmail?: boolean\n  expiration?: number\n  overrideAccess?: boolean\n  req?: Partial<PayloadRequest>\n}\n\nexport async function forgotPasswordLocal<T extends CollectionSlug>(\n  payload: Payload,\n  options: Options<T>,\n): Promise<Result> {\n  const {\n    collection: collectionSlug,\n    data,\n    disableEmail,\n    expiration,\n    overrideAccess = true,\n  } = options\n\n  const collection = payload.collections[collectionSlug]\n\n  if (!collection) {\n    throw new APIError(\n      `The collection with slug ${String(\n        collectionSlug,\n      )} can't be found. Forgot Password Operation.`,\n    )\n  }\n\n  return forgotPasswordOperation({\n    collection,\n    data,\n    disableEmail,\n    expiration,\n    overrideAccess,\n    req: await createLocalReq(options, payload),\n  }) as Promise<Result>\n}\n"],"names":["APIError","createLocalReq","forgotPasswordOperation","forgotPasswordLocal","payload","options","collection","collectionSlug","data","disableEmail","expiration","overrideAccess","collections","String","req"],"mappings":";;;;AAIA,SAASA,QAAQ,QAAQ,2BAA0B;AACnD,SAASC,cAAc,QAAQ,uCAAsC;AACrE,SAASC,uBAAuB,QAAQ,uBAAsB;;;;AAcvD,eAAeC,oBACpBC,OAAgB,EAChBC,OAAmB;IAEnB,MAAM,EACJC,YAAYC,cAAc,EAC1BC,IAAI,EACJC,YAAY,EACZC,UAAU,EACVC,iBAAiB,IAAI,EACtB,GAAGN;IAEJ,MAAMC,aAAaF,QAAQQ,WAAW,CAACL,eAAe;IAEtD,IAAI,CAACD,YAAY;QACf,MAAM,IAAIN,mKAAAA,CACR,CAAC,yBAAyB,EAAEa,OAC1BN,gBACA,2CAA2C,CAAC;IAElD;IAEA,WAAOL,oMAAAA,EAAwB;QAC7BI;QACAE;QACAC;QACAC;QACAC;QACAG,KAAK,UAAMb,kLAAAA,EAAeI,SAASD;IACrC;AACF"}},
    {"offset": {"line": 221, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/auth/getFieldsToSign.ts"],"sourcesContent":["import type { CollectionConfig } from '../collections/config/types.js'\nimport type { Field, TabAsField } from '../fields/config/types.js'\nimport type { PayloadRequest } from '../types/index.js'\n\nimport { fieldAffectsData, tabHasName } from '../fields/config/types.js'\n\ntype TraverseFieldsArgs = {\n  data: Record<string, unknown>\n  fields: (Field | TabAsField)[]\n  result: Record<string, unknown>\n}\nconst traverseFields = ({\n  data,\n  // parent,\n  fields,\n  result,\n}: TraverseFieldsArgs) => {\n  fields.forEach((field) => {\n    switch (field.type) {\n      case 'collapsible':\n      case 'row': {\n        traverseFields({\n          data,\n          fields: field.fields,\n          result,\n        })\n        break\n      }\n      case 'group': {\n        if (fieldAffectsData(field)) {\n          let targetResult\n          if (typeof field.saveToJWT === 'string') {\n            targetResult = field.saveToJWT\n            result[field.saveToJWT] = data[field.name]\n          } else if (field.saveToJWT) {\n            targetResult = field.name\n            result[field.name] = data[field.name]\n          }\n          const groupData: Record<string, unknown> = data[field.name] as Record<string, unknown>\n          const groupResult = (targetResult ? result[targetResult] : result) as Record<\n            string,\n            unknown\n          >\n          traverseFields({\n            data: groupData,\n            fields: field.fields,\n            result: groupResult,\n          })\n          break\n        } else {\n          traverseFields({\n            data,\n            fields: field.fields,\n            result,\n          })\n\n          break\n        }\n      }\n      case 'tab': {\n        if (tabHasName(field)) {\n          let targetResult\n          if (typeof field.saveToJWT === 'string') {\n            targetResult = field.saveToJWT\n            result[field.saveToJWT] = data[field.name]\n          } else if (field.saveToJWT) {\n            targetResult = field.name\n            result[field.name] = data[field.name]\n          }\n          const tabData: Record<string, unknown> = data[field.name] as Record<string, unknown>\n          const tabResult = (targetResult ? result[targetResult] : result) as Record<\n            string,\n            unknown\n          >\n          traverseFields({\n            data: tabData,\n            fields: field.fields,\n            result: tabResult,\n          })\n        } else {\n          traverseFields({\n            data,\n            fields: field.fields,\n            result,\n          })\n        }\n        break\n      }\n      case 'tabs': {\n        traverseFields({\n          data,\n          fields: field.tabs.map((tab) => ({ ...tab, type: 'tab' })),\n          result,\n        })\n        break\n      }\n      default:\n        if (fieldAffectsData(field)) {\n          if (field.saveToJWT) {\n            if (typeof field.saveToJWT === 'string') {\n              result[field.saveToJWT] = data[field.name]\n              delete result[field.name]\n            } else {\n              result[field.name] = data[field.name] as Record<string, unknown>\n            }\n          } else if (field.saveToJWT === false) {\n            delete result[field.name]\n          }\n        }\n    }\n  })\n  return result\n}\nexport const getFieldsToSign = (args: {\n  collectionConfig: CollectionConfig\n  email: string\n  sid?: string\n  user: PayloadRequest['user']\n}): Record<string, unknown> => {\n  const { collectionConfig, email, sid, user } = args\n\n  const result: Record<string, unknown> = {\n    id: user?.id,\n    collection: collectionConfig.slug,\n    email,\n  }\n\n  if (sid) {\n    result.sid = sid\n  }\n\n  traverseFields({\n    data: user!,\n    fields: collectionConfig.fields,\n    result,\n  })\n\n  return result\n}\n"],"names":["fieldAffectsData","tabHasName","traverseFields","data","fields","result","forEach","field","type","targetResult","saveToJWT","name","groupData","groupResult","tabData","tabResult","tabs","map","tab","getFieldsToSign","args","collectionConfig","email","sid","user","id","collection","slug"],"mappings":"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"}},
    {"offset": {"line": 345, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/auth/isUserLocked.ts"],"sourcesContent":["export const isUserLocked = (date: Date): boolean => {\n  if (!date) {\n    return false\n  }\n  return date.getTime() > Date.now()\n}\n"],"names":["isUserLocked","date","getTime","Date","now"],"mappings":";;;;AAAO,MAAMA,eAAe,CAACC;IAC3B,IAAI,CAACA,MAAM;QACT,OAAO;IACT;IACA,OAAOA,KAAKC,OAAO,KAAKC,KAAKC,GAAG;AAClC,EAAC"}},
    {"offset": {"line": 359, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/auth/jwt.ts"],"sourcesContent":["import { SignJWT } from 'jose'\n\nexport const jwtSign = async ({\n  fieldsToSign,\n  secret,\n  tokenExpiration,\n}: {\n  fieldsToSign: Record<string, unknown>\n  secret: string\n  tokenExpiration: number\n}) => {\n  const secretKey = new TextEncoder().encode(secret)\n  const issuedAt = Math.floor(Date.now() / 1000)\n  const exp = issuedAt + tokenExpiration\n  const token = await new SignJWT(fieldsToSign)\n    .setProtectedHeader({ alg: 'HS256', typ: 'JWT' })\n    .setIssuedAt(issuedAt)\n    .setExpirationTime(exp)\n    .sign(secretKey)\n  return { exp, token }\n}\n"],"names":["SignJWT","jwtSign","fieldsToSign","secret","tokenExpiration","secretKey","TextEncoder","encode","issuedAt","Math","floor","Date","now","exp","token","setProtectedHeader","alg","typ","setIssuedAt","setExpirationTime","sign"],"mappings":";;;;AAAA,SAASA,OAAO,QAAQ,OAAM;;AAEvB,MAAMC,UAAU,OAAO,EAC5BC,YAAY,EACZC,MAAM,EACNC,eAAe,EAKhB;IACC,MAAMC,YAAY,IAAIC,cAAcC,MAAM,CAACJ;IAC3C,MAAMK,WAAWC,KAAKC,KAAK,CAACC,KAAKC,GAAG,KAAK;IACzC,MAAMC,MAAML,WAAWJ;IACvB,MAAMU,QAAQ,MAAM,IAAId,uKAAAA,CAAQE,cAC7Ba,kBAAkB,CAAC;QAAEC,KAAK;QAASC,KAAK;IAAM,GAC9CC,WAAW,CAACV,UACZW,iBAAiB,CAACN,KAClBO,IAAI,CAACf;IACR,OAAO;QAAEQ;QAAKC;IAAM;AACtB,EAAC"}},
    {"offset": {"line": 382, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/auth/sessions.ts"],"sourcesContent":["import { v4 as uuid } from 'uuid'\n\nimport type { SanitizedCollectionConfig, TypeWithID } from '../collections/config/types.js'\nimport type { TypedUser } from '../index.js'\nimport type { Payload, PayloadRequest } from '../types/index.js'\nimport type { UntypedUser, UserSession } from './types.js'\n\n/**\n * Removes expired sessions from an array of sessions\n */\nexport const removeExpiredSessions = (sessions: UserSession[]) => {\n  const now = new Date()\n\n  return sessions.filter(({ expiresAt }) => {\n    const expiry = expiresAt instanceof Date ? expiresAt : new Date(expiresAt)\n    return expiry > now\n  })\n}\n\n/**\n * Adds a session to the user and removes expired sessions\n * @returns The session ID (sid) if sessions are used\n */\nexport const addSessionToUser = async ({\n  collectionConfig,\n  payload,\n  req,\n  user,\n}: {\n  collectionConfig: SanitizedCollectionConfig\n  payload: Payload\n  req: PayloadRequest\n  user: TypedUser\n}): Promise<{ sid?: string }> => {\n  let sid: string | undefined\n  if (collectionConfig.auth.useSessions) {\n    // Add session to user\n    sid = uuid()\n    const now = new Date()\n    const tokenExpInMs = collectionConfig.auth.tokenExpiration * 1000\n    const expiresAt = new Date(now.getTime() + tokenExpInMs)\n\n    const session = { id: sid, createdAt: now, expiresAt }\n\n    if (!user.sessions?.length) {\n      user.sessions = [session]\n    } else {\n      user.sessions = removeExpiredSessions(user.sessions)\n      user.sessions.push(session)\n    }\n\n    // Prevent updatedAt from being updated when only adding a session\n    user.updatedAt = null\n\n    await payload.db.updateOne({\n      id: user.id,\n      collection: collectionConfig.slug,\n      data: user,\n      req,\n      returning: false,\n    })\n\n    user.collection = collectionConfig.slug\n    user._strategy = 'local-jwt'\n  }\n\n  return {\n    sid,\n  }\n}\n\nexport const revokeSession = async ({\n  collectionConfig,\n  payload,\n  req,\n  sid,\n  user,\n}: {\n  collectionConfig: SanitizedCollectionConfig\n  payload: Payload\n  req: PayloadRequest\n  sid: string\n  user: null | (TypeWithID & UntypedUser)\n}): Promise<void> => {\n  if (collectionConfig.auth.useSessions && user && user.sessions?.length) {\n    user.sessions = user.sessions.filter((session) => session.id !== sid)\n    await payload.db.updateOne({\n      id: user.id,\n      collection: collectionConfig.slug,\n      data: user,\n      req,\n      returning: false,\n    })\n  }\n}\n"],"names":["v4","uuid","removeExpiredSessions","sessions","now","Date","filter","expiresAt","expiry","addSessionToUser","collectionConfig","payload","req","user","sid","auth","useSessions","tokenExpInMs","tokenExpiration","getTime","session","id","createdAt","length","push","updatedAt","db","updateOne","collection","slug","data","returning","_strategy","revokeSession"],"mappings":";;;;;;;;AAAA,SAASA,MAAMC,IAAI,QAAQ,OAAM;;AAU1B,MAAMC,wBAAwB,CAACC;IACpC,MAAMC,MAAM,IAAIC;IAEhB,OAAOF,SAASG,MAAM,CAAC,CAAC,EAAEC,SAAS,EAAE;QACnC,MAAMC,SAASD,qBAAqBF,OAAOE,YAAY,IAAIF,KAAKE;QAChE,OAAOC,SAASJ;IAClB;AACF,EAAC;AAMM,MAAMK,mBAAmB,OAAO,EACrCC,gBAAgB,EAChBC,OAAO,EACPC,GAAG,EACHC,IAAI,EAML;IACC,IAAIC;IACJ,IAAIJ,iBAAiBK,IAAI,CAACC,WAAW,EAAE;QACrC,sBAAsB;QACtBF,UAAMb,0LAAAA;QACN,MAAMG,MAAM,IAAIC;QAChB,MAAMY,eAAeP,iBAAiBK,IAAI,CAACG,eAAe,GAAG;QAC7D,MAAMX,YAAY,IAAIF,KAAKD,IAAIe,OAAO,KAAKF;QAE3C,MAAMG,UAAU;YAAEC,IAAIP;YAAKQ,WAAWlB;YAAKG;QAAU;QAErD,IAAI,CAACM,KAAKV,QAAQ,EAAEoB,QAAQ;YAC1BV,KAAKV,QAAQ,GAAG;gBAACiB;aAAQ;QAC3B,OAAO;YACLP,KAAKV,QAAQ,GAAGD,sBAAsBW,KAAKV,QAAQ;YACnDU,KAAKV,QAAQ,CAACqB,IAAI,CAACJ;QACrB;QAEA,kEAAkE;QAClEP,KAAKY,SAAS,GAAG;QAEjB,MAAMd,QAAQe,EAAE,CAACC,SAAS,CAAC;YACzBN,IAAIR,KAAKQ,EAAE;YACXO,YAAYlB,iBAAiBmB,IAAI;YACjCC,MAAMjB;YACND;YACAmB,WAAW;QACb;QAEAlB,KAAKe,UAAU,GAAGlB,iBAAiBmB,IAAI;QACvChB,KAAKmB,SAAS,GAAG;IACnB;IAEA,OAAO;QACLlB;IACF;AACF,EAAC;AAEM,MAAMmB,gBAAgB,OAAO,EAClCvB,gBAAgB,EAChBC,OAAO,EACPC,GAAG,EACHE,GAAG,EACHD,IAAI,EAOL;IACC,IAAIH,iBAAiBK,IAAI,CAACC,WAAW,IAAIH,QAAQA,KAAKV,QAAQ,EAAEoB,QAAQ;QACtEV,KAAKV,QAAQ,GAAGU,KAAKV,QAAQ,CAACG,MAAM,CAAC,CAACc,UAAYA,QAAQC,EAAE,KAAKP;QACjE,MAAMH,QAAQe,EAAE,CAACC,SAAS,CAAC;YACzBN,IAAIR,KAAKQ,EAAE;YACXO,YAAYlB,iBAAiBmB,IAAI;YACjCC,MAAMjB;YACND;YACAmB,WAAW;QACb;IACF;AACF,EAAC"}},
    {"offset": {"line": 452, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/auth/strategies/local/authenticate.ts"],"sourcesContent":["// @ts-strict-ignore\nimport crypto from 'crypto'\n\nimport type { TypeWithID } from '../../../collections/config/types.js'\n\ntype Doc = Record<string, unknown> & TypeWithID\n\ntype Args = {\n  doc: Doc\n  password: string\n}\n\nexport const authenticateLocalStrategy = async ({ doc, password }: Args): Promise<Doc | null> => {\n  try {\n    const { hash, salt } = doc\n\n    if (typeof salt === 'string' && typeof hash === 'string') {\n      const res = await new Promise<Doc | null>((resolve, reject) => {\n        crypto.pbkdf2(password, salt, 25000, 512, 'sha256', (e, hashBuffer) => {\n          if (e) {\n            reject(e)\n          }\n\n          const storedHashBuffer = Buffer.from(hash, 'hex')\n\n          if (\n            hashBuffer.length === storedHashBuffer.length &&\n            crypto.timingSafeEqual(hashBuffer, storedHashBuffer)\n          ) {\n            resolve(doc)\n          } else {\n            reject(new Error('Invalid password'))\n          }\n        })\n      })\n\n      return res\n    }\n\n    return null\n  } catch (ignore) {\n    return null\n  }\n}\n"],"names":["crypto","authenticateLocalStrategy","doc","password","hash","salt","res","Promise","resolve","reject","pbkdf2","e","hashBuffer","storedHashBuffer","Buffer","from","length","timingSafeEqual","Error","ignore"],"mappings":";;;;AAAA,oBAAoB;AACpB,OAAOA,YAAY,SAAQ;;AAWpB,MAAMC,4BAA4B,OAAO,EAAEC,GAAG,EAAEC,QAAQ,EAAQ;IACrE,IAAI;QACF,MAAM,EAAEC,IAAI,EAAEC,IAAI,EAAE,GAAGH;QAEvB,IAAI,OAAOG,SAAS,YAAY,OAAOD,SAAS,UAAU;YACxD,MAAME,MAAM,MAAM,IAAIC,QAAoB,CAACC,SAASC;gBAClDT,gHAAAA,CAAOU,MAAM,CAACP,UAAUE,MAAM,OAAO,KAAK,UAAU,CAACM,GAAGC;oBACtD,IAAID,GAAG;wBACLF,OAAOE;oBACT;oBAEA,MAAME,mBAAmBC,OAAOC,IAAI,CAACX,MAAM;oBAE3C,IACEQ,WAAWI,MAAM,KAAKH,iBAAiBG,MAAM,IAC7ChB,gHAAAA,CAAOiB,eAAe,CAACL,YAAYC,mBACnC;wBACAL,QAAQN;oBACV,OAAO;wBACLO,OAAO,IAAIS,MAAM;oBACnB;gBACF;YACF;YAEA,OAAOZ;QACT;QAEA,OAAO;IACT,EAAE,OAAOa,QAAQ;QACf,OAAO;IACT;AACF,EAAC"}},
    {"offset": {"line": 487, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/auth/strategies/local/incrementLoginAttempts.ts"],"sourcesContent":["import type { SanitizedCollectionConfig } from '../../../collections/config/types.js'\n\nimport { type JsonObject, type Payload, type TypedUser } from '../../../index.js'\nimport { isUserLocked } from '../../isUserLocked.js'\n\ntype Args = {\n  collection: SanitizedCollectionConfig\n  payload: Payload\n  user: TypedUser\n}\n\n// Note: this function does not use req in its updates, as we want those to be visible in parallel requests that are on a different\n// transaction. At the same time, we want updates from parallel requests to be visible here.\nexport const incrementLoginAttempts = async ({\n  collection,\n  payload,\n  user,\n}: Args): Promise<void> => {\n  const {\n    auth: { lockTime, maxLoginAttempts },\n  } = collection\n\n  const currentTime = Date.now()\n\n  let updatedLockUntil: null | string = null\n  let updatedLoginAttempts: null | number = null\n\n  if (user.lockUntil && !isUserLocked(new Date(user.lockUntil))) {\n    // Expired lock, restart count at 1\n    const updatedUser = await payload.db.updateOne({\n      id: user.id,\n      collection: collection.slug,\n      data: {\n        lockUntil: null,\n        loginAttempts: 1,\n      },\n      select: {\n        lockUntil: true,\n        loginAttempts: true,\n      },\n    })\n    updatedLockUntil = updatedUser.lockUntil\n    updatedLoginAttempts = updatedUser.loginAttempts\n    user.lockUntil = updatedLockUntil\n  } else {\n    const data: JsonObject = {\n      loginAttempts: {\n        $inc: 1,\n      },\n    }\n\n    const willReachMaxAttempts =\n      typeof user.loginAttempts === 'number' && user.loginAttempts + 1 >= maxLoginAttempts\n    // Lock the account if at max attempts and not already locked\n    if (willReachMaxAttempts) {\n      const lockUntil = new Date(currentTime + lockTime).toISOString()\n      data.lockUntil = lockUntil\n    }\n\n    const updatedUser = await payload.db.updateOne({\n      id: user.id,\n      collection: collection.slug,\n      data,\n      select: {\n        lockUntil: true,\n        loginAttempts: true,\n      },\n    })\n\n    updatedLockUntil = updatedUser.lockUntil\n    updatedLoginAttempts = updatedUser.loginAttempts\n  }\n\n  if (updatedLoginAttempts === null) {\n    throw new Error('Failed to update login attempts or lockUntil for user')\n  }\n\n  // Check updated latest lockUntil and loginAttempts in case there were parallel updates\n  const reachedMaxAttemptsForCurrentUser =\n    typeof updatedLoginAttempts === 'number' && updatedLoginAttempts - 1 >= maxLoginAttempts\n\n  const reachedMaxAttemptsForNextUser =\n    typeof updatedLoginAttempts === 'number' && updatedLoginAttempts >= maxLoginAttempts\n\n  if (reachedMaxAttemptsForCurrentUser) {\n    user.lockUntil = updatedLockUntil\n  }\n  user.loginAttempts = updatedLoginAttempts - 1 // -1, as the updated increment is applied for the *next* login attempt, not the current one\n\n  if (\n    reachedMaxAttemptsForNextUser &&\n    (!updatedLockUntil || !isUserLocked(new Date(updatedLockUntil)))\n  ) {\n    // If lockUntil reached max login attempts due to multiple parallel attempts but user was not locked yet,\n    const newLockUntil = new Date(currentTime + lockTime).toISOString()\n\n    await payload.db.updateOne({\n      id: user.id,\n      collection: collection.slug,\n      data: {\n        lockUntil: newLockUntil,\n      },\n      returning: false,\n    })\n\n    if (reachedMaxAttemptsForCurrentUser) {\n      user.lockUntil = newLockUntil\n    }\n\n    if (collection.auth.useSessions) {\n      // Remove all active sessions that have been created in a 20 second window. This protects\n      // against brute force attacks - example: 99 incorrect, 1 correct parallel login attempts.\n      // The correct login attempt will be finished first, as it's faster due to not having to perform\n      // an additional db update here.\n      // However, this request (the incorrect login attempt request) can kill the successful login attempt here.\n\n      // Fetch user sessions separately (do not do this in the updateOne select in order to preserve the returning: true db call optimization)\n      const currentUser = await payload.db.findOne<TypedUser>({\n        collection: collection.slug,\n        select: {\n          sessions: true,\n        },\n        where: {\n          id: {\n            equals: user.id,\n          },\n        },\n      })\n      if (currentUser?.sessions?.length) {\n        // Does not hurt also removing expired sessions\n        currentUser.sessions = currentUser.sessions.filter((session) => {\n          const sessionCreatedAt = new Date(session.createdAt)\n          const twentySecondsAgo = new Date(currentTime - 20000)\n\n          // Remove sessions created within the last 20 seconds\n          return sessionCreatedAt <= twentySecondsAgo\n        })\n\n        user.sessions = currentUser.sessions\n\n        // Ensure updatedAt date is always updated\n        user.updatedAt = new Date().toISOString()\n\n        await payload.db.updateOne({\n          id: user.id,\n          collection: collection.slug,\n          data: user,\n          returning: false,\n        })\n      }\n    }\n  }\n}\n"],"names":["isUserLocked","incrementLoginAttempts","collection","payload","user","auth","lockTime","maxLoginAttempts","currentTime","Date","now","updatedLockUntil","updatedLoginAttempts","lockUntil","updatedUser","db","updateOne","id","slug","data","loginAttempts","select","$inc","willReachMaxAttempts","toISOString","Error","reachedMaxAttemptsForCurrentUser","reachedMaxAttemptsForNextUser","newLockUntil","returning","useSessions","currentUser","findOne","sessions","where","equals","length","filter","session","sessionCreatedAt","createdAt","twentySecondsAgo","updatedAt"],"mappings":"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"}},
    {"offset": {"line": 606, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/auth/strategies/local/resetLoginAttempts.ts"],"sourcesContent":["import type { SanitizedCollectionConfig, TypeWithID } from '../../../collections/config/types.js'\nimport type { Payload } from '../../../index.js'\nimport type { PayloadRequest } from '../../../types/index.js'\n\ntype Args = {\n  collection: SanitizedCollectionConfig\n  doc: Record<string, unknown> & TypeWithID\n  payload: Payload\n  req: PayloadRequest\n}\n\nexport const resetLoginAttempts = async ({\n  collection,\n  doc,\n  payload,\n  req,\n}: Args): Promise<void> => {\n  if (\n    !('lockUntil' in doc && typeof doc.lockUntil === 'string') &&\n    (!('loginAttempts' in doc) || doc.loginAttempts === 0)\n  ) {\n    return\n  }\n  await payload.db.updateOne({\n    id: doc.id,\n    collection: collection.slug,\n    data: {\n      lockUntil: null,\n      loginAttempts: 0,\n    },\n    req,\n    returning: false,\n  })\n}\n"],"names":["resetLoginAttempts","collection","doc","payload","req","lockUntil","loginAttempts","db","updateOne","id","slug","data","returning"],"mappings":";;;;AAWO,MAAMA,qBAAqB,OAAO,EACvCC,UAAU,EACVC,GAAG,EACHC,OAAO,EACPC,GAAG,EACE;IACL,IACE,CAAE,CAAA,eAAeF,OAAO,OAAOA,IAAIG,SAAS,KAAK,QAAO,KACvD,CAAA,CAAE,CAAA,mBAAmBH,GAAE,KAAMA,IAAII,aAAa,KAAK,CAAA,GACpD;QACA;IACF;IACA,MAAMH,QAAQI,EAAE,CAACC,SAAS,CAAC;QACzBC,IAAIP,IAAIO,EAAE;QACVR,YAAYA,WAAWS,IAAI;QAC3BC,MAAM;YACJN,WAAW;YACXC,eAAe;QACjB;QACAF;QACAQ,WAAW;IACb;AACF,EAAC"}},
    {"offset": {"line": 629, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/auth/operations/login.ts"],"sourcesContent":["import type {\n  AuthOperationsFromCollectionSlug,\n  Collection,\n  DataFromCollectionSlug,\n} from '../../collections/config/types.js'\nimport type { CollectionSlug, TypedUser } from '../../index.js'\nimport type { PayloadRequest, Where } from '../../types/index.js'\n\nimport { buildAfterOperation } from '../../collections/operations/utilities/buildAfterOperation.js'\nimport { buildBeforeOperation } from '../../collections/operations/utilities/buildBeforeOperation.js'\nimport {\n  AuthenticationError,\n  LockedAuth,\n  UnverifiedEmail,\n  ValidationError,\n} from '../../errors/index.js'\nimport { afterRead } from '../../fields/hooks/afterRead/index.js'\nimport { commitTransaction, Forbidden, initTransaction } from '../../index.js'\nimport { appendNonTrashedFilter } from '../../utilities/appendNonTrashedFilter.js'\nimport { killTransaction } from '../../utilities/killTransaction.js'\nimport { sanitizeInternalFields } from '../../utilities/sanitizeInternalFields.js'\nimport { getFieldsToSign } from '../getFieldsToSign.js'\nimport { getLoginOptions } from '../getLoginOptions.js'\nimport { isUserLocked } from '../isUserLocked.js'\nimport { jwtSign } from '../jwt.js'\nimport { addSessionToUser, revokeSession } from '../sessions.js'\nimport { authenticateLocalStrategy } from '../strategies/local/authenticate.js'\nimport { incrementLoginAttempts } from '../strategies/local/incrementLoginAttempts.js'\nimport { resetLoginAttempts } from '../strategies/local/resetLoginAttempts.js'\n\nexport type Result = {\n  exp?: number\n  token?: string\n  user?: TypedUser\n}\n\nexport type Arguments<TSlug extends CollectionSlug> = {\n  collection: Collection\n  data: AuthOperationsFromCollectionSlug<TSlug>['login']\n  depth?: number\n  overrideAccess?: boolean\n  req: PayloadRequest\n  showHiddenFields?: boolean\n}\n\ntype CheckLoginPermissionArgs = {\n  loggingInWithUsername?: boolean\n  req: PayloadRequest\n  user: any\n}\n\n/**\n * Throws an error if the user is locked or does not exist.\n * This does not check the login attempts, only the lock status. Whoever increments login attempts\n * is responsible for locking the user properly, not whoever checks the login permission.\n */\nexport const checkLoginPermission = ({\n  loggingInWithUsername,\n  req,\n  user,\n}: CheckLoginPermissionArgs) => {\n  if (!user) {\n    throw new AuthenticationError(req.t, Boolean(loggingInWithUsername))\n  }\n\n  if (isUserLocked(new Date(user.lockUntil))) {\n    throw new LockedAuth(req.t)\n  }\n}\n\nexport const loginOperation = async <TSlug extends CollectionSlug>(\n  incomingArgs: Arguments<TSlug>,\n): Promise<{ user: DataFromCollectionSlug<TSlug> } & Result> => {\n  let args = incomingArgs\n\n  if (args.collection.config.auth.disableLocalStrategy) {\n    throw new Forbidden(args.req.t)\n  }\n\n  // /////////////////////////////////////\n  // beforeOperation - Collection\n  // /////////////////////////////////////\n\n  args = await buildBeforeOperation({\n    args,\n    collection: args.collection.config,\n    operation: 'login',\n    overrideAccess: args.overrideAccess!,\n  })\n\n  const {\n    collection: { config: collectionConfig },\n    data,\n    depth,\n    overrideAccess = false,\n    req,\n    req: {\n      fallbackLocale,\n      locale,\n      payload,\n      payload: { secret },\n    },\n    showHiddenFields,\n  } = args\n\n  // /////////////////////////////////////\n  // Login\n  // /////////////////////////////////////\n\n  const { email: unsanitizedEmail, password } = data\n  const loginWithUsername = collectionConfig.auth.loginWithUsername\n\n  const sanitizedEmail =\n    typeof unsanitizedEmail === 'string' ? unsanitizedEmail.toLowerCase().trim() : null\n  const sanitizedUsername =\n    'username' in data && typeof data?.username === 'string'\n      ? data.username.toLowerCase().trim()\n      : null\n\n  const { canLoginWithEmail, canLoginWithUsername } = getLoginOptions(loginWithUsername)\n\n  // cannot login with email, did not provide username\n  if (!canLoginWithEmail && !sanitizedUsername) {\n    throw new ValidationError({\n      collection: collectionConfig.slug,\n      errors: [{ message: req.i18n.t('validation:required'), path: 'username' }],\n    })\n  }\n\n  // cannot login with username, did not provide email\n  if (!canLoginWithUsername && !sanitizedEmail) {\n    throw new ValidationError({\n      collection: collectionConfig.slug,\n      errors: [{ message: req.i18n.t('validation:required'), path: 'email' }],\n    })\n  }\n\n  // can login with either email or username, did not provide either\n  if (!sanitizedUsername && !sanitizedEmail) {\n    throw new ValidationError({\n      collection: collectionConfig.slug,\n      errors: [\n        { message: req.i18n.t('validation:required'), path: 'email' },\n        { message: req.i18n.t('validation:required'), path: 'username' },\n      ],\n    })\n  }\n\n  // did not provide password for login\n  if (typeof password !== 'string' || password.trim() === '') {\n    throw new ValidationError({\n      collection: collectionConfig.slug,\n      errors: [{ message: req.i18n.t('validation:required'), path: 'password' }],\n    })\n  }\n\n  let whereConstraint: Where = {}\n  const emailConstraint: Where = {\n    email: {\n      equals: sanitizedEmail,\n    },\n  }\n  const usernameConstraint: Where = {\n    username: {\n      equals: sanitizedUsername,\n    },\n  }\n\n  if (canLoginWithEmail && canLoginWithUsername && (sanitizedUsername || sanitizedEmail)) {\n    if (sanitizedUsername) {\n      whereConstraint = {\n        or: [\n          usernameConstraint,\n          {\n            email: {\n              equals: sanitizedUsername,\n            },\n          },\n        ],\n      }\n    } else {\n      whereConstraint = {\n        or: [\n          emailConstraint,\n          {\n            username: {\n              equals: sanitizedEmail,\n            },\n          },\n        ],\n      }\n    }\n  } else if (canLoginWithEmail && sanitizedEmail) {\n    whereConstraint = emailConstraint\n  } else if (canLoginWithUsername && sanitizedUsername) {\n    whereConstraint = usernameConstraint\n  }\n\n  // Exclude trashed users\n  whereConstraint = appendNonTrashedFilter({\n    enableTrash: collectionConfig.trash,\n    trash: false,\n    where: whereConstraint,\n  })\n\n  let user = (await payload.db.findOne<TypedUser>({\n    collection: collectionConfig.slug,\n    req,\n    where: whereConstraint,\n  })) as TypedUser\n\n  checkLoginPermission({\n    loggingInWithUsername: Boolean(canLoginWithUsername && sanitizedUsername),\n    req,\n    user,\n  })\n\n  user.collection = collectionConfig.slug\n  user._strategy = 'local-jwt'\n\n  const authResult = await authenticateLocalStrategy({ doc: user, password })\n  user = sanitizeInternalFields(user)\n\n  const maxLoginAttemptsEnabled = args.collection.config.auth.maxLoginAttempts > 0\n\n  if (!authResult) {\n    if (maxLoginAttemptsEnabled) {\n      await incrementLoginAttempts({\n        collection: collectionConfig,\n        payload: req.payload,\n        user,\n      })\n\n      // Re-check login permissions and max attempts after incrementing attempts, in case parallel updates occurred\n      checkLoginPermission({\n        loggingInWithUsername: Boolean(canLoginWithUsername && sanitizedUsername),\n        req,\n        user,\n      })\n    }\n\n    throw new AuthenticationError(req.t)\n  }\n\n  if (collectionConfig.auth.verify && user._verified === false) {\n    throw new UnverifiedEmail({ t: req.t })\n  }\n\n  // Authentication successful - start transaction for remaining operations\n  const shouldCommit = await initTransaction(args.req)\n  let sid: string | undefined\n\n  try {\n    /*\n     * Correct password accepted - reâ€‘check that the account didn't\n     * get locked by parallel bad attempts in the meantime.\n     */\n    if (maxLoginAttemptsEnabled) {\n      const { lockUntil, loginAttempts } = (await payload.db.findOne<TypedUser>({\n        collection: collectionConfig.slug,\n        req,\n        select: {\n          lockUntil: true,\n          loginAttempts: true,\n        },\n        where: { id: { equals: user.id } },\n      }))!\n\n      user.lockUntil = lockUntil\n      user.loginAttempts = loginAttempts\n\n      checkLoginPermission({\n        req,\n        user,\n      })\n    }\n\n    const fieldsToSignArgs: Parameters<typeof getFieldsToSign>[0] = {\n      collectionConfig,\n      email: sanitizedEmail!,\n      user,\n    }\n\n    const session = await addSessionToUser({\n      collectionConfig,\n      payload,\n      req,\n      user,\n    })\n    sid = session.sid\n\n    if (sid) {\n      fieldsToSignArgs.sid = sid\n    }\n\n    const fieldsToSign = getFieldsToSign(fieldsToSignArgs)\n\n    if (maxLoginAttemptsEnabled) {\n      await resetLoginAttempts({\n        collection: collectionConfig,\n        doc: user,\n        payload: req.payload,\n        req,\n      })\n    }\n\n    // /////////////////////////////////////\n    // beforeLogin - Collection\n    // /////////////////////////////////////\n\n    if (collectionConfig.hooks?.beforeLogin?.length) {\n      for (const hook of collectionConfig.hooks.beforeLogin) {\n        user =\n          (await hook({\n            collection: args.collection?.config,\n            context: args.req.context,\n            req: args.req,\n            user,\n          })) || user\n      }\n    }\n\n    const { exp, token } = await jwtSign({\n      fieldsToSign,\n      secret,\n      tokenExpiration: collectionConfig.auth.tokenExpiration,\n    })\n\n    req.user = user\n\n    // /////////////////////////////////////\n    // afterLogin - Collection\n    // /////////////////////////////////////\n\n    if (collectionConfig.hooks?.afterLogin?.length) {\n      for (const hook of collectionConfig.hooks.afterLogin) {\n        user =\n          (await hook({\n            collection: args.collection?.config,\n            context: args.req.context,\n            req: args.req,\n            token,\n            user,\n          })) || user\n      }\n    }\n\n    // /////////////////////////////////////\n    // afterRead - Fields\n    // /////////////////////////////////////\n\n    user = await afterRead({\n      collection: collectionConfig,\n      context: req.context,\n      depth: depth!,\n      doc: user,\n      // @ts-expect-error - vestiges of when tsconfig was not strict. Feel free to improve\n      draft: undefined,\n      fallbackLocale: fallbackLocale!,\n      global: null,\n      locale: locale!,\n      overrideAccess,\n      req,\n      showHiddenFields: showHiddenFields!,\n    })\n\n    // /////////////////////////////////////\n    // afterRead - Collection\n    // /////////////////////////////////////\n\n    if (collectionConfig.hooks?.afterRead?.length) {\n      for (const hook of collectionConfig.hooks.afterRead) {\n        user =\n          (await hook({\n            collection: args.collection?.config,\n            context: req.context,\n            doc: user,\n            overrideAccess,\n            req,\n          })) || user\n      }\n    }\n\n    let result: { user: DataFromCollectionSlug<TSlug> } & Result = {\n      exp,\n      token,\n      user,\n    }\n\n    // /////////////////////////////////////\n    // afterOperation - Collection\n    // /////////////////////////////////////\n\n    result = await buildAfterOperation({\n      args,\n      collection: args.collection?.config,\n      operation: 'login',\n      overrideAccess: args.overrideAccess!,\n      result,\n    })\n\n    if (shouldCommit) {\n      await commitTransaction(req)\n    }\n\n    // /////////////////////////////////////\n    // Return results\n    // /////////////////////////////////////\n\n    return result\n  } catch (error: unknown) {\n    if (sid) {\n      await revokeSession({\n        collectionConfig,\n        payload,\n        req,\n        sid,\n        user,\n      })\n    }\n    await killTransaction(args.req)\n    throw error\n  }\n}\n"],"names":["buildAfterOperation","buildBeforeOperation","AuthenticationError","LockedAuth","UnverifiedEmail","ValidationError","afterRead","commitTransaction","Forbidden","initTransaction","appendNonTrashedFilter","killTransaction","sanitizeInternalFields","getFieldsToSign","getLoginOptions","isUserLocked","jwtSign","addSessionToUser","revokeSession","authenticateLocalStrategy","incrementLoginAttempts","resetLoginAttempts","checkLoginPermission","loggingInWithUsername","req","user","t","Boolean","Date","lockUntil","loginOperation","incomingArgs","args","collection","config","auth","disableLocalStrategy","operation","overrideAccess","collectionConfig","data","depth","fallbackLocale","locale","payload","secret","showHiddenFields","email","unsanitizedEmail","password","loginWithUsername","sanitizedEmail","toLowerCase","trim","sanitizedUsername","username","canLoginWithEmail","canLoginWithUsername","slug","errors","message","i18n","path","whereConstraint","emailConstraint","equals","usernameConstraint","or","enableTrash","trash","where","db","findOne","_strategy","authResult","doc","maxLoginAttemptsEnabled","maxLoginAttempts","verify","_verified","shouldCommit","sid","loginAttempts","select","id","fieldsToSignArgs","session","fieldsToSign","hooks","beforeLogin","length","hook","context","exp","token","tokenExpiration","afterLogin","draft","undefined","global","result","error"],"mappings":"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"}},
    {"offset": {"line": 996, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/auth/operations/local/login.ts"],"sourcesContent":["import type {\n  AuthOperationsFromCollectionSlug,\n  CollectionSlug,\n  DataFromCollectionSlug,\n  Payload,\n  RequestContext,\n} from '../../../index.js'\nimport type { PayloadRequest } from '../../../types/index.js'\nimport type { Result } from '../login.js'\n\nimport { APIError } from '../../../errors/index.js'\nimport { createLocalReq } from '../../../utilities/createLocalReq.js'\nimport { loginOperation } from '../login.js'\n\nexport type Options<TSlug extends CollectionSlug> = {\n  collection: TSlug\n  context?: RequestContext\n  data: AuthOperationsFromCollectionSlug<TSlug>['login']\n  depth?: number\n  fallbackLocale?: string\n  locale?: string\n  overrideAccess?: boolean\n  req?: Partial<PayloadRequest>\n  showHiddenFields?: boolean\n  trash?: boolean\n}\n\nexport async function loginLocal<TSlug extends CollectionSlug>(\n  payload: Payload,\n  options: Options<TSlug>,\n): Promise<{ user: DataFromCollectionSlug<TSlug> } & Result> {\n  const {\n    collection: collectionSlug,\n    data,\n    depth,\n    overrideAccess = true,\n    showHiddenFields,\n  } = options\n\n  const collection = payload.collections[collectionSlug]\n\n  if (!collection) {\n    throw new APIError(\n      `The collection with slug ${String(collectionSlug)} can't be found. Login Operation.`,\n    )\n  }\n\n  const args = {\n    collection,\n    data,\n    depth,\n    overrideAccess,\n    req: await createLocalReq(options, payload),\n    showHiddenFields,\n  }\n\n  const result = await loginOperation<TSlug>(args)\n\n  if (collection.config.auth.removeTokenFromResponses) {\n    delete result.token\n  }\n\n  return result\n}\n"],"names":["APIError","createLocalReq","loginOperation","loginLocal","payload","options","collection","collectionSlug","data","depth","overrideAccess","showHiddenFields","collections","String","args","req","result","config","auth","removeTokenFromResponses","token"],"mappings":";;;;AAUA,SAASA,QAAQ,QAAQ,2BAA0B;AACnD,SAASC,cAAc,QAAQ,uCAAsC;AACrE,SAASC,cAAc,QAAQ,cAAa;;;;AAerC,eAAeC,WACpBC,OAAgB,EAChBC,OAAuB;IAEvB,MAAM,EACJC,YAAYC,cAAc,EAC1BC,IAAI,EACJC,KAAK,EACLC,iBAAiB,IAAI,EACrBC,gBAAgB,EACjB,GAAGN;IAEJ,MAAMC,aAAaF,QAAQQ,WAAW,CAACL,eAAe;IAEtD,IAAI,CAACD,YAAY;QACf,MAAM,IAAIN,mKAAAA,CACR,CAAC,yBAAyB,EAAEa,OAAON,gBAAgB,iCAAiC,CAAC;IAEzF;IAEA,MAAMO,OAAO;QACXR;QACAE;QACAC;QACAC;QACAK,KAAK,UAAMd,kLAAAA,EAAeI,SAASD;QACnCO;IACF;IAEA,MAAMK,SAAS,UAAMd,kLAAAA,EAAsBY;IAE3C,IAAIR,WAAWW,MAAM,CAACC,IAAI,CAACC,wBAAwB,EAAE;QACnD,OAAOH,OAAOI,KAAK;IACrB;IAEA,OAAOJ;AACT"}},
    {"offset": {"line": 1030, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/auth/strategies/local/generatePasswordSaltHash.ts"],"sourcesContent":["import crypto from 'crypto'\n\nimport type { SanitizedCollectionConfig } from '../../../collections/config/types.js'\nimport type { PayloadRequest } from '../../../types/index.js'\n\nimport { ValidationError } from '../../../errors/index.js'\nimport { password } from '../../../fields/validations.js'\n\nfunction randomBytes(): Promise<Buffer> {\n  return new Promise((resolve, reject) =>\n    crypto.randomBytes(32, (err, saltBuffer) => (err ? reject(err) : resolve(saltBuffer))),\n  )\n}\n\nfunction pbkdf2Promisified(password: string, salt: string): Promise<Buffer> {\n  return new Promise((resolve, reject) =>\n    crypto.pbkdf2(password, salt, 25000, 512, 'sha256', (err, hashRaw) =>\n      err ? reject(err) : resolve(hashRaw),\n    ),\n  )\n}\n\ntype Args = {\n  collection: SanitizedCollectionConfig\n  password: string\n  req: PayloadRequest\n}\n\nexport const generatePasswordSaltHash = async ({\n  collection,\n  password: passwordToSet,\n  req,\n}: Args): Promise<{ hash: string; salt: string }> => {\n  const validationResult = password(passwordToSet, {\n    name: 'password',\n    type: 'text',\n    blockData: {},\n    data: {},\n    event: 'submit',\n    path: ['password'],\n    preferences: { fields: {} },\n    req,\n    required: true,\n    siblingData: {},\n  })\n\n  if (typeof validationResult === 'string') {\n    throw new ValidationError({\n      collection: collection?.slug,\n      errors: [{ message: validationResult, path: 'password' }],\n    })\n  }\n\n  const saltBuffer = await randomBytes()\n  const salt = saltBuffer.toString('hex')\n\n  const hashRaw = await pbkdf2Promisified(passwordToSet, salt)\n  const hash = hashRaw.toString('hex')\n\n  return { hash, salt }\n}\n"],"names":["crypto","ValidationError","password","randomBytes","Promise","resolve","reject","err","saltBuffer","pbkdf2Promisified","salt","pbkdf2","hashRaw","generatePasswordSaltHash","collection","passwordToSet","req","validationResult","name","type","blockData","data","event","path","preferences","fields","required","siblingData","slug","errors","message","toString","hash"],"mappings":";;;;AAAA,OAAOA,YAAY,SAAQ;AAK3B,SAASC,eAAe,QAAQ,2BAA0B;AAC1D,SAASC,QAAQ,QAAQ,iCAAgC;;;;AAEzD,SAASC;IACP,OAAO,IAAIC,QAAQ,CAACC,SAASC,SAC3BN,gHAAAA,CAAOG,WAAW,CAAC,IAAI,CAACI,KAAKC,aAAgBD,MAAMD,OAAOC,OAAOF,QAAQG;AAE7E;AAEA,SAASC,kBAAkBP,QAAgB,EAAEQ,IAAY;IACvD,OAAO,IAAIN,QAAQ,CAACC,SAASC,SAC3BN,gHAAAA,CAAOW,MAAM,CAACT,UAAUQ,MAAM,OAAO,KAAK,UAAU,CAACH,KAAKK,UACxDL,MAAMD,OAAOC,OAAOF,QAAQO;AAGlC;AAQO,MAAMC,2BAA2B,OAAO,EAC7CC,UAAU,EACVZ,UAAUa,aAAa,EACvBC,GAAG,EACE;IACL,MAAMC,uBAAmBf,sKAAAA,EAASa,eAAe;QAC/CG,MAAM;QACNC,MAAM;QACNC,WAAW,CAAC;QACZC,MAAM,CAAC;QACPC,OAAO;QACPC,MAAM;YAAC;SAAW;QAClBC,aAAa;YAAEC,QAAQ,CAAC;QAAE;QAC1BT;QACAU,UAAU;QACVC,aAAa,CAAC;IAChB;IAEA,IAAI,OAAOV,qBAAqB,UAAU;QACxC,MAAM,IAAIhB,iLAAAA,CAAgB;YACxBa,YAAYA,YAAYc;YACxBC,QAAQ;gBAAC;oBAAEC,SAASb;oBAAkBM,MAAM;gBAAW;aAAE;QAC3D;IACF;IAEA,MAAMf,aAAa,MAAML;IACzB,MAAMO,OAAOF,WAAWuB,QAAQ,CAAC;IAEjC,MAAMnB,UAAU,MAAMH,kBAAkBM,eAAeL;IACvD,MAAMsB,OAAOpB,QAAQmB,QAAQ,CAAC;IAE9B,OAAO;QAAEC;QAAMtB;IAAK;AACtB,EAAC"}},
    {"offset": {"line": 1087, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/auth/operations/resetPassword.ts"],"sourcesContent":["import { status as httpStatus } from 'http-status'\n\nimport type { Collection, DataFromCollectionSlug } from '../../collections/config/types.js'\nimport type { CollectionSlug, UntypedUser } from '../../index.js'\nimport type { PayloadRequest } from '../../types/index.js'\n\nimport { buildAfterOperation } from '../../collections/operations/utilities/buildAfterOperation.js'\nimport { buildBeforeOperation } from '../../collections/operations/utilities/buildBeforeOperation.js'\nimport { APIError, Forbidden } from '../../errors/index.js'\nimport { appendNonTrashedFilter } from '../../utilities/appendNonTrashedFilter.js'\nimport { commitTransaction } from '../../utilities/commitTransaction.js'\nimport { initTransaction } from '../../utilities/initTransaction.js'\nimport { killTransaction } from '../../utilities/killTransaction.js'\nimport { getFieldsToSign } from '../getFieldsToSign.js'\nimport { jwtSign } from '../jwt.js'\nimport { addSessionToUser, revokeSession } from '../sessions.js'\nimport { authenticateLocalStrategy } from '../strategies/local/authenticate.js'\nimport { generatePasswordSaltHash } from '../strategies/local/generatePasswordSaltHash.js'\n\nexport type Result = {\n  token?: string\n  user: Record<string, unknown>\n}\n\nexport type Arguments = {\n  collection: Collection\n  data: {\n    password: string\n    token: string\n  }\n  depth?: number\n  overrideAccess?: boolean\n  req: PayloadRequest\n}\n\nexport const resetPasswordOperation = async <TSlug extends CollectionSlug>(\n  args: Arguments,\n): Promise<Result> => {\n  const {\n    collection: { config: collectionConfig },\n    data,\n    depth,\n    overrideAccess,\n    req: {\n      payload: { secret },\n      payload,\n    },\n    req,\n  } = args\n\n  if (\n    !Object.prototype.hasOwnProperty.call(data, 'token') ||\n    !Object.prototype.hasOwnProperty.call(data, 'password')\n  ) {\n    throw new APIError('Missing required data.', httpStatus.BAD_REQUEST)\n  }\n\n  if (collectionConfig.auth.disableLocalStrategy) {\n    throw new Forbidden(req.t)\n  }\n\n  let sid: string | undefined\n  let user: null | UntypedUser = null\n\n  try {\n    const shouldCommit = await initTransaction(req)\n\n    args = await buildBeforeOperation({\n      args,\n      collection: args.collection.config,\n      operation: 'resetPassword',\n      overrideAccess,\n    })\n\n    // /////////////////////////////////////\n    // Reset Password\n    // /////////////////////////////////////\n\n    const where = appendNonTrashedFilter({\n      enableTrash: Boolean(collectionConfig.trash),\n      trash: false,\n      where: {\n        resetPasswordExpiration: { greater_than: new Date().toISOString() },\n        resetPasswordToken: { equals: data.token },\n      },\n    })\n\n    user = await payload.db.findOne<any>({\n      collection: collectionConfig.slug,\n      req,\n      where,\n    })\n\n    if (!user) {\n      throw new APIError('Token is either invalid or has expired.', httpStatus.FORBIDDEN)\n    }\n\n    // TODO: replace this method\n    const { hash, salt } = await generatePasswordSaltHash({\n      collection: collectionConfig,\n      password: data.password,\n      req,\n    })\n\n    user.salt = salt\n    user.hash = hash\n\n    user.resetPasswordExpiration = new Date().toISOString()\n\n    if (collectionConfig.auth.verify) {\n      user._verified = Boolean(user._verified)\n    }\n\n    // /////////////////////////////////////\n    // beforeValidate - Collection\n    // /////////////////////////////////////\n\n    if (collectionConfig.hooks?.beforeValidate?.length) {\n      for (const hook of collectionConfig.hooks.beforeValidate) {\n        await hook({\n          collection: args.collection?.config,\n          context: req.context,\n          data: user,\n          operation: 'update',\n          req,\n        })\n      }\n    }\n\n    // /////////////////////////////////////\n    // Update new password\n    // /////////////////////////////////////\n\n    // Ensure updatedAt date is always updated\n    user.updatedAt = new Date().toISOString()\n\n    const doc = await payload.db.updateOne({\n      id: user.id,\n      collection: collectionConfig.slug,\n      data: user,\n      req,\n    })\n\n    await authenticateLocalStrategy({ doc, password: data.password })\n\n    const fieldsToSignArgs: Parameters<typeof getFieldsToSign>[0] = {\n      collectionConfig,\n      email: user.email!,\n      user,\n    }\n\n    const session = await addSessionToUser({\n      collectionConfig,\n      payload,\n      req,\n      user,\n    })\n    sid = session.sid\n\n    if (sid) {\n      fieldsToSignArgs.sid = sid\n    }\n\n    const fieldsToSign = getFieldsToSign(fieldsToSignArgs)\n\n    // /////////////////////////////////////\n    // beforeLogin - Collection\n    // /////////////////////////////////////\n\n    let userBeforeLogin = user\n\n    if (collectionConfig.hooks?.beforeLogin?.length) {\n      for (const hook of collectionConfig.hooks.beforeLogin) {\n        userBeforeLogin =\n          (await hook({\n            collection: args.collection?.config,\n            context: args.req.context,\n            req: args.req,\n            user: userBeforeLogin,\n          })) || userBeforeLogin\n      }\n    }\n\n    const { token } = await jwtSign({\n      fieldsToSign,\n      secret,\n      tokenExpiration: collectionConfig.auth.tokenExpiration,\n    })\n\n    req.user = userBeforeLogin\n\n    // /////////////////////////////////////\n    // afterLogin - Collection\n    // /////////////////////////////////////\n\n    if (collectionConfig.hooks?.afterLogin?.length) {\n      for (const hook of collectionConfig.hooks.afterLogin) {\n        userBeforeLogin =\n          (await hook({\n            collection: args.collection?.config,\n            context: args.req.context,\n            req: args.req,\n            token,\n            user: userBeforeLogin,\n          })) || userBeforeLogin\n      }\n    }\n\n    const fullUser = await payload.findByID({\n      id: user.id,\n      collection: collectionConfig.slug,\n      depth,\n      overrideAccess,\n      req,\n      trash: false,\n    })\n\n    if (shouldCommit) {\n      await commitTransaction(req)\n    }\n\n    if (fullUser) {\n      fullUser.collection = collectionConfig.slug\n      fullUser._strategy = 'local-jwt'\n    }\n\n    let result: { user: DataFromCollectionSlug<TSlug> } & Result = {\n      token,\n      user: fullUser,\n    }\n\n    // /////////////////////////////////////\n    // afterOperation - Collection\n    // /////////////////////////////////////\n\n    result = await buildAfterOperation({\n      args,\n      collection: args.collection?.config,\n      operation: 'resetPassword',\n      overrideAccess,\n      result,\n    })\n\n    return result\n  } catch (error: unknown) {\n    if (sid) {\n      await revokeSession({\n        collectionConfig,\n        payload,\n        req,\n        sid,\n        user,\n      })\n    }\n    await killTransaction(req)\n    throw error\n  }\n}\n"],"names":["status","httpStatus","buildAfterOperation","buildBeforeOperation","APIError","Forbidden","appendNonTrashedFilter","commitTransaction","initTransaction","killTransaction","getFieldsToSign","jwtSign","addSessionToUser","revokeSession","authenticateLocalStrategy","generatePasswordSaltHash","resetPasswordOperation","args","collection","config","collectionConfig","data","depth","overrideAccess","req","payload","secret","Object","prototype","hasOwnProperty","call","BAD_REQUEST","auth","disableLocalStrategy","t","sid","user","shouldCommit","operation","where","enableTrash","Boolean","trash","resetPasswordExpiration","greater_than","Date","toISOString","resetPasswordToken","equals","token","db","findOne","slug","FORBIDDEN","hash","salt","password","verify","_verified","hooks","beforeValidate","length","hook","context","updatedAt","doc","updateOne","id","fieldsToSignArgs","email","session","fieldsToSign","userBeforeLogin","beforeLogin","tokenExpiration","afterLogin","fullUser","findByID","_strategy","result","error"],"mappings":"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"}},
    {"offset": {"line": 1299, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/auth/operations/local/resetPassword.ts"],"sourcesContent":["import type { CollectionSlug, Payload, RequestContext } from '../../../index.js'\nimport type { PayloadRequest } from '../../../types/index.js'\nimport type { Result } from '../resetPassword.js'\n\nimport { APIError } from '../../../errors/index.js'\nimport { createLocalReq } from '../../../utilities/createLocalReq.js'\nimport { resetPasswordOperation } from '../resetPassword.js'\n\nexport type Options<T extends CollectionSlug> = {\n  collection: T\n  context?: RequestContext\n  data: {\n    password: string\n    token: string\n  }\n  overrideAccess: boolean\n  req?: Partial<PayloadRequest>\n}\n\nexport async function resetPasswordLocal<TSlug extends CollectionSlug>(\n  payload: Payload,\n  options: Options<TSlug>,\n): Promise<Result> {\n  const { collection: collectionSlug, data, overrideAccess } = options\n\n  const collection = payload.collections[collectionSlug]\n\n  if (!collection) {\n    throw new APIError(\n      `The collection with slug ${String(\n        collectionSlug,\n      )} can't be found. Reset Password Operation.`,\n    )\n  }\n\n  const result = await resetPasswordOperation<TSlug>({\n    collection,\n    data,\n    overrideAccess,\n    req: await createLocalReq(options, payload),\n  })\n\n  if (collection.config.auth.removeTokenFromResponses) {\n    delete result.token\n  }\n\n  return result\n}\n"],"names":["APIError","createLocalReq","resetPasswordOperation","resetPasswordLocal","payload","options","collection","collectionSlug","data","overrideAccess","collections","String","result","req","config","auth","removeTokenFromResponses","token"],"mappings":";;;;AAIA,SAASA,QAAQ,QAAQ,2BAA0B;AACnD,SAASC,cAAc,QAAQ,uCAAsC;AACrE,SAASC,sBAAsB,QAAQ,sBAAqB;;;;AAarD,eAAeC,mBACpBC,OAAgB,EAChBC,OAAuB;IAEvB,MAAM,EAAEC,YAAYC,cAAc,EAAEC,IAAI,EAAEC,cAAc,EAAE,GAAGJ;IAE7D,MAAMC,aAAaF,QAAQM,WAAW,CAACH,eAAe;IAEtD,IAAI,CAACD,YAAY;QACf,MAAM,IAAIN,mKAAAA,CACR,CAAC,yBAAyB,EAAEW,OAC1BJ,gBACA,0CAA0C,CAAC;IAEjD;IAEA,MAAMK,SAAS,UAAMV,kMAAAA,EAA8B;QACjDI;QACAE;QACAC;QACAI,KAAK,UAAMZ,kLAAAA,EAAeI,SAASD;IACrC;IAEA,IAAIE,WAAWQ,MAAM,CAACC,IAAI,CAACC,wBAAwB,EAAE;QACnD,OAAOJ,OAAOK,KAAK;IACrB;IAEA,OAAOL;AACT"}},
    {"offset": {"line": 1330, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/auth/types.ts"],"sourcesContent":["import type { DeepRequired } from 'ts-essentials'\n\nimport type { CollectionSlug, GlobalSlug, Payload, TypedUser } from '../index.js'\nimport type { PayloadRequest, Where } from '../types/index.js'\n\n/**\n * A permission object that can be used to determine if a user has access to a specific operation.\n */\nexport type Permission = {\n  permission: boolean\n  where?: Where\n}\n\nexport type FieldsPermissions = {\n  [fieldName: string]: FieldPermissions\n}\n\nexport type BlockPermissions = {\n  create: Permission\n  fields: FieldsPermissions\n  read: Permission\n  update: Permission\n}\n\nexport type SanitizedBlockPermissions =\n  | {\n      fields: SanitizedFieldsPermissions\n    }\n  | true\n\nexport type BlocksPermissions = {\n  [blockSlug: string]: BlockPermissions\n}\n\nexport type SanitizedBlocksPermissions =\n  | {\n      [blockSlug: string]: SanitizedBlockPermissions\n    }\n  | true\n\nexport type FieldPermissions = {\n  blocks?: BlocksPermissions\n  create?: Permission\n  fields?: FieldsPermissions\n  read?: Permission\n  update?: Permission\n}\n\nexport type SanitizedFieldPermissions =\n  | {\n      blocks?: SanitizedBlocksPermissions\n      create: true\n      fields?: SanitizedFieldsPermissions\n      read: true\n      update: true\n    }\n  | true\n\nexport type SanitizedFieldsPermissions =\n  | {\n      [fieldName: string]: SanitizedFieldPermissions\n    }\n  | true\n\nexport type CollectionPermission = {\n  create?: Permission\n  delete?: Permission\n  fields: FieldsPermissions\n  read?: Permission\n  readVersions?: Permission\n  // Auth-enabled Collections only\n  unlock?: Permission\n  update?: Permission\n}\n\nexport type SanitizedCollectionPermission = {\n  create?: true\n  delete?: true\n  fields: SanitizedFieldsPermissions\n  read?: true\n  readVersions?: true\n  // Auth-enabled Collections only\n  unlock?: true\n  update?: true\n}\n\nexport type GlobalPermission = {\n  fields: FieldsPermissions\n  read?: Permission\n  readVersions?: Permission\n  update?: Permission\n}\n\nexport type SanitizedGlobalPermission = {\n  fields: SanitizedFieldsPermissions\n  read?: true\n  readVersions?: true\n  update?: true\n}\n\nexport type DocumentPermissions = CollectionPermission | GlobalPermission\n\nexport type SanitizedDocumentPermissions = SanitizedCollectionPermission | SanitizedGlobalPermission\n\nexport type Permissions = {\n  canAccessAdmin: boolean\n  collections?: Record<CollectionSlug, CollectionPermission>\n  globals?: Record<GlobalSlug, GlobalPermission>\n}\n\nexport type SanitizedPermissions = {\n  canAccessAdmin?: boolean\n  collections?: {\n    [collectionSlug: string]: SanitizedCollectionPermission\n  }\n  globals?: {\n    [globalSlug: string]: SanitizedGlobalPermission\n  }\n}\n\ntype BaseUser = {\n  collection: string\n  email?: string\n  id: number | string\n  sessions?: Array<UserSession>\n  username?: string\n}\n\n/**\n * @deprecated Use `TypedUser` instead. This will be removed in 4.0.\n */\nexport type UntypedUser = {\n  [key: string]: any\n} & BaseUser\n\n/**\n * `collection` is not available one the client. It's only available on the server (req.user)\n * On the client, you can access the collection via config.admin.user. Config can be accessed using the useConfig() hook\n */\nexport type ClientUser = {\n  [key: string]: any\n} & BaseUser\n\nexport type UserSession = { createdAt: Date | string; expiresAt: Date | string; id: string }\ntype GenerateVerifyEmailHTML<TUser = any> = (args: {\n  req: PayloadRequest\n  token: string\n  user: TUser\n}) => Promise<string> | string\n\ntype GenerateVerifyEmailSubject<TUser = any> = (args: {\n  req: PayloadRequest\n  token: string\n  user: TUser\n}) => Promise<string> | string\n\ntype GenerateForgotPasswordEmailHTML<TUser = any> = (args?: {\n  req?: PayloadRequest\n  token?: string\n  user?: TUser\n}) => Promise<string> | string\n\ntype GenerateForgotPasswordEmailSubject<TUser = any> = (args?: {\n  req?: PayloadRequest\n  token?: string\n  user?: TUser\n}) => Promise<string> | string\n\nexport type AuthStrategyFunctionArgs = {\n  /**\n   * Specifies whether or not response headers can be set from this strategy.\n   */\n  canSetHeaders?: boolean\n  headers: Request['headers']\n  isGraphQL?: boolean\n  payload: Payload\n  /**\n   * The AuthStrategy name property from the payload config.\n   */\n  strategyName?: string\n}\n\nexport type AuthStrategyResult = {\n  responseHeaders?: Headers\n  user:\n    | ({\n        _strategy?: string\n        collection?: string\n      } & TypedUser)\n    | null\n}\n\nexport type AuthStrategyFunction = (\n  args: AuthStrategyFunctionArgs,\n) => AuthStrategyResult | Promise<AuthStrategyResult>\nexport type AuthStrategy = {\n  authenticate: AuthStrategyFunction\n  name: string\n}\n\nexport type LoginWithUsernameOptions =\n  | {\n      allowEmailLogin?: false\n      requireEmail?: boolean\n      // If `allowEmailLogin` is false, `requireUsername` must be true (default: true)\n      requireUsername?: true\n    }\n  | {\n      allowEmailLogin?: true\n      requireEmail?: boolean\n      requireUsername?: boolean\n    }\n\nexport interface IncomingAuthType {\n  /**\n   * Set cookie options, including secure, sameSite, and domain. For advanced users.\n   */\n  cookies?: {\n    domain?: string\n    sameSite?: 'Lax' | 'None' | 'Strict' | boolean\n    secure?: boolean\n  }\n  /**\n   * How many levels deep a user document should be populated when creating the JWT and binding the user to the req. Defaults to 0 and should only be modified if absolutely necessary, as this will affect performance.\n   * @default 0\n   */\n  depth?: number\n  /**\n   * Advanced - disable Payload's built-in local auth strategy. Only use this property if you have replaced Payload's auth mechanisms with your own.\n   */\n  disableLocalStrategy?:\n    | {\n        /**\n         * Include auth fields on the collection even though the local strategy is disabled.\n         * Useful when you do not want the database or types to vary depending on the auth configuration.\n         */\n        enableFields?: true\n        optionalPassword?: true\n      }\n    | true\n  /**\n   * Customize the way that the forgotPassword operation functions.\n   * @link https://payloadcms.com/docs/authentication/email#forgot-password\n   */\n  forgotPassword?: {\n    /**\n     * The number of milliseconds that the forgot password token should be valid for.\n     * @default 3600000 // 1 hour\n     */\n    expiration?: number\n    generateEmailHTML?: GenerateForgotPasswordEmailHTML\n    generateEmailSubject?: GenerateForgotPasswordEmailSubject\n  }\n  /**\n   * Set the time (in milliseconds) that a user should be locked out if they fail authentication more times than maxLoginAttempts allows for.\n   */\n  lockTime?: number\n  /**\n   * Ability to allow users to login with username/password.\n   *\n   * @link https://payloadcms.com/docs/authentication/overview#login-with-username\n   */\n  loginWithUsername?: boolean | LoginWithUsernameOptions\n  /**\n   * Only allow a user to attempt logging in X amount of times. Automatically locks out a user from authenticating if this limit is passed. Set to 0 to disable.\n   */\n  maxLoginAttempts?: number\n  /***\n   * Set to true if you want to remove the token from the returned authentication API responses such as login or refresh.\n   */\n  removeTokenFromResponses?: true\n  /**\n   * Advanced - an array of custom authentification strategies to extend this collection's authentication with.\n   * @link https://payloadcms.com/docs/authentication/custom-strategies\n   */\n  strategies?: AuthStrategy[]\n  /**\n   * Controls how many seconds the token will be valid for. Default is 2 hours.\n   * @default 7200\n   * @link https://payloadcms.com/docs/authentication/overview#config-options\n   */\n  tokenExpiration?: number\n  /**\n   * Payload Authentication provides for API keys to be set on each user within an Authentication-enabled Collection.\n   * @default false\n   * @link https://payloadcms.com/docs/authentication/api-keys\n   */\n  useAPIKey?: boolean\n\n  /**\n   * Use sessions for authentication. Enabled by default.\n   * @default true\n   */\n  useSessions?: boolean\n\n  /**\n   * Set to true or pass an object with verification options to require users to verify by email before they are allowed to log into your app.\n   * @link https://payloadcms.com/docs/authentication/email#email-verification\n   */\n  verify?:\n    | {\n        generateEmailHTML?: GenerateVerifyEmailHTML\n        generateEmailSubject?: GenerateVerifyEmailSubject\n      }\n    | boolean\n}\n\nexport type VerifyConfig = {\n  generateEmailHTML?: GenerateVerifyEmailHTML\n  generateEmailSubject?: GenerateVerifyEmailSubject\n}\n\nexport interface Auth\n  extends Omit<DeepRequired<IncomingAuthType>, 'forgotPassword' | 'loginWithUsername' | 'verify'> {\n  forgotPassword?: {\n    expiration?: number\n    generateEmailHTML?: GenerateForgotPasswordEmailHTML\n    generateEmailSubject?: GenerateForgotPasswordEmailSubject\n  }\n  loginWithUsername: false | LoginWithUsernameOptions\n  verify?: boolean | VerifyConfig\n}\n\nexport function hasWhereAccessResult(result: boolean | Where): result is Where {\n  return result && typeof result === 'object'\n}\n"],"names":["hasWhereAccessResult","result"],"mappings":";;;;AAmUO,SAASA,qBAAqBC,MAAuB;IAC1D,OAAOA,UAAU,OAAOA,WAAW;AACrC"}},
    {"offset": {"line": 1341, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/auth/executeAccess.ts"],"sourcesContent":["import type { Access, AccessResult } from '../config/types.js'\nimport type { PayloadRequest } from '../types/index.js'\n\nimport { Forbidden } from '../errors/index.js'\n\ntype OperationArgs = {\n  data?: any\n  disableErrors?: boolean\n  id?: number | string\n  isReadingStaticFile?: boolean\n  req: PayloadRequest\n}\nexport const executeAccess = async (\n  { id, data, disableErrors, isReadingStaticFile = false, req }: OperationArgs,\n  access: Access,\n): Promise<AccessResult> => {\n  if (access) {\n    const resolvedConstraint = await access({\n      id,\n      data,\n      isReadingStaticFile,\n      req,\n    })\n\n    if (!resolvedConstraint) {\n      if (!disableErrors) {\n        throw new Forbidden(req.t)\n      }\n    }\n\n    return resolvedConstraint\n  }\n\n  if (req.user) {\n    return true\n  }\n\n  if (!disableErrors) {\n    throw new Forbidden(req.t)\n  }\n  return false\n}\n"],"names":["Forbidden","executeAccess","id","data","disableErrors","isReadingStaticFile","req","access","resolvedConstraint","t","user"],"mappings":";;;;AAGA,SAASA,SAAS,QAAQ,qBAAoB;;AASvC,MAAMC,gBAAgB,OAC3B,EAAEC,EAAE,EAAEC,IAAI,EAAEC,aAAa,EAAEC,sBAAsB,KAAK,EAAEC,GAAG,EAAiB,EAC5EC;IAEA,IAAIA,QAAQ;QACV,MAAMC,qBAAqB,MAAMD,OAAO;YACtCL;YACAC;YACAE;YACAC;QACF;QAEA,IAAI,CAACE,oBAAoB;YACvB,IAAI,CAACJ,eAAe;gBAClB,MAAM,IAAIJ,qKAAAA,CAAUM,IAAIG,CAAC;YAC3B;QACF;QAEA,OAAOD;IACT;IAEA,IAAIF,IAAII,IAAI,EAAE;QACZ,OAAO;IACT;IAEA,IAAI,CAACN,eAAe;QAClB,MAAM,IAAIJ,qKAAAA,CAAUM,IAAIG,CAAC;IAC3B;IACA,OAAO;AACT,EAAC"}},
    {"offset": {"line": 1374, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/auth/operations/unlock.ts"],"sourcesContent":["import { status as httpStatus } from 'http-status'\n\nimport type {\n  AuthOperationsFromCollectionSlug,\n  Collection,\n} from '../../collections/config/types.js'\nimport type { CollectionSlug } from '../../index.js'\nimport type { PayloadRequest, Where } from '../../types/index.js'\n\nimport { buildAfterOperation } from '../../collections/operations/utilities/buildAfterOperation.js'\nimport { buildBeforeOperation } from '../../collections/operations/utilities/buildBeforeOperation.js'\nimport { APIError } from '../../errors/index.js'\nimport { combineQueries, Forbidden } from '../../index.js'\nimport { appendNonTrashedFilter } from '../../utilities/appendNonTrashedFilter.js'\nimport { commitTransaction } from '../../utilities/commitTransaction.js'\nimport { initTransaction } from '../../utilities/initTransaction.js'\nimport { killTransaction } from '../../utilities/killTransaction.js'\nimport { executeAccess } from '../executeAccess.js'\nimport { getLoginOptions } from '../getLoginOptions.js'\nimport { resetLoginAttempts } from '../strategies/local/resetLoginAttempts.js'\n\nexport type Arguments<TSlug extends CollectionSlug> = {\n  collection: Collection\n  data: AuthOperationsFromCollectionSlug<TSlug>['unlock']\n  overrideAccess?: boolean\n  req: PayloadRequest\n}\n\nexport const unlockOperation = async <TSlug extends CollectionSlug>(\n  args: Arguments<TSlug>,\n): Promise<boolean> => {\n  const {\n    collection: { config: collectionConfig },\n    overrideAccess,\n    req: { locale },\n    req,\n  } = args\n\n  const loginWithUsername = collectionConfig.auth.loginWithUsername\n\n  const { canLoginWithEmail, canLoginWithUsername } = getLoginOptions(loginWithUsername)\n\n  const sanitizedEmail = canLoginWithEmail && (args.data?.email || '').toLowerCase().trim()\n  const sanitizedUsername =\n    (canLoginWithUsername &&\n      'username' in args.data &&\n      typeof args.data.username === 'string' &&\n      args.data.username.toLowerCase().trim()) ||\n    null\n\n  if (collectionConfig.auth.disableLocalStrategy) {\n    throw new Forbidden(req.t)\n  }\n  if (!sanitizedEmail && !sanitizedUsername) {\n    throw new APIError(\n      `Missing ${collectionConfig.auth.loginWithUsername ? 'username' : 'email'}.`,\n      httpStatus.BAD_REQUEST,\n    )\n  }\n\n  try {\n    args = await buildBeforeOperation({\n      args,\n      collection: args.collection.config,\n      operation: 'unlock',\n      overrideAccess,\n    })\n\n    const shouldCommit = await initTransaction(req)\n    let whereConstraint: Where = {}\n\n    // /////////////////////////////////////\n    // Access\n    // /////////////////////////////////////\n\n    if (!overrideAccess) {\n      const accessResult = await executeAccess({ req }, collectionConfig.access.unlock)\n\n      if (accessResult && typeof accessResult === 'object') {\n        whereConstraint = accessResult\n      }\n    }\n\n    // /////////////////////////////////////\n    // Unlock\n    // /////////////////////////////////////\n\n    if (canLoginWithEmail && sanitizedEmail) {\n      whereConstraint = combineQueries(whereConstraint, {\n        email: {\n          equals: sanitizedEmail,\n        },\n      })\n    } else if (canLoginWithUsername && sanitizedUsername) {\n      whereConstraint = combineQueries(whereConstraint, {\n        username: {\n          equals: sanitizedUsername,\n        },\n      })\n    }\n\n    // Exclude trashed users unless `trash: true`\n    whereConstraint = appendNonTrashedFilter({\n      enableTrash: Boolean(collectionConfig.trash),\n      trash: false,\n      where: whereConstraint,\n    })\n\n    const user = await req.payload.db.findOne({\n      collection: collectionConfig.slug,\n      locale: locale!,\n      req,\n      where: whereConstraint,\n    })\n\n    let result: boolean | null = null\n\n    if (user) {\n      await resetLoginAttempts({\n        collection: collectionConfig,\n        doc: user,\n        payload: req.payload,\n        req,\n      })\n      result = true\n    } else {\n      result = null\n      throw new Forbidden(req.t)\n    }\n\n    if (shouldCommit) {\n      await commitTransaction(req)\n    }\n\n    result = await buildAfterOperation({\n      args,\n      collection: args.collection.config,\n      operation: 'unlock',\n      overrideAccess,\n      result,\n    })\n\n    return Boolean(result)\n  } catch (error: unknown) {\n    await killTransaction(req)\n    throw error\n  }\n}\n"],"names":["status","httpStatus","buildAfterOperation","buildBeforeOperation","APIError","combineQueries","Forbidden","appendNonTrashedFilter","commitTransaction","initTransaction","killTransaction","executeAccess","getLoginOptions","resetLoginAttempts","unlockOperation","args","collection","config","collectionConfig","overrideAccess","req","locale","loginWithUsername","auth","canLoginWithEmail","canLoginWithUsername","sanitizedEmail","data","email","toLowerCase","trim","sanitizedUsername","username","disableLocalStrategy","t","BAD_REQUEST","operation","shouldCommit","whereConstraint","accessResult","access","unlock","equals","enableTrash","Boolean","trash","where","user","payload","db","findOne","slug","result","doc","error"],"mappings":"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"}},
    {"offset": {"line": 1497, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/auth/operations/local/unlock.ts"],"sourcesContent":["import type {\n  AuthOperationsFromCollectionSlug,\n  CollectionSlug,\n  Payload,\n  RequestContext,\n} from '../../../index.js'\nimport type { PayloadRequest } from '../../../types/index.js'\n\nimport { APIError } from '../../../errors/index.js'\nimport { createLocalReq } from '../../../utilities/createLocalReq.js'\nimport { unlockOperation } from '../unlock.js'\n\nexport type Options<TSlug extends CollectionSlug> = {\n  collection: TSlug\n  context?: RequestContext\n  data: AuthOperationsFromCollectionSlug<TSlug>['unlock']\n  overrideAccess: boolean\n  req?: Partial<PayloadRequest>\n}\n\nexport async function unlockLocal<TSlug extends CollectionSlug>(\n  payload: Payload,\n  options: Options<TSlug>,\n): Promise<boolean> {\n  const { collection: collectionSlug, data, overrideAccess = true } = options\n\n  const collection = payload.collections[collectionSlug]\n\n  if (!collection) {\n    throw new APIError(\n      `The collection with slug ${String(collectionSlug)} can't be found. Unlock Operation.`,\n    )\n  }\n\n  return unlockOperation<TSlug>({\n    collection,\n    data,\n    overrideAccess,\n    req: await createLocalReq(options, payload),\n  })\n}\n"],"names":["APIError","createLocalReq","unlockOperation","unlockLocal","payload","options","collection","collectionSlug","data","overrideAccess","collections","String","req"],"mappings":";;;;AAQA,SAASA,QAAQ,QAAQ,2BAA0B;AACnD,SAASC,cAAc,QAAQ,uCAAsC;AACrE,SAASC,eAAe,QAAQ,eAAc;;;;AAUvC,eAAeC,YACpBC,OAAgB,EAChBC,OAAuB;IAEvB,MAAM,EAAEC,YAAYC,cAAc,EAAEC,IAAI,EAAEC,iBAAiB,IAAI,EAAE,GAAGJ;IAEpE,MAAMC,aAAaF,QAAQM,WAAW,CAACH,eAAe;IAEtD,IAAI,CAACD,YAAY;QACf,MAAM,IAAIN,mKAAAA,CACR,CAAC,yBAAyB,EAAEW,OAAOJ,gBAAgB,kCAAkC,CAAC;IAE1F;IAEA,WAAOL,oLAAAA,EAAuB;QAC5BI;QACAE;QACAC;QACAG,KAAK,UAAMX,kLAAAA,EAAeI,SAASD;IACrC;AACF"}},
    {"offset": {"line": 1524, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/auth/operations/verifyEmail.ts"],"sourcesContent":["import { status as httpStatus } from 'http-status'\n\nimport type { Collection } from '../../collections/config/types.js'\nimport type { PayloadRequest } from '../../types/index.js'\n\nimport { APIError, Forbidden } from '../../errors/index.js'\nimport { appendNonTrashedFilter } from '../../utilities/appendNonTrashedFilter.js'\nimport { commitTransaction } from '../../utilities/commitTransaction.js'\nimport { initTransaction } from '../../utilities/initTransaction.js'\nimport { killTransaction } from '../../utilities/killTransaction.js'\n\nexport type Args = {\n  collection: Collection\n  req: PayloadRequest\n  token: string\n}\n\nexport const verifyEmailOperation = async (args: Args): Promise<boolean> => {\n  const { collection, req, token } = args\n\n  if (collection.config.auth.disableLocalStrategy) {\n    throw new Forbidden(req.t)\n  }\n  if (!Object.prototype.hasOwnProperty.call(args, 'token')) {\n    throw new APIError('Missing required data.', httpStatus.BAD_REQUEST)\n  }\n\n  try {\n    const shouldCommit = await initTransaction(req)\n\n    const where = appendNonTrashedFilter({\n      enableTrash: Boolean(collection.config.trash),\n      trash: false,\n      where: {\n        _verificationToken: { equals: token },\n      },\n    })\n\n    const user = await req.payload.db.findOne<any>({\n      collection: collection.config.slug,\n      req,\n      where,\n    })\n\n    if (!user) {\n      throw new APIError('Verification token is invalid.', httpStatus.FORBIDDEN)\n    }\n\n    // Ensure updatedAt date is always updated\n    user.updatedAt = new Date().toISOString()\n\n    await req.payload.db.updateOne({\n      id: user.id,\n      collection: collection.config.slug,\n      data: {\n        ...user,\n        _verificationToken: null,\n        _verified: true,\n      },\n      req,\n      returning: false,\n    })\n\n    if (shouldCommit) {\n      await commitTransaction(req)\n    }\n\n    return true\n  } catch (error: unknown) {\n    await killTransaction(req)\n    throw error\n  }\n}\n"],"names":["status","httpStatus","APIError","Forbidden","appendNonTrashedFilter","commitTransaction","initTransaction","killTransaction","verifyEmailOperation","args","collection","req","token","config","auth","disableLocalStrategy","t","Object","prototype","hasOwnProperty","call","BAD_REQUEST","shouldCommit","where","enableTrash","Boolean","trash","_verificationToken","equals","user","payload","db","findOne","slug","FORBIDDEN","updatedAt","Date","toISOString","updateOne","id","data","_verified","returning","error"],"mappings":";;;;;AAAA,SAASA,UAAUC,UAAU,QAAQ,cAAa;;AAKlD,SAASC,QAAQ,EAAEC,SAAS,QAAQ,wBAAuB;AAC3D,SAASC,sBAAsB,QAAQ,4CAA2C;AAClF,SAASC,iBAAiB,QAAQ,uCAAsC;AACxE,SAASC,eAAe,QAAQ,qCAAoC;AACpE,SAASC,eAAe,QAAQ,qCAAoC;;;;;;;AAQ7D,MAAMC,uBAAuB,OAAOC;IACzC,MAAM,EAAEC,UAAU,EAAEC,GAAG,EAAEC,KAAK,EAAE,GAAGH;IAEnC,IAAIC,WAAWG,MAAM,CAACC,IAAI,CAACC,oBAAoB,EAAE;QAC/C,MAAM,IAAIZ,qKAAAA,CAAUQ,IAAIK,CAAC;IAC3B;IACA,IAAI,CAACC,OAAOC,SAAS,CAACC,cAAc,CAACC,IAAI,CAACX,MAAM,UAAU;QACxD,MAAM,IAAIP,mKAAAA,CAAS,0BAA0BD,sMAAAA,CAAWoB,WAAW;IACrE;IAEA,IAAI;QACF,MAAMC,eAAe,UAAMhB,oLAAAA,EAAgBK;QAE3C,MAAMY,YAAQnB,kMAAAA,EAAuB;YACnCoB,aAAaC,QAAQf,WAAWG,MAAM,CAACa,KAAK;YAC5CA,OAAO;YACPH,OAAO;gBACLI,oBAAoB;oBAAEC,QAAQhB;gBAAM;YACtC;QACF;QAEA,MAAMiB,OAAO,MAAMlB,IAAImB,OAAO,CAACC,EAAE,CAACC,OAAO,CAAM;YAC7CtB,YAAYA,WAAWG,MAAM,CAACoB,IAAI;YAClCtB;YACAY;QACF;QAEA,IAAI,CAACM,MAAM;YACT,MAAM,IAAI3B,mKAAAA,CAAS,kCAAkCD,sMAAAA,CAAWiC,SAAS;QAC3E;QAEA,0CAA0C;QAC1CL,KAAKM,SAAS,GAAG,IAAIC,OAAOC,WAAW;QAEvC,MAAM1B,IAAImB,OAAO,CAACC,EAAE,CAACO,SAAS,CAAC;YAC7BC,IAAIV,KAAKU,EAAE;YACX7B,YAAYA,WAAWG,MAAM,CAACoB,IAAI;YAClCO,MAAM;gBACJ,GAAGX,IAAI;gBACPF,oBAAoB;gBACpBc,WAAW;YACb;YACA9B;YACA+B,WAAW;QACb;QAEA,IAAIpB,cAAc;YAChB,UAAMjB,wLAAAA,EAAkBM;QAC1B;QAEA,OAAO;IACT,EAAE,OAAOgC,OAAgB;QACvB,UAAMpC,oLAAAA,EAAgBI;QACtB,MAAMgC;IACR;AACF,EAAC"}},
    {"offset": {"line": 1595, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/auth/operations/local/verifyEmail.ts"],"sourcesContent":["import type { CollectionSlug, Payload, RequestContext } from '../../../index.js'\nimport type { PayloadRequest } from '../../../types/index.js'\n\nimport { APIError } from '../../../errors/index.js'\nimport { createLocalReq } from '../../../utilities/createLocalReq.js'\nimport { verifyEmailOperation } from '../verifyEmail.js'\n\nexport type Options<T extends CollectionSlug> = {\n  collection: T\n  context?: RequestContext\n  req?: Partial<PayloadRequest>\n  token: string\n}\n\nexport async function verifyEmailLocal<T extends CollectionSlug>(\n  payload: Payload,\n  options: Options<T>,\n): Promise<boolean> {\n  const { collection: collectionSlug, token } = options\n\n  const collection = payload.collections[collectionSlug]\n\n  if (!collection) {\n    throw new APIError(\n      `The collection with slug ${String(collectionSlug)} can't be found. Verify Email Operation.`,\n    )\n  }\n\n  return verifyEmailOperation({\n    collection,\n    req: await createLocalReq(options, payload),\n    token,\n  })\n}\n"],"names":["APIError","createLocalReq","verifyEmailOperation","verifyEmailLocal","payload","options","collection","collectionSlug","token","collections","String","req"],"mappings":";;;;AAGA,SAASA,QAAQ,QAAQ,2BAA0B;AACnD,SAASC,cAAc,QAAQ,uCAAsC;AACrE,SAASC,oBAAoB,QAAQ,oBAAmB;;;;AASjD,eAAeC,iBACpBC,OAAgB,EAChBC,OAAmB;IAEnB,MAAM,EAAEC,YAAYC,cAAc,EAAEC,KAAK,EAAE,GAAGH;IAE9C,MAAMC,aAAaF,QAAQK,WAAW,CAACF,eAAe;IAEtD,IAAI,CAACD,YAAY;QACf,MAAM,IAAIN,mKAAAA,CACR,CAAC,yBAAyB,EAAEU,OAAOH,gBAAgB,wCAAwC,CAAC;IAEhG;IAEA,WAAOL,8LAAAA,EAAqB;QAC1BI;QACAK,KAAK,UAAMV,kLAAAA,EAAeI,SAASD;QACnCI;IACF;AACF"}},
    {"offset": {"line": 1621, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/auth/ensureUsernameOrEmail.ts"],"sourcesContent":["import type { RequiredDataFromCollectionSlug } from '../collections/config/types.js'\nimport type { AuthCollection, CollectionSlug, PayloadRequest } from '../index.js'\n\nimport { ValidationError } from '../errors/index.js'\n\ntype ValidateUsernameOrEmailArgs<TSlug extends CollectionSlug> = {\n  authOptions: AuthCollection['config']['auth']\n  collectionSlug: string\n  data: RequiredDataFromCollectionSlug<TSlug>\n  req: PayloadRequest\n} & (\n  | {\n      operation: 'create'\n      originalDoc?: never\n    }\n  | {\n      operation: 'update'\n      originalDoc: RequiredDataFromCollectionSlug<TSlug>\n    }\n)\nexport const ensureUsernameOrEmail = <TSlug extends CollectionSlug>({\n  authOptions: { disableLocalStrategy, loginWithUsername },\n  collectionSlug,\n  data,\n  operation,\n  originalDoc,\n  req,\n}: ValidateUsernameOrEmailArgs<TSlug>) => {\n  // neither username or email are required\n  // and neither are provided\n  // so we need to manually validate\n  if (\n    !disableLocalStrategy &&\n    loginWithUsername &&\n    !loginWithUsername.requireEmail &&\n    !loginWithUsername.requireUsername\n  ) {\n    let missingFields = false\n    if (operation === 'create' && !data.email && !data.username) {\n      missingFields = true\n    } else if (operation === 'update') {\n      // prevent clearing both email and username\n      if ('email' in data && !data.email && 'username' in data && !data.username) {\n        missingFields = true\n      }\n      // prevent clearing email if no username\n      if ('email' in data && !data.email && !originalDoc.username && !data?.username) {\n        missingFields = true\n      }\n      // prevent clearing username if no email\n      if ('username' in data && !data.username && !originalDoc.email && !data?.email) {\n        missingFields = true\n      }\n    }\n\n    if (missingFields) {\n      throw new ValidationError(\n        {\n          collection: collectionSlug,\n          errors: [\n            {\n              message: 'Username or email is required',\n              path: 'username',\n            },\n            {\n              message: 'Username or email is required',\n              path: 'email',\n            },\n          ],\n        },\n        req.t,\n      )\n    }\n  }\n\n  return\n}\n"],"names":["ValidationError","ensureUsernameOrEmail","authOptions","disableLocalStrategy","loginWithUsername","collectionSlug","data","operation","originalDoc","req","requireEmail","requireUsername","missingFields","email","username","collection","errors","message","path","t"],"mappings":";;;;AAGA,SAASA,eAAe,QAAQ,qBAAoB;;AAiB7C,MAAMC,wBAAwB,CAA+B,EAClEC,aAAa,EAAEC,oBAAoB,EAAEC,iBAAiB,EAAE,EACxDC,cAAc,EACdC,IAAI,EACJC,SAAS,EACTC,WAAW,EACXC,GAAG,EACgC;IACnC,yCAAyC;IACzC,2BAA2B;IAC3B,kCAAkC;IAClC,IACE,CAACN,wBACDC,qBACA,CAACA,kBAAkBM,YAAY,IAC/B,CAACN,kBAAkBO,eAAe,EAClC;QACA,IAAIC,gBAAgB;QACpB,IAAIL,cAAc,YAAY,CAACD,KAAKO,KAAK,IAAI,CAACP,KAAKQ,QAAQ,EAAE;YAC3DF,gBAAgB;QAClB,OAAO,IAAIL,cAAc,UAAU;YACjC,2CAA2C;YAC3C,IAAI,WAAWD,QAAQ,CAACA,KAAKO,KAAK,IAAI,cAAcP,QAAQ,CAACA,KAAKQ,QAAQ,EAAE;gBAC1EF,gBAAgB;YAClB;YACA,wCAAwC;YACxC,IAAI,WAAWN,QAAQ,CAACA,KAAKO,KAAK,IAAI,CAACL,YAAYM,QAAQ,IAAI,CAACR,MAAMQ,UAAU;gBAC9EF,gBAAgB;YAClB;YACA,wCAAwC;YACxC,IAAI,cAAcN,QAAQ,CAACA,KAAKQ,QAAQ,IAAI,CAACN,YAAYK,KAAK,IAAI,CAACP,MAAMO,OAAO;gBAC9ED,gBAAgB;YAClB;QACF;QAEA,IAAIA,eAAe;YACjB,MAAM,IAAIZ,iLAAAA,CACR;gBACEe,YAAYV;gBACZW,QAAQ;oBACN;wBACEC,SAAS;wBACTC,MAAM;oBACR;oBACA;wBACED,SAAS;wBACTC,MAAM;oBACR;iBACD;YACH,GACAT,IAAIU,CAAC;QAET;IACF;IAEA;AACF,EAAC"}},
    {"offset": {"line": 1671, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/auth/sendVerificationEmail.ts"],"sourcesContent":["import { URL } from 'url'\n\nimport type { Collection } from '../collections/config/types.js'\nimport type { SanitizedConfig } from '../config/types.js'\nimport type { InitializedEmailAdapter } from '../email/types.js'\nimport type { TypedUser } from '../index.js'\nimport type { PayloadRequest } from '../types/index.js'\nimport type { VerifyConfig } from './types.js'\n\nimport { formatAdminURL } from '../utilities/formatAdminURL.js'\n\ntype Args = {\n  collection: Collection\n  config: SanitizedConfig\n  disableEmail: boolean\n  email: InitializedEmailAdapter\n  req: PayloadRequest\n  token: string\n  user: TypedUser\n}\n\nexport async function sendVerificationEmail(args: Args): Promise<void> {\n  // Verify token from e-mail\n  const {\n    collection: { config: collectionConfig },\n    config,\n    disableEmail,\n    email,\n    req,\n    token,\n    user,\n  } = args\n\n  if (!disableEmail) {\n    const protocol = new URL(req.url!).protocol // includes the final :\n    const serverURL =\n      config.serverURL !== null && config.serverURL !== ''\n        ? config.serverURL\n        : `${protocol}//${req.headers.get('host')}`\n\n    const verificationURL = formatAdminURL({\n      adminRoute: config.routes.admin,\n      path: `/${collectionConfig.slug}/verify/${token}`,\n      serverURL,\n    })\n\n    let html = `${req.t('authentication:newAccountCreated', {\n      serverURL: config.serverURL,\n      verificationURL,\n    })}`\n\n    const verify = collectionConfig.auth.verify as VerifyConfig\n\n    // Allow config to override email content\n    if (typeof verify.generateEmailHTML === 'function') {\n      html = await verify.generateEmailHTML({\n        req,\n        token,\n        user,\n      })\n    }\n\n    let subject = req.t('authentication:verifyYourEmail')\n\n    // Allow config to override email subject\n    if (typeof verify.generateEmailSubject === 'function') {\n      subject = await verify.generateEmailSubject({\n        req,\n        token,\n        user,\n      })\n    }\n\n    await email.sendEmail({\n      from: `\"${email.defaultFromName}\" <${email.defaultFromAddress}>`,\n      html,\n      subject,\n      to: user.email,\n    })\n  }\n}\n"],"names":["URL","formatAdminURL","sendVerificationEmail","args","collection","config","collectionConfig","disableEmail","email","req","token","user","protocol","url","serverURL","headers","get","verificationURL","adminRoute","routes","admin","path","slug","html","t","verify","auth","generateEmailHTML","subject","generateEmailSubject","sendEmail","from","defaultFromName","defaultFromAddress","to"],"mappings":";;;;AAAA,SAASA,GAAG,QAAQ,MAAK;AASzB,SAASC,cAAc,QAAQ,iCAAgC;;;AAYxD,eAAeC,sBAAsBC,IAAU;IACpD,2BAA2B;IAC3B,MAAM,EACJC,YAAY,EAAEC,QAAQC,gBAAgB,EAAE,EACxCD,MAAM,EACNE,YAAY,EACZC,KAAK,EACLC,GAAG,EACHC,KAAK,EACLC,IAAI,EACL,GAAGR;IAEJ,IAAI,CAACI,cAAc;QACjB,MAAMK,WAAW,IAAIZ,sGAAAA,CAAIS,IAAII,GAAG,EAAGD,QAAQ,CAAC,uBAAuB;;QACnE,MAAME,YACJT,OAAOS,SAAS,KAAK,QAAQT,OAAOS,SAAS,KAAK,KAC9CT,OAAOS,SAAS,GAChB,GAAGF,SAAS,EAAE,EAAEH,IAAIM,OAAO,CAACC,GAAG,CAAC,SAAS;QAE/C,MAAMC,sBAAkBhB,kLAAAA,EAAe;YACrCiB,YAAYb,OAAOc,MAAM,CAACC,KAAK;YAC/BC,MAAM,CAAC,CAAC,EAAEf,iBAAiBgB,IAAI,CAAC,QAAQ,EAAEZ,OAAO;YACjDI;QACF;QAEA,IAAIS,OAAO,GAAGd,IAAIe,CAAC,CAAC,oCAAoC;YACtDV,WAAWT,OAAOS,SAAS;YAC3BG;QACF,IAAI;QAEJ,MAAMQ,SAASnB,iBAAiBoB,IAAI,CAACD,MAAM;QAE3C,yCAAyC;QACzC,IAAI,OAAOA,OAAOE,iBAAiB,KAAK,YAAY;YAClDJ,OAAO,MAAME,OAAOE,iBAAiB,CAAC;gBACpClB;gBACAC;gBACAC;YACF;QACF;QAEA,IAAIiB,UAAUnB,IAAIe,CAAC,CAAC;QAEpB,yCAAyC;QACzC,IAAI,OAAOC,OAAOI,oBAAoB,KAAK,YAAY;YACrDD,UAAU,MAAMH,OAAOI,oBAAoB,CAAC;gBAC1CpB;gBACAC;gBACAC;YACF;QACF;QAEA,MAAMH,MAAMsB,SAAS,CAAC;YACpBC,MAAM,CAAC,CAAC,EAAEvB,MAAMwB,eAAe,CAAC,GAAG,EAAExB,MAAMyB,kBAAkB,CAAC,CAAC,CAAC;YAChEV;YACAK;YACAM,IAAIvB,KAAKH,KAAK;QAChB;IACF;AACF"}},
    {"offset": {"line": 1725, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/auth/strategies/local/register.ts"],"sourcesContent":["import type { SanitizedCollectionConfig } from '../../../collections/config/types.js'\nimport type { JsonObject, Payload } from '../../../index.js'\nimport type { PayloadRequest, SelectType, Where } from '../../../types/index.js'\n\nimport { ValidationError } from '../../../errors/index.js'\nimport { getLoginOptions } from '../../getLoginOptions.js'\nimport { generatePasswordSaltHash } from './generatePasswordSaltHash.js'\n\ntype Args = {\n  collection: SanitizedCollectionConfig\n  doc: JsonObject\n  password: string\n  payload: Payload\n  req: PayloadRequest\n}\n\nexport const registerLocalStrategy = async ({\n  collection,\n  doc,\n  password,\n  payload,\n  req,\n}: Args): Promise<Record<string, unknown>> => {\n  const loginWithUsername = collection?.auth?.loginWithUsername\n\n  const { canLoginWithEmail, canLoginWithUsername } = getLoginOptions(loginWithUsername)\n\n  let whereConstraint: Where\n\n  if (!canLoginWithUsername) {\n    whereConstraint = {\n      email: {\n        equals: doc.email,\n      },\n    }\n  } else {\n    whereConstraint = {\n      or: [],\n    }\n\n    if (canLoginWithEmail && doc.email) {\n      whereConstraint.or?.push({\n        email: {\n          equals: doc.email,\n        },\n      })\n    }\n\n    if (doc.username) {\n      whereConstraint.or?.push({\n        username: {\n          equals: doc.username,\n        },\n      })\n    }\n  }\n\n  const existingUser = await payload.find({\n    collection: collection.slug,\n    depth: 0,\n    limit: 1,\n    pagination: false,\n    req,\n    where: whereConstraint,\n  })\n\n  if (existingUser.docs.length > 0) {\n    throw new ValidationError({\n      collection: collection.slug,\n      errors: [\n        canLoginWithUsername\n          ? {\n              message: req.t('error:usernameAlreadyRegistered'),\n              path: 'username',\n            }\n          : { message: req.t('error:userEmailAlreadyRegistered'), path: 'email' },\n      ],\n    })\n  }\n\n  const { hash, salt } = await generatePasswordSaltHash({ collection, password, req })\n\n  const sanitizedDoc = { ...doc }\n  if (sanitizedDoc.password) {\n    delete sanitizedDoc.password\n  }\n\n  return payload.db.create({\n    collection: collection.slug,\n    data: {\n      ...sanitizedDoc,\n      hash,\n      salt,\n    },\n    req,\n  })\n}\n"],"names":["ValidationError","getLoginOptions","generatePasswordSaltHash","registerLocalStrategy","collection","doc","password","payload","req","loginWithUsername","auth","canLoginWithEmail","canLoginWithUsername","whereConstraint","email","equals","or","push","username","existingUser","find","slug","depth","limit","pagination","where","docs","length","errors","message","t","path","hash","salt","sanitizedDoc","db","create","data"],"mappings":";;;;AAIA,SAASA,eAAe,QAAQ,2BAA0B;AAC1D,SAASC,eAAe,QAAQ,2BAA0B;AAC1D,SAASC,wBAAwB,QAAQ,gCAA+B;;;;AAUjE,MAAMC,wBAAwB,OAAO,EAC1CC,UAAU,EACVC,GAAG,EACHC,QAAQ,EACRC,OAAO,EACPC,GAAG,EACE;IACL,MAAMC,oBAAoBL,YAAYM,MAAMD;IAE5C,MAAM,EAAEE,iBAAiB,EAAEC,oBAAoB,EAAE,OAAGX,+KAAAA,EAAgBQ;IAEpE,IAAII;IAEJ,IAAI,CAACD,sBAAsB;QACzBC,kBAAkB;YAChBC,OAAO;gBACLC,QAAQV,IAAIS,KAAK;YACnB;QACF;IACF,OAAO;QACLD,kBAAkB;YAChBG,IAAI,EAAE;QACR;QAEA,IAAIL,qBAAqBN,IAAIS,KAAK,EAAE;YAClCD,gBAAgBG,EAAE,EAAEC,KAAK;gBACvBH,OAAO;oBACLC,QAAQV,IAAIS,KAAK;gBACnB;YACF;QACF;QAEA,IAAIT,IAAIa,QAAQ,EAAE;YAChBL,gBAAgBG,EAAE,EAAEC,KAAK;gBACvBC,UAAU;oBACRH,QAAQV,IAAIa,QAAQ;gBACtB;YACF;QACF;IACF;IAEA,MAAMC,eAAe,MAAMZ,QAAQa,IAAI,CAAC;QACtChB,YAAYA,WAAWiB,IAAI;QAC3BC,OAAO;QACPC,OAAO;QACPC,YAAY;QACZhB;QACAiB,OAAOZ;IACT;IAEA,IAAIM,aAAaO,IAAI,CAACC,MAAM,GAAG,GAAG;QAChC,MAAM,IAAI3B,iLAAAA,CAAgB;YACxBI,YAAYA,WAAWiB,IAAI;YAC3BO,QAAQ;gBACNhB,uBACI;oBACEiB,SAASrB,IAAIsB,CAAC,CAAC;oBACfC,MAAM;gBACR,IACA;oBAAEF,SAASrB,IAAIsB,CAAC,CAAC;oBAAqCC,MAAM;gBAAQ;aACzE;QACH;IACF;IAEA,MAAM,EAAEC,IAAI,EAAEC,IAAI,EAAE,GAAG,UAAM/B,wNAAAA,EAAyB;QAAEE;QAAYE;QAAUE;IAAI;IAElF,MAAM0B,eAAe;QAAE,GAAG7B,GAAG;IAAC;IAC9B,IAAI6B,aAAa5B,QAAQ,EAAE;QACzB,OAAO4B,aAAa5B,QAAQ;IAC9B;IAEA,OAAOC,QAAQ4B,EAAE,CAACC,MAAM,CAAC;QACvBhC,YAAYA,WAAWiB,IAAI;QAC3BgB,MAAM;YACJ,GAAGH,YAAY;YACfF;YACAC;QACF;QACAzB;IACF;AACF,EAAC"}},
    {"offset": {"line": 1811, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/auth/defaultAccess.ts"],"sourcesContent":["import type { PayloadRequest } from '../types/index.js'\n\nexport const defaultAccess = ({ req: { user } }: { req: PayloadRequest }): boolean => Boolean(user)\n"],"names":["defaultAccess","req","user","Boolean"],"mappings":";;;;AAEO,MAAMA,gBAAgB,CAAC,EAAEC,KAAK,EAAEC,IAAI,EAAE,EAA2B,GAAcC,QAAQD,MAAK"}},
    {"offset": {"line": 1820, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/auth/crypto.ts"],"sourcesContent":["import crypto from 'crypto'\n\nconst algorithm = 'aes-256-ctr'\n\nexport function encrypt(text: string): string {\n  const iv = crypto.randomBytes(16)\n  // @ts-expect-error - vestiges of when tsconfig was not strict. Feel free to improve\n  const secret = this.secret\n  const cipher = crypto.createCipheriv(algorithm, secret, iv)\n\n  const encrypted = cipher.update(text, 'utf8', 'hex') + cipher.final('hex')\n  const ivString = iv.toString('hex')\n\n  return `${ivString}${encrypted}`\n}\n\nexport function decrypt(hash: string): string {\n  const iv = hash.slice(0, 32)\n  const content = hash.slice(32)\n\n  // @ts-expect-error - vestiges of when tsconfig was not strict. Feel free to improve\n  const secret = this.secret\n  const decipher = crypto.createDecipheriv(algorithm, secret, Buffer.from(iv, 'hex'))\n\n  return decipher.update(content, 'hex', 'utf8') + decipher.final('utf8')\n}\n"],"names":["crypto","algorithm","encrypt","text","iv","randomBytes","secret","cipher","createCipheriv","encrypted","update","final","ivString","toString","decrypt","hash","slice","content","decipher","createDecipheriv","Buffer","from"],"mappings":";;;;;;AAAA,OAAOA,YAAY,SAAQ;;AAE3B,MAAMC,YAAY;AAEX,SAASC,QAAQC,IAAY;IAClC,MAAMC,KAAKJ,gHAAAA,CAAOK,WAAW,CAAC;IAC9B,oFAAoF;IACpF,MAAMC,SAAS,IAAI,CAACA,MAAM;IAC1B,MAAMC,SAASP,gHAAAA,CAAOQ,cAAc,CAACP,WAAWK,QAAQF;IAExD,MAAMK,YAAYF,OAAOG,MAAM,CAACP,MAAM,QAAQ,SAASI,OAAOI,KAAK,CAAC;IACpE,MAAMC,WAAWR,GAAGS,QAAQ,CAAC;IAE7B,OAAO,GAAGD,WAAWH,WAAW;AAClC;AAEO,SAASK,QAAQC,IAAY;IAClC,MAAMX,KAAKW,KAAKC,KAAK,CAAC,GAAG;IACzB,MAAMC,UAAUF,KAAKC,KAAK,CAAC;IAE3B,oFAAoF;IACpF,MAAMV,SAAS,IAAI,CAACA,MAAM;IAC1B,MAAMY,WAAWlB,gHAAAA,CAAOmB,gBAAgB,CAAClB,WAAWK,QAAQc,OAAOC,IAAI,CAACjB,IAAI;IAE5E,OAAOc,SAASR,MAAM,CAACO,SAAS,OAAO,UAAUC,SAASP,KAAK,CAAC;AAClE"}},
    {"offset": {"line": 1850, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/auth/executeAuthStrategies.ts"],"sourcesContent":["import type { AuthStrategyFunctionArgs, AuthStrategyResult } from './index.js'\n\nimport { logError } from '../utilities/logError.js'\nimport { mergeHeaders } from '../utilities/mergeHeaders.js'\nexport const executeAuthStrategies = async (\n  args: AuthStrategyFunctionArgs,\n): Promise<AuthStrategyResult> => {\n  let result: AuthStrategyResult = { user: null }\n\n  if (!args.payload.authStrategies?.length) {\n    return result\n  }\n\n  for (const strategy of args.payload.authStrategies) {\n    // add the configured AuthStrategy `name` to the strategy function args\n    args.strategyName = strategy.name\n    args.isGraphQL = Boolean(args.isGraphQL)\n    args.canSetHeaders = Boolean(args.canSetHeaders)\n\n    try {\n      const authResult = await strategy.authenticate(args)\n      if (authResult.responseHeaders) {\n        authResult.responseHeaders = mergeHeaders(\n          result.responseHeaders || new Headers(),\n          authResult.responseHeaders || new Headers(),\n        )\n      }\n      result = authResult\n    } catch (err) {\n      logError({ err, payload: args.payload })\n    }\n\n    if (result.user) {\n      return result\n    }\n  }\n  return result\n}\n"],"names":["logError","mergeHeaders","executeAuthStrategies","args","result","user","payload","authStrategies","length","strategy","strategyName","name","isGraphQL","Boolean","canSetHeaders","authResult","authenticate","responseHeaders","Headers","err"],"mappings":";;;;AAEA,SAASA,QAAQ,QAAQ,2BAA0B;AACnD,SAASC,YAAY,QAAQ,+BAA8B;;;AACpD,MAAMC,wBAAwB,OACnCC;IAEA,IAAIC,SAA6B;QAAEC,MAAM;IAAK;IAE9C,IAAI,CAACF,KAAKG,OAAO,CAACC,cAAc,EAAEC,QAAQ;QACxC,OAAOJ;IACT;IAEA,KAAK,MAAMK,YAAYN,KAAKG,OAAO,CAACC,cAAc,CAAE;QAClD,uEAAuE;QACvEJ,KAAKO,YAAY,GAAGD,SAASE,IAAI;QACjCR,KAAKS,SAAS,GAAGC,QAAQV,KAAKS,SAAS;QACvCT,KAAKW,aAAa,GAAGD,QAAQV,KAAKW,aAAa;QAE/C,IAAI;YACF,MAAMC,aAAa,MAAMN,SAASO,YAAY,CAACb;YAC/C,IAAIY,WAAWE,eAAe,EAAE;gBAC9BF,WAAWE,eAAe,OAAGhB,8KAAAA,EAC3BG,OAAOa,eAAe,IAAI,IAAIC,WAC9BH,WAAWE,eAAe,IAAI,IAAIC;YAEtC;YACAd,SAASW;QACX,EAAE,OAAOI,KAAK;gBACZnB,sKAAAA,EAAS;gBAAEmB;gBAAKb,SAASH,KAAKG,OAAO;YAAC;QACxC;QAEA,IAAIF,OAAOC,IAAI,EAAE;YACf,OAAOD;QACT;IACF;IACA,OAAOA;AACT,EAAC"}},
    {"offset": {"line": 1892, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/auth/getAccessResults.ts"],"sourcesContent":["import type { AllOperations, PayloadRequest } from '../types/index.js'\nimport type { Permissions, SanitizedPermissions } from './types.js'\n\nimport { getEntityPermissions } from '../utilities/getEntityPermissions/getEntityPermissions.js'\nimport { sanitizePermissions } from '../utilities/sanitizePermissions.js'\n\ntype GetAccessResultsArgs = {\n  req: PayloadRequest\n}\nexport async function getAccessResults({\n  req,\n}: GetAccessResultsArgs): Promise<SanitizedPermissions> {\n  const results = {\n    collections: {},\n    globals: {},\n  } as Permissions\n  const { payload, user } = req\n\n  const isLoggedIn = !!user\n  const userCollectionConfig =\n    user && user.collection ? payload?.collections?.[user.collection]?.config : null\n\n  if (userCollectionConfig && payload.config.admin.user === user?.collection) {\n    results.canAccessAdmin = userCollectionConfig.access.admin\n      ? await userCollectionConfig.access.admin({ req })\n      : isLoggedIn\n  } else {\n    results.canAccessAdmin = false\n  }\n  const blockReferencesPermissions = {}\n\n  await Promise.all(\n    payload.config.collections.map(async (collection) => {\n      const collectionOperations: AllOperations[] = ['create', 'read', 'update', 'delete']\n\n      if (\n        collection.auth &&\n        typeof collection.auth.maxLoginAttempts !== 'undefined' &&\n        collection.auth.maxLoginAttempts !== 0\n      ) {\n        collectionOperations.push('unlock')\n      }\n\n      if (collection.versions) {\n        collectionOperations.push('readVersions')\n      }\n\n      const collectionPermissions = await getEntityPermissions({\n        blockReferencesPermissions,\n        entity: collection,\n        entityType: 'collection',\n        fetchData: false,\n        operations: collectionOperations,\n        req,\n      })\n      results.collections![collection.slug] = collectionPermissions\n    }),\n  )\n\n  await Promise.all(\n    payload.config.globals.map(async (global) => {\n      const globalOperations: AllOperations[] = ['read', 'update']\n\n      if (global.versions) {\n        globalOperations.push('readVersions')\n      }\n\n      const globalPermissions = await getEntityPermissions({\n        blockReferencesPermissions,\n        entity: global,\n        entityType: 'global',\n        fetchData: false,\n        operations: globalOperations,\n        req,\n      })\n      results.globals![global.slug] = globalPermissions\n    }),\n  )\n\n  return sanitizePermissions(results)\n}\n"],"names":["getEntityPermissions","sanitizePermissions","getAccessResults","req","results","collections","globals","payload","user","isLoggedIn","userCollectionConfig","collection","config","admin","canAccessAdmin","access","blockReferencesPermissions","Promise","all","map","collectionOperations","auth","maxLoginAttempts","push","versions","collectionPermissions","entity","entityType","fetchData","operations","slug","global","globalOperations","globalPermissions"],"mappings":";;;;AAGA,SAASA,oBAAoB,QAAQ,4DAA2D;AAChG,SAASC,mBAAmB,QAAQ,sCAAqC;;;AAKlE,eAAeC,iBAAiB,EACrCC,GAAG,EACkB;IACrB,MAAMC,UAAU;QACdC,aAAa,CAAC;QACdC,SAAS,CAAC;IACZ;IACA,MAAM,EAAEC,OAAO,EAAEC,IAAI,EAAE,GAAGL;IAE1B,MAAMM,aAAa,CAAC,CAACD;IACrB,MAAME,uBACJF,QAAQA,KAAKG,UAAU,GAAGJ,SAASF,aAAa,CAACG,KAAKG,UAAU,CAAC,EAAEC,SAAS;IAE9E,IAAIF,wBAAwBH,QAAQK,MAAM,CAACC,KAAK,CAACL,IAAI,KAAKA,MAAMG,YAAY;QAC1EP,QAAQU,cAAc,GAAGJ,qBAAqBK,MAAM,CAACF,KAAK,GACtD,MAAMH,qBAAqBK,MAAM,CAACF,KAAK,CAAC;YAAEV;QAAI,KAC9CM;IACN,OAAO;QACLL,QAAQU,cAAc,GAAG;IAC3B;IACA,MAAME,6BAA6B,CAAC;IAEpC,MAAMC,QAAQC,GAAG,CACfX,QAAQK,MAAM,CAACP,WAAW,CAACc,GAAG,CAAC,OAAOR;QACpC,MAAMS,uBAAwC;YAAC;YAAU;YAAQ;YAAU;SAAS;QAEpF,IACET,WAAWU,IAAI,IACf,OAAOV,WAAWU,IAAI,CAACC,gBAAgB,KAAK,eAC5CX,WAAWU,IAAI,CAACC,gBAAgB,KAAK,GACrC;YACAF,qBAAqBG,IAAI,CAAC;QAC5B;QAEA,IAAIZ,WAAWa,QAAQ,EAAE;YACvBJ,qBAAqBG,IAAI,CAAC;QAC5B;QAEA,MAAME,wBAAwB,UAAMzB,sNAAAA,EAAqB;YACvDgB;YACAU,QAAQf;YACRgB,YAAY;YACZC,WAAW;YACXC,YAAYT;YACZjB;QACF;QACAC,QAAQC,WAAY,CAACM,WAAWmB,IAAI,CAAC,GAAGL;IAC1C;IAGF,MAAMR,QAAQC,GAAG,CACfX,QAAQK,MAAM,CAACN,OAAO,CAACa,GAAG,CAAC,OAAOY;QAChC,MAAMC,mBAAoC;YAAC;YAAQ;SAAS;QAE5D,IAAID,OAAOP,QAAQ,EAAE;YACnBQ,iBAAiBT,IAAI,CAAC;QACxB;QAEA,MAAMU,oBAAoB,UAAMjC,sNAAAA,EAAqB;YACnDgB;YACAU,QAAQK;YACRJ,YAAY;YACZC,WAAW;YACXC,YAAYG;YACZ7B;QACF;QACAC,QAAQE,OAAQ,CAACyB,OAAOD,IAAI,CAAC,GAAGG;IAClC;IAGF,WAAOhC,4LAAAA,EAAoBG;AAC7B"}},
    {"offset": {"line": 1963, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/auth/operations/auth.ts"],"sourcesContent":["import type { SanitizedPermissions, TypedUser } from '../../index.js'\nimport type { PayloadRequest } from '../../types/index.js'\n\nimport { killTransaction } from '../../utilities/killTransaction.js'\nimport { executeAuthStrategies } from '../executeAuthStrategies.js'\nimport { getAccessResults } from '../getAccessResults.js'\n\nexport type AuthArgs = {\n  /**\n   * Specify if it's possible for auth strategies to set headers within this operation.\n   */\n  canSetHeaders?: boolean\n  headers: Request['headers']\n  req?: Omit<PayloadRequest, 'user'>\n}\n\nexport type AuthResult = {\n  permissions: SanitizedPermissions\n  responseHeaders?: Headers\n  user: null | TypedUser\n}\n\nexport const auth = async (args: Required<AuthArgs>): Promise<AuthResult> => {\n  const { canSetHeaders, headers } = args\n  const req = args.req as PayloadRequest\n  const { payload } = req\n\n  try {\n    const { responseHeaders, user } = await executeAuthStrategies({\n      canSetHeaders,\n      headers,\n      payload,\n    })\n\n    req.user = user\n    req.responseHeaders = responseHeaders\n\n    const permissions = await getAccessResults({\n      req,\n    })\n\n    return {\n      permissions,\n      responseHeaders,\n      user,\n    }\n  } catch (error: unknown) {\n    await killTransaction(req)\n    throw error\n  }\n}\n"],"names":["killTransaction","executeAuthStrategies","getAccessResults","auth","args","canSetHeaders","headers","req","payload","responseHeaders","user","permissions","error"],"mappings":";;;;AAGA,SAASA,eAAe,QAAQ,qCAAoC;AACpE,SAASC,qBAAqB,QAAQ,8BAA6B;AACnE,SAASC,gBAAgB,QAAQ,yBAAwB;;;;AAiBlD,MAAMC,OAAO,OAAOC;IACzB,MAAM,EAAEC,aAAa,EAAEC,OAAO,EAAE,GAAGF;IACnC,MAAMG,MAAMH,KAAKG,GAAG;IACpB,MAAM,EAAEC,OAAO,EAAE,GAAGD;IAEpB,IAAI;QACF,MAAM,EAAEE,eAAe,EAAEC,IAAI,EAAE,GAAG,UAAMT,2LAAAA,EAAsB;YAC5DI;YACAC;YACAE;QACF;QAEAD,IAAIG,IAAI,GAAGA;QACXH,IAAIE,eAAe,GAAGA;QAEtB,MAAME,cAAc,UAAMT,iLAAAA,EAAiB;YACzCK;QACF;QAEA,OAAO;YACLI;YACAF;YACAC;QACF;IACF,EAAE,OAAOE,OAAgB;QACvB,UAAMZ,oLAAAA,EAAgBO;QACtB,MAAMK;IACR;AACF,EAAC"}},
    {"offset": {"line": 2002, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/auth/operations/local/auth.ts"],"sourcesContent":["import type { Payload } from '../../../index.js'\nimport type { AuthArgs, AuthResult } from '../auth.js'\n\nimport { createLocalReq } from '../../../utilities/createLocalReq.js'\nimport { auth as authOperation } from '../auth.js'\n\nexport const authLocal = async (payload: Payload, options: AuthArgs): Promise<AuthResult> => {\n  const { headers, req } = options\n\n  return await authOperation({\n    canSetHeaders: Boolean(options.canSetHeaders),\n    headers,\n    req: await createLocalReq({ req }, payload),\n  })\n}\n"],"names":["createLocalReq","auth","authOperation","authLocal","payload","options","headers","req","canSetHeaders","Boolean"],"mappings":";;;;AAGA,SAASA,cAAc,QAAQ,uCAAsC;AACrE,SAASC,QAAQC,aAAa,QAAQ,aAAY;;;AAE3C,MAAMC,YAAY,OAAOC,SAAkBC;IAChD,MAAM,EAAEC,OAAO,EAAEC,GAAG,EAAE,GAAGF;IAEzB,OAAO,UAAMH,uKAAAA,EAAc;QACzBM,eAAeC,QAAQJ,QAAQG,aAAa;QAC5CF;QACAC,KAAK,UAAMP,kLAAAA,EAAe;YAAEO;QAAI,GAAGH;IACrC;AACF,EAAC"}},
    {"offset": {"line": 2024, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/auth/strategies/apiKey.ts"],"sourcesContent":["import crypto from 'crypto'\n\nimport type { SanitizedCollectionConfig } from '../../collections/config/types.js'\nimport type { TypedUser } from '../../index.js'\nimport type { Where } from '../../types/index.js'\nimport type { AuthStrategyFunction } from '../index.js'\n\nexport const APIKeyAuthentication =\n  (collectionConfig: SanitizedCollectionConfig): AuthStrategyFunction =>\n  async ({ headers, isGraphQL = false, payload }) => {\n    const authHeader = headers.get('Authorization')\n\n    if (authHeader?.startsWith(`${collectionConfig.slug} API-Key `)) {\n      const apiKey = authHeader.replace(`${collectionConfig.slug} API-Key `, '')\n\n      // TODO: V4 remove extra algorithm check\n      // api keys saved prior to v3.46.0 will have sha1\n      const sha1APIKeyIndex = crypto.createHmac('sha1', payload.secret).update(apiKey).digest('hex')\n      const sha256APIKeyIndex = crypto\n        .createHmac('sha256', payload.secret)\n        .update(apiKey)\n        .digest('hex')\n\n      const apiKeyConstraints = [\n        {\n          apiKeyIndex: {\n            equals: sha1APIKeyIndex,\n          },\n        },\n        {\n          apiKeyIndex: {\n            equals: sha256APIKeyIndex,\n          },\n        },\n      ]\n\n      try {\n        const where: Where = {}\n        if (collectionConfig.auth?.verify) {\n          where.and = [\n            {\n              or: apiKeyConstraints,\n            },\n            {\n              _verified: {\n                not_equals: false,\n              },\n            },\n          ]\n        } else {\n          where.or = apiKeyConstraints\n        }\n\n        const userQuery = await payload.find({\n          collection: collectionConfig.slug,\n          depth: isGraphQL ? 0 : collectionConfig.auth.depth,\n          limit: 1,\n          overrideAccess: true,\n          pagination: false,\n          where,\n        })\n\n        if (userQuery.docs && userQuery.docs.length > 0) {\n          const user = userQuery.docs[0]\n          user!.collection = collectionConfig.slug\n          user!._strategy = 'api-key'\n\n          return {\n            user: user as TypedUser,\n          }\n        }\n      } catch (ignore) {\n        return { user: null }\n      }\n    }\n\n    return { user: null }\n  }\n"],"names":["crypto","APIKeyAuthentication","collectionConfig","headers","isGraphQL","payload","authHeader","get","startsWith","slug","apiKey","replace","sha1APIKeyIndex","createHmac","secret","update","digest","sha256APIKeyIndex","apiKeyConstraints","apiKeyIndex","equals","where","auth","verify","and","or","_verified","not_equals","userQuery","find","collection","depth","limit","overrideAccess","pagination","docs","length","user","_strategy","ignore"],"mappings":";;;;AAAA,OAAOA,YAAY,SAAQ;;AAOpB,MAAMC,uBACX,CAACC,mBACD,OAAO,EAAEC,OAAO,EAAEC,YAAY,KAAK,EAAEC,OAAO,EAAE;QAC5C,MAAMC,aAAaH,QAAQI,GAAG,CAAC;QAE/B,IAAID,YAAYE,WAAW,GAAGN,iBAAiBO,IAAI,CAAC,SAAS,CAAC,GAAG;YAC/D,MAAMC,SAASJ,WAAWK,OAAO,CAAC,GAAGT,iBAAiBO,IAAI,CAAC,SAAS,CAAC,EAAE;YAEvE,wCAAwC;YACxC,iDAAiD;YACjD,MAAMG,kBAAkBZ,gHAAAA,CAAOa,UAAU,CAAC,QAAQR,QAAQS,MAAM,EAAEC,MAAM,CAACL,QAAQM,MAAM,CAAC;YACxF,MAAMC,oBAAoBjB,gHAAAA,CACvBa,UAAU,CAAC,UAAUR,QAAQS,MAAM,EACnCC,MAAM,CAACL,QACPM,MAAM,CAAC;YAEV,MAAME,oBAAoB;gBACxB;oBACEC,aAAa;wBACXC,QAAQR;oBACV;gBACF;gBACA;oBACEO,aAAa;wBACXC,QAAQH;oBACV;gBACF;aACD;YAED,IAAI;gBACF,MAAMI,QAAe,CAAC;gBACtB,IAAInB,iBAAiBoB,IAAI,EAAEC,QAAQ;oBACjCF,MAAMG,GAAG,GAAG;wBACV;4BACEC,IAAIP;wBACN;wBACA;4BACEQ,WAAW;gCACTC,YAAY;4BACd;wBACF;qBACD;gBACH,OAAO;oBACLN,MAAMI,EAAE,GAAGP;gBACb;gBAEA,MAAMU,YAAY,MAAMvB,QAAQwB,IAAI,CAAC;oBACnCC,YAAY5B,iBAAiBO,IAAI;oBACjCsB,OAAO3B,YAAY,IAAIF,iBAAiBoB,IAAI,CAACS,KAAK;oBAClDC,OAAO;oBACPC,gBAAgB;oBAChBC,YAAY;oBACZb;gBACF;gBAEA,IAAIO,UAAUO,IAAI,IAAIP,UAAUO,IAAI,CAACC,MAAM,GAAG,GAAG;oBAC/C,MAAMC,OAAOT,UAAUO,IAAI,CAAC,EAAE;oBAC9BE,KAAMP,UAAU,GAAG5B,iBAAiBO,IAAI;oBACxC4B,KAAMC,SAAS,GAAG;oBAElB,OAAO;wBACLD,MAAMA;oBACR;gBACF;YACF,EAAE,OAAOE,QAAQ;gBACf,OAAO;oBAAEF,MAAM;gBAAK;YACtB;QACF;QAEA,OAAO;YAAEA,MAAM;QAAK;IACtB,EAAC"}},
    {"offset": {"line": 2096, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/auth/extractJWT.ts"],"sourcesContent":["import type { BasePayload } from '../index.js'\nimport type { AuthStrategyFunctionArgs } from './index.js'\n\nimport { parseCookies } from '../utilities/parseCookies.js'\n\ntype ExtractionMethod = (args: { headers: Headers; payload: BasePayload }) => null | string\n\nconst extractionMethods: Record<string, ExtractionMethod> = {\n  Bearer: ({ headers }) => {\n    const jwtFromHeader = headers.get('Authorization')\n\n    // allow RFC6750 OAuth 2.0 compliant Bearer tokens\n    // in addition to the payload default JWT format\n    if (jwtFromHeader?.startsWith('Bearer ')) {\n      return jwtFromHeader.replace('Bearer ', '')\n    }\n\n    return null\n  },\n  cookie: ({ headers, payload }) => {\n    const origin = headers.get('Origin')\n    const cookies = parseCookies(headers)\n    const tokenCookieName = `${payload.config.cookiePrefix}-token`\n    const cookieToken = cookies.get(tokenCookieName)\n\n    if (!cookieToken) {\n      return null\n    }\n\n    if (!origin || payload.config.csrf.length === 0 || payload.config.csrf.indexOf(origin) > -1) {\n      return cookieToken\n    }\n\n    return null\n  },\n  JWT: ({ headers }) => {\n    const jwtFromHeader = headers.get('Authorization')\n\n    if (jwtFromHeader?.startsWith('JWT ')) {\n      return jwtFromHeader.replace('JWT ', '')\n    }\n\n    return null\n  },\n}\n\nexport const extractJWT = (args: Omit<AuthStrategyFunctionArgs, 'strategyName'>): null | string => {\n  const { headers, payload } = args\n\n  const extractionOrder = payload.config.auth.jwtOrder\n\n  for (const extractionStrategy of extractionOrder) {\n    const result = extractionMethods[extractionStrategy]!({ headers, payload })\n\n    if (result) {\n      return result\n    }\n  }\n\n  return null\n}\n"],"names":["parseCookies","extractionMethods","Bearer","headers","jwtFromHeader","get","startsWith","replace","cookie","payload","origin","cookies","tokenCookieName","config","cookiePrefix","cookieToken","csrf","length","indexOf","JWT","extractJWT","args","extractionOrder","auth","jwtOrder","extractionStrategy","result"],"mappings":";;;;AAGA,SAASA,YAAY,QAAQ,+BAA8B;;AAI3D,MAAMC,oBAAsD;IAC1DC,QAAQ,CAAC,EAAEC,OAAO,EAAE;QAClB,MAAMC,gBAAgBD,QAAQE,GAAG,CAAC;QAElC,kDAAkD;QAClD,gDAAgD;QAChD,IAAID,eAAeE,WAAW,YAAY;YACxC,OAAOF,cAAcG,OAAO,CAAC,WAAW;QAC1C;QAEA,OAAO;IACT;IACAC,QAAQ,CAAC,EAAEL,OAAO,EAAEM,OAAO,EAAE;QAC3B,MAAMC,SAASP,QAAQE,GAAG,CAAC;QAC3B,MAAMM,cAAUX,8KAAAA,EAAaG;QAC7B,MAAMS,kBAAkB,GAAGH,QAAQI,MAAM,CAACC,YAAY,CAAC,MAAM,CAAC;QAC9D,MAAMC,cAAcJ,QAAQN,GAAG,CAACO;QAEhC,IAAI,CAACG,aAAa;YAChB,OAAO;QACT;QAEA,IAAI,CAACL,UAAUD,QAAQI,MAAM,CAACG,IAAI,CAACC,MAAM,KAAK,KAAKR,QAAQI,MAAM,CAACG,IAAI,CAACE,OAAO,CAACR,UAAU,CAAC,GAAG;YAC3F,OAAOK;QACT;QAEA,OAAO;IACT;IACAI,KAAK,CAAC,EAAEhB,OAAO,EAAE;QACf,MAAMC,gBAAgBD,QAAQE,GAAG,CAAC;QAElC,IAAID,eAAeE,WAAW,SAAS;YACrC,OAAOF,cAAcG,OAAO,CAAC,QAAQ;QACvC;QAEA,OAAO;IACT;AACF;AAEO,MAAMa,aAAa,CAACC;IACzB,MAAM,EAAElB,OAAO,EAAEM,OAAO,EAAE,GAAGY;IAE7B,MAAMC,kBAAkBb,QAAQI,MAAM,CAACU,IAAI,CAACC,QAAQ;IAEpD,KAAK,MAAMC,sBAAsBH,gBAAiB;QAChD,MAAMI,SAASzB,iBAAiB,CAACwB,mBAAmB,CAAE;YAAEtB;YAASM;QAAQ;QAEzE,IAAIiB,QAAQ;YACV,OAAOA;QACT;IACF;IAEA,OAAO;AACT,EAAC"}},
    {"offset": {"line": 2151, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/auth/strategies/jwt.ts"],"sourcesContent":["import { jwtVerify } from 'jose'\n\nimport type { Payload, Where } from '../../types/index.js'\nimport type { AuthStrategyFunction, AuthStrategyResult } from '../index.js'\n\nimport { extractJWT } from '../extractJWT.js'\n\ntype JWTToken = {\n  collection: string\n  id: string\n  sid?: string\n}\n\nasync function autoLogin({\n  isGraphQL,\n  payload,\n  strategyName = 'local-jwt',\n}: {\n  isGraphQL: boolean\n  payload: Payload\n  strategyName?: string\n}): Promise<{\n  user: AuthStrategyResult['user']\n}> {\n  if (\n    typeof payload?.config?.admin?.autoLogin !== 'object' ||\n    payload.config.admin?.autoLogin.prefillOnly ||\n    !payload?.config?.admin?.autoLogin ||\n    (!payload.config.admin?.autoLogin.email && !payload.config.admin?.autoLogin.username)\n  ) {\n    return { user: null }\n  }\n\n  const collection = payload.collections[payload.config.admin.user]\n\n  const where: Where = {\n    or: [],\n  }\n  if (payload.config.admin?.autoLogin.email) {\n    where.or?.push({\n      email: {\n        equals: payload.config.admin?.autoLogin.email,\n      },\n    })\n  } else if (payload.config.admin?.autoLogin.username) {\n    where.or?.push({\n      username: {\n        equals: payload.config.admin?.autoLogin.username,\n      },\n    })\n  }\n\n  const user = (\n    await payload.find({\n      collection: collection!.config.slug,\n      depth: isGraphQL ? 0 : collection!.config.auth.depth,\n      limit: 1,\n      pagination: false,\n      where,\n    })\n  ).docs[0] as AuthStrategyResult['user']\n\n  if (!user) {\n    return { user: null }\n  }\n  user.collection = collection!.config.slug\n  user._strategy = strategyName\n\n  return {\n    user,\n  }\n}\n\n/**\n * Authentication strategy function for JWT tokens\n */\nexport const JWTAuthentication: AuthStrategyFunction = async ({\n  headers,\n  isGraphQL = false,\n  payload,\n  strategyName = 'local-jwt',\n}) => {\n  try {\n    const token = extractJWT({ headers, payload })\n\n    if (!token) {\n      if (headers.get('DisableAutologin') !== 'true') {\n        return await autoLogin({ isGraphQL, payload, strategyName })\n      }\n      return { user: null }\n    }\n\n    const secretKey = new TextEncoder().encode(payload.secret)\n    const { payload: decodedPayload } = await jwtVerify<JWTToken>(token, secretKey)\n    const collection = payload.collections[decodedPayload.collection]\n\n    const user = (await payload.findByID({\n      id: decodedPayload.id,\n      collection: decodedPayload.collection,\n      depth: isGraphQL ? 0 : collection!.config.auth.depth,\n    })) as AuthStrategyResult['user']\n\n    if (user && (!collection!.config.auth.verify || user._verified)) {\n      if (collection!.config.auth.useSessions) {\n        const existingSession = (user.sessions || []).find(({ id }) => id === decodedPayload.sid)\n\n        if (!existingSession || !decodedPayload.sid) {\n          return {\n            user: null,\n          }\n        }\n\n        user._sid = decodedPayload.sid\n      }\n\n      user.collection = collection!.config.slug\n      user._strategy = strategyName\n      return {\n        user,\n      }\n    } else {\n      if (headers.get('DisableAutologin') !== 'true') {\n        return await autoLogin({ isGraphQL, payload, strategyName })\n      }\n      return { user: null }\n    }\n  } catch (ignore) {\n    if (headers.get('DisableAutologin') !== 'true') {\n      return await autoLogin({ isGraphQL, payload, strategyName })\n    }\n    return { user: null }\n  }\n}\n"],"names":["jwtVerify","extractJWT","autoLogin","isGraphQL","payload","strategyName","config","admin","prefillOnly","email","username","user","collection","collections","where","or","push","equals","find","slug","depth","auth","limit","pagination","docs","_strategy","JWTAuthentication","headers","token","get","secretKey","TextEncoder","encode","secret","decodedPayload","findByID","id","verify","_verified","useSessions","existingSession","sessions","sid","_sid","ignore"],"mappings":"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"}}]
}