{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/utilities/addDataAndFileToRequest.ts"],"sourcesContent":["import type { PayloadRequest } from '../types/index.js'\n\nimport { APIError } from '../errors/APIError.js'\nimport { processMultipartFormdata } from '../uploads/fetchAPI-multipart/index.js'\n\ntype AddDataAndFileToRequest = (req: PayloadRequest) => Promise<void>\n\n/**\n * Mutates the Request, appending 'data' and 'file' if found\n */\nexport const addDataAndFileToRequest: AddDataAndFileToRequest = async (req) => {\n  const { body, headers, method, payload } = req\n\n  if (method && ['PATCH', 'POST', 'PUT'].includes(method.toUpperCase()) && body) {\n    const [contentType] = (headers.get('Content-Type') || '').split(';', 1)\n    const bodyByteSize = parseInt(req.headers.get('Content-Length') || '0', 10)\n\n    if (contentType === 'application/json') {\n      let data = {}\n      try {\n        const text = await req.text?.()\n        data = text ? JSON.parse(text) : {}\n      } catch (error) {\n        req.payload.logger.error(error)\n      } finally {\n        req.data = data\n        // @ts-expect-error attach json method to request\n        req.json = () => Promise.resolve(data)\n      }\n    } else if (bodyByteSize && contentType?.includes('multipart/')) {\n      const { error, fields, files } = await processMultipartFormdata({\n        options: {\n          ...(payload.config.bodyParser || {}),\n          ...(payload.config.upload || {}),\n        },\n        request: req as Request,\n      })\n\n      if (error) {\n        throw new APIError(error.message)\n      }\n\n      if (files?.file) {\n        req.file = files.file\n      }\n\n      if (fields?._payload && typeof fields._payload === 'string') {\n        req.data = JSON.parse(fields._payload)\n      }\n\n      if (!req.file && fields?.file && typeof fields?.file === 'string') {\n        const { clientUploadContext, collectionSlug, filename, mimeType, size } = JSON.parse(\n          fields.file,\n        )\n        const uploadConfig = req.payload.collections[collectionSlug]!.config.upload\n\n        if (!uploadConfig.handlers) {\n          throw new APIError('uploadConfig.handlers is not present for ' + collectionSlug)\n        }\n\n        let response: null | Response = null\n        let error: unknown\n\n        for (const handler of uploadConfig.handlers) {\n          try {\n            const result = await handler(req, {\n              doc: null!,\n              params: {\n                clientUploadContext, // Pass additional specific to adapters context returned from UploadHandler, then staticHandler can use them.\n                collection: collectionSlug,\n                filename,\n              },\n            })\n            if (result) {\n              response = result\n            }\n            // If we couldn't get the file from that handler, save the error and try other.\n          } catch (err) {\n            error = err\n          }\n        }\n\n        if (!response) {\n          if (error) {\n            payload.logger.error(error)\n          }\n\n          throw new APIError('Expected response from the upload handler.')\n        }\n\n        req.file = {\n          name: filename,\n          clientUploadContext,\n          data: Buffer.from(await response.arrayBuffer()),\n          mimetype: response.headers.get('Content-Type') || mimeType,\n          size,\n        }\n      }\n    }\n  }\n}\n"],"names":["APIError","processMultipartFormdata","addDataAndFileToRequest","req","body","headers","method","payload","includes","toUpperCase","contentType","get","split","bodyByteSize","parseInt","data","text","JSON","parse","error","logger","json","Promise","resolve","fields","files","options","config","bodyParser","upload","request","message","file","_payload","clientUploadContext","collectionSlug","filename","mimeType","size","uploadConfig","collections","handlers","response","handler","result","doc","params","collection","err","name","Buffer","from","arrayBuffer","mimetype"],"mappings":"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"}},
    {"offset": {"line": 97, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/utilities/sanitizeFallbackLocale.ts"],"sourcesContent":["import type { SanitizedLocalizationConfig } from '../config/types.js'\nimport type { TypedFallbackLocale } from '../index.js'\n\ninterface Args {\n  fallbackLocale: TypedFallbackLocale\n  locale: string\n  localization: SanitizedLocalizationConfig\n}\n\n/**\n * Sanitizes fallbackLocale based on a provided fallbackLocale, locale and localization config\n *\n * Handles the following scenarios:\n * - determines if a fallback locale should be used\n * - determines if a locale specific fallback should be used in place of the default locale\n * - sets the fallbackLocale to 'null' if no fallback locale should be used\n */\nexport const sanitizeFallbackLocale = ({\n  fallbackLocale,\n  locale,\n  localization,\n}: Args): TypedFallbackLocale => {\n  if (fallbackLocale === undefined || fallbackLocale === null) {\n    if (localization && localization.fallback) {\n      // Check for locale specific fallback\n      const localeSpecificFallback = localization.locales.length\n        ? localization.locales.find((localeConfig) => localeConfig.code === locale)?.fallbackLocale\n        : undefined\n\n      if (localeSpecificFallback) {\n        return localeSpecificFallback\n      }\n\n      return localization.defaultLocale\n    }\n\n    return false\n  } else if (Array.isArray(fallbackLocale)) {\n    return fallbackLocale.filter((localeCode) => localization.localeCodes.includes(localeCode))\n  } else if (fallbackLocale) {\n    if (['false', 'none', 'null'].includes(fallbackLocale)) {\n      return false\n    }\n\n    if (localization.localeCodes.includes(fallbackLocale)) {\n      return fallbackLocale\n    }\n  }\n\n  return false\n}\n"],"names":["sanitizeFallbackLocale","fallbackLocale","locale","localization","undefined","fallback","localeSpecificFallback","locales","length","find","localeConfig","code","defaultLocale","Array","isArray","filter","localeCode","localeCodes","includes"],"mappings":"AASA;;;;;;;CAOC,GACD;;;;AAAO,MAAMA,yBAAyB,CAAC,EACrCC,cAAc,EACdC,MAAM,EACNC,YAAY,EACP;IACL,IAAIF,mBAAmBG,aAAaH,mBAAmB,MAAM;QAC3D,IAAIE,gBAAgBA,aAAaE,QAAQ,EAAE;YACzC,qCAAqC;YACrC,MAAMC,yBAAyBH,aAAaI,OAAO,CAACC,MAAM,GACtDL,aAAaI,OAAO,CAACE,IAAI,CAAC,CAACC,eAAiBA,aAAaC,IAAI,KAAKT,SAASD,iBAC3EG;YAEJ,IAAIE,wBAAwB;gBAC1B,OAAOA;YACT;YAEA,OAAOH,aAAaS,aAAa;QACnC;QAEA,OAAO;IACT,OAAO,IAAIC,MAAMC,OAAO,CAACb,iBAAiB;QACxC,OAAOA,eAAec,MAAM,CAAC,CAACC,aAAeb,aAAac,WAAW,CAACC,QAAQ,CAACF;IACjF,OAAO,IAAIf,gBAAgB;QACzB,IAAI;YAAC;YAAS;YAAQ;SAAO,CAACiB,QAAQ,CAACjB,iBAAiB;YACtD,OAAO;QACT;QAEA,IAAIE,aAAac,WAAW,CAACC,QAAQ,CAACjB,iBAAiB;YACrD,OAAOA;QACT;IACF;IAEA,OAAO;AACT,EAAC"}},
    {"offset": {"line": 139, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/utilities/addLocalesToRequest.ts"],"sourcesContent":["import type { SanitizedConfig } from '../config/types.js'\nimport type { TypedFallbackLocale } from '../index.js'\nimport type { PayloadRequest } from '../types/index.js'\n\nimport { sanitizeFallbackLocale } from './sanitizeFallbackLocale.js'\n\n/**\n * Mutates the Request to contain 'locale' and 'fallbackLocale' based on data or searchParams\n */\nexport function addLocalesToRequestFromData(req: PayloadRequest): void {\n  const {\n    data,\n    payload: { config },\n  } = req\n\n  if (data) {\n    const localeOnReq = req.locale\n    const fallbackLocaleOnReq = req.fallbackLocale\n    let localeFromData!: string\n    let fallbackLocaleFromData!: string | string[]\n\n    if (!localeOnReq && data?.locale && typeof data.locale === 'string') {\n      localeFromData = data.locale\n    }\n\n    if (!fallbackLocaleOnReq) {\n      if (data?.['fallback-locale'] && typeof data?.['fallback-locale'] === 'string') {\n        fallbackLocaleFromData = data['fallback-locale']\n      }\n\n      if (data?.['fallbackLocale'] && typeof data?.['fallbackLocale'] === 'string') {\n        fallbackLocaleFromData = data['fallbackLocale']\n      }\n    }\n\n    if (!localeOnReq || !fallbackLocaleOnReq) {\n      const { fallbackLocale, locale } = sanitizeLocales({\n        fallbackLocale: fallbackLocaleFromData,\n        locale: localeFromData,\n        localization: config.localization,\n      })\n\n      if (localeFromData) {\n        req.locale = locale\n      }\n\n      if (fallbackLocaleFromData) {\n        req.fallbackLocale = fallbackLocale\n      }\n    }\n  }\n}\n\ntype SanitizeLocalesArgs = {\n  fallbackLocale: TypedFallbackLocale\n  locale: string\n  localization: SanitizedConfig['localization']\n}\ntype SanitizeLocalesReturn = {\n  fallbackLocale?: TypedFallbackLocale\n  locale?: string\n}\nexport const sanitizeLocales = ({\n  fallbackLocale,\n  locale,\n  localization,\n}: SanitizeLocalesArgs): SanitizeLocalesReturn => {\n  // Check if localization has fallback enabled or if a fallback locale is provided\n\n  if (localization) {\n    fallbackLocale = sanitizeFallbackLocale({\n      fallbackLocale,\n      locale,\n      localization,\n    })!\n  }\n\n  if (['*', 'all'].includes(locale)) {\n    locale = 'all'\n  } else if (localization && !localization.localeCodes.includes(locale) && localization.fallback) {\n    locale = localization.defaultLocale\n  }\n\n  return {\n    fallbackLocale,\n    locale,\n  }\n}\n"],"names":["sanitizeFallbackLocale","addLocalesToRequestFromData","req","data","payload","config","localeOnReq","locale","fallbackLocaleOnReq","fallbackLocale","localeFromData","fallbackLocaleFromData","sanitizeLocales","localization","includes","localeCodes","fallback","defaultLocale"],"mappings":";;;;;;AAIA,SAASA,sBAAsB,QAAQ,8BAA6B;;AAK7D,SAASC,4BAA4BC,GAAmB;IAC7D,MAAM,EACJC,IAAI,EACJC,SAAS,EAAEC,MAAM,EAAE,EACpB,GAAGH;IAEJ,IAAIC,MAAM;QACR,MAAMG,cAAcJ,IAAIK,MAAM;QAC9B,MAAMC,sBAAsBN,IAAIO,cAAc;QAC9C,IAAIC;QACJ,IAAIC;QAEJ,IAAI,CAACL,eAAeH,MAAMI,UAAU,OAAOJ,KAAKI,MAAM,KAAK,UAAU;YACnEG,iBAAiBP,KAAKI,MAAM;QAC9B;QAEA,IAAI,CAACC,qBAAqB;YACxB,IAAIL,MAAM,CAAC,kBAAkB,IAAI,OAAOA,MAAM,CAAC,kBAAkB,KAAK,UAAU;gBAC9EQ,yBAAyBR,IAAI,CAAC,kBAAkB;YAClD;YAEA,IAAIA,MAAM,CAAC,iBAAiB,IAAI,OAAOA,MAAM,CAAC,iBAAiB,KAAK,UAAU;gBAC5EQ,yBAAyBR,IAAI,CAAC,iBAAiB;YACjD;QACF;QAEA,IAAI,CAACG,eAAe,CAACE,qBAAqB;YACxC,MAAM,EAAEC,cAAc,EAAEF,MAAM,EAAE,GAAGK,gBAAgB;gBACjDH,gBAAgBE;gBAChBJ,QAAQG;gBACRG,cAAcR,OAAOQ,YAAY;YACnC;YAEA,IAAIH,gBAAgB;gBAClBR,IAAIK,MAAM,GAAGA;YACf;YAEA,IAAII,wBAAwB;gBAC1BT,IAAIO,cAAc,GAAGA;YACvB;QACF;IACF;AACF;AAWO,MAAMG,kBAAkB,CAAC,EAC9BH,cAAc,EACdF,MAAM,EACNM,YAAY,EACQ;IACpB,iFAAiF;IAEjF,IAAIA,cAAc;QAChBJ,qBAAiBT,kMAAAA,EAAuB;YACtCS;YACAF;YACAM;QACF;IACF;IAEA,IAAI;QAAC;QAAK;KAAM,CAACC,QAAQ,CAACP,SAAS;QACjCA,SAAS;IACX,OAAO,IAAIM,gBAAgB,CAACA,aAAaE,WAAW,CAACD,QAAQ,CAACP,WAAWM,aAAaG,QAAQ,EAAE;QAC9FT,SAASM,aAAaI,aAAa;IACrC;IAEA,OAAO;QACLR;QACAF;IACF;AACF,EAAC"}},
    {"offset": {"line": 206, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/utilities/wrapInternalEndpoints.ts"],"sourcesContent":["import type { Endpoint } from '../config/types.js'\n\nimport { addDataAndFileToRequest } from './addDataAndFileToRequest.js'\nimport { addLocalesToRequestFromData } from './addLocalesToRequest.js'\n\nexport const wrapInternalEndpoints = (endpoints: Endpoint[]): Endpoint[] => {\n  return endpoints.map((endpoint) => {\n    const handler = endpoint.handler\n\n    if (['patch', 'post'].includes(endpoint.method)) {\n      endpoint.handler = async (req) => {\n        await addDataAndFileToRequest(req)\n        addLocalesToRequestFromData(req)\n        return handler(req)\n      }\n    }\n\n    return endpoint\n  })\n}\n"],"names":["addDataAndFileToRequest","addLocalesToRequestFromData","wrapInternalEndpoints","endpoints","map","endpoint","handler","includes","method","req"],"mappings":";;;;AAEA,SAASA,uBAAuB,QAAQ,+BAA8B;AACtE,SAASC,2BAA2B,QAAQ,2BAA0B;;;AAE/D,MAAMC,wBAAwB,CAACC;IACpC,OAAOA,UAAUC,GAAG,CAAC,CAACC;QACpB,MAAMC,UAAUD,SAASC,OAAO;QAEhC,IAAI;YAAC;YAAS;SAAO,CAACC,QAAQ,CAACF,SAASG,MAAM,GAAG;YAC/CH,SAASC,OAAO,GAAG,OAAOG;gBACxB,UAAMT,oMAAAA,EAAwBS;oBAC9BR,oMAAAA,EAA4BQ;gBAC5B,OAAOH,QAAQG;YACjB;QACF;QAEA,OAAOJ;IACT;AACF,EAAC"}},
    {"offset": {"line": 234, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/utilities/headersWithCors.ts"],"sourcesContent":["import type { PayloadRequest } from '../types/index.js'\n\ntype CorsArgs = {\n  headers: Headers\n  req: Partial<PayloadRequest>\n}\nexport const headersWithCors = ({ headers, req }: CorsArgs): Headers => {\n  const cors = req?.payload?.config.cors\n  const requestOrigin = req?.headers?.get('Origin')\n\n  if (cors) {\n    const defaultAllowedHeaders = [\n      'Origin',\n      'X-Requested-With',\n      'Content-Type',\n      'Accept',\n      'Authorization',\n      'Content-Encoding',\n      'x-apollo-tracing',\n      'X-Payload-HTTP-Method-Override',\n    ]\n\n    // Only set default CORS headers if they haven't been set by custom handler\n    if (!headers.has('Access-Control-Allow-Methods')) {\n      headers.set('Access-Control-Allow-Methods', 'PUT, PATCH, POST, GET, DELETE, OPTIONS')\n    }\n\n    if (!headers.has('Access-Control-Allow-Headers')) {\n      if (typeof cors === 'object' && 'headers' in cors) {\n        headers.set(\n          'Access-Control-Allow-Headers',\n          [...defaultAllowedHeaders, ...cors.headers].filter(Boolean).join(', '),\n        )\n      } else {\n        headers.set('Access-Control-Allow-Headers', defaultAllowedHeaders.join(', '))\n      }\n    }\n\n    if (!headers.has('Access-Control-Allow-Origin')) {\n      if (cors === '*' || (typeof cors === 'object' && 'origins' in cors && cors.origins === '*')) {\n        headers.set('Access-Control-Allow-Origin', '*')\n      } else if (\n        (Array.isArray(cors) && cors.indexOf(requestOrigin!) > -1) ||\n        (!Array.isArray(cors) &&\n          typeof cors === 'object' &&\n          'origins' in cors &&\n          cors.origins.indexOf(requestOrigin!) > -1)\n      ) {\n        headers.set('Access-Control-Allow-Credentials', 'true')\n        headers.set('Access-Control-Allow-Origin', requestOrigin!)\n      }\n    }\n  }\n\n  return headers\n}\n"],"names":["headersWithCors","headers","req","cors","payload","config","requestOrigin","get","defaultAllowedHeaders","has","set","filter","Boolean","join","origins","Array","isArray","indexOf"],"mappings":";;;;AAMO,MAAMA,kBAAkB,CAAC,EAAEC,OAAO,EAAEC,GAAG,EAAY;IACxD,MAAMC,OAAOD,KAAKE,SAASC,OAAOF;IAClC,MAAMG,gBAAgBJ,KAAKD,SAASM,IAAI;IAExC,IAAIJ,MAAM;QACR,MAAMK,wBAAwB;YAC5B;YACA;YACA;YACA;YACA;YACA;YACA;YACA;SACD;QAED,2EAA2E;QAC3E,IAAI,CAACP,QAAQQ,GAAG,CAAC,iCAAiC;YAChDR,QAAQS,GAAG,CAAC,gCAAgC;QAC9C;QAEA,IAAI,CAACT,QAAQQ,GAAG,CAAC,iCAAiC;YAChD,IAAI,OAAON,SAAS,YAAY,aAAaA,MAAM;gBACjDF,QAAQS,GAAG,CACT,gCACA;uBAAIF;uBAA0BL,KAAKF,OAAO;iBAAC,CAACU,MAAM,CAACC,SAASC,IAAI,CAAC;YAErE,OAAO;gBACLZ,QAAQS,GAAG,CAAC,gCAAgCF,sBAAsBK,IAAI,CAAC;YACzE;QACF;QAEA,IAAI,CAACZ,QAAQQ,GAAG,CAAC,gCAAgC;YAC/C,IAAIN,SAAS,OAAQ,OAAOA,SAAS,YAAY,aAAaA,QAAQA,KAAKW,OAAO,KAAK,KAAM;gBAC3Fb,QAAQS,GAAG,CAAC,+BAA+B;YAC7C,OAAO,IACJK,MAAMC,OAAO,CAACb,SAASA,KAAKc,OAAO,CAACX,iBAAkB,CAAC,KACvD,CAACS,MAAMC,OAAO,CAACb,SACd,OAAOA,SAAS,YAChB,aAAaA,QACbA,KAAKW,OAAO,CAACG,OAAO,CAACX,iBAAkB,CAAC,GAC1C;gBACAL,QAAQS,GAAG,CAAC,oCAAoC;gBAChDT,QAAQS,GAAG,CAAC,+BAA+BJ;YAC7C;QACF;IACF;IAEA,OAAOL;AACT,EAAC"}},
    {"offset": {"line": 281, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/utilities/killTransaction.ts"],"sourcesContent":["import type { MarkRequired } from 'ts-essentials'\n\nimport type { PayloadRequest } from '../types/index.js'\n\n/**\n * Rollback the transaction from the req using the db adapter and removes it from the req\n */\nexport async function killTransaction(\n  req: MarkRequired<Partial<PayloadRequest>, 'payload'>,\n): Promise<void> {\n  const { payload, transactionID } = req\n  if (transactionID && !(transactionID instanceof Promise)) {\n    try {\n      await payload.db.rollbackTransaction(req.transactionID!)\n    } catch (ignore) {\n      // swallow any errors while attempting to rollback\n    }\n    delete req.transactionID\n  }\n}\n"],"names":["killTransaction","req","payload","transactionID","Promise","db","rollbackTransaction","ignore"],"mappings":"AAIA;;CAEC,GACD;;;;AAAO,eAAeA,gBACpBC,GAAqD;IAErD,MAAM,EAAEC,OAAO,EAAEC,aAAa,EAAE,GAAGF;IACnC,IAAIE,iBAAiB,CAAEA,CAAAA,yBAAyBC,OAAM,GAAI;QACxD,IAAI;YACF,MAAMF,QAAQG,EAAE,CAACC,mBAAmB,CAACL,IAAIE,aAAa;QACxD,EAAE,OAAOI,QAAQ;QACf,kDAAkD;QACpD;QACA,OAAON,IAAIE,aAAa;IAC1B;AACF"}},
    {"offset": {"line": 302, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/utilities/findUp.ts"],"sourcesContent":["import fs from 'fs'\nimport path from 'path'\n\n/**\n * Synchronously walks up parent directories until a condition is met and/or one of the file names within the fileNames array is found.\n */\nexport function findUpSync({\n  condition,\n  dir,\n  fileNames,\n}: {\n  condition?: (dir: string) => boolean | Promise<boolean | string> | string\n  dir: string\n  fileNames?: string[]\n}): null | string {\n  const { root } = path.parse(dir)\n\n  while (true) {\n    if (fileNames?.length) {\n      let found = false\n      for (const fileName of fileNames) {\n        const filePath = path.join(dir, fileName)\n        const exists = pathExistsAndIsAccessibleSync(filePath)\n        if (exists) {\n          if (!condition) {\n            return filePath\n          }\n          found = true\n          break\n        }\n      }\n      if (!found && dir !== root) {\n        dir = path.dirname(dir) // Move up one directory level.\n        continue\n      }\n    }\n    const result = condition?.(dir)\n    if (result === true) {\n      return dir\n    }\n    if (typeof result === 'string' && result?.length) {\n      return result\n    }\n    if (dir === root) {\n      return null // Reached the root directory without a match.\n    }\n    dir = path.dirname(dir) // Move up one directory level.\n  }\n}\n\n/**\n * Asynchronously walks up parent directories until a condition is met and/or one of the file names within the fileNames array is found.\n */\nexport async function findUp({\n  condition,\n  dir,\n  fileNames,\n}: {\n  condition?: (dir: string) => boolean | Promise<boolean | string> | string\n  dir: string\n  fileNames?: string[]\n}): Promise<null | string> {\n  const { root } = path.parse(dir)\n\n  while (true) {\n    if (fileNames?.length) {\n      let found = false\n      for (const fileName of fileNames) {\n        const filePath = path.resolve(dir, fileName)\n        const exists = await pathExistsAndIsAccessible(filePath)\n        if (exists) {\n          if (!condition) {\n            return filePath\n          }\n          found = true\n          break\n        }\n      }\n      if (!found && dir !== root) {\n        dir = path.dirname(dir) // Move up one directory level.\n        continue\n      }\n    }\n    const result = await condition?.(dir)\n    if (result === true) {\n      return dir\n    }\n    if (typeof result === 'string' && result?.length) {\n      return result\n    }\n    if (dir === root) {\n      return null // Reached the root directory without a match.\n    }\n    dir = path.dirname(dir) // Move up one directory level.\n  }\n}\n\n// From https://github.com/sindresorhus/path-exists/blob/main/index.js\n// fs.accessSync is preferred over fs.existsSync as it's usually a good idea\n// to check if the process has permission to read/write to a file before doing so.\n// Also see https://github.com/nodejs/node/issues/39960\nexport function pathExistsAndIsAccessibleSync(path: string) {\n  try {\n    fs.accessSync(path)\n    return true\n  } catch {\n    return false\n  }\n}\n\nexport async function pathExistsAndIsAccessible(path: string) {\n  try {\n    await fs.promises.access(path)\n    return true\n  } catch {\n    return false\n  }\n}\n"],"names":["fs","path","findUpSync","condition","dir","fileNames","root","parse","length","found","fileName","filePath","join","exists","pathExistsAndIsAccessibleSync","dirname","result","findUp","resolve","pathExistsAndIsAccessible","accessSync","promises","access"],"mappings":";;;;;;;;;;AAAA,OAAOA,QAAQ,KAAI;AACnB,OAAOC,UAAU,OAAM;;;AAKhB,SAASC,WAAW,EACzBC,SAAS,EACTC,GAAG,EACHC,SAAS,EAKV;IACC,MAAM,EAAEC,IAAI,EAAE,GAAGL,4GAAAA,CAAKM,KAAK,CAACH;IAE5B,MAAO,KAAM;QACX,IAAIC,WAAWG,QAAQ;YACrB,IAAIC,QAAQ;YACZ,KAAK,MAAMC,YAAYL,UAAW;gBAChC,MAAMM,WAAWV,4GAAAA,CAAKW,IAAI,CAACR,KAAKM;gBAChC,MAAMG,SAASC,8BAA8BH;gBAC7C,IAAIE,QAAQ;oBACV,IAAI,CAACV,WAAW;wBACd,OAAOQ;oBACT;oBACAF,QAAQ;oBACR;gBACF;YACF;YACA,IAAI,CAACA,SAASL,QAAQE,MAAM;gBAC1BF,MAAMH,4GAAAA,CAAKc,OAAO,CAACX,MAAK,+BAA+B;gBACvD;YACF;QACF;QACA,MAAMY,SAASb,YAAYC;QAC3B,IAAIY,WAAW,MAAM;YACnB,OAAOZ;QACT;QACA,IAAI,OAAOY,WAAW,YAAYA,QAAQR,QAAQ;YAChD,OAAOQ;QACT;QACA,IAAIZ,QAAQE,MAAM;YAChB,OAAO,KAAK,8CAA8C;;QAC5D;QACAF,MAAMH,4GAAAA,CAAKc,OAAO,CAACX,MAAK,+BAA+B;IACzD;AACF;AAKO,eAAea,OAAO,EAC3Bd,SAAS,EACTC,GAAG,EACHC,SAAS,EAKV;IACC,MAAM,EAAEC,IAAI,EAAE,GAAGL,4GAAAA,CAAKM,KAAK,CAACH;IAE5B,MAAO,KAAM;QACX,IAAIC,WAAWG,QAAQ;YACrB,IAAIC,QAAQ;YACZ,KAAK,MAAMC,YAAYL,UAAW;gBAChC,MAAMM,WAAWV,4GAAAA,CAAKiB,OAAO,CAACd,KAAKM;gBACnC,MAAMG,SAAS,MAAMM,0BAA0BR;gBAC/C,IAAIE,QAAQ;oBACV,IAAI,CAACV,WAAW;wBACd,OAAOQ;oBACT;oBACAF,QAAQ;oBACR;gBACF;YACF;YACA,IAAI,CAACA,SAASL,QAAQE,MAAM;gBAC1BF,MAAMH,4GAAAA,CAAKc,OAAO,CAACX,MAAK,+BAA+B;gBACvD;YACF;QACF;QACA,MAAMY,SAAS,MAAMb,YAAYC;QACjC,IAAIY,WAAW,MAAM;YACnB,OAAOZ;QACT;QACA,IAAI,OAAOY,WAAW,YAAYA,QAAQR,QAAQ;YAChD,OAAOQ;QACT;QACA,IAAIZ,QAAQE,MAAM;YAChB,OAAO,KAAK,8CAA8C;;QAC5D;QACAF,MAAMH,4GAAAA,CAAKc,OAAO,CAACX,MAAK,+BAA+B;IACzD;AACF;AAMO,SAASU,8BAA8Bb,IAAY;IACxD,IAAI;QACFD,wGAAAA,CAAGoB,UAAU,CAACnB;QACd,OAAO;IACT,EAAE,OAAM;QACN,OAAO;IACT;AACF;AAEO,eAAekB,0BAA0BlB,IAAY;IAC1D,IAAI;QACF,MAAMD,wGAAAA,CAAGqB,QAAQ,CAACC,MAAM,CAACrB;QACzB,OAAO;IACT,EAAE,OAAM;QACN,OAAO;IACT;AACF"}},
    {"offset": {"line": 406, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/utilities/telemetry/conf/envPaths.ts"],"sourcesContent":["// @ts-strict-ignore\n/**\n * Taken from https://github.com/sindresorhus/env-paths/blob/main/index.js\n *\n * MIT License\n *\n * Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (https://sindresorhus.com)\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\nimport os from 'node:os'\nimport path from 'node:path'\nimport process from 'node:process'\n\nconst homedir = os.homedir()\nconst tmpdir = os.tmpdir()\nconst { env } = process\n\nconst macos = (name: string) => {\n  const library = path.join(homedir, 'Library')\n\n  return {\n    cache: path.join(library, 'Caches', name),\n    config: path.join(library, 'Preferences', name),\n    data: path.join(library, 'Application Support', name),\n    log: path.join(library, 'Logs', name),\n    temp: path.join(tmpdir, name),\n  }\n}\n\nconst windows = (name: string) => {\n  const appData = env.APPDATA || path.join(homedir, 'AppData', 'Roaming')\n  const localAppData = env.LOCALAPPDATA || path.join(homedir, 'AppData', 'Local')\n\n  return {\n    // Data/config/cache/log are invented by me as Windows isn't opinionated about this\n    cache: path.join(localAppData, name, 'Cache'),\n    config: path.join(appData, name, 'Config'),\n    data: path.join(localAppData, name, 'Data'),\n    log: path.join(localAppData, name, 'Log'),\n    temp: path.join(tmpdir, name),\n  }\n}\n\n// https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html\nconst linux = (name: string) => {\n  const username = path.basename(homedir)\n\n  return {\n    cache: path.join(env.XDG_CACHE_HOME || path.join(homedir, '.cache'), name),\n    config: path.join(env.XDG_CONFIG_HOME || path.join(homedir, '.config'), name),\n    data: path.join(env.XDG_DATA_HOME || path.join(homedir, '.local', 'share'), name),\n    // https://wiki.debian.org/XDGBaseDirectorySpecification#state\n    log: path.join(env.XDG_STATE_HOME || path.join(homedir, '.local', 'state'), name),\n    temp: path.join(tmpdir, username, name),\n  }\n}\n\nexport function envPaths(name: string, { suffix = 'nodejs' } = {}) {\n  if (typeof name !== 'string') {\n    throw new TypeError(`Expected a string, got ${typeof name}`)\n  }\n\n  if (suffix) {\n    // Add suffix to prevent possible conflict with native apps\n    name += `-${suffix}`\n  }\n\n  if (process.platform === 'darwin') {\n    return macos(name)\n  }\n\n  if (process.platform === 'win32') {\n    return windows(name)\n  }\n\n  return linux(name)\n}\n"],"names":["os","path","process","homedir","tmpdir","env","macos","name","library","join","cache","config","data","log","temp","windows","appData","APPDATA","localAppData","LOCALAPPDATA","linux","username","basename","XDG_CACHE_HOME","XDG_CONFIG_HOME","XDG_DATA_HOME","XDG_STATE_HOME","envPaths","suffix","TypeError","platform"],"mappings":";;;;AAAA,oBAAoB;AACpB;;;;;;;;;;;;CAYC,GAED,OAAOA,QAAQ,UAAS;AACxB,OAAOC,UAAU,YAAW;AAC5B,OAAOC,aAAa,eAAc;;;;AAElC,MAAMC,UAAUH,wHAAAA,CAAGG,OAAO;AAC1B,MAAMC,SAASJ,wHAAAA,CAAGI,MAAM;AACxB,MAAM,EAAEC,GAAG,EAAE,GAAGH,kIAAAA;AAEhB,MAAMI,QAAQ,CAACC;IACb,MAAMC,UAAUP,4HAAAA,CAAKQ,IAAI,CAACN,SAAS;IAEnC,OAAO;QACLO,OAAOT,4HAAAA,CAAKQ,IAAI,CAACD,SAAS,UAAUD;QACpCI,QAAQV,4HAAAA,CAAKQ,IAAI,CAACD,SAAS,eAAeD;QAC1CK,MAAMX,4HAAAA,CAAKQ,IAAI,CAACD,SAAS,uBAAuBD;QAChDM,KAAKZ,4HAAAA,CAAKQ,IAAI,CAACD,SAAS,QAAQD;QAChCO,MAAMb,4HAAAA,CAAKQ,IAAI,CAACL,QAAQG;IAC1B;AACF;AAEA,MAAMQ,UAAU,CAACR;IACf,MAAMS,UAAUX,IAAIY,OAAO,IAAIhB,4HAAAA,CAAKQ,IAAI,CAACN,SAAS,WAAW;IAC7D,MAAMe,eAAeb,IAAIc,YAAY,IAAIlB,4HAAAA,CAAKQ,IAAI,CAACN,SAAS,WAAW;IAEvE,OAAO;QACL,mFAAmF;QACnFO,OAAOT,4HAAAA,CAAKQ,IAAI,CAACS,cAAcX,MAAM;QACrCI,QAAQV,4HAAAA,CAAKQ,IAAI,CAACO,SAAST,MAAM;QACjCK,MAAMX,4HAAAA,CAAKQ,IAAI,CAACS,cAAcX,MAAM;QACpCM,KAAKZ,4HAAAA,CAAKQ,IAAI,CAACS,cAAcX,MAAM;QACnCO,MAAMb,4HAAAA,CAAKQ,IAAI,CAACL,QAAQG;IAC1B;AACF;AAEA,+EAA+E;AAC/E,MAAMa,QAAQ,CAACb;IACb,MAAMc,WAAWpB,4HAAAA,CAAKqB,QAAQ,CAACnB;IAE/B,OAAO;QACLO,OAAOT,4HAAAA,CAAKQ,IAAI,CAACJ,IAAIkB,cAAc,IAAItB,4HAAAA,CAAKQ,IAAI,CAACN,SAAS,WAAWI;QACrEI,QAAQV,4HAAAA,CAAKQ,IAAI,CAACJ,IAAImB,eAAe,IAAIvB,4HAAAA,CAAKQ,IAAI,CAACN,SAAS,YAAYI;QACxEK,MAAMX,4HAAAA,CAAKQ,IAAI,CAACJ,IAAIoB,aAAa,IAAIxB,4HAAAA,CAAKQ,IAAI,CAACN,SAAS,UAAU,UAAUI;QAC5E,8DAA8D;QAC9DM,KAAKZ,4HAAAA,CAAKQ,IAAI,CAACJ,IAAIqB,cAAc,IAAIzB,4HAAAA,CAAKQ,IAAI,CAACN,SAAS,UAAU,UAAUI;QAC5EO,MAAMb,4HAAAA,CAAKQ,IAAI,CAACL,QAAQiB,UAAUd;IACpC;AACF;AAEO,SAASoB,SAASpB,IAAY,EAAE,EAAEqB,SAAS,QAAQ,EAAE,GAAG,CAAC,CAAC;IAC/D,IAAI,OAAOrB,SAAS,UAAU;QAC5B,MAAM,IAAIsB,UAAU,CAAC,uBAAuB,EAAE,OAAOtB,MAAM;IAC7D;IAEA,IAAIqB,QAAQ;QACV,2DAA2D;QAC3DrB,QAAQ,CAAC,CAAC,EAAEqB,QAAQ;IACtB;IAEA,IAAI1B,kIAAAA,CAAQ4B,QAAQ,KAAK,UAAU;QACjC,OAAOxB,MAAMC;IACf;IAEA,IAAIL,kIAAAA,CAAQ4B,QAAQ,KAAK,SAAS;QAChC,OAAOf,QAAQR;IACjB;IAEA,OAAOa,MAAMb;AACf"}},
    {"offset": {"line": 486, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/utilities/telemetry/conf/index.ts"],"sourcesContent":["/**\n * Taken & simplified from https://github.com/sindresorhus/conf/blob/main/source/index.ts\n *\n * MIT License\n *\n * Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (https://sindresorhus.com)\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\nimport assert from 'node:assert'\nimport fs from 'node:fs'\nimport path from 'node:path'\n\nimport { envPaths } from './envPaths.js'\n\nconst createPlainObject = <T = Record<string, unknown>>(): T => Object.create(null)\n\nconst checkValueType = (key: string, value: unknown): void => {\n  const nonJsonTypes = new Set(['function', 'symbol', 'undefined'])\n\n  const type = typeof value\n\n  if (nonJsonTypes.has(type)) {\n    throw new TypeError(\n      `Setting a value of type \\`${type}\\` for key \\`${key}\\` is not allowed as it's not supported by JSON`,\n    )\n  }\n}\n\nexport class Conf<T extends Record<string, any> = Record<string, unknown>>\n  implements Iterable<[keyof T, T[keyof T]]>\n{\n  readonly #options: Readonly<Partial<Options>>\n  private readonly _deserialize: Deserialize<T> = (value) => JSON.parse(value)\n  private readonly _serialize: Serialize<T> = (value) => JSON.stringify(value, undefined, '\\t')\n\n  readonly events: EventTarget\n\n  readonly path: string\n\n  constructor() {\n    const options: Partial<Options> = {\n      configFileMode: 0o666,\n      configName: 'config',\n      fileExtension: 'json',\n      projectSuffix: 'nodejs',\n    }\n\n    const cwd = envPaths('payload', { suffix: options.projectSuffix }).config\n\n    this.#options = options\n\n    this.events = new EventTarget()\n\n    const fileExtension = options.fileExtension ? `.${options.fileExtension}` : ''\n    this.path = path.resolve(cwd, `${options.configName ?? 'config'}${fileExtension}`)\n\n    const fileStore = this.store\n    const store = Object.assign(createPlainObject(), fileStore)\n\n    try {\n      assert.deepEqual(fileStore, store)\n    } catch {\n      this.store = store\n    }\n  }\n\n  private _ensureDirectory(): void {\n    // Ensure the directory exists as it could have been deleted in the meantime.\n    fs.mkdirSync(path.dirname(this.path), { recursive: true })\n  }\n\n  private _write(value: T): void {\n    const data: string | Uint8Array = this._serialize(value)\n\n    fs.writeFileSync(this.path, data, { mode: this.#options.configFileMode })\n  }\n\n  /**\n   Delete an item.\n\n   @param key - The key of the item to delete.\n   */\n  delete(key: string): void {\n    const { store } = this\n    delete store[key]\n\n    this.store = store\n  }\n\n  /**\n   Get an item.\n\n   @param key - The key of the item to get.\n   */\n  get<Key extends keyof T>(key: Key): T[Key] {\n    const { store } = this\n    return store[key]\n  }\n\n  /**\n   Set an item or multiple items at once.\n\n   @param key - You can use [dot-notation](https://github.com/sindresorhus/dot-prop) in a key to access nested properties. Or a hashmap of items to set at once.\n   @param value - Must be JSON serializable. Trying to set the type `undefined`, `function`, or `symbol` will result in a `TypeError`.\n   */\n  set<Key extends keyof T>(key: string, value?: T[Key] | unknown): void {\n    if (typeof key !== 'string' && typeof key !== 'object') {\n      throw new TypeError(\n        `Expected \\`key\\` to be of type \\`string\\` or \\`object\\`, got ${typeof key}`,\n      )\n    }\n\n    if (typeof key !== 'object' && value === undefined) {\n      throw new TypeError('Use `delete()` to clear values')\n    }\n\n    const { store } = this\n\n    const set = (key: string, value?: T | T[Key] | unknown): void => {\n      checkValueType(key, value)\n      store[key as Key] = value as T[Key]\n    }\n\n    if (typeof key === 'object') {\n      const object = key\n      for (const [key, value] of Object.entries(object)) {\n        set(key, value)\n      }\n    } else {\n      set(key, value)\n    }\n\n    this.store = store\n  }\n\n  *[Symbol.iterator](): IterableIterator<[keyof T, T[keyof T]]> {\n    for (const [key, value] of Object.entries(this.store)) {\n      yield [key, value]\n    }\n  }\n  get size(): number {\n    return Object.keys(this.store).length\n  }\n  get store(): T {\n    try {\n      const dataString = fs.readFileSync(this.path, 'utf8')\n      const deserializedData = this._deserialize(dataString)\n      return Object.assign(createPlainObject(), deserializedData)\n    } catch (error: unknown) {\n      if ((error as any)?.code === 'ENOENT') {\n        this._ensureDirectory()\n        return createPlainObject()\n      }\n\n      throw error\n    }\n  }\n\n  set store(value: T) {\n    this._ensureDirectory()\n\n    this._write(value)\n\n    this.events.dispatchEvent(new Event('change'))\n  }\n}\n\nexport type Options = {\n  /**\n   The config is cleared if reading the config file causes a `SyntaxError`. This is a good behavior for unimportant data, as the config file is not intended to be hand-edited, so it usually means the config is corrupt and there's nothing the user can do about it anyway. However, if you let the user edit the config file directly, mistakes might happen and it could be more useful to throw an error when the config is invalid instead of clearing.\n\n   @default false\n   */\n  clearInvalidConfig?: boolean\n\n  /**\n   The [mode](https://en.wikipedia.org/wiki/File-system_permissions#Numeric_notation) that will be used for the config file.\n\n   You would usually not need this, but it could be useful if you want to restrict the permissions of the config file. Setting a permission such as `0o600` would result in a config file that can only be accessed by the user running the program.\n\n   Note that setting restrictive permissions can cause problems if different users need to read the file. A common problem is a user running your tool with and without `sudo` and then not being able to access the config the second time.\n\n   @default 0o666\n   */\n  readonly configFileMode?: number\n\n  /**\n   Name of the config file (without extension).\n\n   Useful if you need multiple config files for your app or module. For example, different config files between two major versions.\n\n   @default 'config'\n   */\n  configName?: string\n\n  /**\n   Extension of the config file.\n\n   You would usually not need this, but could be useful if you want to interact with a file with a custom file extension that can be associated with your app. These might be simple save/export/preference files that are intended to be shareable or saved outside of the app.\n\n   @default 'json'\n   */\n  fileExtension?: string\n\n  readonly projectSuffix?: string\n}\n\nexport type Serialize<T> = (value: T) => string\nexport type Deserialize<T> = (text: string) => T\n"],"names":["assert","fs","path","envPaths","createPlainObject","Object","create","checkValueType","key","value","nonJsonTypes","Set","type","has","TypeError","Conf","_deserialize","JSON","parse","_serialize","stringify","undefined","events","options","configFileMode","configName","fileExtension","projectSuffix","cwd","suffix","config","EventTarget","resolve","fileStore","store","assign","deepEqual","_ensureDirectory","mkdirSync","dirname","recursive","_write","data","writeFileSync","mode","delete","get","set","object","entries","Symbol","iterator","size","keys","length","dataString","readFileSync","deserializedData","error","code","dispatchEvent","Event"],"mappings":"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"}},
    {"offset": {"line": 640, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/utilities/telemetry/oneWayHash.ts"],"sourcesContent":["import type { BinaryLike } from 'crypto'\n\nimport { createHash } from 'crypto'\n\nexport const oneWayHash = (data: BinaryLike, secret: string): string => {\n  const hash = createHash('sha256')\n\n  // prepend value with payload secret. This ensure one-way.\n  hash.update(secret)\n\n  // Update is an append operation, not a replacement. The secret from the prior\n  // update is still present!\n  hash.update(data)\n  return hash.digest('hex')\n}\n"],"names":["createHash","oneWayHash","data","secret","hash","update","digest"],"mappings":";;;;AAEA,SAASA,UAAU,QAAQ,SAAQ;;AAE5B,MAAMC,aAAa,CAACC,MAAkBC;IAC3C,MAAMC,WAAOJ,mHAAAA,EAAW;IAExB,0DAA0D;IAC1DI,KAAKC,MAAM,CAACF;IAEZ,8EAA8E;IAC9E,2BAA2B;IAC3BC,KAAKC,MAAM,CAACH;IACZ,OAAOE,KAAKE,MAAM,CAAC;AACrB,EAAC"}},
    {"offset": {"line": 659, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/utilities/telemetry/index.ts"],"sourcesContent":["import { execSync } from 'child_process'\nimport ciInfo from 'ci-info'\nimport { randomBytes } from 'crypto'\nimport fs from 'fs'\nimport path from 'path'\nimport { fileURLToPath } from 'url'\n\nimport type { Payload } from '../../types/index.js'\nimport type { AdminInitEvent } from './events/adminInit.js'\nimport type { ServerInitEvent } from './events/serverInit.js'\n\nimport { findUp } from '../findUp.js'\nimport { Conf } from './conf/index.js'\nimport { oneWayHash } from './oneWayHash.js'\n\nexport type BaseEvent = {\n  ciName: null | string\n  dbAdapter: string\n  emailAdapter: null | string\n  envID: string\n  isCI: boolean\n  locales: string[]\n  localizationDefaultLocale: null | string\n  localizationEnabled: boolean\n  nodeEnv: string\n  nodeVersion: string\n  payloadVersion: string\n  projectID: string\n  projectIDSource: 'cwd' | 'git' | 'packageJSON' | 'serverURL'\n  uploadAdapters: string[]\n}\n\ntype PackageJSON = {\n  dependencies: Record<string, string | undefined>\n  name: string\n}\n\ntype TelemetryEvent = AdminInitEvent | ServerInitEvent\n\ntype Args = {\n  event: TelemetryEvent\n  payload: Payload\n}\n\nlet baseEvent: BaseEvent | null = null\n\nexport const sendEvent = async ({ event, payload }: Args): Promise<void> => {\n  try {\n    if (payload.config.telemetry !== false) {\n      const { packageJSON, packageJSONPath } = await getPackageJSON()\n\n      // Only generate the base event once\n      if (!baseEvent) {\n        const { projectID, source: projectIDSource } = getProjectID(payload, packageJSON!)\n        baseEvent = {\n          ciName: ciInfo.isCI ? ciInfo.name : null,\n          envID: getEnvID(),\n          isCI: ciInfo.isCI,\n          nodeEnv: process.env.NODE_ENV || 'development',\n          nodeVersion: process.version,\n          payloadVersion: getPayloadVersion(packageJSON!),\n          projectID,\n          projectIDSource,\n          ...getLocalizationInfo(payload),\n          dbAdapter: payload.db.name,\n          emailAdapter: payload.email?.name || null,\n          uploadAdapters: payload.config.upload.adapters,\n        }\n      }\n\n      if (process.env.PAYLOAD_TELEMETRY_DEBUG) {\n        payload.logger.info({\n          event: { ...baseEvent, ...event, packageJSONPath },\n          msg: 'Telemetry Event',\n        })\n        return\n      }\n\n      await fetch('https://telemetry.payloadcms.com/events', {\n        body: JSON.stringify({ ...baseEvent, ...event }),\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        method: 'post',\n      })\n    }\n  } catch (_) {\n    // Eat any errors in sending telemetry event\n  }\n}\n\n/**\n * This is a quasi-persistent identifier used to dedupe recurring events. It's\n * generated from random data and completely anonymous.\n */\nconst getEnvID = (): string => {\n  const conf = new Conf()\n  const ENV_ID = 'envID'\n\n  const val = conf.get(ENV_ID)\n  if (val) {\n    return val as string\n  }\n\n  const generated = randomBytes(32).toString('hex')\n  conf.set(ENV_ID, generated)\n  return generated\n}\n\nconst getProjectID = (\n  payload: Payload,\n  packageJSON: PackageJSON,\n): { projectID: string; source: BaseEvent['projectIDSource'] } => {\n  const gitID = getGitID(payload)\n  if (gitID) {\n    return { projectID: oneWayHash(gitID, payload.secret), source: 'git' }\n  }\n\n  const packageJSONID = getPackageJSONID(payload, packageJSON)\n  if (packageJSONID) {\n    return { projectID: oneWayHash(packageJSONID, payload.secret), source: 'packageJSON' }\n  }\n\n  const serverURL = payload.config.serverURL\n  if (serverURL) {\n    return { projectID: oneWayHash(serverURL, payload.secret), source: 'serverURL' }\n  }\n\n  const cwd = process.cwd()\n  return { projectID: oneWayHash(cwd, payload.secret), source: 'cwd' }\n}\n\nconst getGitID = (payload: Payload) => {\n  try {\n    const originBuffer = execSync('git config --local --get remote.origin.url', {\n      stdio: 'pipe',\n      timeout: 1000,\n    })\n\n    return oneWayHash(String(originBuffer).trim(), payload.secret)\n  } catch (_) {\n    return null\n  }\n}\n\nconst getPackageJSON = async (): Promise<{\n  packageJSON?: PackageJSON\n  packageJSONPath: string\n}> => {\n  let packageJSONPath = path.resolve(process.cwd(), 'package.json')\n\n  if (!fs.existsSync(packageJSONPath)) {\n    // Old logic\n    const filename = fileURLToPath(import.meta.url)\n    const dirname = path.dirname(filename)\n    packageJSONPath = (await findUp({\n      dir: dirname,\n      fileNames: ['package.json'],\n    }))!\n  }\n\n  const jsonContentString = await fs.promises.readFile(packageJSONPath, 'utf-8')\n  const jsonContent: PackageJSON = JSON.parse(jsonContentString)\n  return { packageJSON: jsonContent, packageJSONPath }\n}\n\nconst getPackageJSONID = (payload: Payload, packageJSON: PackageJSON): string => {\n  return oneWayHash(packageJSON.name, payload.secret)\n}\n\nexport const getPayloadVersion = (packageJSON: PackageJSON): string => {\n  return packageJSON?.dependencies?.payload ?? ''\n}\n\nexport const getLocalizationInfo = (\n  payload: Payload,\n): Pick<BaseEvent, 'locales' | 'localizationDefaultLocale' | 'localizationEnabled'> => {\n  if (!payload.config.localization) {\n    return {\n      locales: [],\n      localizationDefaultLocale: null,\n      localizationEnabled: false,\n    }\n  }\n\n  return {\n    locales: payload.config.localization.localeCodes,\n    localizationDefaultLocale: payload.config.localization.defaultLocale,\n    localizationEnabled: true,\n  }\n}\n"],"names":["execSync","ciInfo","randomBytes","fs","path","fileURLToPath","findUp","Conf","oneWayHash","baseEvent","sendEvent","event","payload","config","telemetry","packageJSON","packageJSONPath","getPackageJSON","projectID","source","projectIDSource","getProjectID","ciName","isCI","name","envID","getEnvID","nodeEnv","process","env","NODE_ENV","nodeVersion","version","payloadVersion","getPayloadVersion","getLocalizationInfo","dbAdapter","db","emailAdapter","email","uploadAdapters","upload","adapters","PAYLOAD_TELEMETRY_DEBUG","logger","info","msg","fetch","body","JSON","stringify","headers","method","_","conf","ENV_ID","val","get","generated","toString","set","gitID","getGitID","secret","packageJSONID","getPackageJSONID","serverURL","cwd","originBuffer","stdio","timeout","String","trim","resolve","existsSync","filename","url","dirname","dir","fileNames","jsonContentString","promises","readFile","jsonContent","parse","dependencies","localization","locales","localizationDefaultLocale","localizationEnabled","localeCodes","defaultLocale"],"mappings":"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"}},
    {"offset": {"line": 836, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/utilities/telemetry/events/adminInit.ts"],"sourcesContent":["import type { Payload } from '../../../index.js'\nimport type { PayloadRequest } from '../../../types/index.js'\n\nimport { sendEvent } from '../index.js'\nimport { oneWayHash } from '../oneWayHash.js'\n\nexport type AdminInitEvent = {\n  domainID?: string\n  type: 'admin-init'\n  userID?: string\n}\n\ntype Args = {\n  headers: Request['headers']\n  payload: Payload\n  user: PayloadRequest['user']\n}\nexport const adminInit = ({ headers, payload, user }: Args): void => {\n  const host = headers.get('host')\n\n  let domainID: string\n  let userID: string\n\n  if (host) {\n    domainID = oneWayHash(host, payload.secret)\n  }\n\n  if (user?.id) {\n    userID = oneWayHash(String(user.id), payload.secret)\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-floating-promises\n  sendEvent({\n    event: {\n      type: 'admin-init',\n      domainID: domainID!,\n      userID: userID!,\n    },\n    payload,\n  })\n}\n"],"names":["sendEvent","oneWayHash","adminInit","headers","payload","user","host","get","domainID","userID","secret","id","String","event","type"],"mappings":";;;;AAGA,SAASA,SAAS,QAAQ,cAAa;AACvC,SAASC,UAAU,QAAQ,mBAAkB;;;AAatC,MAAMC,YAAY,CAAC,EAAEC,OAAO,EAAEC,OAAO,EAAEC,IAAI,EAAQ;IACxD,MAAMC,OAAOH,QAAQI,GAAG,CAAC;IAEzB,IAAIC;IACJ,IAAIC;IAEJ,IAAIH,MAAM;QACRE,eAAWP,uLAAAA,EAAWK,MAAMF,QAAQM,MAAM;IAC5C;IAEA,IAAIL,MAAMM,IAAI;QACZF,aAASR,uLAAAA,EAAWW,OAAOP,KAAKM,EAAE,GAAGP,QAAQM,MAAM;IACrD;IAEA,mEAAmE;QACnEV,iLAAAA,EAAU;QACRa,OAAO;YACLC,MAAM;YACNN,UAAUA;YACVC,QAAQA;QACV;QACAL;IACF;AACF,EAAC"}},
    {"offset": {"line": 868, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/utilities/getEntityPermissions/entityDocExists.ts"],"sourcesContent":["import {\n  type AllOperations,\n  combineQueries,\n  type DefaultDocumentIDType,\n  type PayloadRequest,\n  type Where,\n} from '../../index.js'\n\n/**\n * Returns whether or not the entity doc exists based on the where query.\n */\nexport async function entityDocExists({\n  id,\n  slug,\n  entityType,\n  locale,\n  operation,\n  req,\n  where,\n}: {\n  entityType: 'collection' | 'global'\n  id?: DefaultDocumentIDType\n  locale?: string\n  operation?: AllOperations\n  req: PayloadRequest\n  slug: string\n  where: Where\n}): Promise<boolean> {\n  if (entityType === 'global') {\n    const global = await req.payload.db.findGlobal({\n      slug,\n      locale,\n      req,\n      select: {},\n      where,\n    })\n\n    const hasGlobalDoc = Boolean(global && Object.keys(global).length > 0)\n\n    return hasGlobalDoc\n  }\n\n  if (entityType === 'collection' && id) {\n    if (operation === 'readVersions') {\n      const count = await req.payload.db.countVersions({\n        collection: slug,\n        locale,\n        req,\n        where: combineQueries(where, { parent: { equals: id } }),\n      })\n      return count.totalDocs > 0\n    }\n\n    const count = await req.payload.db.count({\n      collection: slug,\n      locale,\n      req,\n      where: combineQueries(where, { id: { equals: id } }),\n    })\n\n    return count.totalDocs > 0\n  }\n\n  return false\n}\n"],"names":["combineQueries","entityDocExists","id","slug","entityType","locale","operation","req","where","global","payload","db","findGlobal","select","hasGlobalDoc","Boolean","Object","keys","length","count","countVersions","collection","parent","equals","totalDocs"],"mappings":";;;;AAAA,SAEEA,cAAc,QAIT,iBAAgB;;AAKhB,eAAeC,gBAAgB,EACpCC,EAAE,EACFC,IAAI,EACJC,UAAU,EACVC,MAAM,EACNC,SAAS,EACTC,GAAG,EACHC,KAAK,EASN;IACC,IAAIJ,eAAe,UAAU;QAC3B,MAAMK,SAAS,MAAMF,IAAIG,OAAO,CAACC,EAAE,CAACC,UAAU,CAAC;YAC7CT;YACAE;YACAE;YACAM,QAAQ,CAAC;YACTL;QACF;QAEA,MAAMM,eAAeC,QAAQN,UAAUO,OAAOC,IAAI,CAACR,QAAQS,MAAM,GAAG;QAEpE,OAAOJ;IACT;IAEA,IAAIV,eAAe,gBAAgBF,IAAI;QACrC,IAAII,cAAc,gBAAgB;YAChC,MAAMa,QAAQ,MAAMZ,IAAIG,OAAO,CAACC,EAAE,CAACS,aAAa,CAAC;gBAC/CC,YAAYlB;gBACZE;gBACAE;gBACAC,WAAOR,iLAAAA,EAAeQ,OAAO;oBAAEc,QAAQ;wBAAEC,QAAQrB;oBAAG;gBAAE;YACxD;YACA,OAAOiB,MAAMK,SAAS,GAAG;QAC3B;QAEA,MAAML,QAAQ,MAAMZ,IAAIG,OAAO,CAACC,EAAE,CAACQ,KAAK,CAAC;YACvCE,YAAYlB;YACZE;YACAE;YACAC,WAAOR,iLAAAA,EAAeQ,OAAO;gBAAEN,IAAI;oBAAEqB,QAAQrB;gBAAG;YAAE;QACpD;QAEA,OAAOiB,MAAMK,SAAS,GAAG;IAC3B;IAEA,OAAO;AACT"}},
    {"offset": {"line": 918, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/utilities/getEntityPermissions/populateFieldPermissions.ts"],"sourcesContent":["import type {\n  BlockPermissions,\n  BlocksPermissions,\n  CollectionPermission,\n  FieldPermissions,\n  FieldsPermissions,\n  GlobalPermission,\n  Permission,\n} from '../../auth/types.js'\nimport type { DefaultDocumentIDType } from '../../index.js'\nimport type { AllOperations, JsonObject, PayloadRequest } from '../../types/index.js'\nimport type { BlockReferencesPermissions } from './getEntityPermissions.js'\n\nimport { type Field, tabHasName } from '../../fields/config/types.js'\n\nconst isThenable = (value: unknown): value is Promise<unknown> =>\n  value != null && typeof (value as { then?: unknown }).then === 'function'\n\n/**\n * Helper to set a permission value that might be a promise.\n * If it's a promise, creates a chained promise that resolves to update the target,\n * stores the promise temporarily, and adds it to the promises array for later resolution.\n */\nconst setPermission = (\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  target: any,\n  operation: AllOperations,\n  value: boolean | Promise<boolean> | undefined,\n  promises: Promise<void>[],\n): void => {\n  if (isThenable(value)) {\n    // Create a single permission object that will be mutated in place\n    // This ensures all references (including cached blocks) see the resolved value\n    const permissionObj = { permission: value as any }\n    target[operation] = permissionObj\n\n    const permissionPromise = value.then((result) => {\n      // Mutate the permission property in place so all references see the update\n      permissionObj.permission = result\n    })\n\n    promises.push(permissionPromise)\n  } else {\n    target[operation] = { permission: value }\n  }\n}\n\n/**\n * Build up permissions object and run access functions for each field of an entity\n * This function is synchronous and collects all async work into the promises array\n */\nexport const populateFieldPermissions = ({\n  id,\n  blockReferencesPermissions,\n  data,\n  fields,\n  operations,\n  parentPermissionsObject,\n  permissionsObject,\n  promises,\n  req,\n}: {\n  blockReferencesPermissions: BlockReferencesPermissions\n  data: JsonObject | undefined\n  fields: Field[]\n  id?: DefaultDocumentIDType\n  /**\n   * Operations to check access for\n   */\n  operations: AllOperations[]\n  parentPermissionsObject: CollectionPermission | FieldPermissions | GlobalPermission\n  permissionsObject: FieldsPermissions\n  promises: Promise<void>[]\n  req: PayloadRequest\n}): void => {\n  for (const field of fields) {\n    // Set up permissions for all operations\n    for (const operation of operations) {\n      const parentPermissionForOperation = (\n        parentPermissionsObject[operation as keyof typeof parentPermissionsObject] as Permission\n      )?.permission\n\n      // Fields don't have all operations of a collection\n      if (operation === 'delete' || operation === 'readVersions' || operation === 'unlock') {\n        continue\n      }\n\n      if ('name' in field && field.name) {\n        if (!permissionsObject[field.name]) {\n          permissionsObject[field.name] = {} as FieldPermissions\n        }\n        const fieldPermissions: FieldPermissions = permissionsObject[field.name]!\n\n        if ('access' in field && field.access && typeof field.access[operation] === 'function') {\n          const accessResult = field.access[operation]({\n            id,\n            data,\n            doc: data,\n            req,\n            // We cannot include siblingData or blockData here, as we do not have siblingData/blockData available once we reach block or array\n            // rows, as we're calculating schema permissions, which do not include individual rows.\n            // For consistency, it's thus better to never include the siblingData and blockData\n          })\n\n          // Handle both sync and async access results\n          if (isThenable(accessResult)) {\n            const booleanPromise = accessResult.then((result) => Boolean(result))\n            setPermission(fieldPermissions, operation, booleanPromise, promises)\n          } else {\n            setPermission(fieldPermissions, operation, Boolean(accessResult), promises)\n          }\n        } else {\n          // Inherit from parent (which might be a promise)\n          setPermission(fieldPermissions, operation, parentPermissionForOperation, promises)\n        }\n      }\n    }\n\n    // Handle named fields with nested content\n    if ('name' in field && field.name) {\n      const fieldPermissions: FieldPermissions = permissionsObject[field.name]!\n\n      if ('fields' in field && field.fields) {\n        if (!fieldPermissions.fields) {\n          fieldPermissions.fields = {}\n        }\n\n        populateFieldPermissions({\n          id,\n          blockReferencesPermissions,\n          data,\n          fields: field.fields,\n          operations,\n          parentPermissionsObject: fieldPermissions,\n          permissionsObject: fieldPermissions.fields,\n          promises,\n          req,\n        })\n      }\n\n      if (\n        ('blocks' in field && field.blocks?.length) ||\n        ('blockReferences' in field && field.blockReferences?.length)\n      ) {\n        if (!fieldPermissions.blocks) {\n          fieldPermissions.blocks = {}\n        }\n        const blocksPermissions: BlocksPermissions = fieldPermissions.blocks\n\n        // Set up permissions for all operations for all blocks\n        for (const operation of operations) {\n          // Fields don't have all operations of a collection\n          if (operation === 'delete' || operation === 'readVersions' || operation === 'unlock') {\n            continue\n          }\n\n          const parentPermissionForOperation = (\n            parentPermissionsObject[operation as keyof typeof parentPermissionsObject] as Permission\n          )?.permission\n\n          for (const _block of field.blockReferences ?? field.blocks) {\n            const block = typeof _block === 'string' ? req.payload.blocks[_block] : _block\n\n            // Skip if block doesn't exist (invalid block reference)\n            if (!block) {\n              continue\n            }\n\n            // Handle block references - check if we've seen this block before\n            if (typeof _block === 'string') {\n              const blockReferencePermissions = blockReferencesPermissions[_block]\n              if (blockReferencePermissions) {\n                // Reference the cached permissions (may be a promise or resolved object)\n                blocksPermissions[block.slug] = blockReferencePermissions as BlockPermissions\n                continue\n              }\n            }\n\n            // Initialize block permissions object if needed\n            if (!blocksPermissions[block.slug]) {\n              blocksPermissions[block.slug] = {} as BlockPermissions\n            }\n\n            const blockPermission = blocksPermissions[block.slug]!\n\n            // Set permission for this operation\n            if (!blockPermission[operation]) {\n              const fieldPermission =\n                fieldPermissions[operation]?.permission ?? parentPermissionForOperation\n\n              // Inherit from field permission (which might be a promise)\n              setPermission(blockPermission, operation, fieldPermission, promises)\n            }\n          }\n        }\n\n        // Process nested content for each unique block (once per block, not once per operation)\n        const processedBlocks = new Set<string>()\n        for (const _block of field.blockReferences ?? field.blocks) {\n          const block = typeof _block === 'string' ? req.payload.blocks[_block] : _block\n\n          // Skip if block doesn't exist (invalid block reference)\n          if (!block || processedBlocks.has(block.slug)) {\n            continue\n          }\n          processedBlocks.add(block.slug)\n\n          const blockPermission = blocksPermissions[block.slug]\n          if (!blockPermission) {\n            continue\n          }\n\n          if (!blockPermission.fields) {\n            blockPermission.fields = {}\n          }\n\n          // Handle block references with caching - store as promise that will be resolved later\n          if (typeof _block === 'string' && !blockReferencesPermissions[_block]) {\n            // Mark this block as being processed by storing a reference\n            blockReferencesPermissions[_block] = blockPermission\n          }\n\n          // Recursively process block fields synchronously\n          populateFieldPermissions({\n            id,\n            blockReferencesPermissions,\n            data,\n            fields: block.fields,\n            operations,\n            parentPermissionsObject: blockPermission,\n            permissionsObject: blockPermission.fields,\n            promises,\n            req,\n          })\n        }\n      }\n    }\n\n    // Handle unnamed group fields\n    if ('fields' in field && field.fields && !('name' in field && field.name)) {\n      // Field does not have a name => same parentPermissionsObject\n      populateFieldPermissions({\n        id,\n        blockReferencesPermissions,\n        data,\n        fields: field.fields,\n        operations,\n        // Field does not have a name here => use parent permissions object\n        parentPermissionsObject,\n        permissionsObject,\n        promises,\n        req,\n      })\n    }\n\n    // Handle tabs fields\n    if (field.type === 'tabs') {\n      // Process tabs for all operations\n      for (const operation of operations) {\n        // Fields don't have all operations of a collection\n        if (operation === 'delete' || operation === 'readVersions' || operation === 'unlock') {\n          continue\n        }\n\n        const parentPermissionForOperation = (\n          parentPermissionsObject[operation as keyof typeof parentPermissionsObject] as Permission\n        )?.permission\n\n        for (const tab of field.tabs) {\n          if (tabHasName(tab)) {\n            if (!permissionsObject[tab.name]) {\n              permissionsObject[tab.name] = { fields: {} } as FieldPermissions\n            }\n\n            const tabPermissions = permissionsObject[tab.name]!\n            if (!tabPermissions[operation]) {\n              // Inherit from parent (which might be a promise)\n              setPermission(tabPermissions, operation, parentPermissionForOperation, promises)\n            }\n          }\n        }\n      }\n\n      for (const tab of field.tabs) {\n        if (tabHasName(tab)) {\n          const tabPermissions: FieldPermissions = permissionsObject[tab.name]!\n\n          if (!tabPermissions.fields) {\n            tabPermissions.fields = {}\n          }\n\n          populateFieldPermissions({\n            id,\n            blockReferencesPermissions,\n            data,\n            fields: tab.fields,\n            operations,\n            parentPermissionsObject: tabPermissions,\n            permissionsObject: tabPermissions.fields,\n            promises,\n            req,\n          })\n        } else {\n          // Tab does not have a name => same parentPermissionsObject\n          populateFieldPermissions({\n            id,\n            blockReferencesPermissions,\n            data,\n            fields: tab.fields,\n            operations,\n            // Tab does not have a name here => use parent permissions object\n            parentPermissionsObject,\n            permissionsObject,\n            promises,\n            req,\n          })\n        }\n      }\n    }\n  }\n}\n"],"names":["tabHasName","isThenable","value","then","setPermission","target","operation","promises","permissionObj","permission","permissionPromise","result","push","populateFieldPermissions","id","blockReferencesPermissions","data","fields","operations","parentPermissionsObject","permissionsObject","req","field","parentPermissionForOperation","name","fieldPermissions","access","accessResult","doc","booleanPromise","Boolean","blocks","length","blockReferences","blocksPermissions","_block","block","payload","blockReferencePermissions","slug","blockPermission","fieldPermission","processedBlocks","Set","has","add","type","tab","tabs","tabPermissions"],"mappings":"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"}},
    {"offset": {"line": 1157, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/utilities/getEntityPermissions/getEntityPermissions.ts"],"sourcesContent":["import { isDeepStrictEqual } from 'util'\n\nimport type {\n  BlockPermissions,\n  CollectionPermission,\n  FieldsPermissions,\n  GlobalPermission,\n  Permission,\n} from '../../auth/types.js'\nimport type { SanitizedCollectionConfig, TypeWithID } from '../../collections/config/types.js'\nimport type { SanitizedGlobalConfig } from '../../globals/config/types.js'\nimport type { BlockSlug, DefaultDocumentIDType } from '../../index.js'\nimport type { AllOperations, JsonObject, PayloadRequest, Where } from '../../types/index.js'\n\nimport { entityDocExists } from './entityDocExists.js'\nimport { populateFieldPermissions } from './populateFieldPermissions.js'\n\ntype WhereQueryCache = { result: Promise<boolean>; where: Where }[]\n\nexport type BlockReferencesPermissions = Record<\n  BlockSlug,\n  BlockPermissions | Promise<BlockPermissions>\n>\n\nexport type EntityDoc = JsonObject | TypeWithID\n\ntype ReturnType<TEntityType extends 'collection' | 'global'> = TEntityType extends 'global'\n  ? GlobalPermission\n  : CollectionPermission\n\ntype Args<TEntityType extends 'collection' | 'global'> = {\n  blockReferencesPermissions: BlockReferencesPermissions\n  /**\n   * If the document data is passed, it will be used to check access instead of fetching the document from the database.\n   */\n  data?: JsonObject\n  entity: TEntityType extends 'collection' ? SanitizedCollectionConfig : SanitizedGlobalConfig\n  entityType: TEntityType\n  /**\n   * Operations to check access for\n   */\n  operations: AllOperations[]\n  req: PayloadRequest\n} & (\n  | {\n      fetchData: false\n      id?: never\n    }\n  | {\n      fetchData: true\n      id: TEntityType extends 'collection' ? DefaultDocumentIDType : undefined\n    }\n)\n\nconst topLevelCollectionPermissions = [\n  'create',\n  'delete',\n  'read',\n  'readVersions',\n  'update',\n  'unlock',\n]\nconst topLevelGlobalPermissions = ['read', 'readVersions', 'update']\n\n/**\n * Build up permissions object for an entity (collection or global).\n * This is not run during any update and reflects the current state of the entity data => doc and data is the same.\n *\n * When `fetchData` is false:\n * - returned `Where` are not run and evaluated as \"does not have permission\".\n * - If req.data is passed: `data` and `doc` is passed to access functions.\n * - If req.data is not passed: `data` and `doc` is not passed to access functions.\n *\n * When `fetchData` is true:\n * - `Where` are run and evaluated as \"has permission\" or \"does not have permission\".\n * - `data` and `doc` are always passed to access functions.\n * - Error is thrown if `entityType` is 'collection' and `id` is not passed.\n *\n * In both cases:\n * We cannot include siblingData or blockData here, as we do not have siblingData available once we reach block or array\n * rows, as we're calculating schema permissions, which do not include individual rows.\n * For consistency, it's thus better to never include the siblingData and blockData\n *\n * @internal\n */\nexport async function getEntityPermissions<TEntityType extends 'collection' | 'global'>(\n  args: Args<TEntityType>,\n): Promise<ReturnType<TEntityType>> {\n  const {\n    id,\n    blockReferencesPermissions,\n    data: _data,\n    entity,\n    entityType,\n    fetchData,\n    operations,\n    req,\n  } = args\n  const { locale: _locale, user } = req\n\n  const locale = _locale ? _locale : undefined\n\n  if (fetchData && entityType === 'collection' && !id) {\n    throw new Error('ID is required when fetching data for a collection')\n  }\n\n  const hasData = _data && Object.keys(_data).length > 0\n  const data: JsonObject | undefined = hasData\n    ? _data\n    : fetchData\n      ? await (async () => {\n          if (entityType === 'global') {\n            return req.payload.findGlobal({\n              slug: entity.slug,\n              depth: 0,\n              fallbackLocale: null,\n              locale,\n              overrideAccess: true,\n              req,\n            })\n          }\n\n          if (entityType === 'collection') {\n            return req.payload.findByID({\n              id: id!,\n              collection: entity.slug,\n              depth: 0,\n              fallbackLocale: null,\n              locale,\n              overrideAccess: true,\n              req,\n              trash: true,\n            })\n          }\n        })()\n      : undefined\n\n  const isLoggedIn = !!user\n\n  const fieldsPermissions: FieldsPermissions = {}\n\n  const entityPermissions: ReturnType<TEntityType> = {\n    fields: fieldsPermissions,\n  } as ReturnType<TEntityType>\n\n  const promises: Promise<void>[] = []\n\n  // Phase 1: Resolve all access functions to get where queries\n  const accessResults: {\n    operation: keyof typeof entity.access\n    result: Promise<boolean | Where>\n  }[] = []\n\n  for (const _operation of operations) {\n    const operation = _operation as keyof typeof entity.access\n    const accessFunction = entity.access[operation]\n\n    if (\n      (entityType === 'collection' && topLevelCollectionPermissions.includes(operation)) ||\n      (entityType === 'global' && topLevelGlobalPermissions.includes(operation))\n    ) {\n      if (typeof accessFunction === 'function') {\n        accessResults.push({\n          operation,\n          result: Promise.resolve(accessFunction({ id, data, req })) as Promise<boolean | Where>,\n        })\n      } else {\n        entityPermissions[operation] = {\n          permission: isLoggedIn,\n        }\n      }\n    }\n  }\n\n  // Await all access functions in parallel\n  const resolvedAccessResults = await Promise.all(\n    accessResults.map(async (item) => ({\n      operation: item.operation,\n      result: await item.result,\n    })),\n  )\n\n  // Phase 2: Process where queries with cache and resolve in parallel\n  const whereQueryCache: WhereQueryCache = []\n  const wherePromises: Promise<void>[] = []\n\n  for (const { operation, result: accessResult } of resolvedAccessResults) {\n    if (typeof accessResult === 'object') {\n      processWhereQuery({\n        id,\n        slug: entity.slug,\n        accessResult,\n        entityPermissions,\n        entityType,\n        fetchData,\n        locale,\n        operation,\n        req,\n        wherePromises,\n        whereQueryCache,\n      })\n    } else if (entityPermissions[operation]?.permission !== false) {\n      entityPermissions[operation] = { permission: !!accessResult }\n    }\n  }\n\n  // Await all where query DB calls in parallel\n  await Promise.all(wherePromises)\n\n  populateFieldPermissions({\n    blockReferencesPermissions,\n    data,\n    fields: entity.fields,\n    operations,\n    parentPermissionsObject: entityPermissions,\n    permissionsObject: fieldsPermissions,\n    promises,\n    req,\n  })\n\n  /**\n   * Await all promises in parallel.\n   * A promise can add more promises to the promises array (group of fields calls populateFieldPermissions again in their own promise), which will not be\n   * awaited in the first run.\n   * This is why we need to loop again to process the new promises, until there are no more promises left.\n   */\n  let iterations = 0\n  while (promises.length > 0) {\n    const currentPromises = promises.splice(0, promises.length)\n\n    await Promise.all(currentPromises)\n\n    iterations++\n    if (iterations >= 100) {\n      throw new Error('Infinite getEntityPermissions promise loop detected.')\n    }\n  }\n\n  return entityPermissions\n}\n\nconst processWhereQuery = ({\n  id,\n  slug,\n  accessResult,\n  entityPermissions,\n  entityType,\n  fetchData,\n  locale,\n  operation,\n  req,\n  wherePromises,\n  whereQueryCache,\n}: {\n  accessResult: Where\n  entityPermissions: CollectionPermission | GlobalPermission\n  entityType: 'collection' | 'global'\n  fetchData: boolean\n  id?: DefaultDocumentIDType\n  locale?: string\n  operation: Extract<keyof (CollectionPermission | GlobalPermission), AllOperations>\n  req: PayloadRequest\n  slug: string\n  wherePromises: Promise<void>[]\n  whereQueryCache: WhereQueryCache\n}): void => {\n  if (fetchData) {\n    // Check cache for identical where query using deep comparison\n    let cached = whereQueryCache.find((entry) => isDeepStrictEqual(entry.where, accessResult))\n\n    if (!cached) {\n      // Cache miss - start DB query (don't await)\n      cached = {\n        result: entityDocExists({\n          id,\n          slug,\n          entityType,\n          locale,\n          operation,\n          req,\n          where: accessResult,\n        }),\n        where: accessResult,\n      }\n      whereQueryCache.push(cached)\n    }\n\n    // Defer resolution to Promise.all (cache hits reuse same promise)\n    wherePromises.push(\n      cached.result.then((hasPermission) => {\n        entityPermissions[operation] = {\n          permission: hasPermission,\n          where: accessResult,\n        } as Permission\n      }),\n    )\n  } else {\n    // TODO: 4.0: Investigate defaulting to `false` here, if where query is returned but ignored as we don't\n    // have the document data available. This seems more secure.\n    // Alternatively, we could set permission to a third state, like 'unknown'.\n    // Even after calling sanitizePermissions, the permissions will still be true if the where query is returned but ignored as we don't have the document data available.\n    entityPermissions[operation] = { permission: true, where: accessResult } as Permission\n  }\n}\n"],"names":["isDeepStrictEqual","entityDocExists","populateFieldPermissions","topLevelCollectionPermissions","topLevelGlobalPermissions","getEntityPermissions","args","id","blockReferencesPermissions","data","_data","entity","entityType","fetchData","operations","req","locale","_locale","user","undefined","Error","hasData","Object","keys","length","payload","findGlobal","slug","depth","fallbackLocale","overrideAccess","findByID","collection","trash","isLoggedIn","fieldsPermissions","entityPermissions","fields","promises","accessResults","_operation","operation","accessFunction","access","includes","push","result","Promise","resolve","permission","resolvedAccessResults","all","map","item","whereQueryCache","wherePromises","accessResult","processWhereQuery","parentPermissionsObject","permissionsObject","iterations","currentPromises","splice","cached","find","entry","where","then","hasPermission"],"mappings":"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"}},
    {"offset": {"line": 1339, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/utilities/sanitizePermissions.ts"],"sourcesContent":["import type { MarkOptional } from 'ts-essentials'\n\nimport type {\n  CollectionPermission,\n  FieldPermissions,\n  FieldsPermissions,\n  GlobalPermission,\n  Permissions,\n  SanitizedBlocksPermissions,\n  SanitizedFieldPermissions,\n  SanitizedFieldsPermissions,\n  SanitizedPermissions,\n} from '../auth/types.js'\n\nfunction checkAndSanitizeFieldsPermssions(data: FieldsPermissions): boolean {\n  let allFieldPermissionsTrue = true\n  for (const key in data) {\n    if (typeof data[key] === 'object') {\n      if (!checkAndSanitizePermissions(data[key])) {\n        allFieldPermissionsTrue = false\n      } else {\n        ;(data[key] as unknown as SanitizedFieldPermissions) = true\n      }\n    } else if (data[key] !== true) {\n      allFieldPermissionsTrue = false\n    }\n  }\n\n  // If all values are true or it's an empty object, return true\n  return allFieldPermissionsTrue\n}\n\n/**\n * Check if all permissions in a FieldPermissions, CollectionPermission or GlobalPermission object are true.\n * If nested fields or blocks are present, the function will recursively check those as well.\n */\nfunction checkAndSanitizePermissions(\n  _data: CollectionPermission | FieldPermissions | GlobalPermission,\n): boolean {\n  const data = _data as Record<string, any>\n  /**\n   * Check blocks permissions\n   */\n  let blocksPermissions = true\n  if ('blocks' in data && data.blocks) {\n    for (const blockSlug in data.blocks) {\n      if (typeof data.blocks[blockSlug] === 'object') {\n        for (const key in data.blocks[blockSlug]) {\n          /**\n           * Check fields in nested blocks\n           */\n          if (key === 'fields') {\n            if (data.blocks[blockSlug].fields) {\n              if (!checkAndSanitizeFieldsPermssions(data.blocks[blockSlug].fields)) {\n                blocksPermissions = false\n              } else {\n                ;(data.blocks[blockSlug].fields as unknown as SanitizedFieldsPermissions) = true\n              }\n            }\n          } else {\n            if (typeof data.blocks[blockSlug][key] === 'object') {\n              /**\n               * Check Permissions in nested blocks\n               */\n              if (isPermissionObject(data.blocks[blockSlug][key])) {\n                if (\n                  data.blocks[blockSlug][key]['permission'] === true &&\n                  !('where' in data.blocks[blockSlug][key])\n                ) {\n                  // If the permission is true and there is no where clause, set the key to true\n                  data.blocks[blockSlug][key] = true\n                  continue\n                } else if (\n                  data.blocks[blockSlug][key]['permission'] === true &&\n                  'where' in data.blocks[blockSlug][key]\n                ) {\n                  // otherwise do nothing so we can keep the where clause\n                  blocksPermissions = false\n                } else {\n                  blocksPermissions = false\n                  data.blocks[blockSlug][key] = false\n                  delete data.blocks[blockSlug][key]\n                  continue\n                }\n              } else {\n                throw new Error('Unexpected object in block permissions')\n              }\n            }\n          }\n        }\n      } else if (data.blocks[blockSlug] !== true) {\n        // If any value is not true, return false\n        blocksPermissions = false\n        delete data.blocks[blockSlug]\n      }\n    }\n    if (blocksPermissions) {\n      ;(data.blocks as unknown as SanitizedBlocksPermissions) = true\n    }\n  }\n\n  /**\n   * Check nested Fields permissions\n   */\n  let fieldsPermissions = true\n  if (data.fields) {\n    if (!checkAndSanitizeFieldsPermssions(data.fields)) {\n      fieldsPermissions = false\n    } else {\n      ;(data.fields as unknown as SanitizedFieldsPermissions) = true\n    }\n  }\n\n  /**\n   * Check other Permissions objects (e.g. read, write)\n   */\n  let otherPermissions = true\n  for (const key in data) {\n    if (key === 'fields' || key === 'blocks') {\n      continue\n    }\n    if (typeof data[key] === 'object') {\n      if (isPermissionObject(data[key])) {\n        if (data[key]['permission'] === true && !('where' in data[key])) {\n          // If the permission is true and there is no where clause, set the key to true\n          data[key] = true\n          continue\n        } else if (data[key]['permission'] === true && 'where' in data[key]) {\n          // otherwise do nothing so we can keep the where clause\n          otherPermissions = false\n        } else {\n          otherPermissions = false\n          data[key] = false\n          delete data[key]\n          continue\n        }\n      } else {\n        // eslint-disable-next-line no-console\n        console.error('Unexpected object in fields permissions', data, 'key:', key)\n        throw new Error('Unexpected object in fields permissions')\n      }\n    } else if (data[key] !== true) {\n      // If any value is not true, return false\n      otherPermissions = false\n    }\n  }\n\n  // If all values are true or it's an empty object, return true\n  return fieldsPermissions && blocksPermissions && otherPermissions\n}\n\n/**\n * Check if an object is a permission object.\n */\nfunction isPermissionObject(data: unknown): boolean {\n  return (\n    typeof data === 'object' && 'permission' in data! && typeof data['permission'] === 'boolean'\n  )\n}\n\n/**\n * Recursively remove empty objects from an object.\n */\nfunction cleanEmptyObjects(obj: any): void {\n  Object.keys(obj).forEach((key) => {\n    if (typeof obj[key] === 'object' && obj[key] !== null) {\n      // Recursive call\n      cleanEmptyObjects(obj[key])\n      if (Object.keys(obj[key]).length === 0) {\n        // Delete the key if the object is empty\n        delete obj[key]\n      }\n    } else if (obj[key] === null || obj[key] === undefined) {\n      delete obj[key]\n    }\n  })\n}\n\nexport function recursivelySanitizeCollections(obj: Permissions['collections']): void {\n  if (typeof obj !== 'object') {\n    return\n  }\n\n  const collectionPermissions = Object.values(obj)\n\n  for (const collectionPermission of collectionPermissions) {\n    checkAndSanitizePermissions(collectionPermission)\n  }\n}\n\nexport function recursivelySanitizeGlobals(obj: Permissions['globals']): void {\n  if (typeof obj !== 'object') {\n    return\n  }\n\n  const globalPermissions = Object.values(obj)\n\n  for (const globalPermission of globalPermissions) {\n    checkAndSanitizePermissions(globalPermission)\n  }\n}\n\n/**\n * Recursively remove empty objects and false values from an object.\n *\n * @internal\n */\nexport function sanitizePermissions(\n  data: MarkOptional<Permissions, 'canAccessAdmin'>,\n): SanitizedPermissions {\n  if (data.canAccessAdmin === false) {\n    delete data.canAccessAdmin\n  }\n\n  if (data.collections) {\n    recursivelySanitizeCollections(data.collections)\n  }\n\n  if (data.globals) {\n    recursivelySanitizeGlobals(data.globals)\n  }\n\n  // Run clean up of empty objects at the end\n  cleanEmptyObjects(data)\n\n  return data as unknown as SanitizedPermissions\n}\n"],"names":["checkAndSanitizeFieldsPermssions","data","allFieldPermissionsTrue","key","checkAndSanitizePermissions","_data","blocksPermissions","blocks","blockSlug","fields","isPermissionObject","Error","fieldsPermissions","otherPermissions","console","error","cleanEmptyObjects","obj","Object","keys","forEach","length","undefined","recursivelySanitizeCollections","collectionPermissions","values","collectionPermission","recursivelySanitizeGlobals","globalPermissions","globalPermission","sanitizePermissions","canAccessAdmin","collections","globals"],"mappings":"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"}},
    {"offset": {"line": 1525, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/utilities/getRequestEntity.ts"],"sourcesContent":["import type { Collection } from '../collections/config/types.js'\nimport type { SanitizedGlobalConfig } from '../globals/config/types.js'\nimport type { PayloadRequest } from '../types/index.js'\n\nimport { APIError } from '../errors/APIError.js'\n\nexport const getRequestCollection = (req: PayloadRequest): Collection => {\n  const collectionSlug = req.routeParams?.collection\n\n  if (typeof collectionSlug !== 'string') {\n    throw new APIError(`No collection was specified`, 400)\n  }\n\n  const collection = req.payload.collections[collectionSlug]\n\n  if (!collection) {\n    throw new APIError(`Collection with the slug ${collectionSlug} was not found`, 404)\n  }\n\n  return collection\n}\n\nexport const getRequestCollectionWithID = <T extends boolean>(\n  req: PayloadRequest,\n  {\n    disableSanitize,\n    optionalID,\n  }: {\n    disableSanitize?: T\n    optionalID?: boolean\n  } = {},\n): {\n  collection: Collection\n  id: T extends true ? string : number | string\n} => {\n  const collection = getRequestCollection(req)\n  const id = req.routeParams?.id\n\n  if (typeof id !== 'string') {\n    if (optionalID) {\n      return {\n        id: undefined!,\n        collection,\n      }\n    }\n\n    throw new APIError(`ID was not specified`, 400)\n  }\n\n  if (disableSanitize === true) {\n    return {\n      id,\n      collection,\n    }\n  }\n\n  let sanitizedID: number | string = id\n\n  // If default db ID type is a number, we should sanitize\n  let shouldSanitize = Boolean(req.payload.db.defaultIDType === 'number')\n\n  // UNLESS the customIDType for this collection is text.... then we leave it\n  if (shouldSanitize && collection.customIDType === 'text') {\n    shouldSanitize = false\n  }\n\n  // If we still should sanitize, parse float\n  if (shouldSanitize) {\n    sanitizedID = parseFloat(sanitizedID)\n  }\n\n  return {\n    // @ts-expect-error generic return\n    id: sanitizedID,\n    collection,\n  }\n}\n\nexport const getRequestGlobal = (req: PayloadRequest): SanitizedGlobalConfig => {\n  const globalSlug = req.routeParams?.global\n\n  if (typeof globalSlug !== 'string') {\n    throw new APIError(`No global was specified`, 400)\n  }\n\n  const globalConfig = req.payload.globals.config.find((each) => each.slug === globalSlug)\n\n  if (!globalConfig) {\n    throw new APIError(`Global with the slug ${globalSlug} was not found`, 404)\n  }\n\n  return globalConfig\n}\n"],"names":["APIError","getRequestCollection","req","collectionSlug","routeParams","collection","payload","collections","getRequestCollectionWithID","disableSanitize","optionalID","id","undefined","sanitizedID","shouldSanitize","Boolean","db","defaultIDType","customIDType","parseFloat","getRequestGlobal","globalSlug","global","globalConfig","globals","config","find","each","slug"],"mappings":";;;;;;;;AAIA,SAASA,QAAQ,QAAQ,wBAAuB;;AAEzC,MAAMC,uBAAuB,CAACC;IACnC,MAAMC,iBAAiBD,IAAIE,WAAW,EAAEC;IAExC,IAAI,OAAOF,mBAAmB,UAAU;QACtC,MAAM,IAAIH,mKAAAA,CAAS,CAAC,2BAA2B,CAAC,EAAE;IACpD;IAEA,MAAMK,aAAaH,IAAII,OAAO,CAACC,WAAW,CAACJ,eAAe;IAE1D,IAAI,CAACE,YAAY;QACf,MAAM,IAAIL,mKAAAA,CAAS,CAAC,yBAAyB,EAAEG,eAAe,cAAc,CAAC,EAAE;IACjF;IAEA,OAAOE;AACT,EAAC;AAEM,MAAMG,6BAA6B,CACxCN,KACA,EACEO,eAAe,EACfC,UAAU,EAIX,GAAG,CAAC,CAAC;IAKN,MAAML,aAAaJ,qBAAqBC;IACxC,MAAMS,KAAKT,IAAIE,WAAW,EAAEO;IAE5B,IAAI,OAAOA,OAAO,UAAU;QAC1B,IAAID,YAAY;YACd,OAAO;gBACLC,IAAIC;gBACJP;YACF;QACF;QAEA,MAAM,IAAIL,mKAAAA,CAAS,CAAC,oBAAoB,CAAC,EAAE;IAC7C;IAEA,IAAIS,oBAAoB,MAAM;QAC5B,OAAO;YACLE;YACAN;QACF;IACF;IAEA,IAAIQ,cAA+BF;IAEnC,wDAAwD;IACxD,IAAIG,iBAAiBC,QAAQb,IAAII,OAAO,CAACU,EAAE,CAACC,aAAa,KAAK;IAE9D,2EAA2E;IAC3E,IAAIH,kBAAkBT,WAAWa,YAAY,KAAK,QAAQ;QACxDJ,iBAAiB;IACnB;IAEA,2CAA2C;IAC3C,IAAIA,gBAAgB;QAClBD,cAAcM,WAAWN;IAC3B;IAEA,OAAO;QACL,kCAAkC;QAClCF,IAAIE;QACJR;IACF;AACF,EAAC;AAEM,MAAMe,mBAAmB,CAAClB;IAC/B,MAAMmB,aAAanB,IAAIE,WAAW,EAAEkB;IAEpC,IAAI,OAAOD,eAAe,UAAU;QAClC,MAAM,IAAIrB,mKAAAA,CAAS,CAAC,uBAAuB,CAAC,EAAE;IAChD;IAEA,MAAMuB,eAAerB,IAAII,OAAO,CAACkB,OAAO,CAACC,MAAM,CAACC,IAAI,CAAC,CAACC,OAASA,KAAKC,IAAI,KAAKP;IAE7E,IAAI,CAACE,cAAc;QACjB,MAAM,IAAIvB,mKAAAA,CAAS,CAAC,qBAAqB,EAAEqB,WAAW,cAAc,CAAC,EAAE;IACzE;IAEA,OAAOE;AACT,EAAC"}},
    {"offset": {"line": 1596, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/utilities/appendNonTrashedFilter.ts"],"sourcesContent":["import type { Where } from '../types/index.js'\n\nexport const appendNonTrashedFilter = ({\n  deletedAtPath = 'deletedAt',\n  enableTrash,\n  trash,\n  where,\n}: {\n  deletedAtPath?: string\n  enableTrash: boolean\n  trash?: boolean\n  where: Where\n}): Where => {\n  if (!enableTrash || trash) {\n    return where\n  }\n\n  const notTrashedFilter = {\n    [deletedAtPath]: { exists: false },\n  }\n\n  if (where?.and) {\n    return {\n      ...where,\n      and: [...where.and, notTrashedFilter],\n    }\n  }\n\n  return {\n    and: [notTrashedFilter, ...(where ? [where] : [])],\n  }\n}\n"],"names":["appendNonTrashedFilter","deletedAtPath","enableTrash","trash","where","notTrashedFilter","exists","and"],"mappings":";;;;AAEO,MAAMA,yBAAyB,CAAC,EACrCC,gBAAgB,WAAW,EAC3BC,WAAW,EACXC,KAAK,EACLC,KAAK,EAMN;IACC,IAAI,CAACF,eAAeC,OAAO;QACzB,OAAOC;IACT;IAEA,MAAMC,mBAAmB;QACvB,CAACJ,cAAc,EAAE;YAAEK,QAAQ;QAAM;IACnC;IAEA,IAAIF,OAAOG,KAAK;QACd,OAAO;YACL,GAAGH,KAAK;YACRG,KAAK;mBAAIH,MAAMG,GAAG;gBAAEF;aAAiB;QACvC;IACF;IAEA,OAAO;QACLE,KAAK;YAACF;eAAsBD,QAAQ;gBAACA;aAAM,GAAG,EAAE;SAAE;IACpD;AACF,EAAC"}},
    {"offset": {"line": 1631, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/utilities/commitTransaction.ts"],"sourcesContent":["import type { MarkRequired } from 'ts-essentials'\n\nimport type { PayloadRequest } from '../types/index.js'\n\n/**\n * complete a transaction calling adapter db.commitTransaction and delete the transactionID from req\n */\nexport async function commitTransaction(\n  req: MarkRequired<Partial<PayloadRequest>, 'payload'>,\n): Promise<void> {\n  const { payload, transactionID } = req\n\n  await payload.db.commitTransaction(transactionID!)\n  delete req.transactionID\n}\n"],"names":["commitTransaction","req","payload","transactionID","db"],"mappings":"AAIA;;CAEC,GACD;;;;AAAO,eAAeA,kBACpBC,GAAqD;IAErD,MAAM,EAAEC,OAAO,EAAEC,aAAa,EAAE,GAAGF;IAEnC,MAAMC,QAAQE,EAAE,CAACJ,iBAAiB,CAACG;IACnC,OAAOF,IAAIE,aAAa;AAC1B"}},
    {"offset": {"line": 1646, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/utilities/formatAdminURL.ts"],"sourcesContent":["import type { Config } from '../config/types.js'\n\n/**\n * This function builds correct URLs for admin panel routing.\n * Its primary responsibilities are:\n * 1. Read from your `routes.admin` config and appropriately handle `\"/\"` admin paths\n * 2. Prepend the `basePath` from your Next.js config, if specified\n * 3. Return relative or absolute URLs, as needed\n */\ntype BaseFormatURLArgs = {\n  /**\n   * The subpath of your application, if specified.\n   * @see https://nextjs.org/docs/app/api-reference/config/next-config-js/basePath\n   * @example '/docs'\n   */\n  basePath?: string\n  includeBasePath?: boolean\n  path?: '' | `/${string}` | null\n  /**\n   * Return a relative URL, e.g. ignore `serverURL`.\n   * Useful for route-matching, etc.\n   */\n  relative?: boolean\n} & Pick<Config, 'serverURL'>\n\ntype FormatURLArgs =\n  | ({\n      adminRoute: NonNullable<Config['routes']>['admin']\n      apiRoute?: never\n    } & BaseFormatURLArgs)\n  | ({\n      adminRoute?: never\n      apiRoute: NonNullable<Config['routes']>['api']\n    } & BaseFormatURLArgs)\n\nexport const formatAdminURL = (args: FormatURLArgs): string => {\n  const {\n    adminRoute,\n    apiRoute,\n    includeBasePath: includeBasePathArg,\n    path = '',\n    relative = false,\n    serverURL,\n  } = args\n  const basePath = process.env.NEXT_BASE_PATH || args.basePath || ''\n  const routePath = adminRoute || apiRoute\n  const segments = [routePath && routePath !== '/' && routePath, path && path].filter(Boolean)\n  const pathname = segments.join('') || '/'\n  const pathnameWithBase = (basePath + pathname).replace(/\\/$/, '') || '/'\n  const includeBasePath = includeBasePathArg ?? (adminRoute ? false : true)\n\n  if (relative || !serverURL) {\n    if (includeBasePath && basePath) {\n      return pathnameWithBase\n    }\n    return pathname\n  }\n\n  const serverURLObj = new URL(serverURL)\n  return new URL(pathnameWithBase, serverURLObj.origin).toString()\n}\n"],"names":["formatAdminURL","args","adminRoute","apiRoute","includeBasePath","includeBasePathArg","path","relative","serverURL","basePath","process","env","NEXT_BASE_PATH","routePath","segments","filter","Boolean","pathname","join","pathnameWithBase","replace","serverURLObj","URL","origin","toString"],"mappings":";;;;AAmCO,MAAMA,iBAAiB,CAACC;IAC7B,MAAM,EACJC,UAAU,EACVC,QAAQ,EACRC,iBAAiBC,kBAAkB,EACnCC,OAAO,EAAE,EACTC,WAAW,KAAK,EAChBC,SAAS,EACV,GAAGP;IACJ,MAAMQ,WAAWC,QAAQC,GAAG,CAACC,cAAc,IAAIX,KAAKQ,QAAQ,IAAI;IAChE,MAAMI,YAAYX,cAAcC;IAChC,MAAMW,WAAW;QAACD,aAAaA,cAAc,OAAOA;QAAWP,QAAQA;KAAK,CAACS,MAAM,CAACC;IACpF,MAAMC,WAAWH,SAASI,IAAI,CAAC,OAAO;IACtC,MAAMC,mBAAoBV,CAAAA,WAAWQ,QAAO,EAAGG,OAAO,CAAC,OAAO,OAAO;IACrE,MAAMhB,kBAAkBC,sBAAuBH,CAAAA,aAAa,QAAQ,IAAG;IAEvE,IAAIK,YAAY,CAACC,WAAW;QAC1B,IAAIJ,mBAAmBK,UAAU;YAC/B,OAAOU;QACT;QACA,OAAOF;IACT;IAEA,MAAMI,eAAe,IAAIC,IAAId;IAC7B,OAAO,IAAIc,IAAIH,kBAAkBE,aAAaE,MAAM,EAAEC,QAAQ;AAChE,EAAC"}},
    {"offset": {"line": 1674, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/utilities/initTransaction.ts"],"sourcesContent":["import type { MarkRequired } from 'ts-essentials'\n\nimport type { PayloadRequest } from '../types/index.js'\n\n/**\n * Starts a new transaction using the db adapter with a random id and then assigns it to the req.transaction\n * @returns true if beginning a transaction and false when req already has a transaction to use\n */\nexport async function initTransaction(\n  req: MarkRequired<Partial<PayloadRequest>, 'payload'>,\n): Promise<boolean> {\n  const { payload, transactionID } = req\n  if (transactionID instanceof Promise) {\n    // wait for whoever else is already creating the transaction\n    await transactionID\n    return false\n  }\n\n  if (transactionID) {\n    // we already have a transaction, we're not in charge of committing it\n    return false\n  }\n  if (typeof payload.db.beginTransaction === 'function') {\n    // create a new transaction\n    req.transactionID = payload.db.beginTransaction().then((transactionID) => {\n      if (transactionID) {\n        req.transactionID = transactionID\n      }\n\n      return transactionID!\n    })\n    return !!(await req.transactionID)\n  }\n  return false\n}\n"],"names":["initTransaction","req","payload","transactionID","Promise","db","beginTransaction","then"],"mappings":"AAIA;;;CAGC,GACD;;;;AAAO,eAAeA,gBACpBC,GAAqD;IAErD,MAAM,EAAEC,OAAO,EAAEC,aAAa,EAAE,GAAGF;IACnC,IAAIE,yBAAyBC,SAAS;QACpC,4DAA4D;QAC5D,MAAMD;QACN,OAAO;IACT;IAEA,IAAIA,eAAe;QACjB,sEAAsE;QACtE,OAAO;IACT;IACA,IAAI,OAAOD,QAAQG,EAAE,CAACC,gBAAgB,KAAK,YAAY;QACrD,2BAA2B;QAC3BL,IAAIE,aAAa,GAAGD,QAAQG,EAAE,CAACC,gBAAgB,GAAGC,IAAI,CAAC,CAACJ;YACtD,IAAIA,eAAe;gBACjBF,IAAIE,aAAa,GAAGA;YACtB;YAEA,OAAOA;QACT;QACA,OAAO,CAAC,CAAE,MAAMF,IAAIE,aAAa;IACnC;IACA,OAAO;AACT"}},
    {"offset": {"line": 1708, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/utilities/isNumber.ts"],"sourcesContent":["export function isNumber(value: unknown): value is number {\n  if (value === null || value === undefined || (typeof value === 'string' && value.trim() === '')) {\n    return false\n  }\n\n  return !Number.isNaN(Number(value))\n}\n"],"names":["isNumber","value","undefined","trim","Number","isNaN"],"mappings":";;;;AAAO,SAASA,SAASC,KAAc;IACrC,IAAIA,UAAU,QAAQA,UAAUC,aAAc,OAAOD,UAAU,YAAYA,MAAME,IAAI,OAAO,IAAK;QAC/F,OAAO;IACT;IAEA,OAAO,CAACC,OAAOC,KAAK,CAACD,OAAOH;AAC9B"}},
    {"offset": {"line": 1722, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/utilities/getSelectMode.ts"],"sourcesContent":["import type { SelectMode, SelectType } from '../types/index.js'\n\nexport const getSelectMode = (select: SelectType): SelectMode => {\n  for (const key in select) {\n    const selectValue = select[key]\n    if (selectValue === false) {\n      return 'exclude'\n    }\n\n    if (typeof selectValue === 'object') {\n      return getSelectMode(selectValue)\n    }\n  }\n\n  return 'include'\n}\n"],"names":["getSelectMode","select","key","selectValue"],"mappings":";;;;AAEO,MAAMA,gBAAgB,CAACC;IAC5B,IAAK,MAAMC,OAAOD,OAAQ;QACxB,MAAME,cAAcF,MAAM,CAACC,IAAI;QAC/B,IAAIC,gBAAgB,OAAO;YACzB,OAAO;QACT;QAEA,IAAI,OAAOA,gBAAgB,UAAU;YACnC,OAAOH,cAAcG;QACvB;IACF;IAEA,OAAO;AACT,EAAC"}},
    {"offset": {"line": 1742, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/utilities/getBlockSelect.ts"],"sourcesContent":["import type { Block } from '../fields/config/types.js'\nimport type { SelectMode, SelectType } from '../types/index.js'\n\n/**\n * This is used for the Select API to determine the select level of a block.\n * It will ensure that `id` and `blockType` are always included in the select object.\n * @returns { blockSelect: boolean | SelectType, blockSelectMode: SelectMode }\n */\nexport const getBlockSelect = ({\n  block,\n  select,\n  selectMode,\n}: {\n  block: Block\n  select: SelectType[string]\n  selectMode: SelectMode\n}): { blockSelect: boolean | SelectType; blockSelectMode: SelectMode } => {\n  if (typeof select === 'object') {\n    let blockSelectMode = selectMode\n\n    const blocksSelect = {\n      ...select,\n    }\n\n    let blockSelect = blocksSelect[block.slug]\n\n    // sanitize `{ blocks: { cta: false }}` to `{ blocks: { cta: { id: true, blockType: true }}}`\n    if (selectMode === 'exclude' && blockSelect === false) {\n      blockSelectMode = 'include'\n\n      blockSelect = {\n        id: true,\n        blockType: true,\n      }\n    } else if (selectMode === 'include') {\n      if (!blockSelect) {\n        blockSelect = {}\n      }\n\n      if (typeof blockSelect === 'object') {\n        blockSelect = {\n          ...blockSelect,\n        }\n\n        blockSelect['id'] = true\n        blockSelect['blockType'] = true\n      }\n    }\n\n    return { blockSelect: blockSelect!, blockSelectMode }\n  }\n\n  return { blockSelect: select, blockSelectMode: selectMode }\n}\n"],"names":["getBlockSelect","block","select","selectMode","blockSelectMode","blocksSelect","blockSelect","slug","id","blockType"],"mappings":"AAGA;;;;CAIC,GACD;;;;AAAO,MAAMA,iBAAiB,CAAC,EAC7BC,KAAK,EACLC,MAAM,EACNC,UAAU,EAKX;IACC,IAAI,OAAOD,WAAW,UAAU;QAC9B,IAAIE,kBAAkBD;QAEtB,MAAME,eAAe;YACnB,GAAGH,MAAM;QACX;QAEA,IAAII,cAAcD,YAAY,CAACJ,MAAMM,IAAI,CAAC;QAE1C,6FAA6F;QAC7F,IAAIJ,eAAe,aAAaG,gBAAgB,OAAO;YACrDF,kBAAkB;YAElBE,cAAc;gBACZE,IAAI;gBACJC,WAAW;YACb;QACF,OAAO,IAAIN,eAAe,WAAW;YACnC,IAAI,CAACG,aAAa;gBAChBA,cAAc,CAAC;YACjB;YAEA,IAAI,OAAOA,gBAAgB,UAAU;gBACnCA,cAAc;oBACZ,GAAGA,WAAW;gBAChB;gBAEAA,WAAW,CAAC,KAAK,GAAG;gBACpBA,WAAW,CAAC,YAAY,GAAG;YAC7B;QACF;QAEA,OAAO;YAAEA,aAAaA;YAAcF;QAAgB;IACtD;IAEA,OAAO;QAAEE,aAAaJ;QAAQE,iBAAiBD;IAAW;AAC5D,EAAC"}},
    {"offset": {"line": 1790, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/utilities/stripUnselectedFields.ts"],"sourcesContent":["import type { Data } from '../admin/types.js'\nimport type { Field, TabAsField } from '../fields/config/types.js'\nimport type { SelectMode, SelectType } from '../types/index.js'\n\nimport { fieldAffectsData } from '../fields/config/types.js'\n\n/**\n * This is used for the Select API to strip out fields that are not selected.\n * It will mutate the given data object and determine if your recursive function should continue to run.\n * It is used within the `afterRead` hook as well as `getFormState`.\n * @returns boolean - whether or not the recursive function should continue\n */\nexport const stripUnselectedFields = ({\n  field,\n  select,\n  selectMode,\n  siblingDoc,\n}: {\n  field: Field | TabAsField\n  select: SelectType\n  selectMode: SelectMode\n  siblingDoc: Data\n}): boolean => {\n  let shouldContinue = true\n\n  if (fieldAffectsData(field) && select && selectMode && field.name) {\n    if (selectMode === 'include') {\n      if (!select[field.name]) {\n        delete siblingDoc[field.name]\n        shouldContinue = false\n      }\n    }\n\n    if (selectMode === 'exclude') {\n      if (select[field.name] === false) {\n        delete siblingDoc[field.name]\n        shouldContinue = false\n      }\n    }\n  }\n\n  return shouldContinue\n}\n"],"names":["fieldAffectsData","stripUnselectedFields","field","select","selectMode","siblingDoc","shouldContinue","name"],"mappings":";;;;AAIA,SAASA,gBAAgB,QAAQ,4BAA2B;;AAQrD,MAAMC,wBAAwB,CAAC,EACpCC,KAAK,EACLC,MAAM,EACNC,UAAU,EACVC,UAAU,EAMX;IACC,IAAIC,iBAAiB;IAErB,QAAIN,kLAAAA,EAAiBE,UAAUC,UAAUC,cAAcF,MAAMK,IAAI,EAAE;QACjE,IAAIH,eAAe,WAAW;YAC5B,IAAI,CAACD,MAAM,CAACD,MAAMK,IAAI,CAAC,EAAE;gBACvB,OAAOF,UAAU,CAACH,MAAMK,IAAI,CAAC;gBAC7BD,iBAAiB;YACnB;QACF;QAEA,IAAIF,eAAe,WAAW;YAC5B,IAAID,MAAM,CAACD,MAAMK,IAAI,CAAC,KAAK,OAAO;gBAChC,OAAOF,UAAU,CAACH,MAAMK,IAAI,CAAC;gBAC7BD,iBAAiB;YACnB;QACF;IACF;IAEA,OAAOA;AACT,EAAC"}},
    {"offset": {"line": 1818, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/utilities/deepCopyObject.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\nimport type { JsonValue } from '../types/index.js'\n\n/*\nMain deepCopyObject handling - from rfdc: https://github.com/davidmarkclements/rfdc/blob/master/index.js\n\nCopyright 2019 \"David Mark Clements <david.mark.clements@gmail.com>\"\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\ndocumentation files (the \"Software\"), to deal in the Software without restriction, including without limitation\nthe rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and\nto permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions\nof the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED\nTO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\nCONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\nIN THE SOFTWARE.\n*/\n\nfunction copyBuffer(cur: any) {\n  if (cur instanceof Buffer) {\n    return Buffer.from(cur)\n  }\n\n  return new cur.constructor(cur.buffer.slice(), cur.byteOffset, cur.length)\n}\n\nconst constructorHandlers = new Map()\nconstructorHandlers.set(Date, (o: any) => new Date(o))\nconstructorHandlers.set(Map, (o: any, fn: any) => new Map(cloneArray<any>(Array.from(o), fn)))\nconstructorHandlers.set(Set, (o: any, fn: any) => new Set(cloneArray(Array.from(o), fn)))\nconstructorHandlers.set(RegExp, (regex: RegExp) => new RegExp(regex.source, regex.flags))\n\nlet handler: ((o: any, fn: any) => any) | null = null\n\nfunction cloneArray<T extends object>(a: T, fn: (o: any) => any): T {\n  const keys = Object.keys(a)\n  const a2 = new Array(keys.length) as T\n  for (let i = 0; i < keys.length; i++) {\n    const k = keys[i] as keyof typeof a\n    const cur = a[k] as any\n    if (typeof cur !== 'object' || cur === null) {\n      a2[k] = cur\n    } else if (cur instanceof RegExp) {\n      a2[k] = new RegExp(cur.source, cur.flags) as any\n    } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {\n      a2[k] = handler(cur, fn)\n    } else if (ArrayBuffer.isView(cur)) {\n      a2[k] = copyBuffer(cur)\n    } else {\n      a2[k] = fn(cur)\n    }\n  }\n  return a2\n}\n\nexport const deepCopyObject = <T>(o: T): T => {\n  if (typeof o !== 'object' || o === null) {\n    return o\n  }\n  if (Array.isArray(o)) {\n    return cloneArray(o, deepCopyObject)\n  }\n  if (o instanceof RegExp) {\n    return new RegExp(o.source, o.flags) as T\n  }\n\n  if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) {\n    return handler(o, deepCopyObject)\n  }\n  const o2 = {} as T\n  for (const k in o) {\n    if (Object.hasOwnProperty.call(o, k) === false) {\n      continue\n    }\n    const cur = o[k]\n    if (typeof cur !== 'object' || cur === null) {\n      o2[k] = cur\n    } else if (cur instanceof RegExp) {\n      o2[k] = new RegExp(cur.source, cur.flags) as any\n    } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {\n      o2[k] = handler(cur, deepCopyObject)\n    } else if (ArrayBuffer.isView(cur)) {\n      o2[k] = copyBuffer(cur)\n    } else {\n      o2[k] = deepCopyObject(cur)\n    }\n  }\n  return o2\n}\n\n/*\nFast deepCopyObjectSimple handling - from fast-json-clone: https://github.com/rhysd/fast-json-clone\n\nBenchmark: https://github.com/AlessioGr/fastest-deep-clone-json/blob/main/test/benchmark.js\n*/\n\n/**\n * A deepCopyObject implementation which only works for JSON objects and arrays, and is faster than\n * JSON.parse(JSON.stringify(obj))\n *\n * @param value The JSON value to be cloned. There are two invariants. 1) It must not contain circles\n *              as JSON does not allow it. This function will cause infinite loop for such values by\n *              design. 2) It must contain JSON values only. Other values like `Date`, `Regexp`, `Map`,\n *              `Set`, `Buffer`, ... are not allowed.\n * @returns The cloned JSON value.\n */\nexport function deepCopyObjectSimple<T extends JsonValue>(value: T, filterUndefined = false): T {\n  if (typeof value !== 'object' || value === null) {\n    return value\n  } else if (Array.isArray(value)) {\n    return value.map((e) =>\n      typeof e !== 'object' || e === null ? e : deepCopyObjectSimple(e, filterUndefined),\n    ) as T\n  } else {\n    if (value instanceof Date) {\n      return new Date(value) as unknown as T\n    }\n    const ret: { [key: string]: T } = {}\n    for (const k in value) {\n      const v = value[k]\n      if (filterUndefined && v === undefined) {\n        continue\n      }\n      ret[k] =\n        typeof v !== 'object' || v === null\n          ? v\n          : (deepCopyObjectSimple(v as T, filterUndefined) as any)\n    }\n    return ret as unknown as T\n  }\n}\n\nexport function deepCopyObjectSimpleWithoutReactComponents<T extends JsonValue>(\n  value: T,\n  opts: {\n    excludeFiles?: boolean\n  } = {},\n): T {\n  if (\n    typeof value === 'object' &&\n    value !== null &&\n    '$$typeof' in value &&\n    typeof value.$$typeof === 'symbol'\n  ) {\n    return undefined!\n  } else if (typeof value !== 'object' || value === null) {\n    return value\n  } else if (Array.isArray(value)) {\n    return value.map((e) =>\n      typeof e !== 'object' || e === null ? e : deepCopyObjectSimpleWithoutReactComponents(e, opts),\n    ) as T\n  } else {\n    // Handle File objects by returning them as-is (don't serialize to plain object) or exclude if excludeFiles is provided\n    if (value instanceof File) {\n      if (opts.excludeFiles) {\n        return undefined!\n      }\n\n      return value as unknown as T\n    }\n    if (value instanceof Date) {\n      return new Date(value) as unknown as T\n    }\n    const ret: { [key: string]: T } = {}\n    for (const k in value) {\n      const v = value[k]\n      ret[k] =\n        typeof v !== 'object' || v === null\n          ? v\n          : (deepCopyObjectSimpleWithoutReactComponents(v as T, opts) as any)\n    }\n    return ret as unknown as T\n  }\n}\n\n/**\n * A deepCopyObject implementation which is slower than deepCopyObject, but more correct.\n * Can be used if correctness is more important than speed. Supports circular dependencies\n */\nexport function deepCopyObjectComplex<T>(object: T, cache: WeakMap<any, any> = new WeakMap()): T {\n  if (object === null) {\n    return null!\n  }\n\n  if (cache.has(object)) {\n    return cache.get(object)\n  }\n\n  // Handle File\n  if (object instanceof File) {\n    return object as unknown as T\n  }\n\n  // Handle Date\n  if (object instanceof Date) {\n    return new Date(object.getTime()) as unknown as T\n  }\n\n  // Handle RegExp\n  if (object instanceof RegExp) {\n    return new RegExp(object.source, object.flags) as unknown as T\n  }\n\n  // Handle Map\n  if (object instanceof Map) {\n    const clonedMap = new Map()\n    cache.set(object, clonedMap)\n    for (const [key, value] of object.entries()) {\n      clonedMap.set(key, deepCopyObjectComplex(value, cache))\n    }\n    return clonedMap as unknown as T\n  }\n\n  // Handle Set\n  if (object instanceof Set) {\n    const clonedSet = new Set()\n    cache.set(object, clonedSet)\n    for (const value of object.values()) {\n      clonedSet.add(deepCopyObjectComplex(value, cache))\n    }\n    return clonedSet as unknown as T\n  }\n\n  // Handle Array and Object\n  if (typeof object === 'object' && object !== null) {\n    if ('$$typeof' in object && typeof object.$$typeof === 'symbol') {\n      return object\n    }\n\n    const clonedObject: any = Array.isArray(object)\n      ? []\n      : Object.create(Object.getPrototypeOf(object))\n    cache.set(object, clonedObject)\n\n    for (const key in object) {\n      if (\n        Object.prototype.hasOwnProperty.call(object, key) ||\n        Object.getOwnPropertySymbols(object).includes(key as any)\n      ) {\n        clonedObject[key] = deepCopyObjectComplex(object[key], cache)\n      }\n    }\n\n    return clonedObject as T\n  }\n\n  // Handle all other cases\n  return object\n}\n"],"names":["copyBuffer","cur","Buffer","from","buffer","slice","byteOffset","length","constructorHandlers","Map","set","Date","o","fn","cloneArray","Array","Set","RegExp","regex","source","flags","handler","a","keys","Object","a2","i","k","get","ArrayBuffer","isView","deepCopyObject","isArray","o2","hasOwnProperty","call","deepCopyObjectSimple","value","filterUndefined","map","e","ret","v","undefined","deepCopyObjectSimpleWithoutReactComponents","opts","$$typeof","File","excludeFiles","deepCopyObjectComplex","object","cache","WeakMap","has","getTime","clonedMap","key","entries","clonedSet","values","add","clonedObject","create","getPrototypeOf","prototype","getOwnPropertySymbols","includes"],"mappings":"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"}},
    {"offset": {"line": 2015, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/utilities/isValidID.ts"],"sourcesContent":["import ObjectIdImport from 'bson-objectid'\n\nconst ObjectId = 'default' in ObjectIdImport ? ObjectIdImport.default : ObjectIdImport\n\nexport const isValidID = (\n  value: number | string,\n  type: 'number' | 'ObjectID' | 'text',\n): boolean => {\n  if (type === 'text' && value) {\n    if (['object', 'string'].includes(typeof value)) {\n      const isObjectID = ObjectId.isValid(value as string)\n      return typeof value === 'string' || isObjectID\n    }\n    return false\n  }\n\n  if (type === 'number' && typeof value === 'number' && !Number.isNaN(value)) {\n    return true\n  }\n\n  if (type === 'ObjectID') {\n    return ObjectId.isValid(String(value))\n  }\n\n  return false\n}\n"],"names":["ObjectIdImport","ObjectId","default","isValidID","value","type","includes","isObjectID","isValid","Number","isNaN","String"],"mappings":";;;;AAAA,OAAOA,oBAAoB,gBAAe;;AAE1C,MAAMC,WAAW,aAAaD,yJAAAA,GAAiBA,yJAAAA,CAAeE,OAAO,GAAGF,yJAAAA;AAEjE,MAAMG,YAAY,CACvBC,OACAC;IAEA,IAAIA,SAAS,UAAUD,OAAO;QAC5B,IAAI;YAAC;YAAU;SAAS,CAACE,QAAQ,CAAC,OAAOF,QAAQ;YAC/C,MAAMG,aAAaN,SAASO,OAAO,CAACJ;YACpC,OAAO,OAAOA,UAAU,YAAYG;QACtC;QACA,OAAO;IACT;IAEA,IAAIF,SAAS,YAAY,OAAOD,UAAU,YAAY,CAACK,OAAOC,KAAK,CAACN,QAAQ;QAC1E,OAAO;IACT;IAEA,IAAIC,SAAS,YAAY;QACvB,OAAOJ,SAASO,OAAO,CAACG,OAAOP;IACjC;IAEA,OAAO;AACT,EAAC"}},
    {"offset": {"line": 2045, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/utilities/sanitizeInternalFields.ts"],"sourcesContent":["export const sanitizeInternalFields = <T extends Record<string, unknown>>(incomingDoc: T): T => {\n  // Create a new object to hold the sanitized fields\n  const newDoc: Record<string, unknown> = {}\n\n  for (const key in incomingDoc) {\n    const val = incomingDoc[key]\n    if (key === '_id') {\n      newDoc['id'] = val\n    } else if (key !== '__v') {\n      newDoc[key] = val\n    }\n  }\n\n  return newDoc as T\n}\n"],"names":["sanitizeInternalFields","incomingDoc","newDoc","key","val"],"mappings":";;;;AAAO,MAAMA,yBAAyB,CAAoCC;IACxE,mDAAmD;IACnD,MAAMC,SAAkC,CAAC;IAEzC,IAAK,MAAMC,OAAOF,YAAa;QAC7B,MAAMG,MAAMH,WAAW,CAACE,IAAI;QAC5B,IAAIA,QAAQ,OAAO;YACjBD,MAAM,CAAC,KAAK,GAAGE;QACjB,OAAO,IAAID,QAAQ,OAAO;YACxBD,MAAM,CAACC,IAAI,GAAGC;QAChB;IACF;IAEA,OAAOF;AACT,EAAC"}},
    {"offset": {"line": 2066, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/utilities/sanitizeJoinParams.ts"],"sourcesContent":["import type { JoinQuery } from '../types/index.js'\n\nimport { isNumber } from './isNumber.js'\n\nexport type JoinParams =\n  | {\n      [schemaPath: string]:\n        | {\n            limit?: unknown\n            sort?: string\n            where?: unknown\n          }\n        | false\n    }\n  | false\n\n/**\n * Convert request JoinQuery object from strings to numbers\n * @param joins\n */\nexport const sanitizeJoinParams = (_joins: JoinParams = {}): JoinQuery => {\n  const joinQuery: Record<string, any> = {}\n  const joins = _joins as Record<string, any>\n\n  Object.keys(joins).forEach((schemaPath) => {\n    if (joins[schemaPath] === 'false' || joins[schemaPath] === false) {\n      joinQuery[schemaPath] = false\n    } else {\n      joinQuery[schemaPath] = {\n        count: joins[schemaPath].count === 'true',\n        limit: isNumber(joins[schemaPath]?.limit) ? Number(joins[schemaPath].limit) : undefined,\n        page: isNumber(joins[schemaPath]?.page) ? Number(joins[schemaPath].page) : undefined,\n        sort: joins[schemaPath]?.sort ? joins[schemaPath].sort : undefined,\n        where: joins[schemaPath]?.where ? joins[schemaPath].where : undefined,\n      }\n    }\n  })\n\n  return joinQuery\n}\n"],"names":["isNumber","sanitizeJoinParams","_joins","joinQuery","joins","Object","keys","forEach","schemaPath","count","limit","Number","undefined","page","sort","where"],"mappings":";;;;AAEA,SAASA,QAAQ,QAAQ,gBAAe;;AAkBjC,MAAMC,qBAAqB,CAACC,SAAqB,CAAC,CAAC;IACxD,MAAMC,YAAiC,CAAC;IACxC,MAAMC,QAAQF;IAEdG,OAAOC,IAAI,CAACF,OAAOG,OAAO,CAAC,CAACC;QAC1B,IAAIJ,KAAK,CAACI,WAAW,KAAK,WAAWJ,KAAK,CAACI,WAAW,KAAK,OAAO;YAChEL,SAAS,CAACK,WAAW,GAAG;QAC1B,OAAO;YACLL,SAAS,CAACK,WAAW,GAAG;gBACtBC,OAAOL,KAAK,CAACI,WAAW,CAACC,KAAK,KAAK;gBACnCC,WAAOV,sKAAAA,EAASI,KAAK,CAACI,WAAW,EAAEE,SAASC,OAAOP,KAAK,CAACI,WAAW,CAACE,KAAK,IAAIE;gBAC9EC,UAAMb,sKAAAA,EAASI,KAAK,CAACI,WAAW,EAAEK,QAAQF,OAAOP,KAAK,CAACI,WAAW,CAACK,IAAI,IAAID;gBAC3EE,MAAMV,KAAK,CAACI,WAAW,EAAEM,OAAOV,KAAK,CAACI,WAAW,CAACM,IAAI,GAAGF;gBACzDG,OAAOX,KAAK,CAACI,WAAW,EAAEO,QAAQX,KAAK,CAACI,WAAW,CAACO,KAAK,GAAGH;YAC9D;QACF;IACF;IAEA,OAAOT;AACT,EAAC"}},
    {"offset": {"line": 2094, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/utilities/sanitizeSelectParam.ts"],"sourcesContent":["import type { SelectType } from '../types/index.js'\n\n/**\n * Sanitizes REST select query to SelectType\n */\nexport const sanitizeSelectParam = (unsanitizedSelect: unknown): SelectType | undefined => {\n  if (unsanitizedSelect && typeof unsanitizedSelect === 'object') {\n    for (const _k in unsanitizedSelect) {\n      const k = _k as keyof typeof unsanitizedSelect\n      if (unsanitizedSelect[k] === 'true') {\n        ;(unsanitizedSelect as Record<string, any>)[k] = true\n      } else if (unsanitizedSelect[k] === 'false') {\n        ;(unsanitizedSelect as Record<string, any>)[k] = false\n      } else if (typeof unsanitizedSelect[k] === 'object') {\n        sanitizeSelectParam(unsanitizedSelect[k])\n      }\n    }\n  }\n\n  return unsanitizedSelect as SelectType\n}\n"],"names":["sanitizeSelectParam","unsanitizedSelect","_k","k"],"mappings":"AAEA;;CAEC,GACD;;;;AAAO,MAAMA,sBAAsB,CAACC;IAClC,IAAIA,qBAAqB,OAAOA,sBAAsB,UAAU;QAC9D,IAAK,MAAMC,MAAMD,kBAAmB;YAClC,MAAME,IAAID;YACV,IAAID,iBAAiB,CAACE,EAAE,KAAK,QAAQ;;gBACjCF,iBAAyC,CAACE,EAAE,GAAG;YACnD,OAAO,IAAIF,iBAAiB,CAACE,EAAE,KAAK,SAAS;;gBACzCF,iBAAyC,CAACE,EAAE,GAAG;YACnD,OAAO,IAAI,OAAOF,iBAAiB,CAACE,EAAE,KAAK,UAAU;gBACnDH,oBAAoBC,iBAAiB,CAACE,EAAE;YAC1C;QACF;IACF;IAEA,OAAOF;AACT,EAAC"}},
    {"offset": {"line": 2121, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/utilities/sanitizePopulateParam.ts"],"sourcesContent":["import type { PopulateType } from '../types/index.js'\n\nimport { sanitizeSelectParam } from './sanitizeSelectParam.js'\n\n/**\n * Sanitizes REST populate query to PopulateType\n */\nexport const sanitizePopulateParam = (unsanitizedPopulate: unknown): PopulateType | undefined => {\n  if (!unsanitizedPopulate || typeof unsanitizedPopulate !== 'object') {\n    return\n  }\n\n  for (const k in unsanitizedPopulate) {\n    ;(unsanitizedPopulate as Record<string, any>)[k] = sanitizeSelectParam(\n      unsanitizedPopulate[k as keyof typeof unsanitizedPopulate],\n    )\n  }\n\n  return unsanitizedPopulate as PopulateType\n}\n"],"names":["sanitizeSelectParam","sanitizePopulateParam","unsanitizedPopulate","k"],"mappings":";;;;AAEA,SAASA,mBAAmB,QAAQ,2BAA0B;;AAKvD,MAAMC,wBAAwB,CAACC;IACpC,IAAI,CAACA,uBAAuB,OAAOA,wBAAwB,UAAU;QACnE;IACF;IAEA,IAAK,MAAMC,KAAKD,oBAAqB;;QACjCA,mBAA2C,CAACC,EAAE,OAAGH,4LAAAA,EACjDE,mBAAmB,CAACC,EAAsC;IAE9D;IAEA,OAAOD;AACT,EAAC"}},
    {"offset": {"line": 2141, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/utilities/parseCookies.ts"],"sourcesContent":["export const parseCookies = (headers: Request['headers']): Map<string, string> => {\n  const list = new Map<string, string>()\n  const rc = headers.get('Cookie')\n\n  if (rc) {\n    rc.split(';').forEach((cookie) => {\n      const parts = cookie.split('=')\n      const key = parts.shift()?.trim()\n      const encodedValue = parts.join('=')\n\n      try {\n        const decodedValue = decodeURI(encodedValue)\n        list.set(key!, decodedValue)\n      } catch {\n        // ignore invalid encoded values\n      }\n    })\n  }\n\n  return list\n}\n"],"names":["parseCookies","headers","list","Map","rc","get","split","forEach","cookie","parts","key","shift","trim","encodedValue","join","decodedValue","decodeURI","set"],"mappings":";;;;AAAO,MAAMA,eAAe,CAACC;IAC3B,MAAMC,OAAO,IAAIC;IACjB,MAAMC,KAAKH,QAAQI,GAAG,CAAC;IAEvB,IAAID,IAAI;QACNA,GAAGE,KAAK,CAAC,KAAKC,OAAO,CAAC,CAACC;YACrB,MAAMC,QAAQD,OAAOF,KAAK,CAAC;YAC3B,MAAMI,MAAMD,MAAME,KAAK,IAAIC;YAC3B,MAAMC,eAAeJ,MAAMK,IAAI,CAAC;YAEhC,IAAI;gBACF,MAAMC,eAAeC,UAAUH;gBAC/BX,KAAKe,GAAG,CAACP,KAAMK;YACjB,EAAE,OAAM;YACN,gCAAgC;YAClC;QACF;IACF;IAEA,OAAOb;AACT,EAAC"}},
    {"offset": {"line": 2167, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/utilities/flattenAllFields.ts"],"sourcesContent":["import type {\n  Block,\n  Field,\n  FlattenedBlock,\n  FlattenedBlocksField,\n  FlattenedField,\n  FlattenedJoinField,\n} from '../fields/config/types.js'\n\nimport { fieldAffectsData, tabHasName } from '../fields/config/types.js'\n\nexport const flattenBlock = ({ block }: { block: Block }): FlattenedBlock => {\n  return {\n    ...block,\n    flattenedFields: flattenAllFields({ fields: block.fields }),\n  }\n}\n\nconst flattenedFieldsCache = new Map<Field[], FlattenedField[]>()\n\n/**\n * Flattens all fields in a collection, preserving the nested field structure.\n * @param cache\n * @param fields\n */\nexport const flattenAllFields = ({\n  cache,\n  fields,\n}: {\n  /** Allows you to get FlattenedField[] from Field[] anywhere without performance overhead by caching. */\n  cache?: boolean\n  fields: Field[]\n}): FlattenedField[] => {\n  if (cache) {\n    const maybeFields = flattenedFieldsCache.get(fields)\n    if (maybeFields) {\n      return maybeFields\n    }\n  }\n\n  const result: FlattenedField[] = []\n\n  for (const field of fields) {\n    switch (field.type) {\n      case 'array':\n      case 'group': {\n        if (fieldAffectsData(field)) {\n          result.push({ ...field, flattenedFields: flattenAllFields({ fields: field.fields }) })\n        } else {\n          for (const nestedField of flattenAllFields({ fields: field.fields })) {\n            result.push(nestedField)\n          }\n        }\n        break\n      }\n\n      case 'blocks': {\n        const blocks: FlattenedBlock[] = []\n        let blockReferences: (FlattenedBlock | string)[] | undefined = undefined\n        if (field.blockReferences) {\n          blockReferences = []\n          for (const block of field.blockReferences) {\n            if (typeof block === 'string') {\n              blockReferences.push(block)\n              continue\n            }\n            blockReferences.push(flattenBlock({ block }))\n          }\n        } else {\n          for (const block of field.blocks) {\n            if (typeof block === 'string') {\n              blocks.push(block)\n              continue\n            }\n            blocks.push(flattenBlock({ block }))\n          }\n        }\n\n        const resultField: FlattenedBlocksField = {\n          ...field,\n          blockReferences,\n          blocks,\n        }\n\n        result.push(resultField)\n        break\n      }\n\n      case 'collapsible':\n      case 'row': {\n        for (const nestedField of flattenAllFields({ fields: field.fields })) {\n          result.push(nestedField)\n        }\n        break\n      }\n\n      case 'join': {\n        result.push(field as FlattenedJoinField)\n        break\n      }\n\n      case 'tabs': {\n        for (const tab of field.tabs) {\n          if (!tabHasName(tab)) {\n            for (const nestedField of flattenAllFields({ fields: tab.fields })) {\n              result.push(nestedField)\n            }\n          } else {\n            result.push({\n              ...tab,\n              type: 'tab',\n              flattenedFields: flattenAllFields({ fields: tab.fields }),\n            })\n          }\n        }\n        break\n      }\n\n      default: {\n        if (field.type !== 'ui') {\n          result.push(field)\n        }\n      }\n    }\n  }\n\n  flattenedFieldsCache.set(fields, result)\n\n  return result\n}\n"],"names":["fieldAffectsData","tabHasName","flattenBlock","block","flattenedFields","flattenAllFields","fields","flattenedFieldsCache","Map","cache","maybeFields","get","result","field","type","push","nestedField","blocks","blockReferences","undefined","resultField","tab","tabs","set"],"mappings":";;;;;;AASA,SAASA,gBAAgB,EAAEC,UAAU,QAAQ,4BAA2B;;AAEjE,MAAMC,eAAe,CAAC,EAAEC,KAAK,EAAoB;IACtD,OAAO;QACL,GAAGA,KAAK;QACRC,iBAAiBC,iBAAiB;YAAEC,QAAQH,MAAMG,MAAM;QAAC;IAC3D;AACF,EAAC;AAED,MAAMC,uBAAuB,IAAIC;AAO1B,MAAMH,mBAAmB,CAAC,EAC/BI,KAAK,EACLH,MAAM,EAKP;IACC,IAAIG,OAAO;QACT,MAAMC,cAAcH,qBAAqBI,GAAG,CAACL;QAC7C,IAAII,aAAa;YACf,OAAOA;QACT;IACF;IAEA,MAAME,SAA2B,EAAE;IAEnC,KAAK,MAAMC,SAASP,OAAQ;QAC1B,OAAQO,MAAMC,IAAI;YAChB,KAAK;YACL,KAAK;gBAAS;oBACZ,QAAId,kLAAAA,EAAiBa,QAAQ;wBAC3BD,OAAOG,IAAI,CAAC;4BAAE,GAAGF,KAAK;4BAAET,iBAAiBC,iBAAiB;gCAAEC,QAAQO,MAAMP,MAAM;4BAAC;wBAAG;oBACtF,OAAO;wBACL,KAAK,MAAMU,eAAeX,iBAAiB;4BAAEC,QAAQO,MAAMP,MAAM;wBAAC,GAAI;4BACpEM,OAAOG,IAAI,CAACC;wBACd;oBACF;oBACA;gBACF;YAEA,KAAK;gBAAU;oBACb,MAAMC,SAA2B,EAAE;oBACnC,IAAIC,kBAA2DC;oBAC/D,IAAIN,MAAMK,eAAe,EAAE;wBACzBA,kBAAkB,EAAE;wBACpB,KAAK,MAAMf,SAASU,MAAMK,eAAe,CAAE;4BACzC,IAAI,OAAOf,UAAU,UAAU;gCAC7Be,gBAAgBH,IAAI,CAACZ;gCACrB;4BACF;4BACAe,gBAAgBH,IAAI,CAACb,aAAa;gCAAEC;4BAAM;wBAC5C;oBACF,OAAO;wBACL,KAAK,MAAMA,SAASU,MAAMI,MAAM,CAAE;4BAChC,IAAI,OAAOd,UAAU,UAAU;gCAC7Bc,OAAOF,IAAI,CAACZ;gCACZ;4BACF;4BACAc,OAAOF,IAAI,CAACb,aAAa;gCAAEC;4BAAM;wBACnC;oBACF;oBAEA,MAAMiB,cAAoC;wBACxC,GAAGP,KAAK;wBACRK;wBACAD;oBACF;oBAEAL,OAAOG,IAAI,CAACK;oBACZ;gBACF;YAEA,KAAK;YACL,KAAK;gBAAO;oBACV,KAAK,MAAMJ,eAAeX,iBAAiB;wBAAEC,QAAQO,MAAMP,MAAM;oBAAC,GAAI;wBACpEM,OAAOG,IAAI,CAACC;oBACd;oBACA;gBACF;YAEA,KAAK;gBAAQ;oBACXJ,OAAOG,IAAI,CAACF;oBACZ;gBACF;YAEA,KAAK;gBAAQ;oBACX,KAAK,MAAMQ,OAAOR,MAAMS,IAAI,CAAE;wBAC5B,IAAI,KAACrB,4KAAAA,EAAWoB,MAAM;4BACpB,KAAK,MAAML,eAAeX,iBAAiB;gCAAEC,QAAQe,IAAIf,MAAM;4BAAC,GAAI;gCAClEM,OAAOG,IAAI,CAACC;4BACd;wBACF,OAAO;4BACLJ,OAAOG,IAAI,CAAC;gCACV,GAAGM,GAAG;gCACNP,MAAM;gCACNV,iBAAiBC,iBAAiB;oCAAEC,QAAQe,IAAIf,MAAM;gCAAC;4BACzD;wBACF;oBACF;oBACA;gBACF;YAEA;gBAAS;oBACP,IAAIO,MAAMC,IAAI,KAAK,MAAM;wBACvBF,OAAOG,IAAI,CAACF;oBACd;gBACF;QACF;IACF;IAEAN,qBAAqBgB,GAAG,CAACjB,QAAQM;IAEjC,OAAOA;AACT,EAAC"}},
    {"offset": {"line": 2298, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/utilities/formatLabels.ts"],"sourcesContent":["import pluralize from 'pluralize'\nconst { isPlural, singular } = pluralize\n\nconst capitalizeFirstLetter = (string: string): string =>\n  string.charAt(0).toUpperCase() + string.slice(1)\n\nconst toWords = (inputString: string, joinWords = false): string => {\n  const notNullString = inputString || ''\n  const trimmedString = notNullString.trim()\n  const arrayOfStrings = trimmedString.split(/[\\s-]/)\n\n  const splitStringsArray: string[] = []\n  arrayOfStrings.forEach((tempString) => {\n    if (tempString !== '') {\n      const splitWords = tempString.split(/(?=[A-Z])/).join(' ')\n      splitStringsArray.push(capitalizeFirstLetter(splitWords))\n    }\n  })\n\n  return joinWords ? splitStringsArray.join('').replace(/\\s/g, '') : splitStringsArray.join(' ')\n}\n\nconst formatLabels = (slug: string): { plural: string; singular: string } => {\n  const words = toWords(slug)\n\n  return isPlural(slug)\n    ? {\n        plural: words,\n        singular: singular(words),\n      }\n    : {\n        plural: pluralize(words),\n        singular: words,\n      }\n}\n\nconst formatNames = (slug: string): { plural: string; singular: string } => {\n  const words = toWords(slug, true)\n  return isPlural(slug)\n    ? {\n        plural: words,\n        singular: singular(words),\n      }\n    : {\n        plural: pluralize(words),\n        singular: words,\n      }\n}\n\nexport { formatLabels, formatNames, toWords }\n"],"names":["pluralize","isPlural","singular","capitalizeFirstLetter","string","charAt","toUpperCase","slice","toWords","inputString","joinWords","notNullString","trimmedString","trim","arrayOfStrings","split","splitStringsArray","forEach","tempString","splitWords","join","push","replace","formatLabels","slug","words","plural","formatNames"],"mappings":";;;;;;;;AAAA,OAAOA,eAAe,YAAW;;AACjC,MAAM,EAAEC,QAAQ,EAAEC,QAAQ,EAAE,GAAGF,mJAAAA;AAE/B,MAAMG,wBAAwB,CAACC,SAC7BA,OAAOC,MAAM,CAAC,GAAGC,WAAW,KAAKF,OAAOG,KAAK,CAAC;AAEhD,MAAMC,UAAU,CAACC,aAAqBC,YAAY,KAAK;IACrD,MAAMC,gBAAgBF,eAAe;IACrC,MAAMG,gBAAgBD,cAAcE,IAAI;IACxC,MAAMC,iBAAiBF,cAAcG,KAAK,CAAC;IAE3C,MAAMC,oBAA8B,EAAE;IACtCF,eAAeG,OAAO,CAAC,CAACC;QACtB,IAAIA,eAAe,IAAI;YACrB,MAAMC,aAAaD,WAAWH,KAAK,CAAC,aAAaK,IAAI,CAAC;YACtDJ,kBAAkBK,IAAI,CAAClB,sBAAsBgB;QAC/C;IACF;IAEA,OAAOT,YAAYM,kBAAkBI,IAAI,CAAC,IAAIE,OAAO,CAAC,OAAO,MAAMN,kBAAkBI,IAAI,CAAC;AAC5F;AAEA,MAAMG,eAAe,CAACC;IACpB,MAAMC,QAAQjB,QAAQgB;IAEtB,OAAOvB,SAASuB,QACZ;QACEE,QAAQD;QACRvB,UAAUA,SAASuB;IACrB,IACA;QACEC,YAAQ1B,mJAAAA,EAAUyB;QAClBvB,UAAUuB;IACZ;AACN;AAEA,MAAME,cAAc,CAACH;IACnB,MAAMC,QAAQjB,QAAQgB,MAAM;IAC5B,OAAOvB,SAASuB,QACZ;QACEE,QAAQD;QACRvB,UAAUA,SAASuB;IACrB,IACA;QACEC,YAAQ1B,mJAAAA,EAAUyB;QAClBvB,UAAUuB;IACZ;AACN"}},
    {"offset": {"line": 2349, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/utilities/validateTimezones.ts"],"sourcesContent":["import type { Timezone } from '../config/types.js'\n\nimport { InvalidConfiguration } from '../errors/index.js'\n\ntype ValidateTimezonesArgs = {\n  /**\n   * The source of the timezones for error messaging\n   */\n  source?: string\n  /**\n   * Array of timezones to validate\n   */\n  timezones: Timezone[] | undefined\n}\n\n/**\n * Validates a UTC offset string.\n * Only supports the HH:mm format (e.g., +05:30, -08:00).\n *\n * Valid ranges: hours -12 to +14, minutes 0-59\n *\n * @returns true if the offset is valid\n */\nconst isValidUtcOffset = (value: string): boolean => {\n  // Strict format check: only HH:mm\n  const match = value.match(/^([+-])(\\d{2}):(\\d{2})$/)\n  if (!match) {\n    return false\n  }\n\n  const sign = match[1] === '+' ? 1 : -1\n  const hours = parseInt(match[2]!, 10)\n  const minutes = parseInt(match[3]!, 10)\n\n  // Minutes must be 0-59\n  if (minutes > 59) {\n    return false\n  }\n\n  // Valid range: -12:00 (-720 min) to +14:00 (+840 min)\n  const totalMinutes = sign * (hours * 60 + minutes)\n  return totalMinutes >= -720 && totalMinutes <= 840\n}\n\n/**\n * Checks if a timezone is supported by the current runtime.\n * Supports both IANA timezone names and UTC offset formats.\n *\n * For IANA names: Uses Intl.DateTimeFormat and Intl.supportedValuesOf\n * For UTC offsets: Uses native Date API to validate (HH:mm format only)\n */\nconst isTimezoneSupported = (timezoneValue: string): boolean => {\n  // UTC is always supported\n  if (timezoneValue === 'UTC') {\n    return true\n  }\n\n  // Check if it's a UTC offset format (starts with + or -)\n  if (timezoneValue.startsWith('+') || timezoneValue.startsWith('-')) {\n    return isValidUtcOffset(timezoneValue)\n  }\n\n  // For IANA timezone names, use Intl.DateTimeFormat as primary check\n  try {\n    new Intl.DateTimeFormat('en-US', { timeZone: timezoneValue })\n    return true\n  } catch {\n    // DateTimeFormat failed, timezone is not supported\n  }\n\n  // Secondary check: verify against supportedValuesOf if available\n  if (typeof Intl.supportedValuesOf === 'function') {\n    const supportedTimezones = Intl.supportedValuesOf('timeZone')\n    if (supportedTimezones.includes(timezoneValue)) {\n      return true\n    }\n  }\n\n  return false\n}\n\n/**\n * Validates that all provided timezones are supported by the current runtime's Intl API.\n * Uses both Intl.DateTimeFormat and Intl.supportedValuesOf for comprehensive validation.\n *\n * @throws InvalidConfiguration if an unsupported timezone is found\n */\nexport const validateTimezones = ({ source, timezones }: ValidateTimezonesArgs): void => {\n  if (!timezones?.length) {\n    return\n  }\n\n  for (const timezone of timezones) {\n    if (!isTimezoneSupported(timezone.value)) {\n      const sourceText = source ? ` in ${source}` : ''\n      throw new InvalidConfiguration(\n        `Timezone ${timezone.value}${sourceText} is not supported by the current runtime via the Intl API.`,\n      )\n    }\n  }\n}\n"],"names":["InvalidConfiguration","isValidUtcOffset","value","match","sign","hours","parseInt","minutes","totalMinutes","isTimezoneSupported","timezoneValue","startsWith","Intl","DateTimeFormat","timeZone","supportedValuesOf","supportedTimezones","includes","validateTimezones","source","timezones","length","timezone","sourceText"],"mappings":";;;;AAEA,SAASA,oBAAoB,QAAQ,qBAAoB;;AAazD;;;;;;;CAOC,GACD,MAAMC,mBAAmB,CAACC;IACxB,mCAAmC;IACnC,MAAMC,QAAQD,MAAMC,KAAK,CAAC;IAC1B,IAAI,CAACA,OAAO;QACV,OAAO;IACT;IAEA,MAAMC,OAAOD,KAAK,CAAC,EAAE,KAAK,MAAM,IAAI,CAAC;IACrC,MAAME,QAAQC,SAASH,KAAK,CAAC,EAAE,EAAG;IAClC,MAAMI,UAAUD,SAASH,KAAK,CAAC,EAAE,EAAG;IAEpC,uBAAuB;IACvB,IAAII,UAAU,IAAI;QAChB,OAAO;IACT;IAEA,sDAAsD;IACtD,MAAMC,eAAeJ,OAAQC,CAAAA,QAAQ,KAAKE,OAAM;IAChD,OAAOC,gBAAgB,CAAC,OAAOA,gBAAgB;AACjD;AAEA;;;;;;CAMC,GACD,MAAMC,sBAAsB,CAACC;IAC3B,0BAA0B;IAC1B,IAAIA,kBAAkB,OAAO;QAC3B,OAAO;IACT;IAEA,yDAAyD;IACzD,IAAIA,cAAcC,UAAU,CAAC,QAAQD,cAAcC,UAAU,CAAC,MAAM;QAClE,OAAOV,iBAAiBS;IAC1B;IAEA,oEAAoE;IACpE,IAAI;QACF,IAAIE,KAAKC,cAAc,CAAC,SAAS;YAAEC,UAAUJ;QAAc;QAC3D,OAAO;IACT,EAAE,OAAM;IACN,mDAAmD;IACrD;IAEA,iEAAiE;IACjE,IAAI,OAAOE,KAAKG,iBAAiB,KAAK,YAAY;QAChD,MAAMC,qBAAqBJ,KAAKG,iBAAiB,CAAC;QAClD,IAAIC,mBAAmBC,QAAQ,CAACP,gBAAgB;YAC9C,OAAO;QACT;IACF;IAEA,OAAO;AACT;AAQO,MAAMQ,oBAAoB,CAAC,EAAEC,MAAM,EAAEC,SAAS,EAAyB;IAC5E,IAAI,CAACA,WAAWC,QAAQ;QACtB;IACF;IAEA,KAAK,MAAMC,YAAYF,UAAW;QAChC,IAAI,CAACX,oBAAoBa,SAASpB,KAAK,GAAG;YACxC,MAAMqB,aAAaJ,SAAS,CAAC,IAAI,EAAEA,QAAQ,GAAG;YAC9C,MAAM,IAAInB,2LAAAA,CACR,CAAC,SAAS,EAAEsB,SAASpB,KAAK,GAAGqB,WAAW,0DAA0D,CAAC;QAEvG;IACF;AACF,EAAC"}},
    {"offset": {"line": 2427, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/utilities/getFieldByPath.ts"],"sourcesContent":["import type { SanitizedConfig } from '../config/types.js'\nimport type { FlattenedField } from '../fields/config/types.js'\n\n/**\n * Get the field by its schema path, e.g. group.title, array.group.title\n * If there were any localized on the path, `pathHasLocalized` will be true and `localizedPath` will look like:\n * `group.<locale>.title` // group is localized here\n */\nexport const getFieldByPath = ({\n  config,\n  fields,\n  includeRelationships = false,\n  localizedPath = '',\n  path,\n}: {\n  config?: SanitizedConfig\n  fields: FlattenedField[]\n  includeRelationships?: boolean\n  localizedPath?: string\n  /**\n   * The schema path, e.g. `array.group.title`\n   */\n  path: string\n}): {\n  field: FlattenedField\n  localizedPath: string\n  pathHasLocalized: boolean\n} | null => {\n  let currentFields: FlattenedField[] = fields\n\n  let currentField: FlattenedField | null = null\n\n  const segments = path.split('.')\n\n  let pathHasLocalized = false\n\n  while (segments.length > 0) {\n    const segment = segments.shift()\n\n    localizedPath = `${localizedPath ? `${localizedPath}.` : ''}${segment}`\n    const field = currentFields.find((each) => each.name === segment)\n\n    if (!field) {\n      return null\n    }\n\n    if (field.localized) {\n      pathHasLocalized = true\n      localizedPath = `${localizedPath}.<locale>`\n    }\n\n    if ('flattenedFields' in field) {\n      currentFields = field.flattenedFields\n    }\n\n    if (\n      config &&\n      includeRelationships &&\n      (field.type === 'relationship' || field.type === 'upload') &&\n      !Array.isArray(field.relationTo)\n    ) {\n      const flattenedFields = config.collections.find(\n        (e) => e.slug === field.relationTo,\n      )?.flattenedFields\n      if (flattenedFields) {\n        currentFields = flattenedFields\n      }\n\n      if (segments.length === 1 && segments[0] === 'id') {\n        return { field, localizedPath, pathHasLocalized }\n      }\n    }\n\n    if ('blocks' in field && segments.length > 0) {\n      const blockSlug = segments[0]\n      const block = field.blocks.find((b) => b.slug === blockSlug)\n\n      if (block) {\n        segments.shift()\n        localizedPath = `${localizedPath}.${blockSlug}`\n\n        if (segments.length === 0) {\n          return null\n        }\n\n        return getFieldByPath({\n          config,\n          fields: block.flattenedFields,\n          includeRelationships,\n          localizedPath,\n          path: segments.join('.'),\n        })\n      }\n    }\n\n    currentField = field\n  }\n\n  if (!currentField) {\n    return null\n  }\n\n  return { field: currentField, localizedPath, pathHasLocalized }\n}\n"],"names":["getFieldByPath","config","fields","includeRelationships","localizedPath","path","currentFields","currentField","segments","split","pathHasLocalized","length","segment","shift","field","find","each","name","localized","flattenedFields","type","Array","isArray","relationTo","collections","e","slug","blockSlug","block","blocks","b","join"],"mappings":"AAGA;;;;CAIC,GACD;;;;AAAO,MAAMA,iBAAiB,CAAC,EAC7BC,MAAM,EACNC,MAAM,EACNC,uBAAuB,KAAK,EAC5BC,gBAAgB,EAAE,EAClBC,IAAI,EAUL;IAKC,IAAIC,gBAAkCJ;IAEtC,IAAIK,eAAsC;IAE1C,MAAMC,WAAWH,KAAKI,KAAK,CAAC;IAE5B,IAAIC,mBAAmB;IAEvB,MAAOF,SAASG,MAAM,GAAG,EAAG;QAC1B,MAAMC,UAAUJ,SAASK,KAAK;QAE9BT,gBAAgB,GAAGA,gBAAgB,GAAGA,cAAc,CAAC,CAAC,GAAG,KAAKQ,SAAS;QACvE,MAAME,QAAQR,cAAcS,IAAI,CAAC,CAACC,OAASA,KAAKC,IAAI,KAAKL;QAEzD,IAAI,CAACE,OAAO;YACV,OAAO;QACT;QAEA,IAAIA,MAAMI,SAAS,EAAE;YACnBR,mBAAmB;YACnBN,gBAAgB,GAAGA,cAAc,SAAS,CAAC;QAC7C;QAEA,IAAI,qBAAqBU,OAAO;YAC9BR,gBAAgBQ,MAAMK,eAAe;QACvC;QAEA,IACElB,UACAE,wBACCW,CAAAA,MAAMM,IAAI,KAAK,kBAAkBN,MAAMM,IAAI,KAAK,QAAO,KACxD,CAACC,MAAMC,OAAO,CAACR,MAAMS,UAAU,GAC/B;YACA,MAAMJ,kBAAkBlB,OAAOuB,WAAW,CAACT,IAAI,CAC7C,CAACU,IAAMA,EAAEC,IAAI,KAAKZ,MAAMS,UAAU,GACjCJ;YACH,IAAIA,iBAAiB;gBACnBb,gBAAgBa;YAClB;YAEA,IAAIX,SAASG,MAAM,KAAK,KAAKH,QAAQ,CAAC,EAAE,KAAK,MAAM;gBACjD,OAAO;oBAAEM;oBAAOV;oBAAeM;gBAAiB;YAClD;QACF;QAEA,IAAI,YAAYI,SAASN,SAASG,MAAM,GAAG,GAAG;YAC5C,MAAMgB,YAAYnB,QAAQ,CAAC,EAAE;YAC7B,MAAMoB,QAAQd,MAAMe,MAAM,CAACd,IAAI,CAAC,CAACe,IAAMA,EAAEJ,IAAI,KAAKC;YAElD,IAAIC,OAAO;gBACTpB,SAASK,KAAK;gBACdT,gBAAgB,GAAGA,cAAc,CAAC,EAAEuB,WAAW;gBAE/C,IAAInB,SAASG,MAAM,KAAK,GAAG;oBACzB,OAAO;gBACT;gBAEA,OAAOX,eAAe;oBACpBC;oBACAC,QAAQ0B,MAAMT,eAAe;oBAC7BhB;oBACAC;oBACAC,MAAMG,SAASuB,IAAI,CAAC;gBACtB;YACF;QACF;QAEAxB,eAAeO;IACjB;IAEA,IAAI,CAACP,cAAc;QACjB,OAAO;IACT;IAEA,OAAO;QAAEO,OAAOP;QAAcH;QAAeM;IAAiB;AAChE,EAAC"}},
    {"offset": {"line": 2500, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/utilities/isReactComponent.ts"],"sourcesContent":["import type React from 'react'\n\nconst clientRefSymbol = Symbol.for('react.client.reference')\n\nexport function isReactServerComponentOrFunction<T extends any>(\n  component: any | React.ComponentType,\n): component is T {\n  return typeof component === 'function' && component.$$typeof !== clientRefSymbol\n}\n\nexport function isReactClientComponent<T extends any>(\n  component: any | React.ComponentType,\n): component is T {\n  return typeof component === 'function' && component.$$typeof === clientRefSymbol\n}\n\nexport function isReactComponentOrFunction<T extends any>(\n  component: any | React.ComponentType,\n): component is T {\n  return typeof component === 'function'\n}\n"],"names":["clientRefSymbol","Symbol","for","isReactServerComponentOrFunction","component","$$typeof","isReactClientComponent","isReactComponentOrFunction"],"mappings":";;;;;;;;AAEA,MAAMA,kBAAkBC,OAAOC,GAAG,CAAC;AAE5B,SAASC,iCACdC,SAAoC;IAEpC,OAAO,OAAOA,cAAc,cAAcA,UAAUC,QAAQ,KAAKL;AACnE;AAEO,SAASM,uBACdF,SAAoC;IAEpC,OAAO,OAAOA,cAAc,cAAcA,UAAUC,QAAQ,KAAKL;AACnE;AAEO,SAASO,2BACdH,SAAoC;IAEpC,OAAO,OAAOA,cAAc;AAC9B"}},
    {"offset": {"line": 2522, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/utilities/isPlainObject.ts"],"sourcesContent":["import { isReactComponentOrFunction } from './isReactComponent.js'\n\nexport function isPlainObject(o: any): boolean {\n  // Is this a React component?\n  if (isReactComponentOrFunction(o)) {\n    return false\n  }\n\n  // from https://github.com/fastify/deepmerge/blob/master/index.js#L77\n  return typeof o === 'object' && o !== null && !(o instanceof RegExp) && !(o instanceof Date)\n}\n"],"names":["isReactComponentOrFunction","isPlainObject","o","RegExp","Date"],"mappings":";;;;AAAA,SAASA,0BAA0B,QAAQ,wBAAuB;;AAE3D,SAASC,cAAcC,CAAM;IAClC,6BAA6B;IAC7B,QAAIF,gMAAAA,EAA2BE,IAAI;QACjC,OAAO;IACT;IAEA,qEAAqE;IACrE,OAAO,OAAOA,MAAM,YAAYA,MAAM,QAAQ,CAAEA,CAAAA,aAAaC,MAAK,KAAM,CAAED,CAAAA,aAAaE,IAAG;AAC5F"}},
    {"offset": {"line": 2540, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/utilities/deepMerge.ts"],"sourcesContent":["import deepMerge from 'deepmerge'\n\nimport { isPlainObject } from './isPlainObject.js'\n\nexport { deepMerge }\n/**\n * Fully-featured deepMerge.\n *\n * Array handling: Arrays in the target object are combined with the source object's arrays.\n */\nexport function deepMergeWithCombinedArrays<T extends object>(\n  obj1: object,\n  obj2: object,\n  options: deepMerge.Options = {},\n): T {\n  return deepMerge<T>(obj1, obj2, {\n    arrayMerge: (target, source, options) => {\n      const destination = target.slice()\n\n      source.forEach((item, index) => {\n        if (typeof destination[index] === 'undefined') {\n          destination[index] = options?.cloneUnlessOtherwiseSpecified(item, options)\n        } else if (options?.isMergeableObject(item)) {\n          destination[index] = deepMerge(target[index], item, options)\n        } else if (target.indexOf(item) === -1) {\n          destination.push(item)\n        }\n      })\n      return destination\n    },\n    ...options,\n  })\n}\n\n/**\n * Fully-featured deepMerge.\n *\n * Array handling: Arrays in the target object are replaced by the source object's arrays.\n */\nexport function deepMergeWithSourceArrays<T extends object>(obj1: object, obj2: object): T {\n  return deepMerge<T>(obj1, obj2, { arrayMerge: (_, source) => source })\n}\n\n/**\n * Fully-featured deepMerge. Does not clone React components by default.\n */\nexport function deepMergeWithReactComponents<T extends object>(obj1: object, obj2: object): T {\n  return deepMerge<T>(obj1, obj2, {\n    isMergeableObject: isPlainObject,\n  })\n}\n"],"names":["deepMerge","isPlainObject","deepMergeWithCombinedArrays","obj1","obj2","options","arrayMerge","target","source","destination","slice","forEach","item","index","cloneUnlessOtherwiseSpecified","isMergeableObject","indexOf","push","deepMergeWithSourceArrays","_","deepMergeWithReactComponents"],"mappings":";;;;;;;;AAAA,OAAOA,eAAe,YAAW;AAEjC,SAASC,aAAa,QAAQ,qBAAoB;;;;AAQ3C,SAASC,4BACdC,IAAY,EACZC,IAAY,EACZC,UAA6B,CAAC,CAAC;IAE/B,WAAOL,qJAAAA,EAAaG,MAAMC,MAAM;QAC9BE,YAAY,CAACC,QAAQC,QAAQH;YAC3B,MAAMI,cAAcF,OAAOG,KAAK;YAEhCF,OAAOG,OAAO,CAAC,CAACC,MAAMC;gBACpB,IAAI,OAAOJ,WAAW,CAACI,MAAM,KAAK,aAAa;oBAC7CJ,WAAW,CAACI,MAAM,GAAGR,SAASS,8BAA8BF,MAAMP;gBACpE,OAAO,IAAIA,SAASU,kBAAkBH,OAAO;oBAC3CH,WAAW,CAACI,MAAM,OAAGb,qJAAAA,EAAUO,MAAM,CAACM,MAAM,EAAED,MAAMP;gBACtD,OAAO,IAAIE,OAAOS,OAAO,CAACJ,UAAU,CAAC,GAAG;oBACtCH,YAAYQ,IAAI,CAACL;gBACnB;YACF;YACA,OAAOH;QACT;QACA,GAAGJ,OAAO;IACZ;AACF;AAOO,SAASa,0BAA4Cf,IAAY,EAAEC,IAAY;IACpF,WAAOJ,qJAAAA,EAAaG,MAAMC,MAAM;QAAEE,YAAY,CAACa,GAAGX,SAAWA;IAAO;AACtE;AAKO,SAASY,6BAA+CjB,IAAY,EAAEC,IAAY;IACvF,WAAOJ,qJAAAA,EAAaG,MAAMC,MAAM;QAC9BW,mBAAmBd,gLAAAA;IACrB;AACF"}},
    {"offset": {"line": 2585, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/utilities/isURLAllowed.ts"],"sourcesContent":["import type { AllowList } from '../uploads/types.js'\n\nexport const isURLAllowed = (url: string, allowList: AllowList): boolean => {\n  try {\n    const parsedUrl = new URL(url)\n\n    return allowList.some((allowItem) => {\n      return Object.entries(allowItem).every(([key, value]) => {\n        // Skip undefined or null values\n        if (!value) {\n          return true\n        }\n        // Compare protocol with colon\n        if (key === 'protocol') {\n          return typeof value === 'string' && parsedUrl.protocol === `${value}:`\n        }\n\n        if (key === 'pathname') {\n          // Convert wildcards to a regex\n          const regexPattern = value\n            .replace(/\\*\\*/g, '.*') // Match any path\n            .replace(/\\*/g, '[^/]*') // Match any part of a path segment\n            .replace(/\\/$/, '(/)?') // Allow optional trailing slash\n          const regex = new RegExp(`^${regexPattern}$`)\n          return regex.test(parsedUrl.pathname)\n        }\n\n        // Default comparison for all other properties (hostname, port, search)\n        return parsedUrl[key as keyof URL] === value\n      })\n    })\n  } catch {\n    return false // If the URL is invalid, deny by default\n  }\n}\n"],"names":["isURLAllowed","url","allowList","parsedUrl","URL","some","allowItem","Object","entries","every","key","value","protocol","regexPattern","replace","regex","RegExp","test","pathname"],"mappings":";;;;AAEO,MAAMA,eAAe,CAACC,KAAaC;IACxC,IAAI;QACF,MAAMC,YAAY,IAAIC,IAAIH;QAE1B,OAAOC,UAAUG,IAAI,CAAC,CAACC;YACrB,OAAOC,OAAOC,OAAO,CAACF,WAAWG,KAAK,CAAC,CAAC,CAACC,KAAKC,MAAM;gBAClD,gCAAgC;gBAChC,IAAI,CAACA,OAAO;oBACV,OAAO;gBACT;gBACA,8BAA8B;gBAC9B,IAAID,QAAQ,YAAY;oBACtB,OAAO,OAAOC,UAAU,YAAYR,UAAUS,QAAQ,KAAK,GAAGD,MAAM,CAAC,CAAC;gBACxE;gBAEA,IAAID,QAAQ,YAAY;oBACtB,+BAA+B;oBAC/B,MAAMG,eAAeF,MAClBG,OAAO,CAAC,SAAS,MAAM,iBAAiB;qBACxCA,OAAO,CAAC,OAAO,SAAS,mCAAmC;qBAC3DA,OAAO,CAAC,OAAO,QAAQ,gCAAgC;;oBAC1D,MAAMC,QAAQ,IAAIC,OAAO,CAAC,CAAC,EAAEH,aAAa,CAAC,CAAC;oBAC5C,OAAOE,MAAME,IAAI,CAACd,UAAUe,QAAQ;gBACtC;gBAEA,uEAAuE;gBACvE,OAAOf,SAAS,CAACO,IAAiB,KAAKC;YACzC;QACF;IACF,EAAE,OAAM;QACN,OAAO,MAAM,yCAAyC;;IACxD;AACF,EAAC"}},
    {"offset": {"line": 2624, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/utilities/validateMimeType.ts"],"sourcesContent":["export const validateMimeType = (mimeType: string, allowedMimeTypes: string[]): boolean => {\n  if (allowedMimeTypes.length === 0) {\n    return true\n  }\n\n  const cleanedMimeTypes = allowedMimeTypes.map((v) => v.replace('*', ''))\n\n  return cleanedMimeTypes.some((cleanedMimeType) => mimeType.startsWith(cleanedMimeType))\n}\n"],"names":["validateMimeType","mimeType","allowedMimeTypes","length","cleanedMimeTypes","map","v","replace","some","cleanedMimeType","startsWith"],"mappings":";;;;AAAO,MAAMA,mBAAmB,CAACC,UAAkBC;IACjD,IAAIA,iBAAiBC,MAAM,KAAK,GAAG;QACjC,OAAO;IACT;IAEA,MAAMC,mBAAmBF,iBAAiBG,GAAG,CAAC,CAACC,IAAMA,EAAEC,OAAO,CAAC,KAAK;IAEpE,OAAOH,iBAAiBI,IAAI,CAAC,CAACC,kBAAoBR,SAASS,UAAU,CAACD;AACxE,EAAC"}},
    {"offset": {"line": 2639, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/utilities/miniChalk.ts"],"sourcesContent":["const codes = {\n  blue: '\\x1b[34m',\n  bold: '\\x1b[1m',\n  cyan: '\\x1b[36m',\n  dim: '\\x1b[2m',\n  green: '\\x1b[32m',\n  magenta: '\\x1b[35m',\n  red: '\\x1b[31m',\n  reset: '\\x1b[0m',\n  underline: '\\x1b[4m',\n  white: '\\x1b[37m',\n  yellow: '\\x1b[33m',\n}\n\nfunction colorize(str: string, ...styles: (keyof typeof codes)[]) {\n  const start = styles.map((s) => codes[s] || '').join('')\n  return `${start}${str}${codes.reset}`\n}\n\nexport const miniChalk = {\n  blue: (str: string) => colorize(str, 'blue'),\n  bold: (str: string) => colorize(str, 'bold'),\n  cyan: (str: string) => colorize(str, 'cyan'),\n  dim: (str: string) => colorize(str, 'dim'),\n  green: (str: string) => colorize(str, 'green'),\n  magenta: (str: string) => colorize(str, 'magenta'),\n  red: (str: string) => colorize(str, 'red'),\n  underline: (str: string) => colorize(str, 'underline'),\n  white: (str: string) => colorize(str, 'white'),\n  yellow: (str: string) => colorize(str, 'yellow'),\n\n  // combos\n  redBold: (str: string) => colorize(str, 'red', 'bold'),\n  yellowBold: (str: string) => colorize(str, 'yellow', 'bold'),\n}\n"],"names":["codes","blue","bold","cyan","dim","green","magenta","red","reset","underline","white","yellow","colorize","str","styles","start","map","s","join","miniChalk","redBold","yellowBold"],"mappings":";;;;AAAA,MAAMA,QAAQ;IACZC,MAAM;IACNC,MAAM;IACNC,MAAM;IACNC,KAAK;IACLC,OAAO;IACPC,SAAS;IACTC,KAAK;IACLC,OAAO;IACPC,WAAW;IACXC,OAAO;IACPC,QAAQ;AACV;AAEA,SAASC,SAASC,GAAW,EAAE,GAAGC,MAA8B;IAC9D,MAAMC,QAAQD,OAAOE,GAAG,CAAC,CAACC,IAAMjB,KAAK,CAACiB,EAAE,IAAI,IAAIC,IAAI,CAAC;IACrD,OAAO,GAAGH,QAAQF,MAAMb,MAAMQ,KAAK,EAAE;AACvC;AAEO,MAAMW,YAAY;IACvBlB,MAAM,CAACY,MAAgBD,SAASC,KAAK;IACrCX,MAAM,CAACW,MAAgBD,SAASC,KAAK;IACrCV,MAAM,CAACU,MAAgBD,SAASC,KAAK;IACrCT,KAAK,CAACS,MAAgBD,SAASC,KAAK;IACpCR,OAAO,CAACQ,MAAgBD,SAASC,KAAK;IACtCP,SAAS,CAACO,MAAgBD,SAASC,KAAK;IACxCN,KAAK,CAACM,MAAgBD,SAASC,KAAK;IACpCJ,WAAW,CAACI,MAAgBD,SAASC,KAAK;IAC1CH,OAAO,CAACG,MAAgBD,SAASC,KAAK;IACtCF,QAAQ,CAACE,MAAgBD,SAASC,KAAK;IAEvC,SAAS;IACTO,SAAS,CAACP,MAAgBD,SAASC,KAAK,OAAO;IAC/CQ,YAAY,CAACR,MAAgBD,SAASC,KAAK,UAAU;AACvD,EAAC"}},
    {"offset": {"line": 2679, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/utilities/traverseForLocalizedFields.ts"],"sourcesContent":["import type { Field } from '../fields/config/types.js'\n\nexport const traverseForLocalizedFields = (fields: Field[]): boolean => {\n  for (const field of fields) {\n    if ('localized' in field && field.localized) {\n      return true\n    }\n\n    switch (field.type) {\n      case 'array':\n      case 'collapsible':\n      case 'group':\n      case 'row':\n        if (field.fields && traverseForLocalizedFields(field.fields)) {\n          return true\n        }\n        break\n\n      case 'blocks':\n        if (field.blocks) {\n          for (const block of field.blocks) {\n            if (block.fields && traverseForLocalizedFields(block.fields)) {\n              return true\n            }\n          }\n        }\n        break\n\n      case 'tabs':\n        if (field.tabs) {\n          for (const tab of field.tabs) {\n            if ('localized' in tab && tab.localized) {\n              return true\n            }\n            if ('fields' in tab && tab.fields && traverseForLocalizedFields(tab.fields)) {\n              return true\n            }\n          }\n        }\n        break\n    }\n  }\n\n  return false\n}\n"],"names":["traverseForLocalizedFields","fields","field","localized","type","blocks","block","tabs","tab"],"mappings":";;;;AAEO,MAAMA,6BAA6B,CAACC;IACzC,KAAK,MAAMC,SAASD,OAAQ;QAC1B,IAAI,eAAeC,SAASA,MAAMC,SAAS,EAAE;YAC3C,OAAO;QACT;QAEA,OAAQD,MAAME,IAAI;YAChB,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;gBACH,IAAIF,MAAMD,MAAM,IAAID,2BAA2BE,MAAMD,MAAM,GAAG;oBAC5D,OAAO;gBACT;gBACA;YAEF,KAAK;gBACH,IAAIC,MAAMG,MAAM,EAAE;oBAChB,KAAK,MAAMC,SAASJ,MAAMG,MAAM,CAAE;wBAChC,IAAIC,MAAML,MAAM,IAAID,2BAA2BM,MAAML,MAAM,GAAG;4BAC5D,OAAO;wBACT;oBACF;gBACF;gBACA;YAEF,KAAK;gBACH,IAAIC,MAAMK,IAAI,EAAE;oBACd,KAAK,MAAMC,OAAON,MAAMK,IAAI,CAAE;wBAC5B,IAAI,eAAeC,OAAOA,IAAIL,SAAS,EAAE;4BACvC,OAAO;wBACT;wBACA,IAAI,YAAYK,OAAOA,IAAIP,MAAM,IAAID,2BAA2BQ,IAAIP,MAAM,GAAG;4BAC3E,OAAO;wBACT;oBACF;gBACF;gBACA;QACJ;IACF;IAEA,OAAO;AACT,EAAC"}},
    {"offset": {"line": 2726, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/utilities/parseBooleanString.ts"],"sourcesContent":["/**\n * Useful when parsing query parameters where booleans are represented as strings.\n * Falls back to `undefined` to allow default handling elsewhere.\n */\nexport const parseBooleanString = (\n  value: boolean | null | string | undefined,\n): boolean | undefined => {\n  if (typeof value === 'boolean') {\n    return value\n  }\n\n  if (value === 'true') {\n    return true\n  }\n\n  if (value === 'false') {\n    return false\n  }\n\n  return undefined\n}\n"],"names":["parseBooleanString","value","undefined"],"mappings":"AAAA;;;CAGC,GACD;;;;AAAO,MAAMA,qBAAqB,CAChCC;IAEA,IAAI,OAAOA,UAAU,WAAW;QAC9B,OAAOA;IACT;IAEA,IAAIA,UAAU,QAAQ;QACpB,OAAO;IACT;IAEA,IAAIA,UAAU,SAAS;QACrB,OAAO;IACT;IAEA,OAAOC;AACT,EAAC"}},
    {"offset": {"line": 2749, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/utilities/sanitizeSortParams.ts"],"sourcesContent":["export const sanitizeSortParams = (sort: unknown): string[] | undefined => {\n  if (typeof sort === 'string') {\n    return sort.split(',')\n  }\n\n  if (Array.isArray(sort) && sort.every((value) => typeof value === 'string')) {\n    return sort\n  }\n\n  return undefined\n}\n"],"names":["sanitizeSortParams","sort","split","Array","isArray","every","value","undefined"],"mappings":";;;;AAAO,MAAMA,qBAAqB,CAACC;IACjC,IAAI,OAAOA,SAAS,UAAU;QAC5B,OAAOA,KAAKC,KAAK,CAAC;IACpB;IAEA,IAAIC,MAAMC,OAAO,CAACH,SAASA,KAAKI,KAAK,CAAC,CAACC,QAAU,OAAOA,UAAU,WAAW;QAC3E,OAAOL;IACT;IAEA,OAAOM;AACT,EAAC"}},
    {"offset": {"line": 2766, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/utilities/parseParams/index.ts"],"sourcesContent":["import type { JoinQuery, PopulateType, SelectType, Where } from '../../types/index.js'\nimport type { JoinParams } from '../sanitizeJoinParams.js'\n\nimport { isNumber } from '../isNumber.js'\nimport { parseBooleanString } from '../parseBooleanString.js'\nimport { sanitizeJoinParams } from '../sanitizeJoinParams.js'\nimport { sanitizePopulateParam } from '../sanitizePopulateParam.js'\nimport { sanitizeSelectParam } from '../sanitizeSelectParam.js'\nimport { sanitizeSortParams } from '../sanitizeSortParams.js'\n\ntype RawParams = {\n  [key: string]: unknown\n  autosave?: string\n  data?: string\n  depth?: string\n  draft?: string\n  field?: string\n  flattenLocales?: string\n  joins?: JoinParams\n  limit?: string\n  overrideLock?: string\n  page?: string\n  pagination?: string\n  populate?: unknown\n  publishAllLocales?: string\n  publishSpecificLocale?: string\n  select?: unknown\n  selectedLocales?: string\n  sort?: string | string[]\n  trash?: string\n  unpublishAllLocales?: string\n  where?: Where\n}\n\ntype ParsedParams = {\n  autosave?: boolean\n  data?: Record<string, unknown>\n  depth?: number\n  draft?: boolean\n  field?: string\n  flattenLocales?: boolean\n  joins?: JoinQuery\n  limit?: number\n  overrideLock?: boolean\n  page?: number\n  pagination?: boolean\n  populate?: PopulateType\n  publishAllLocales?: boolean\n  publishSpecificLocale?: string\n  select?: SelectType\n  selectedLocales?: string[]\n  sort?: string[]\n  trash?: boolean\n  unpublishAllLocales?: boolean\n  where?: Where\n} & Record<string, unknown>\n\nexport const booleanParams = [\n  'autosave',\n  'draft',\n  'trash',\n  'overrideLock',\n  'pagination',\n  'flattenLocales',\n]\n\nexport const numberParams = ['depth', 'limit', 'page']\n\n/**\n * Takes raw query parameters and parses them into the correct types that Payload expects.\n * Examples:\n *   a. `draft` provided as a string of \"true\" is converted to a boolean\n *   b. `depth` provided as a string of \"0\" is converted to a number\n *   c. `sort` provided as a comma-separated string or array is converted to an array of strings\n */\nexport const parseParams = (params: RawParams): ParsedParams => {\n  const parsedParams = (params || {}) as ParsedParams\n\n  // iterate through known params to make this very fast\n  for (const key of booleanParams) {\n    if (key in params) {\n      parsedParams[key] = parseBooleanString(params[key] as boolean | string)\n    }\n  }\n\n  for (const key of numberParams) {\n    if (key in params) {\n      if (isNumber(params[key])) {\n        parsedParams[key] = Number(params[key])\n      }\n    }\n  }\n\n  if ('populate' in params) {\n    parsedParams.populate = sanitizePopulateParam(params.populate)\n  }\n\n  if ('select' in params) {\n    parsedParams.select = sanitizeSelectParam(params.select)\n  }\n\n  if ('joins' in params) {\n    parsedParams.joins = sanitizeJoinParams(params.joins as JoinParams)\n  }\n\n  if ('sort' in params) {\n    parsedParams.sort = sanitizeSortParams(params.sort)\n  }\n\n  if ('data' in params && typeof params.data === 'string' && params.data.length > 0) {\n    parsedParams.data = JSON.parse(params.data)\n  }\n\n  return parsedParams\n}\n"],"names":["isNumber","parseBooleanString","sanitizeJoinParams","sanitizePopulateParam","sanitizeSelectParam","sanitizeSortParams","booleanParams","numberParams","parseParams","params","parsedParams","key","Number","populate","select","joins","sort","data","length","JSON","parse"],"mappings":";;;;;;;;AAGA,SAASA,QAAQ,QAAQ,iBAAgB;AACzC,SAASC,kBAAkB,QAAQ,2BAA0B;AAC7D,SAASC,kBAAkB,QAAQ,2BAA0B;AAC7D,SAASC,qBAAqB,QAAQ,8BAA6B;AACnE,SAASC,mBAAmB,QAAQ,4BAA2B;AAC/D,SAASC,kBAAkB,QAAQ,2BAA0B;;;;;;;AAiDtD,MAAMC,gBAAgB;IAC3B;IACA;IACA;IACA;IACA;IACA;CACD,CAAA;AAEM,MAAMC,eAAe;IAAC;IAAS;IAAS;CAAO,CAAA;AAS/C,MAAMC,cAAc,CAACC;IAC1B,MAAMC,eAAgBD,UAAU,CAAC;IAEjC,sDAAsD;IACtD,KAAK,MAAME,OAAOL,cAAe;QAC/B,IAAIK,OAAOF,QAAQ;YACjBC,YAAY,CAACC,IAAI,OAAGV,0LAAAA,EAAmBQ,MAAM,CAACE,IAAI;QACpD;IACF;IAEA,KAAK,MAAMA,OAAOJ,aAAc;QAC9B,IAAII,OAAOF,QAAQ;YACjB,QAAIT,sKAAAA,EAASS,MAAM,CAACE,IAAI,GAAG;gBACzBD,YAAY,CAACC,IAAI,GAAGC,OAAOH,MAAM,CAACE,IAAI;YACxC;QACF;IACF;IAEA,IAAI,cAAcF,QAAQ;QACxBC,aAAaG,QAAQ,OAAGV,gMAAAA,EAAsBM,OAAOI,QAAQ;IAC/D;IAEA,IAAI,YAAYJ,QAAQ;QACtBC,aAAaI,MAAM,OAAGV,4LAAAA,EAAoBK,OAAOK,MAAM;IACzD;IAEA,IAAI,WAAWL,QAAQ;QACrBC,aAAaK,KAAK,OAAGb,0LAAAA,EAAmBO,OAAOM,KAAK;IACtD;IAEA,IAAI,UAAUN,QAAQ;QACpBC,aAAaM,IAAI,OAAGX,0LAAAA,EAAmBI,OAAOO,IAAI;IACpD;IAEA,IAAI,UAAUP,UAAU,OAAOA,OAAOQ,IAAI,KAAK,YAAYR,OAAOQ,IAAI,CAACC,MAAM,GAAG,GAAG;QACjFR,aAAaO,IAAI,GAAGE,KAAKC,KAAK,CAACX,OAAOQ,IAAI;IAC5C;IAEA,OAAOP;AACT,EAAC"}},
    {"offset": {"line": 2835, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/utilities/isolateObjectProperty.ts"],"sourcesContent":["/**\n * Creates a proxy for the given object that has its own property\n */\nexport function isolateObjectProperty<T extends object>(object: T, key: (keyof T)[] | keyof T): T {\n  const keys = Array.isArray(key) ? key : [key]\n  const delegate = {} as T\n\n  // Initialize delegate with the keys, if they exist in the original object\n  for (const k of keys) {\n    if (k in object) {\n      delegate[k] = object[k]\n    }\n  }\n\n  const handler: ProxyHandler<T> = {\n    deleteProperty(target, p): boolean {\n      return Reflect.deleteProperty(keys.includes(p as keyof T) ? delegate : target, p)\n    },\n    get(target, p, receiver) {\n      if (keys.includes(p as keyof T)) {\n        return Reflect.get(delegate, p, receiver)\n      }\n      // Use target as receiver to preserve private field access (e.g., Request#headers in Node 24+)\n      return Reflect.get(target, p, target)\n    },\n    has(target, p) {\n      return Reflect.has(keys.includes(p as keyof T) ? delegate : target, p)\n    },\n    set(target, p, newValue, _receiver) {\n      if (keys.includes(p as keyof T)) {\n        // in case of transactionID we must ignore any receiver, because\n        // \"If provided and target does not have a setter for propertyKey, the property will be set on receiver instead.\"\n        return Reflect.set(delegate, p, newValue)\n      }\n      return Reflect.set(target, p, newValue, target)\n    },\n  }\n  return new Proxy(object, handler)\n}\n"],"names":["isolateObjectProperty","object","key","keys","Array","isArray","delegate","k","handler","deleteProperty","target","p","Reflect","includes","get","receiver","has","set","newValue","_receiver","Proxy"],"mappings":"AAAA;;CAEC,GACD;;;;AAAO,SAASA,sBAAwCC,MAAS,EAAEC,GAA0B;IAC3F,MAAMC,OAAOC,MAAMC,OAAO,CAACH,OAAOA,MAAM;QAACA;KAAI;IAC7C,MAAMI,WAAW,CAAC;IAElB,0EAA0E;IAC1E,KAAK,MAAMC,KAAKJ,KAAM;QACpB,IAAII,KAAKN,QAAQ;YACfK,QAAQ,CAACC,EAAE,GAAGN,MAAM,CAACM,EAAE;QACzB;IACF;IAEA,MAAMC,UAA2B;QAC/BC,gBAAeC,MAAM,EAAEC,CAAC;YACtB,OAAOC,QAAQH,cAAc,CAACN,KAAKU,QAAQ,CAACF,KAAgBL,WAAWI,QAAQC;QACjF;QACAG,KAAIJ,MAAM,EAAEC,CAAC,EAAEI,QAAQ;YACrB,IAAIZ,KAAKU,QAAQ,CAACF,IAAe;gBAC/B,OAAOC,QAAQE,GAAG,CAACR,UAAUK,GAAGI;YAClC;YACA,8FAA8F;YAC9F,OAAOH,QAAQE,GAAG,CAACJ,QAAQC,GAAGD;QAChC;QACAM,KAAIN,MAAM,EAAEC,CAAC;YACX,OAAOC,QAAQI,GAAG,CAACb,KAAKU,QAAQ,CAACF,KAAgBL,WAAWI,QAAQC;QACtE;QACAM,KAAIP,MAAM,EAAEC,CAAC,EAAEO,QAAQ,EAAEC,SAAS;YAChC,IAAIhB,KAAKU,QAAQ,CAACF,IAAe;gBAC/B,gEAAgE;gBAChE,iHAAiH;gBACjH,OAAOC,QAAQK,GAAG,CAACX,UAAUK,GAAGO;YAClC;YACA,OAAON,QAAQK,GAAG,CAACP,QAAQC,GAAGO,UAAUR;QAC1C;IACF;IACA,OAAO,IAAIU,MAAMnB,QAAQO;AAC3B"}},
    {"offset": {"line": 2881, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/utilities/filterDataToSelectedLocales.ts"],"sourcesContent":["import type { Block, Field, FlattenedBlock } from '../fields/config/types.js'\nimport type { SanitizedConfig } from '../index.js'\nimport type { JsonObject } from '../types/index.js'\n\nimport { fieldAffectsData, fieldShouldBeLocalized, tabHasName } from '../fields/config/types.js'\n\ntype FilterDataToSelectedLocalesArgs = {\n  configBlockReferences: SanitizedConfig['blocks']\n  docWithLocales: JsonObject\n  fields: Field[]\n  parentIsLocalized?: boolean\n  selectedLocales: string[]\n}\n\n/**\n * Filters localized field data to only include specified locales.\n * For non-localized fields, returns all data as-is.\n * For localized fields, if selectedLocales is provided, returns only those locales.\n * If selectedLocales is not provided and field is localized, returns all locales.\n */\nexport function filterDataToSelectedLocales({\n  configBlockReferences,\n  docWithLocales,\n  fields,\n  parentIsLocalized = false,\n  selectedLocales,\n}: FilterDataToSelectedLocalesArgs): JsonObject {\n  if (!docWithLocales || typeof docWithLocales !== 'object') {\n    return docWithLocales\n  }\n\n  const result: JsonObject = {}\n\n  for (const field of fields) {\n    if (fieldAffectsData(field)) {\n      const fieldIsLocalized = fieldShouldBeLocalized({ field, parentIsLocalized })\n\n      switch (field.type) {\n        case 'array': {\n          if (Array.isArray(docWithLocales[field.name])) {\n            result[field.name] = docWithLocales[field.name].map((item: JsonObject) =>\n              filterDataToSelectedLocales({\n                configBlockReferences,\n                docWithLocales: item,\n                fields: field.fields,\n                parentIsLocalized: fieldIsLocalized,\n                selectedLocales,\n              }),\n            )\n          }\n          break\n        }\n\n        case 'blocks': {\n          if (field.name in docWithLocales && Array.isArray(docWithLocales[field.name])) {\n            result[field.name] = docWithLocales[field.name].map((blockData: JsonObject) => {\n              let block: Block | FlattenedBlock | undefined\n              if (configBlockReferences && field.blockReferences) {\n                for (const blockOrReference of field.blockReferences) {\n                  if (typeof blockOrReference === 'string') {\n                    block = configBlockReferences.find((b) => b.slug === blockData.blockType)\n                  } else {\n                    block = blockOrReference\n                  }\n                }\n              } else if (field.blocks) {\n                block = field.blocks.find((b) => b.slug === blockData.blockType)\n              }\n\n              if (block) {\n                return filterDataToSelectedLocales({\n                  configBlockReferences,\n                  docWithLocales: blockData,\n                  fields: block?.fields || [],\n                  parentIsLocalized: fieldIsLocalized,\n                  selectedLocales,\n                })\n              }\n\n              return blockData\n            })\n          }\n          break\n        }\n\n        case 'group': {\n          // Named groups create a nested data structure\n          if (\n            fieldAffectsData(field) &&\n            field.name in docWithLocales &&\n            typeof docWithLocales[field.name] === 'object'\n          ) {\n            result[field.name] = filterDataToSelectedLocales({\n              configBlockReferences,\n              docWithLocales: docWithLocales[field.name] as JsonObject,\n              fields: field.fields,\n              parentIsLocalized: fieldIsLocalized,\n              selectedLocales,\n            })\n          } else {\n            // Unnamed groups pass through the same data level\n            const nestedResult = filterDataToSelectedLocales({\n              configBlockReferences,\n              docWithLocales,\n              fields: field.fields,\n              parentIsLocalized,\n              selectedLocales,\n            })\n            Object.assign(result, nestedResult)\n          }\n          break\n        }\n\n        default: {\n          // For all other data-affecting fields (text, number, select, etc.)\n          if (field.name in docWithLocales) {\n            const value = docWithLocales[field.name]\n\n            // If the field is localized and has locale data\n            if (fieldIsLocalized && value && typeof value === 'object' && !Array.isArray(value)) {\n              // If selectedLocales is provided, filter to only those locales\n              if (selectedLocales && selectedLocales.length > 0) {\n                const filtered: Record<string, unknown> = {}\n                for (const locale of selectedLocales) {\n                  if (locale in value) {\n                    filtered[locale] = value[locale]\n                  }\n                }\n                if (Object.keys(filtered).length > 0) {\n                  result[field.name] = filtered\n                }\n              } else {\n                // If no selectedLocales, include all locales\n                result[field.name] = value\n              }\n            } else {\n              // Non-localized field or non-object value\n              result[field.name] = value\n            }\n          }\n          break\n        }\n      }\n    } else {\n      // Layout-only fields that don't affect data structure\n      switch (field.type) {\n        case 'collapsible':\n        case 'row': {\n          // These pass through the same data level\n          const nestedResult = filterDataToSelectedLocales({\n            configBlockReferences,\n            docWithLocales,\n            fields: field.fields,\n            parentIsLocalized,\n            selectedLocales,\n          })\n          Object.assign(result, nestedResult)\n          break\n        }\n\n        case 'tabs': {\n          for (const tab of field.tabs) {\n            if (tabHasName(tab)) {\n              // Named tabs create a nested data structure\n              if (tab.name in docWithLocales && typeof docWithLocales[tab.name] === 'object') {\n                result[tab.name] = filterDataToSelectedLocales({\n                  configBlockReferences,\n                  docWithLocales: docWithLocales[tab.name],\n                  fields: tab.fields,\n                  parentIsLocalized,\n                  selectedLocales,\n                })\n              }\n            } else {\n              // Unnamed tabs pass through the same data level\n              const nestedResult = filterDataToSelectedLocales({\n                configBlockReferences,\n                docWithLocales,\n                fields: tab.fields,\n                parentIsLocalized,\n                selectedLocales,\n              })\n              Object.assign(result, nestedResult)\n            }\n          }\n          break\n        }\n      }\n    }\n  }\n\n  return result\n}\n"],"names":["fieldAffectsData","fieldShouldBeLocalized","tabHasName","filterDataToSelectedLocales","configBlockReferences","docWithLocales","fields","parentIsLocalized","selectedLocales","result","field","fieldIsLocalized","type","Array","isArray","name","map","item","blockData","block","blockReferences","blockOrReference","find","b","slug","blockType","blocks","nestedResult","Object","assign","value","length","filtered","locale","keys","tab","tabs"],"mappings":"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"}},
    {"offset": {"line": 3050, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/utilities/getVersionsConfig.ts"],"sourcesContent":["import type { CollectionConfig } from '../collections/config/types.js'\nimport type { GlobalConfig } from '../globals/config/types.js'\nimport type { Autosave, SanitizedDrafts } from '../versions/types.js'\n\nimport { versionDefaults } from '../versions/defaults.js'\n\ntype EntityConfig = Pick<CollectionConfig | GlobalConfig, 'versions'>\n\n/**\n * Check if an entity has drafts enabled\n */\nexport const hasDraftsEnabled = (config: EntityConfig): boolean => {\n  return Boolean(config?.versions && typeof config.versions === 'object' && config.versions.drafts)\n}\n\n/**\n * Check if an entity has localized status enabled\n */\nexport const hasLocalizeStatusEnabled = (config: EntityConfig): boolean => {\n  return Boolean(\n    config?.versions &&\n      typeof config.versions === 'object' &&\n      config.versions.drafts &&\n      typeof config.versions.drafts === 'object' &&\n      config.versions.drafts.localizeStatus,\n  )\n}\n\n/**\n * Check if an entity has autosave enabled\n */\nexport const hasAutosaveEnabled = (\n  config: EntityConfig,\n): config is {\n  versions: {\n    drafts: { autosave: Autosave | false }\n  }\n} & EntityConfig => {\n  return Boolean(\n    config?.versions &&\n      typeof config.versions === 'object' &&\n      config.versions.drafts &&\n      typeof config.versions.drafts === 'object' &&\n      config.versions.drafts.autosave,\n  )\n}\n\n/**\n * Check if an entity has validate drafts enabled\n */\nexport const hasDraftValidationEnabled = (config: EntityConfig): boolean => {\n  return Boolean(\n    config?.versions &&\n      typeof config.versions === 'object' &&\n      config.versions.drafts &&\n      typeof config.versions.drafts === 'object' &&\n      config.versions.drafts.validate,\n  )\n}\n\nexport const hasScheduledPublishEnabled = (\n  config: EntityConfig,\n): config is {\n  versions: {\n    drafts: { schedulePublish: SanitizedDrafts['schedulePublish'] }\n  }\n} & EntityConfig => {\n  return Boolean(\n    config?.versions &&\n      typeof config.versions === 'object' &&\n      config.versions.drafts &&\n      typeof config.versions.drafts === 'object' &&\n      config.versions.drafts.schedulePublish,\n  )\n}\n\n/**\n * Get the maximum number of versions to keep for an entity\n * Returns maxPerDoc for collections or max for globals\n */\nexport const getVersionsMax = (config: EntityConfig): number => {\n  if (!config?.versions || typeof config.versions !== 'object') {\n    return 0\n  }\n  // Collections have maxPerDoc, globals have max\n  if ('maxPerDoc' in config.versions) {\n    return config.versions.maxPerDoc ?? 100\n  }\n  if ('max' in config.versions) {\n    return config.versions.max ?? 100\n  }\n  return 0\n}\n\nexport const getAutosaveInterval = (config: EntityConfig): number => {\n  let interval = versionDefaults.autosaveInterval\n  if (\n    config?.versions &&\n    typeof config.versions === 'object' &&\n    config.versions.drafts &&\n    typeof config.versions.drafts === 'object' &&\n    config.versions.drafts.autosave &&\n    typeof config.versions.drafts.autosave === 'object'\n  ) {\n    interval = config.versions.drafts.autosave.interval ?? versionDefaults.autosaveInterval\n  }\n  return interval\n}\n"],"names":["versionDefaults","hasDraftsEnabled","config","Boolean","versions","drafts","hasLocalizeStatusEnabled","localizeStatus","hasAutosaveEnabled","autosave","hasDraftValidationEnabled","validate","hasScheduledPublishEnabled","schedulePublish","getVersionsMax","maxPerDoc","max","getAutosaveInterval","interval","autosaveInterval"],"mappings":";;;;;;;;;;;;;;;;AAIA,SAASA,eAAe,QAAQ,0BAAyB;;AAOlD,MAAMC,mBAAmB,CAACC;IAC/B,OAAOC,QAAQD,QAAQE,YAAY,OAAOF,OAAOE,QAAQ,KAAK,YAAYF,OAAOE,QAAQ,CAACC,MAAM;AAClG,EAAC;AAKM,MAAMC,2BAA2B,CAACJ;IACvC,OAAOC,QACLD,QAAQE,YACN,OAAOF,OAAOE,QAAQ,KAAK,YAC3BF,OAAOE,QAAQ,CAACC,MAAM,IACtB,OAAOH,OAAOE,QAAQ,CAACC,MAAM,KAAK,YAClCH,OAAOE,QAAQ,CAACC,MAAM,CAACE,cAAc;AAE3C,EAAC;AAKM,MAAMC,qBAAqB,CAChCN;IAMA,OAAOC,QACLD,QAAQE,YACN,OAAOF,OAAOE,QAAQ,KAAK,YAC3BF,OAAOE,QAAQ,CAACC,MAAM,IACtB,OAAOH,OAAOE,QAAQ,CAACC,MAAM,KAAK,YAClCH,OAAOE,QAAQ,CAACC,MAAM,CAACI,QAAQ;AAErC,EAAC;AAKM,MAAMC,4BAA4B,CAACR;IACxC,OAAOC,QACLD,QAAQE,YACN,OAAOF,OAAOE,QAAQ,KAAK,YAC3BF,OAAOE,QAAQ,CAACC,MAAM,IACtB,OAAOH,OAAOE,QAAQ,CAACC,MAAM,KAAK,YAClCH,OAAOE,QAAQ,CAACC,MAAM,CAACM,QAAQ;AAErC,EAAC;AAEM,MAAMC,6BAA6B,CACxCV;IAMA,OAAOC,QACLD,QAAQE,YACN,OAAOF,OAAOE,QAAQ,KAAK,YAC3BF,OAAOE,QAAQ,CAACC,MAAM,IACtB,OAAOH,OAAOE,QAAQ,CAACC,MAAM,KAAK,YAClCH,OAAOE,QAAQ,CAACC,MAAM,CAACQ,eAAe;AAE5C,EAAC;AAMM,MAAMC,iBAAiB,CAACZ;IAC7B,IAAI,CAACA,QAAQE,YAAY,OAAOF,OAAOE,QAAQ,KAAK,UAAU;QAC5D,OAAO;IACT;IACA,+CAA+C;IAC/C,IAAI,eAAeF,OAAOE,QAAQ,EAAE;QAClC,OAAOF,OAAOE,QAAQ,CAACW,SAAS,IAAI;IACtC;IACA,IAAI,SAASb,OAAOE,QAAQ,EAAE;QAC5B,OAAOF,OAAOE,QAAQ,CAACY,GAAG,IAAI;IAChC;IACA,OAAO;AACT,EAAC;AAEM,MAAMC,sBAAsB,CAACf;IAClC,IAAIgB,WAAWlB,4KAAAA,CAAgBmB,gBAAgB;IAC/C,IACEjB,QAAQE,YACR,OAAOF,OAAOE,QAAQ,KAAK,YAC3BF,OAAOE,QAAQ,CAACC,MAAM,IACtB,OAAOH,OAAOE,QAAQ,CAACC,MAAM,KAAK,YAClCH,OAAOE,QAAQ,CAACC,MAAM,CAACI,QAAQ,IAC/B,OAAOP,OAAOE,QAAQ,CAACC,MAAM,CAACI,QAAQ,KAAK,UAC3C;QACAS,WAAWhB,OAAOE,QAAQ,CAACC,MAAM,CAACI,QAAQ,CAACS,QAAQ,IAAIlB,4KAAAA,CAAgBmB,gBAAgB;IACzF;IACA,OAAOD;AACT,EAAC"}},
    {"offset": {"line": 3107, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/utilities/getTranslatedLabel.ts"],"sourcesContent":["import { getTranslation, type I18n } from '@payloadcms/translations'\n\nimport type { LabelFunction, StaticLabel } from '../config/types.js'\n\nexport const getTranslatedLabel = (\n  label: LabelFunction | StaticLabel | undefined,\n  i18n?: I18n,\n): string | undefined => {\n  if (typeof label === 'function') {\n    return label({ i18n: i18n!, t: i18n!.t })\n  }\n\n  if (typeof label === 'object') {\n    return getTranslation(label, i18n!)\n  }\n\n  return label\n}\n"],"names":["getTranslation","getTranslatedLabel","label","i18n","t"],"mappings":";;;;AAAA,SAASA,cAAc,QAAmB,2BAA0B;;AAI7D,MAAMC,qBAAqB,CAChCC,OACAC;IAEA,IAAI,OAAOD,UAAU,YAAY;QAC/B,OAAOA,MAAM;YAAEC,MAAMA;YAAOC,GAAGD,KAAMC,CAAC;QAAC;IACzC;IAEA,IAAI,OAAOF,UAAU,UAAU;QAC7B,WAAOF,uMAAAA,EAAeE,OAAOC;IAC/B;IAEA,OAAOD;AACT,EAAC"}},
    {"offset": {"line": 3129, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/utilities/validatePDF.ts"],"sourcesContent":["export function validatePDF(buffer: Buffer) {\n  // Check for PDF header\n  const header = buffer.subarray(0, 8).toString('latin1')\n  if (!header.startsWith('%PDF-')) {\n    return false\n  }\n\n  // Check for EOF marker and xref table\n  const endSize = Math.min(1024, buffer.length)\n  const end = buffer.subarray(buffer.length - endSize).toString('latin1')\n\n  if (!end.includes('%%EOF') || !end.includes('xref')) {\n    return false\n  }\n\n  return true\n}\n"],"names":["validatePDF","buffer","header","subarray","toString","startsWith","endSize","Math","min","length","end","includes"],"mappings":";;;;AAAO,SAASA,YAAYC,MAAc;IACxC,uBAAuB;IACvB,MAAMC,SAASD,OAAOE,QAAQ,CAAC,GAAG,GAAGC,QAAQ,CAAC;IAC9C,IAAI,CAACF,OAAOG,UAAU,CAAC,UAAU;QAC/B,OAAO;IACT;IAEA,sCAAsC;IACtC,MAAMC,UAAUC,KAAKC,GAAG,CAAC,MAAMP,OAAOQ,MAAM;IAC5C,MAAMC,MAAMT,OAAOE,QAAQ,CAACF,OAAOQ,MAAM,GAAGH,SAASF,QAAQ,CAAC;IAE9D,IAAI,CAACM,IAAIC,QAAQ,CAAC,YAAY,CAACD,IAAIC,QAAQ,CAAC,SAAS;QACnD,OAAO;IACT;IAEA,OAAO;AACT"}},
    {"offset": {"line": 3151, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/utilities/mapAsync.ts"],"sourcesContent":["export async function mapAsync<T, U>(\n  arr: T[],\n  callbackfn: (item: T, index: number, array: T[]) => Promise<U>,\n): Promise<U[]> {\n  return Promise.all(arr.map(callbackfn))\n}\n"],"names":["mapAsync","arr","callbackfn","Promise","all","map"],"mappings":";;;;AAAO,eAAeA,SACpBC,GAAQ,EACRC,UAA8D;IAE9D,OAAOC,QAAQC,GAAG,CAACH,IAAII,GAAG,CAACH;AAC7B"}},
    {"offset": {"line": 3162, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/utilities/sanitizeSelect.ts"],"sourcesContent":["import { deepMergeSimple } from '@payloadcms/translations/utilities'\n\nimport type { FlattenedField } from '../fields/config/types.js'\nimport type { SelectIncludeType, SelectType } from '../types/index.js'\n\nimport { getSelectMode } from './getSelectMode.js'\n\n// Transform post.title -> post, post.category.title -> post\nconst stripVirtualPathToCurrentCollection = ({\n  fields,\n  path,\n  versions,\n}: {\n  fields: FlattenedField[]\n  path: string\n  versions: boolean\n}) => {\n  const resultSegments: string[] = []\n\n  if (versions) {\n    resultSegments.push('version')\n    const versionField = fields.find((each) => each.name === 'version')\n\n    if (versionField && versionField.type === 'group') {\n      fields = versionField.flattenedFields\n    }\n  }\n\n  for (const segment of path.split('.')) {\n    const field = fields.find((each) => each.name === segment)\n\n    if (!field) {\n      continue\n    }\n\n    resultSegments.push(segment)\n\n    if (field.type === 'relationship' || field.type === 'upload') {\n      return resultSegments.join('.')\n    }\n  }\n\n  return resultSegments.join('.')\n}\n\nconst getAllVirtualRelations = ({ fields }: { fields: FlattenedField[] }) => {\n  const result: string[] = []\n\n  for (const field of fields) {\n    if ('virtual' in field && typeof field.virtual === 'string') {\n      result.push(field.virtual)\n    } else if (field.type === 'group' || field.type === 'tab') {\n      const nestedResult = getAllVirtualRelations({ fields: field.flattenedFields })\n\n      for (const nestedItem of nestedResult) {\n        result.push(nestedItem)\n      }\n    }\n  }\n\n  return result\n}\n\nconst resolveVirtualRelationsToSelect = ({\n  fields,\n  selectValue,\n  topLevelFields,\n  versions,\n}: {\n  fields: FlattenedField[]\n  selectValue: SelectIncludeType | true\n  topLevelFields: FlattenedField[]\n  versions: boolean\n}) => {\n  const result: string[] = []\n  if (selectValue === true) {\n    for (const item of getAllVirtualRelations({ fields })) {\n      result.push(\n        stripVirtualPathToCurrentCollection({ fields: topLevelFields, path: item, versions }),\n      )\n    }\n  } else {\n    for (const fieldName in selectValue) {\n      const field = fields.find((each) => each.name === fieldName)\n      if (!field) {\n        continue\n      }\n\n      if ('virtual' in field && typeof field.virtual === 'string') {\n        result.push(\n          stripVirtualPathToCurrentCollection({\n            fields: topLevelFields,\n            path: field.virtual,\n            versions,\n          }),\n        )\n      } else if (field.type === 'group' || field.type === 'tab') {\n        for (const item of resolveVirtualRelationsToSelect({\n          fields: field.flattenedFields,\n          selectValue: selectValue[fieldName]!,\n          topLevelFields,\n          versions,\n        })) {\n          result.push(\n            stripVirtualPathToCurrentCollection({ fields: topLevelFields, path: item, versions }),\n          )\n        }\n      }\n    }\n  }\n\n  return result\n}\n\nexport const sanitizeSelect = ({\n  fields,\n  forceSelect,\n  select,\n  versions,\n}: {\n  fields: FlattenedField[]\n  forceSelect?: SelectType\n  select?: SelectType\n  versions?: boolean\n}): SelectType | undefined => {\n  if (!select) {\n    return select\n  }\n\n  const selectMode = getSelectMode(select)\n\n  if (selectMode === 'exclude') {\n    return select\n  }\n\n  if (forceSelect) {\n    select = deepMergeSimple(select, forceSelect)\n  }\n\n  if (select) {\n    const virtualRelations = resolveVirtualRelationsToSelect({\n      fields,\n      selectValue: select as SelectIncludeType,\n      topLevelFields: fields,\n      versions: versions ?? false,\n    })\n\n    for (const path of virtualRelations) {\n      let currentRef = select\n      const segments = path.split('.')\n      for (let i = 0; i < segments.length; i++) {\n        const isLast = segments.length - 1 === i\n        const segment = segments[i]!\n\n        if (isLast) {\n          currentRef[segment] = true\n        } else {\n          if (!(segment in currentRef)) {\n            currentRef[segment] = {}\n            currentRef = currentRef[segment]\n          }\n        }\n      }\n    }\n  }\n\n  return select\n}\n"],"names":["deepMergeSimple","getSelectMode","stripVirtualPathToCurrentCollection","fields","path","versions","resultSegments","push","versionField","find","each","name","type","flattenedFields","segment","split","field","join","getAllVirtualRelations","result","virtual","nestedResult","nestedItem","resolveVirtualRelationsToSelect","selectValue","topLevelFields","item","fieldName","sanitizeSelect","forceSelect","select","selectMode","virtualRelations","currentRef","segments","i","length","isLast"],"mappings":"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"}},
    {"offset": {"line": 3291, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/utilities/checkDocumentLockStatus.ts"],"sourcesContent":["import type { TypeWithID } from '../collections/config/types.js'\nimport type { PaginatedDocs } from '../database/types.js'\nimport type { JsonObject, PayloadRequest } from '../types/index.js'\n\nimport { Locked } from '../errors/index.js'\nimport { lockedDocumentsCollectionSlug } from '../locked-documents/config.js'\n\ntype CheckDocumentLockStatusArgs = {\n  collectionSlug?: string\n  globalSlug?: string\n  id?: number | string\n  lockDurationDefault?: number\n  lockErrorMessage?: string\n  overrideLock?: boolean\n  req: PayloadRequest\n}\n\nexport const checkDocumentLockStatus = async ({\n  id,\n  collectionSlug,\n  globalSlug,\n  lockDurationDefault = 300, // Default 5 minutes in seconds\n  lockErrorMessage,\n  overrideLock = true,\n  req,\n}: CheckDocumentLockStatusArgs): Promise<void> => {\n  const { payload } = req\n\n  // Check if the locked-documents collection exists\n  if (!payload.collections?.[lockedDocumentsCollectionSlug]) {\n    // If the collection doesn't exist, locking is not available\n    return\n  }\n\n  // Retrieve the lockDocuments property for either collection or global\n  const lockDocumentsProp = collectionSlug\n    ? payload.collections?.[collectionSlug]?.config?.lockDocuments\n    : payload.config?.globals?.find((g) => g.slug === globalSlug)?.lockDocuments\n\n  const isLockingEnabled = lockDocumentsProp !== false\n\n  let lockedDocumentQuery = {}\n\n  if (collectionSlug) {\n    lockedDocumentQuery = {\n      and: [\n        { 'document.relationTo': { equals: collectionSlug } },\n        { 'document.value': { equals: id } },\n      ],\n    }\n  } else if (globalSlug) {\n    lockedDocumentQuery = { globalSlug: { equals: globalSlug } }\n  } else {\n    throw new Error('Either collectionSlug or globalSlug must be provided.')\n  }\n\n  if (!isLockingEnabled) {\n    return\n  }\n\n  // Only perform lock checks if overrideLock is false and locking is enabled\n  if (!overrideLock) {\n    const defaultLockErrorMessage = collectionSlug\n      ? `Document with ID ${id} is currently locked by another user and cannot be modified.`\n      : `Global document with slug \"${globalSlug}\" is currently locked by another user and cannot be modified.`\n\n    const finalLockErrorMessage = lockErrorMessage || defaultLockErrorMessage\n\n    const lockedDocumentResult: PaginatedDocs<JsonObject & TypeWithID> = await payload.db.find({\n      collection: lockedDocumentsCollectionSlug,\n      limit: 1,\n      pagination: false,\n      sort: '-updatedAt',\n      where: lockedDocumentQuery,\n    })\n\n    // If there's a locked document, check lock conditions\n    const lockedDoc = lockedDocumentResult?.docs[0]\n    if (lockedDoc) {\n      const lastEditedAt = new Date(lockedDoc?.updatedAt).getTime()\n      const now = new Date().getTime()\n\n      const lockDuration =\n        typeof lockDocumentsProp === 'object' ? lockDocumentsProp.duration : lockDurationDefault\n\n      const lockDurationInMilliseconds = lockDuration * 1000\n      const currentUserId = req.user?.id\n\n      // document is locked by another user and the lock hasn't expired\n      if (\n        lockedDoc.user?.value !== currentUserId &&\n        now - lastEditedAt <= lockDurationInMilliseconds\n      ) {\n        throw new Locked(finalLockErrorMessage)\n      }\n    }\n  }\n\n  // Perform the delete operation regardless of overrideLock status\n  await payload.db.deleteMany({\n    collection: lockedDocumentsCollectionSlug,\n    // Not passing req fails on postgres\n    req: payload.db.name === 'mongoose' ? undefined : req,\n    where: lockedDocumentQuery,\n  })\n}\n"],"names":["Locked","lockedDocumentsCollectionSlug","checkDocumentLockStatus","id","collectionSlug","globalSlug","lockDurationDefault","lockErrorMessage","overrideLock","req","payload","collections","lockDocumentsProp","config","lockDocuments","globals","find","g","slug","isLockingEnabled","lockedDocumentQuery","and","equals","Error","defaultLockErrorMessage","finalLockErrorMessage","lockedDocumentResult","db","collection","limit","pagination","sort","where","lockedDoc","docs","lastEditedAt","Date","updatedAt","getTime","now","lockDuration","duration","lockDurationInMilliseconds","currentUserId","user","value","deleteMany","name","undefined"],"mappings":";;;;AAIA,SAASA,MAAM,QAAQ,qBAAoB;AAC3C,SAASC,6BAA6B,QAAQ,gCAA+B;;;AAYtE,MAAMC,0BAA0B,OAAO,EAC5CC,EAAE,EACFC,cAAc,EACdC,UAAU,EACVC,sBAAsB,GAAG,EACzBC,gBAAgB,EAChBC,eAAe,IAAI,EACnBC,GAAG,EACyB;IAC5B,MAAM,EAAEC,OAAO,EAAE,GAAGD;IAEpB,kDAAkD;IAClD,IAAI,CAACC,QAAQC,WAAW,EAAE,CAACV,mMAAAA,CAA8B,EAAE;QACzD,4DAA4D;QAC5D;IACF;IAEA,sEAAsE;IACtE,MAAMW,oBAAoBR,iBACtBM,QAAQC,WAAW,EAAE,CAACP,eAAe,EAAES,QAAQC,gBAC/CJ,QAAQG,MAAM,EAAEE,SAASC,KAAK,CAACC,IAAMA,EAAEC,IAAI,KAAKb,aAAaS;IAEjE,MAAMK,mBAAmBP,sBAAsB;IAE/C,IAAIQ,sBAAsB,CAAC;IAE3B,IAAIhB,gBAAgB;QAClBgB,sBAAsB;YACpBC,KAAK;gBACH;oBAAE,uBAAuB;wBAAEC,QAAQlB;oBAAe;gBAAE;gBACpD;oBAAE,kBAAkB;wBAAEkB,QAAQnB;oBAAG;gBAAE;aACpC;QACH;IACF,OAAO,IAAIE,YAAY;QACrBe,sBAAsB;YAAEf,YAAY;gBAAEiB,QAAQjB;YAAW;QAAE;IAC7D,OAAO;QACL,MAAM,IAAIkB,MAAM;IAClB;IAEA,IAAI,CAACJ,kBAAkB;QACrB;IACF;IAEA,2EAA2E;IAC3E,IAAI,CAACX,cAAc;QACjB,MAAMgB,0BAA0BpB,iBAC5B,CAAC,iBAAiB,EAAED,GAAG,4DAA4D,CAAC,GACpF,CAAC,2BAA2B,EAAEE,WAAW,6DAA6D,CAAC;QAE3G,MAAMoB,wBAAwBlB,oBAAoBiB;QAElD,MAAME,uBAA+D,MAAMhB,QAAQiB,EAAE,CAACX,IAAI,CAAC;YACzFY,YAAY3B,mMAAAA;YACZ4B,OAAO;YACPC,YAAY;YACZC,MAAM;YACNC,OAAOZ;QACT;QAEA,sDAAsD;QACtD,MAAMa,YAAYP,sBAAsBQ,IAAI,CAAC,EAAE;QAC/C,IAAID,WAAW;YACb,MAAME,eAAe,IAAIC,KAAKH,WAAWI,WAAWC,OAAO;YAC3D,MAAMC,MAAM,IAAIH,OAAOE,OAAO;YAE9B,MAAME,eACJ,OAAO5B,sBAAsB,WAAWA,kBAAkB6B,QAAQ,GAAGnC;YAEvE,MAAMoC,6BAA6BF,eAAe;YAClD,MAAMG,gBAAgBlC,IAAImC,IAAI,EAAEzC;YAEhC,iEAAiE;YACjE,IACE8B,UAAUW,IAAI,EAAEC,UAAUF,iBAC1BJ,MAAMJ,gBAAgBO,4BACtB;gBACA,MAAM,IAAI1C,+JAAAA,CAAOyB;YACnB;QACF;IACF;IAEA,iEAAiE;IACjE,MAAMf,QAAQiB,EAAE,CAACmB,UAAU,CAAC;QAC1BlB,YAAY3B,mMAAAA;QACZ,oCAAoC;QACpCQ,KAAKC,QAAQiB,EAAE,CAACoB,IAAI,KAAK,aAAaC,YAAYvC;QAClDuB,OAAOZ;IACT;AACF,EAAC"}},
    {"offset": {"line": 3374, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/utilities/isErrorPublic.ts"],"sourcesContent":["import { status as httpStatus } from 'http-status'\n\nimport type { SanitizedConfig } from '../config/types.js'\n\ntype PayloadError = {\n  isPublic?: boolean\n  status?: number\n} & Error\n\n/**\n * Determines if an error should be shown to the user.\n */\nexport function isErrorPublic(error: Error, config: SanitizedConfig) {\n  const payloadError = error as PayloadError\n\n  if (config.debug) {\n    return true\n  }\n  if (payloadError.isPublic === true) {\n    return true\n  }\n  if (payloadError.isPublic === false) {\n    return false\n  }\n  if (payloadError.status && payloadError.status !== httpStatus.INTERNAL_SERVER_ERROR) {\n    return true\n  }\n\n  return false\n}\n"],"names":["status","httpStatus","isErrorPublic","error","config","payloadError","debug","isPublic","INTERNAL_SERVER_ERROR"],"mappings":";;;;;AAAA,SAASA,UAAUC,UAAU,QAAQ,cAAa;;AAY3C,SAASC,cAAcC,KAAY,EAAEC,MAAuB;IACjE,MAAMC,eAAeF;IAErB,IAAIC,OAAOE,KAAK,EAAE;QAChB,OAAO;IACT;IACA,IAAID,aAAaE,QAAQ,KAAK,MAAM;QAClC,OAAO;IACT;IACA,IAAIF,aAAaE,QAAQ,KAAK,OAAO;QACnC,OAAO;IACT;IACA,IAAIF,aAAaL,MAAM,IAAIK,aAAaL,MAAM,KAAKC,sMAAAA,CAAWO,qBAAqB,EAAE;QACnF,OAAO;IACT;IAEA,OAAO;AACT"}},
    {"offset": {"line": 3401, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/utilities/dynamicImport.ts"],"sourcesContent":["import path from 'path'\nimport { pathToFileURL } from 'url'\n\n/**\n * Dynamically imports a module from a file path or module specifier.\n *\n * Uses a direct `import()` in Vitest (where eval'd imports fail with ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING),\n * and `eval(`import(...)`)` elsewhere to hide the import from Next.js bundler static analysis.\n *\n * @param modulePathOrSpecifier - Either an absolute file path or a module specifier (package name)\n */\nexport async function dynamicImport<T = unknown>(modulePathOrSpecifier: string): Promise<T> {\n  // Convert absolute file paths to file:// URLs, but leave package specifiers as-is\n  const importPath = path.isAbsolute(modulePathOrSpecifier)\n    ? pathToFileURL(modulePathOrSpecifier).href\n    : modulePathOrSpecifier\n\n  // Vitest runs tests in a VM context where eval'd dynamic imports fail with\n  // ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING. Use direct import in test environment.\n  if (process.env.VITEST) {\n    return await import(importPath)\n  }\n\n  // Without the eval, the Next.js bundler will throw this error when encountering the import statement:\n  //  Compiled with warnings in X.Xs\n  // Critical dependency: the request of a dependency is an expression\n  return await eval(`import('${importPath}')`)\n}\n"],"names":["path","pathToFileURL","dynamicImport","modulePathOrSpecifier","importPath","isAbsolute","href","process","env","VITEST","eval"],"mappings":";;;;AAAA,OAAOA,UAAU,OAAM;AACvB,SAASC,aAAa,QAAQ,MAAK;;;AAU5B,eAAeC,cAA2BC,qBAA6B;IAC5E,kFAAkF;IAClF,MAAMC,aAAaJ,4GAAAA,CAAKK,UAAU,CAACF,6BAC/BF,gHAAAA,EAAcE,uBAAuBG,IAAI,GACzCH;IAEJ,2EAA2E;IAC3E,iFAAiF;IACjF,IAAII,QAAQC,GAAG,CAACC,MAAM,EAAE;QACtB,OAAO,MAAM,MAAM,CAACL;;;;;IACtB;IAEA,sGAAsG;IACtG,mCAAmC;IACnC,oEAAoE;IACpE,OAAO,MAAMM,KAAK,CAAC,QAAQ,EAAEN,WAAW,EAAE,CAAC;AAC7C"}},
    {"offset": {"line": 3430, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/utilities/mergeLocalizedData.ts"],"sourcesContent":["import type { Block, Field, FlattenedBlock } from '../fields/config/types.js'\nimport type { SanitizedConfig } from '../index.js'\nimport type { JsonObject } from '../types/index.js'\n\nimport { fieldAffectsData, fieldShouldBeLocalized, tabHasName } from '../fields/config/types.js'\n\ntype MergeDataToSelectedLocalesArgs = {\n  configBlockReferences: SanitizedConfig['blocks']\n  dataWithLocales: JsonObject\n  docWithLocales: JsonObject\n  fields: Field[]\n  parentIsLocalized?: boolean\n  selectedLocales: string[]\n}\n\n/**\n * Merges data from dataWithLocales onto docWithLocales for specified locales.\n * For localized fields, merges only the specified locales while preserving others.\n * For non-localized fields, keeps existing values from docWithLocales unchanged.\n * Returns a new object without mutating the original.\n */\nexport function mergeLocalizedData({\n  configBlockReferences,\n  dataWithLocales,\n  docWithLocales,\n  fields,\n  parentIsLocalized = false,\n  selectedLocales,\n}: MergeDataToSelectedLocalesArgs): JsonObject {\n  if (!docWithLocales || typeof docWithLocales !== 'object') {\n    return dataWithLocales || docWithLocales\n  }\n\n  const result: JsonObject = { ...docWithLocales }\n\n  for (const field of fields) {\n    if (fieldAffectsData(field)) {\n      // If the parent is localized, all children are inherently \"localized\"\n      if (parentIsLocalized && dataWithLocales[field.name]) {\n        result[field.name] = dataWithLocales[field.name]\n        continue\n      }\n\n      const fieldIsLocalized = fieldShouldBeLocalized({ field, parentIsLocalized })\n\n      switch (field.type) {\n        case 'array': {\n          if (field.name in dataWithLocales) {\n            const newValue = dataWithLocales[field.name]\n            const existingValue = docWithLocales[field.name]\n\n            if (fieldIsLocalized) {\n              // If localized, handle locale keys\n              if (newValue && typeof newValue === 'object' && !Array.isArray(newValue)) {\n                const updatedArray: Record<string, unknown> = { ...(existingValue || {}) }\n\n                for (const locale of selectedLocales) {\n                  if (locale in newValue) {\n                    updatedArray[locale] = newValue[locale]\n                  }\n                }\n\n                result[field.name] = updatedArray\n              } else {\n                // Preserve existing value if new value is not a valid object\n                result[field.name] = existingValue\n              }\n            } else if (Array.isArray(newValue)) {\n              // Non-localized array - still process children for any localized fields\n              result[field.name] = newValue.map((newItem: JsonObject, index: number) => {\n                const existingItem = existingValue?.[index] || {}\n\n                return mergeLocalizedData({\n                  configBlockReferences,\n                  dataWithLocales: newItem,\n                  docWithLocales: existingItem,\n                  fields: field.fields,\n                  parentIsLocalized,\n                  selectedLocales,\n                })\n              })\n            }\n          }\n          break\n        }\n\n        case 'blocks': {\n          if (field.name in dataWithLocales) {\n            const newValue = dataWithLocales[field.name]\n            const existingValue = docWithLocales[field.name]\n\n            if (fieldIsLocalized) {\n              // If localized, handle locale keys\n              if (newValue && typeof newValue === 'object' && !Array.isArray(newValue)) {\n                const updatedData: Record<string, unknown> = { ...(existingValue || {}) }\n\n                for (const locale of selectedLocales) {\n                  if (locale in newValue) {\n                    updatedData[locale] = newValue[locale]\n                  }\n                }\n\n                result[field.name] = updatedData\n              } else {\n                // Preserve existing value if new value is not a valid object\n                result[field.name] = existingValue\n              }\n            } else if (Array.isArray(newValue)) {\n              // Non-localized blocks - still process children for any localized fields\n              result[field.name] = newValue.map((newBlockData: JsonObject, index: number) => {\n                let block: Block | FlattenedBlock | undefined\n                if (configBlockReferences && field.blockReferences) {\n                  for (const blockOrReference of field.blockReferences) {\n                    if (typeof blockOrReference === 'string') {\n                      block = configBlockReferences.find((b) => b.slug === newBlockData.blockType)\n                    } else {\n                      block = blockOrReference\n                    }\n                  }\n                } else if (field.blocks) {\n                  block = field.blocks.find((b) => b.slug === newBlockData.blockType)\n                }\n\n                if (block) {\n                  const blockData =\n                    Array.isArray(existingValue) && existingValue[index]\n                      ? (existingValue[index] as JsonObject)\n                      : {}\n\n                  return mergeLocalizedData({\n                    configBlockReferences,\n                    dataWithLocales: newBlockData,\n                    docWithLocales: blockData,\n                    fields: block?.fields || [],\n                    parentIsLocalized,\n                    selectedLocales,\n                  })\n                }\n\n                return newBlockData\n              })\n            }\n          }\n          break\n        }\n\n        case 'group': {\n          if (fieldAffectsData(field) && field.name) {\n            // Named groups create a nested data structure\n            if (field.name in dataWithLocales) {\n              const newValue = dataWithLocales[field.name]\n              const existingValue = docWithLocales[field.name]\n\n              if (fieldIsLocalized) {\n                if (newValue && typeof newValue === 'object' && !Array.isArray(newValue)) {\n                  const groupData: Record<string, unknown> = { ...(existingValue || {}) }\n\n                  for (const locale of selectedLocales) {\n                    if (locale in newValue && typeof newValue[locale] === 'object') {\n                      groupData[locale] = newValue[locale]\n                    }\n                  }\n\n                  result[field.name] = groupData\n                } else {\n                  // Preserve existing value if new value is not a valid object\n                  result[field.name] = existingValue\n                }\n              } else if (typeof newValue === 'object' && !Array.isArray(newValue)) {\n                // Non-localized group - still process children for any localized fields\n                result[field.name] = mergeLocalizedData({\n                  configBlockReferences,\n                  dataWithLocales: newValue,\n                  docWithLocales: existingValue || {},\n                  fields: field.fields,\n                  parentIsLocalized,\n                  selectedLocales,\n                })\n              }\n            }\n          } else {\n            // Unnamed groups pass through the same data level\n            const merged = mergeLocalizedData({\n              configBlockReferences,\n              dataWithLocales,\n              docWithLocales: result, // Use current result to avoid re-processing already-handled fields\n              fields: field.fields,\n              parentIsLocalized,\n              selectedLocales,\n            })\n            Object.assign(result, merged)\n          }\n          break\n        }\n\n        default: {\n          // For all other data-affecting fields (text, number, select, etc.)\n          if (fieldIsLocalized) {\n            if (field.name in dataWithLocales) {\n              const newValue = dataWithLocales[field.name]\n              const existingValue = docWithLocales[field.name] || {}\n\n              // If localized, handle locale keys\n              if (newValue && typeof newValue === 'object' && !Array.isArray(newValue)) {\n                const merged: Record<string, unknown> = { ...existingValue }\n\n                for (const locale of selectedLocales) {\n                  if (locale in newValue) {\n                    merged[locale] = newValue[locale]\n                  }\n                }\n\n                result[field.name] = merged\n              } else if (parentIsLocalized) {\n                // Child of localized parent - replace with new value\n                result[field.name] = newValue\n              } else {\n                // Preserve existing value if new value is not a valid object\n                result[field.name] = existingValue\n              }\n            }\n          } else if (parentIsLocalized) {\n            result[field.name] = dataWithLocales[field.name]\n          } else {\n            result[field.name] =\n              field.name in dataWithLocales\n                ? dataWithLocales[field.name]\n                : docWithLocales[field.name]\n          }\n          break\n        }\n      }\n    } else {\n      // Layout-only fields that don't affect data structure\n      switch (field.type) {\n        case 'collapsible':\n        case 'row': {\n          // These pass through the same data level\n          const merged = mergeLocalizedData({\n            configBlockReferences,\n            dataWithLocales,\n            docWithLocales: result, // Use current result to avoid re-processing already-handled fields\n            fields: field.fields,\n            parentIsLocalized,\n            selectedLocales,\n          })\n          Object.assign(result, merged)\n          break\n        }\n\n        case 'tabs': {\n          for (const tab of field.tabs) {\n            if (tabHasName(tab)) {\n              // Named tabs create a nested data structure and can be localized\n              const tabIsLocalized = fieldShouldBeLocalized({ field: tab, parentIsLocalized })\n\n              if (tab.name in dataWithLocales) {\n                const newValue = dataWithLocales[tab.name]\n                const existingValue = docWithLocales[tab.name]\n\n                if (tabIsLocalized) {\n                  if (newValue && typeof newValue === 'object' && !Array.isArray(newValue)) {\n                    const merged: Record<string, unknown> = { ...(existingValue || {}) }\n\n                    for (const locale of selectedLocales) {\n                      if (locale in newValue && typeof newValue[locale] === 'object') {\n                        merged[locale] = newValue[locale]\n                      }\n                    }\n\n                    result[tab.name] = merged\n                  } else {\n                    // Preserve existing value if new value is not a valid object\n                    result[tab.name] = existingValue\n                  }\n                } else if (typeof newValue === 'object' && !Array.isArray(newValue)) {\n                  // Non-localized tab - still process children for any localized fields\n                  result[tab.name] = mergeLocalizedData({\n                    configBlockReferences,\n                    dataWithLocales: newValue as JsonObject,\n                    docWithLocales: existingValue || {},\n                    fields: tab.fields,\n                    parentIsLocalized,\n                    selectedLocales,\n                  })\n                }\n              }\n            } else {\n              // Unnamed tabs pass through the same data level\n              const merged = mergeLocalizedData({\n                configBlockReferences,\n                dataWithLocales,\n                docWithLocales: result, // Use current result to avoid re-processing already-handled fields\n                fields: tab.fields,\n                parentIsLocalized,\n                selectedLocales,\n              })\n              Object.assign(result, merged)\n            }\n          }\n          break\n        }\n      }\n    }\n  }\n\n  return result\n}\n"],"names":["fieldAffectsData","fieldShouldBeLocalized","tabHasName","mergeLocalizedData","configBlockReferences","dataWithLocales","docWithLocales","fields","parentIsLocalized","selectedLocales","result","field","name","fieldIsLocalized","type","newValue","existingValue","Array","isArray","updatedArray","locale","map","newItem","index","existingItem","updatedData","newBlockData","block","blockReferences","blockOrReference","find","b","slug","blockType","blocks","blockData","groupData","merged","Object","assign","tab","tabs","tabIsLocalized"],"mappings":"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"}},
    {"offset": {"line": 3709, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/utilities/flattenTopLevelFields.ts"],"sourcesContent":["import type { I18nClient } from '@payloadcms/translations'\n\nimport { getTranslation } from '@payloadcms/translations'\n\nimport type { ClientTab } from '../admin/fields/Tabs.js'\nimport type { ClientField } from '../fields/config/client.js'\nimport type {\n  Field,\n  FieldAffectingData,\n  FieldAffectingDataClient,\n  FieldPresentationalOnly,\n  FieldPresentationalOnlyClient,\n  Tab,\n} from '../fields/config/types.js'\n\nimport {\n  fieldAffectsData,\n  fieldHasSubFields,\n  fieldIsPresentationalOnly,\n  tabHasName,\n} from '../fields/config/types.js'\n\ntype FlattenedField<TField> = TField extends ClientField\n  ? { accessor?: string; labelWithPrefix?: string } & (\n      | FieldAffectingDataClient\n      | FieldPresentationalOnlyClient\n    )\n  : { accessor?: string; labelWithPrefix?: string } & (FieldAffectingData | FieldPresentationalOnly)\n\ntype TabType<TField> = TField extends ClientField ? ClientTab : Tab\n\n/**\n * Options to control how fields are flattened.\n */\ntype FlattenFieldsOptions = {\n  /**\n   * i18n context used for translating `label` values via `getTranslation`.\n   */\n  i18n?: I18nClient\n  /**\n   * If true, presentational-only fields (like UI fields) will be included\n   * in the output. Otherwise, they will be skipped.\n   * Default: false.\n   */\n  keepPresentationalFields?: boolean\n  /**\n   * A label prefix to prepend to translated labels when building `labelWithPrefix`.\n   * Used recursively when flattening nested fields.\n   */\n  labelPrefix?: string\n  /**\n   * If true, nested fields inside `group` & `tabs` fields will be lifted to the top level\n   * and given contextual `accessor` and `labelWithPrefix` values.\n   * Default: false.\n   */\n  moveSubFieldsToTop?: boolean\n  /**\n   * A path prefix to prepend to field names when building the `accessor`.\n   * Used recursively when flattening nested fields.\n   */\n  pathPrefix?: string\n}\n\n/**\n * Flattens a collection's fields into a single array of fields, optionally\n * extracting nested fields in group fields.\n *\n * @param fields - Array of fields to flatten\n * @param options - Options to control the flattening behavior\n */\nexport function flattenTopLevelFields<TField extends ClientField | Field>(\n  fields: TField[] = [],\n  options?: boolean | FlattenFieldsOptions,\n): FlattenedField<TField>[] {\n  const normalizedOptions: FlattenFieldsOptions =\n    typeof options === 'boolean' ? { keepPresentationalFields: options } : (options ?? {})\n\n  const {\n    i18n,\n    keepPresentationalFields,\n    labelPrefix,\n    moveSubFieldsToTop = false,\n    pathPrefix,\n  } = normalizedOptions\n\n  return fields.reduce<FlattenedField<TField>[]>((acc, field) => {\n    // If a group field has subfields and has a name, otherwise we catch it below along with collapsible and row fields\n    if (field.type === 'group' && 'fields' in field) {\n      if (moveSubFieldsToTop) {\n        const isNamedGroup = 'name' in field && typeof field.name === 'string' && !!field.name\n        const groupName = 'name' in field ? field.name : undefined\n\n        const translatedLabel =\n          'label' in field && field.label && i18n\n            ? getTranslation(field.label as string, i18n)\n            : undefined\n\n        const labelWithPrefix = labelPrefix\n          ? `${labelPrefix} > ${translatedLabel ?? groupName}`\n          : (translatedLabel ?? groupName)\n\n        const nameWithPrefix =\n          'name' in field && field.name\n            ? pathPrefix\n              ? `${pathPrefix}.${field.name}`\n              : field.name\n            : pathPrefix\n\n        acc.push(\n          // Need to include the top-level group field when hoisting its subfields,\n          // so that `buildColumnState` can detect and render a column if the group\n          // has a custom admin Cell component defined in its configuration.\n          // See: packages/ui/src/providers/TableColumns/buildColumnState/index.tsx\n          field as FlattenedField<TField>,\n          ...flattenTopLevelFields(field.fields as TField[], {\n            i18n,\n            keepPresentationalFields,\n            labelPrefix: isNamedGroup ? labelWithPrefix : labelPrefix,\n            moveSubFieldsToTop,\n            pathPrefix: isNamedGroup ? nameWithPrefix : pathPrefix,\n          }),\n        )\n      } else {\n        if (fieldAffectsData(field)) {\n          // Hoisting diabled - keep as top level field\n          acc.push(field as FlattenedField<TField>)\n        } else {\n          acc.push(...flattenTopLevelFields(field.fields as TField[], options))\n        }\n      }\n    } else if (field.type === 'tabs' && 'tabs' in field) {\n      return [\n        ...acc,\n        ...field.tabs.reduce<FlattenedField<TField>[]>((tabFields, tab) => {\n          if (tabHasName(tab)) {\n            if (moveSubFieldsToTop) {\n              const translatedLabel =\n                'label' in tab && tab.label && i18n ? getTranslation(tab.label, i18n) : undefined\n\n              const labelWithPrefixForTab = labelPrefix\n                ? `${labelPrefix} > ${translatedLabel ?? tab.name}`\n                : (translatedLabel ?? tab.name)\n\n              const pathPrefixForTab = tab.name\n                ? pathPrefix\n                  ? `${pathPrefix}.${tab.name}`\n                  : tab.name\n                : pathPrefix\n\n              return [\n                ...tabFields,\n                ...flattenTopLevelFields(tab.fields as TField[], {\n                  i18n,\n                  keepPresentationalFields,\n                  labelPrefix: labelWithPrefixForTab,\n                  moveSubFieldsToTop,\n                  pathPrefix: pathPrefixForTab,\n                }),\n              ]\n            } else {\n              // Named tab, hoisting disabled: keep as top-level field\n              return [\n                ...tabFields,\n                {\n                  ...tab,\n                  type: 'tab',\n                } as unknown as FlattenedField<TField>,\n              ]\n            }\n          } else {\n            // Unnamed tab: always hoist its fields\n            return [...tabFields, ...flattenTopLevelFields<TField>(tab.fields as TField[], options)]\n          }\n        }, []),\n      ]\n    } else if (fieldHasSubFields(field) && ['collapsible', 'row'].includes(field.type)) {\n      // Recurse into row and collapsible\n      acc.push(...flattenTopLevelFields(field.fields as TField[], options))\n    } else if (\n      fieldAffectsData(field) ||\n      (keepPresentationalFields && fieldIsPresentationalOnly(field))\n    ) {\n      // Ignore nested `id` fields when inside nested structure\n      if (field.name === 'id' && labelPrefix !== undefined) {\n        return acc\n      }\n\n      const translatedLabel =\n        'label' in field && field.label && i18n ? getTranslation(field.label, i18n) : undefined\n\n      const name = 'name' in field ? field.name : undefined\n\n      const isHoistingFromGroup = pathPrefix !== undefined || labelPrefix !== undefined\n\n      acc.push({\n        ...(field as FlattenedField<TField>),\n        ...(moveSubFieldsToTop &&\n          isHoistingFromGroup && {\n            accessor: pathPrefix && name ? `${pathPrefix}.${name}` : (name ?? ''),\n            labelWithPrefix: labelPrefix\n              ? `${labelPrefix} > ${translatedLabel ?? name}`\n              : (translatedLabel ?? name),\n          }),\n      })\n    }\n\n    return acc\n  }, [])\n}\n"],"names":["getTranslation","fieldAffectsData","fieldHasSubFields","fieldIsPresentationalOnly","tabHasName","flattenTopLevelFields","fields","options","normalizedOptions","keepPresentationalFields","i18n","labelPrefix","moveSubFieldsToTop","pathPrefix","reduce","acc","field","type","isNamedGroup","name","groupName","undefined","translatedLabel","label","labelWithPrefix","nameWithPrefix","push","tabs","tabFields","tab","labelWithPrefixForTab","pathPrefixForTab","includes","isHoistingFromGroup","accessor"],"mappings":"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"}},
    {"offset": {"line": 3816, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/utilities/extractID.ts"],"sourcesContent":["export const extractID = <IDType extends number | string>(\n  objectOrID: { id: IDType } | IDType,\n): IDType => {\n  if (typeof objectOrID === 'string' || typeof objectOrID === 'number') {\n    return objectOrID\n  }\n\n  return objectOrID.id\n}\n"],"names":["extractID","objectOrID","id"],"mappings":";;;;AAAO,MAAMA,YAAY,CACvBC;IAEA,IAAI,OAAOA,eAAe,YAAY,OAAOA,eAAe,UAAU;QACpE,OAAOA;IACT;IAEA,OAAOA,WAAWC,EAAE;AACtB,EAAC"}},
    {"offset": {"line": 3830, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/utilities/transformWhereQuery.ts"],"sourcesContent":["import type { Where } from '../types/index.js'\n\n/**\n * Transforms a basic \"where\" query into a format in which the \"where builder\" can understand.\n * Even though basic queries are valid, we need to hoist them into the \"and\" / \"or\" format.\n * Use this function alongside `validateWhereQuery` to check that for valid queries before transforming.\n * @example\n * Inaccurate: [text][equals]=example%20post\n * Accurate: [or][0][and][0][text][equals]=example%20post\n */\nexport const transformWhereQuery = (whereQuery: Where): Where => {\n  if (!whereQuery) {\n    return {}\n  }\n\n  // Check if 'whereQuery' has 'or' field but no 'and'. This is the case for \"correct\" queries\n  if (whereQuery.or && !whereQuery.and) {\n    return {\n      or: whereQuery.or.map((query) => {\n        // ...but if the or query does not have an and, we need to add it\n        if (!query.and) {\n          return {\n            and: [query],\n          }\n        }\n        return query\n      }),\n    }\n  }\n\n  // Check if 'whereQuery' has 'and' field but no 'or'.\n  if (whereQuery.and && !whereQuery.or) {\n    return {\n      or: [\n        {\n          and: whereQuery.and,\n        },\n      ],\n    }\n  }\n\n  // Check if 'whereQuery' has neither 'or' nor 'and'.\n  if (!whereQuery.or && !whereQuery.and) {\n    return {\n      or: [\n        {\n          and: [whereQuery], // top-level siblings are considered 'and'\n        },\n      ],\n    }\n  }\n\n  // If 'whereQuery' has 'or' and 'and', just return it as it is.\n  return whereQuery\n}\n"],"names":["transformWhereQuery","whereQuery","or","and","map","query"],"mappings":"AAEA;;;;;;;CAOC,GACD;;;;AAAO,MAAMA,sBAAsB,CAACC;IAClC,IAAI,CAACA,YAAY;QACf,OAAO,CAAC;IACV;IAEA,4FAA4F;IAC5F,IAAIA,WAAWC,EAAE,IAAI,CAACD,WAAWE,GAAG,EAAE;QACpC,OAAO;YACLD,IAAID,WAAWC,EAAE,CAACE,GAAG,CAAC,CAACC;gBACrB,iEAAiE;gBACjE,IAAI,CAACA,MAAMF,GAAG,EAAE;oBACd,OAAO;wBACLA,KAAK;4BAACE;yBAAM;oBACd;gBACF;gBACA,OAAOA;YACT;QACF;IACF;IAEA,qDAAqD;IACrD,IAAIJ,WAAWE,GAAG,IAAI,CAACF,WAAWC,EAAE,EAAE;QACpC,OAAO;YACLA,IAAI;gBACF;oBACEC,KAAKF,WAAWE,GAAG;gBACrB;aACD;QACH;IACF;IAEA,oDAAoD;IACpD,IAAI,CAACF,WAAWC,EAAE,IAAI,CAACD,WAAWE,GAAG,EAAE;QACrC,OAAO;YACLD,IAAI;gBACF;oBACEC,KAAK;wBAACF;qBAAW;gBACnB;aACD;QACH;IACF;IAEA,+DAA+D;IAC/D,OAAOA;AACT,EAAC"}},
    {"offset": {"line": 3890, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/utilities/validateWhereQuery.ts"],"sourcesContent":["import type { Operator, Where } from '../types/index.js'\n\nimport { validOperatorSet } from '../types/constants.js'\n\n/**\n * Validates that a \"where\" query is in a format in which the \"where builder\" can understand.\n * Even though basic queries are valid, we need to hoist them into the \"and\" / \"or\" format.\n * Use this function alongside `transformWhereQuery` to perform a transformation if the query is not valid.\n * @example\n * Inaccurate: [text][equals]=example%20post\n * Accurate: [or][0][and][0][text][equals]=example%20post\n */\nexport const validateWhereQuery = (whereQuery: Where): whereQuery is Where => {\n  if (\n    whereQuery?.or &&\n    (whereQuery?.or?.length === 0 ||\n      (whereQuery?.or?.length > 0 &&\n        whereQuery?.or?.[0]?.and &&\n        whereQuery?.or?.[0]?.and?.length > 0))\n  ) {\n    // At this point we know that the whereQuery has 'or' and 'and' fields,\n    // now let's check the structure and content of these fields.\n\n    const isValid = whereQuery.or.every((orQuery) => {\n      if (orQuery.and && Array.isArray(orQuery.and)) {\n        return orQuery.and.every((andQuery) => {\n          if (typeof andQuery !== 'object') {\n            return false\n          }\n\n          const andKeys = Object.keys(andQuery)\n\n          // If there are no keys, it's not a valid WhereField.\n          if (andKeys.length === 0) {\n            return false\n          }\n\n          for (const key of andKeys) {\n            const operator = Object.keys(andQuery[key]!)[0]\n            // Check if the key is a valid Operator.\n            if (!operator || !validOperatorSet.has(operator as Operator)) {\n              return false\n            }\n          }\n          return true\n        })\n      }\n      return false\n    })\n\n    return isValid\n  }\n\n  return false\n}\n"],"names":["validOperatorSet","validateWhereQuery","whereQuery","or","length","and","isValid","every","orQuery","Array","isArray","andQuery","andKeys","Object","keys","key","operator","has"],"mappings":";;;;AAEA,SAASA,gBAAgB,QAAQ,wBAAuB;;AAUjD,MAAMC,qBAAqB,CAACC;IACjC,IACEA,YAAYC,MACXD,CAAAA,YAAYC,IAAIC,WAAW,KACzBF,YAAYC,IAAIC,SAAS,KACxBF,YAAYC,IAAI,CAAC,EAAE,EAAEE,OACrBH,YAAYC,IAAI,CAAC,EAAE,EAAEE,KAAKD,SAAS,CAAC,GACxC;QACA,uEAAuE;QACvE,6DAA6D;QAE7D,MAAME,UAAUJ,WAAWC,EAAE,CAACI,KAAK,CAAC,CAACC;YACnC,IAAIA,QAAQH,GAAG,IAAII,MAAMC,OAAO,CAACF,QAAQH,GAAG,GAAG;gBAC7C,OAAOG,QAAQH,GAAG,CAACE,KAAK,CAAC,CAACI;oBACxB,IAAI,OAAOA,aAAa,UAAU;wBAChC,OAAO;oBACT;oBAEA,MAAMC,UAAUC,OAAOC,IAAI,CAACH;oBAE5B,qDAAqD;oBACrD,IAAIC,QAAQR,MAAM,KAAK,GAAG;wBACxB,OAAO;oBACT;oBAEA,KAAK,MAAMW,OAAOH,QAAS;wBACzB,MAAMI,WAAWH,OAAOC,IAAI,CAACH,QAAQ,CAACI,IAAI,CAAE,CAAC,EAAE;wBAC/C,wCAAwC;wBACxC,IAAI,CAACC,YAAY,CAAChB,2KAAAA,CAAiBiB,GAAG,CAACD,WAAuB;4BAC5D,OAAO;wBACT;oBACF;oBACA,OAAO;gBACT;YACF;YACA,OAAO;QACT;QAEA,OAAOV;IACT;IAEA,OAAO;AACT,EAAC"}},
    {"offset": {"line": 3931, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/utilities/createLocalReq.ts"],"sourcesContent":["import type { Payload, RequestContext, TypedLocale, TypedUser } from '../index.js'\nimport type { PayloadRequest } from '../types/index.js'\n\nimport { getDataLoader } from '../collections/dataloader.js'\nimport { getLocalI18n } from '../translations/getLocalI18n.js'\nimport { sanitizeFallbackLocale } from '../utilities/sanitizeFallbackLocale.js'\n\nfunction getRequestContext(\n  req: Partial<PayloadRequest> = { context: null } as unknown as PayloadRequest,\n  context: RequestContext = {},\n): RequestContext {\n  if (req.context) {\n    if (Object.keys(req.context).length === 0 && req.context.constructor === Object) {\n      // if req.context is `{}` avoid unnecessary spread\n      return context\n    } else {\n      return { ...req.context, ...context }\n    }\n  } else {\n    return context\n  }\n}\n\nconst attachFakeURLProperties = (req: Partial<PayloadRequest>, urlSuffix?: string) => {\n  /**\n   * *NOTE*\n   * If no URL is provided, the local API was called outside\n   * the context of a request. Therefore we create a fake URL object.\n   * `ts-expect-error` is used below for properties that are 'read-only'.\n   * Since they do not exist yet we can safely ignore the error.\n   */\n  let urlObject: undefined | URL\n\n  function getURLObject() {\n    if (urlObject) {\n      return urlObject\n    }\n\n    const fallbackURL = `http://${req.host || 'localhost'}${urlSuffix || ''}`\n\n    const urlToUse =\n      req?.url ||\n      (req.payload?.config?.serverURL\n        ? `${req.payload?.config.serverURL}${urlSuffix || ''}`\n        : fallbackURL)\n\n    try {\n      urlObject = new URL(urlToUse)\n    } catch (_err) {\n      req.payload?.logger.error(\n        `Failed to create URL object from URL: ${urlToUse}, falling back to ${fallbackURL}`,\n      )\n\n      urlObject = new URL(fallbackURL)\n    }\n\n    return urlObject\n  }\n\n  if (!req.host) {\n    req.host = getURLObject().host\n  }\n\n  if (!req.protocol) {\n    req.protocol = getURLObject().protocol\n  }\n\n  if (!req.pathname) {\n    req.pathname = getURLObject().pathname\n  }\n\n  if (!req.searchParams) {\n    // @ts-expect-error eslint-disable-next-line no-param-reassign\n    req.searchParams = getURLObject().searchParams\n  }\n\n  if (!req.origin) {\n    // @ts-expect-error eslint-disable-next-line no-param-reassign\n    req.origin = getURLObject().origin\n  }\n\n  if (!req?.url) {\n    // @ts-expect-error eslint-disable-next-line no-param-reassign\n    req.url = getURLObject().href\n  }\n}\n\nexport type CreateLocalReqOptions = {\n  context?: RequestContext\n  fallbackLocale?: false | TypedLocale\n  locale?: string\n  req?: Partial<PayloadRequest>\n  urlSuffix?: string\n  user?: TypedUser\n}\n\ntype CreateLocalReq = (options: CreateLocalReqOptions, payload: Payload) => Promise<PayloadRequest>\n\nexport const createLocalReq: CreateLocalReq = async (\n  { context, fallbackLocale, locale: localeArg, req = {} as PayloadRequest, urlSuffix, user },\n  payload,\n): Promise<PayloadRequest> => {\n  const localization = payload.config?.localization\n\n  if (localization) {\n    const locale = localeArg === '*' ? 'all' : localeArg\n    const defaultLocale = localization.defaultLocale\n    const localeCandidate = locale || req?.locale || req?.query?.locale\n\n    req.locale =\n      localeCandidate && typeof localeCandidate === 'string' ? localeCandidate : defaultLocale\n\n    const sanitizedFallback = sanitizeFallbackLocale({\n      fallbackLocale: fallbackLocale!,\n      locale: req.locale,\n      localization,\n    })\n\n    req.fallbackLocale = sanitizedFallback!\n  }\n\n  const i18n =\n    req?.i18n ||\n    (await getLocalI18n({ config: payload.config, language: payload.config.i18n.fallbackLanguage }))\n\n  if (!req.headers) {\n    req.headers = new Headers()\n  }\n\n  req.context = getRequestContext(req, context)\n  req.payloadAPI = req?.payloadAPI || 'local'\n  req.payload = payload\n  req.i18n = i18n\n  req.t = i18n.t\n  req.user = user || req?.user || null\n  req.payloadDataLoader = req?.payloadDataLoader || getDataLoader(req as PayloadRequest)\n  req.routeParams = req?.routeParams || {}\n  req.query = req?.query || {}\n\n  attachFakeURLProperties(req, urlSuffix)\n\n  return req as PayloadRequest\n}\n"],"names":["getDataLoader","getLocalI18n","sanitizeFallbackLocale","getRequestContext","req","context","Object","keys","length","attachFakeURLProperties","urlSuffix","urlObject","getURLObject","fallbackURL","host","urlToUse","url","payload","config","serverURL","URL","_err","logger","error","protocol","pathname","searchParams","origin","href","createLocalReq","fallbackLocale","locale","localeArg","user","localization","defaultLocale","localeCandidate","query","sanitizedFallback","i18n","language","fallbackLanguage","headers","Headers","payloadAPI","t","payloadDataLoader","routeParams"],"mappings":"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"}},
    {"offset": {"line": 4039, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/utilities/traverseFields.ts"],"sourcesContent":["import type { Config, SanitizedConfig } from '../config/types.js'\nimport type { ArrayField, Block, BlocksField, Field, TabAsField } from '../fields/config/types.js'\n\nimport {\n  fieldAffectsData,\n  fieldHasSubFields,\n  fieldShouldBeLocalized,\n  tabHasName,\n} from '../fields/config/types.js'\n\nconst traverseArrayOrBlocksField = ({\n  callback,\n  callbackStack,\n  config,\n  data,\n  field,\n  fillEmpty,\n  leavesFirst,\n  parentIsLocalized,\n  parentPath,\n  parentRef,\n}: {\n  callback: TraverseFieldsCallback\n  callbackStack: (() => ReturnType<TraverseFieldsCallback>)[]\n  config?: Config | SanitizedConfig\n  data: Record<string, unknown>[]\n  field: ArrayField | BlocksField\n  fillEmpty: boolean\n  leavesFirst: boolean\n  parentIsLocalized: boolean\n  parentPath: string\n  parentRef?: unknown\n}) => {\n  if (fillEmpty) {\n    if (field.type === 'array') {\n      traverseFields({\n        callback,\n        callbackStack,\n        config,\n        fields: field.fields,\n        isTopLevel: false,\n        leavesFirst,\n        parentIsLocalized: parentIsLocalized || field.localized,\n        parentPath: `${parentPath}${field.name}.`,\n        parentRef,\n      })\n    }\n    if (field.type === 'blocks') {\n      for (const _block of field.blockReferences ?? field.blocks) {\n        // TODO: iterate over blocks mapped to block slug in v4, or pass through payload.blocks\n        const block =\n          typeof _block === 'string' ? config?.blocks?.find((b) => b.slug === _block) : _block\n        if (block) {\n          traverseFields({\n            callback,\n            callbackStack,\n            config,\n            fields: block.fields,\n            isTopLevel: false,\n            leavesFirst,\n            parentIsLocalized: parentIsLocalized || field.localized,\n            parentPath: `${parentPath}${field.name}.`,\n            parentRef,\n          })\n        }\n      }\n    }\n    return\n  }\n  for (const ref of data) {\n    let fields!: Field[]\n    if (field.type === 'blocks' && typeof ref?.blockType === 'string') {\n      // TODO: iterate over blocks mapped to block slug in v4, or pass through payload.blocks\n      const block = field.blockReferences\n        ? ((config?.blocks?.find((b) => b.slug === ref.blockType) ??\n            field.blockReferences.find(\n              (b) => typeof b !== 'string' && b.slug === ref.blockType,\n            )) as Block)\n        : field.blocks.find((b) => b.slug === ref.blockType)\n\n      fields = block?.fields as Field[]\n    } else if (field.type === 'array') {\n      fields = field.fields\n    }\n\n    if (fields) {\n      traverseFields({\n        callback,\n        callbackStack,\n        config,\n        fields,\n        fillEmpty,\n        isTopLevel: false,\n        leavesFirst,\n        parentIsLocalized: parentIsLocalized || field.localized,\n        parentPath: `${parentPath}${field.name}.`,\n        parentRef,\n        ref,\n      })\n    }\n  }\n}\n\nexport type TraverseFieldsCallback = (args: {\n  /**\n   * The current field\n   */\n  field: Field | TabAsField\n  /**\n   * Function that when called will skip the current field and continue to the next\n   */\n  next?: () => void\n  parentIsLocalized: boolean\n  parentPath: string\n  /**\n   * The parent reference object\n   */\n  parentRef?: Record<string, unknown> | unknown\n  /**\n   * The current reference object\n   */\n  ref?: Record<string, unknown> | unknown\n}) => boolean | void\n\ntype TraverseFieldsArgs = {\n  callback: TraverseFieldsCallback\n  callbackStack?: (() => ReturnType<TraverseFieldsCallback>)[]\n  config?: Config | SanitizedConfig\n  fields: (Field | TabAsField)[]\n  fillEmpty?: boolean\n  isTopLevel?: boolean\n  /**\n   * @default false\n   *\n   * if this is `true`, the callback functions of the leaf fields will be called before the parent fields.\n   * The return value of the callback function will be ignored.\n   */\n  leavesFirst?: boolean\n  parentIsLocalized?: boolean\n  parentPath?: string\n  parentRef?: Record<string, unknown> | unknown\n  ref?: Record<string, unknown> | unknown\n}\n\n/**\n * Iterate a recurse an array of fields, calling a callback for each field\n *\n * @param fields\n * @param callback callback called for each field, discontinue looping if callback returns truthy\n * @param fillEmpty fill empty properties to use this without data\n * @param ref the data or any artifacts assigned in the callback during field recursion\n * @param parentRef the data or any artifacts assigned in the callback during field recursion one level up\n */\nexport const traverseFields = ({\n  callback,\n  callbackStack: _callbackStack = [],\n  config,\n  fields,\n  fillEmpty = true,\n  isTopLevel = true,\n  leavesFirst = false,\n  parentIsLocalized,\n  parentPath = '',\n  parentRef = {},\n  ref = {},\n}: TraverseFieldsArgs): void => {\n  const fieldsMatched = fields.some((field) => {\n    let callbackStack: (() => ReturnType<TraverseFieldsCallback>)[] = []\n    if (!isTopLevel) {\n      callbackStack = _callbackStack\n    }\n    let skip = false\n    const next = () => {\n      skip = true\n    }\n\n    if (!ref || typeof ref !== 'object') {\n      return\n    }\n\n    if (\n      !leavesFirst &&\n      callback &&\n      callback({ field, next, parentIsLocalized: parentIsLocalized!, parentPath, parentRef, ref })\n    ) {\n      return true\n    } else if (leavesFirst) {\n      callbackStack.push(() =>\n        callback({\n          field,\n          next,\n          parentIsLocalized: parentIsLocalized!,\n          parentPath,\n          parentRef,\n          ref,\n        }),\n      )\n    }\n\n    if (skip) {\n      return false\n    }\n\n    // avoid mutation of ref for all fields\n    let currentRef = ref\n    let currentParentRef = parentRef\n\n    if (field.type === 'tabs' && 'tabs' in field) {\n      for (const tab of field.tabs) {\n        let tabRef = ref\n\n        if (skip) {\n          return false\n        }\n\n        if ('name' in tab && tab.name) {\n          if (\n            !ref[tab.name as keyof typeof ref] ||\n            typeof ref[tab.name as keyof typeof ref] !== 'object'\n          ) {\n            if (fillEmpty) {\n              if (tab.localized) {\n                ;(ref as Record<string, any>)[tab.name] = { en: {} }\n              } else {\n                ;(ref as Record<string, any>)[tab.name] = {}\n              }\n            } else {\n              continue\n            }\n          }\n\n          if (\n            callback &&\n            !leavesFirst &&\n            callback({\n              field: { ...tab, type: 'tab' },\n              next,\n              parentIsLocalized: parentIsLocalized!,\n              parentPath,\n              parentRef: currentParentRef,\n              ref: tabRef,\n            })\n          ) {\n            return true\n          } else if (leavesFirst) {\n            callbackStack.push(() =>\n              callback({\n                field: { ...tab, type: 'tab' },\n                next,\n                parentIsLocalized: parentIsLocalized!,\n                parentPath,\n                parentRef: currentParentRef,\n                ref: tabRef,\n              }),\n            )\n          }\n\n          tabRef = tabRef[tab.name as keyof typeof tabRef]\n\n          if (tab.localized) {\n            for (const key in tabRef as Record<string, unknown>) {\n              if (\n                tabRef[key as keyof typeof tabRef] &&\n                typeof tabRef[key as keyof typeof tabRef] === 'object'\n              ) {\n                traverseFields({\n                  callback,\n                  callbackStack,\n                  config,\n                  fields: tab.fields,\n                  fillEmpty,\n                  isTopLevel: false,\n                  leavesFirst,\n                  parentIsLocalized: true,\n                  parentPath: `${parentPath}${tab.name}.`,\n                  parentRef: currentParentRef,\n                  ref: tabRef[key as keyof typeof tabRef],\n                })\n              }\n            }\n          }\n        } else {\n          if (\n            callback &&\n            !leavesFirst &&\n            callback({\n              field: { ...tab, type: 'tab' },\n              next,\n              parentIsLocalized: parentIsLocalized!,\n              parentPath,\n              parentRef: currentParentRef,\n              ref: tabRef,\n            })\n          ) {\n            return true\n          } else if (leavesFirst) {\n            callbackStack.push(() =>\n              callback({\n                field: { ...tab, type: 'tab' },\n                next,\n                parentIsLocalized: parentIsLocalized!,\n                parentPath,\n                parentRef: currentParentRef,\n                ref: tabRef,\n              }),\n            )\n          }\n        }\n\n        if (!tab.localized) {\n          traverseFields({\n            callback,\n            callbackStack,\n            config,\n            fields: tab.fields,\n            fillEmpty,\n            isTopLevel: false,\n            leavesFirst,\n            parentIsLocalized: false,\n            parentPath: tabHasName(tab) ? `${parentPath}${tab.name}.` : parentPath,\n            parentRef: currentParentRef,\n            ref: tabRef,\n          })\n        }\n\n        if (skip) {\n          return false\n        }\n      }\n\n      return\n    }\n\n    if (field.type === 'tab' || fieldHasSubFields(field) || field.type === 'blocks') {\n      if ('name' in field && field.name) {\n        currentParentRef = currentRef\n        if (!ref[field.name as keyof typeof ref]) {\n          if (fillEmpty) {\n            if (field.type === 'group' || field.type === 'tab') {\n              if (fieldShouldBeLocalized({ field, parentIsLocalized: parentIsLocalized! })) {\n                ;(ref as Record<string, any>)[field.name] = { en: {} }\n              } else {\n                ;(ref as Record<string, any>)[field.name] = {}\n              }\n            } else if (field.type === 'array' || field.type === 'blocks') {\n              if (fieldShouldBeLocalized({ field, parentIsLocalized: parentIsLocalized! })) {\n                ;(ref as Record<string, any>)[field.name] = { en: [] }\n              } else {\n                ;(ref as Record<string, any>)[field.name] = []\n              }\n            }\n          } else {\n            return\n          }\n        }\n        currentRef = ref[field.name as keyof typeof ref]\n      }\n\n      if (\n        (field.type === 'tab' || field.type === 'group') &&\n        fieldShouldBeLocalized({ field, parentIsLocalized: parentIsLocalized! }) &&\n        currentRef &&\n        typeof currentRef === 'object'\n      ) {\n        if (fieldAffectsData(field)) {\n          for (const key in currentRef as Record<string, unknown>) {\n            if (currentRef[key as keyof typeof currentRef]) {\n              traverseFields({\n                callback,\n                callbackStack,\n                config,\n                fields: field.fields,\n                fillEmpty,\n                isTopLevel: false,\n                leavesFirst,\n                parentIsLocalized: true,\n                parentPath: field.name ? `${parentPath}${field.name}.` : parentPath,\n                parentRef: currentParentRef,\n                ref: currentRef[key as keyof typeof currentRef],\n              })\n            }\n          }\n        } else {\n          traverseFields({\n            callback,\n            callbackStack,\n            config,\n            fields: field.fields,\n            fillEmpty,\n            isTopLevel: false,\n            leavesFirst,\n            parentIsLocalized,\n            parentRef: currentParentRef,\n            ref: currentRef,\n          })\n        }\n\n        return\n      }\n\n      if (\n        (field.type === 'blocks' || field.type === 'array') &&\n        currentRef &&\n        typeof currentRef === 'object'\n      ) {\n        // TODO: `?? field.localized ?? false` shouldn't be necessary, but right now it\n        // is so that all fields are correctly traversed in copyToLocale and\n        // therefore pass the localization integration tests.\n        // I tried replacing the `!parentIsLocalized` condition with `parentIsLocalized === false`\n        // in `fieldShouldBeLocalized`, but several tests failed. We must be calling it with incorrect\n        // parameters somewhere.\n        if (\n          fieldShouldBeLocalized({\n            field,\n            parentIsLocalized: parentIsLocalized ?? false,\n          })\n        ) {\n          if (Array.isArray(currentRef)) {\n            traverseArrayOrBlocksField({\n              callback,\n              callbackStack,\n              config,\n              data: currentRef,\n              field,\n              fillEmpty,\n              leavesFirst,\n              parentIsLocalized: true,\n              parentPath,\n              parentRef: currentParentRef,\n            })\n          } else {\n            for (const key in currentRef as Record<string, unknown>) {\n              const localeData = currentRef[key as keyof typeof currentRef]\n              if (!Array.isArray(localeData)) {\n                continue\n              }\n\n              traverseArrayOrBlocksField({\n                callback,\n                callbackStack,\n                config,\n                data: localeData,\n                field,\n                fillEmpty,\n                leavesFirst,\n                parentIsLocalized: true,\n                parentPath,\n                parentRef: currentParentRef,\n              })\n            }\n          }\n        } else if (Array.isArray(currentRef)) {\n          traverseArrayOrBlocksField({\n            callback,\n            callbackStack,\n            config,\n            data: currentRef as Record<string, unknown>[],\n            field,\n            fillEmpty,\n            leavesFirst,\n            parentIsLocalized: parentIsLocalized!,\n            parentPath,\n            parentRef: currentParentRef,\n          })\n        }\n      } else if (currentRef && typeof currentRef === 'object' && 'fields' in field) {\n        traverseFields({\n          callback,\n          callbackStack,\n          config,\n          fields: field.fields,\n          fillEmpty,\n          isTopLevel: false,\n          leavesFirst,\n          parentIsLocalized,\n          parentPath: 'name' in field && field.name ? `${parentPath}${field.name}.` : parentPath,\n          parentRef: currentParentRef,\n          ref: currentRef,\n        })\n      }\n    }\n\n    if (isTopLevel) {\n      callbackStack.reverse().forEach((cb) => {\n        cb()\n      })\n    }\n  })\n\n  // Fallback: Handle dot-notation paths when no fields matched\n  if (!fieldsMatched && ref && typeof ref === 'object') {\n    Object.keys(ref).forEach((key) => {\n      if (key.includes('.')) {\n        // Split on first dot only\n        const firstDotIndex = key.indexOf('.')\n        const fieldName = key.substring(0, firstDotIndex)\n        const remainingPath = key.substring(firstDotIndex + 1)\n\n        // Create nested structure for this field\n        if (!ref[fieldName as keyof typeof ref]) {\n          ;(ref as Record<string, unknown>)[fieldName] = {}\n        }\n\n        const nestedRef = ref[fieldName as keyof typeof ref] as Record<string, unknown>\n\n        // Move the value to the nested structure\n        nestedRef[remainingPath] = (ref as Record<string, unknown>)[key]\n        delete (ref as Record<string, unknown>)[key]\n\n        // Recursively process the newly created nested structure\n        // The field traversal will naturally handle it if the field exists in the schema\n        traverseFields({\n          callback,\n          callbackStack: _callbackStack,\n          config,\n          fields,\n          fillEmpty,\n          isTopLevel: false,\n          leavesFirst,\n          parentIsLocalized,\n          parentPath,\n          parentRef,\n          ref,\n        })\n      }\n    })\n  }\n}\n"],"names":["fieldAffectsData","fieldHasSubFields","fieldShouldBeLocalized","tabHasName","traverseArrayOrBlocksField","callback","callbackStack","config","data","field","fillEmpty","leavesFirst","parentIsLocalized","parentPath","parentRef","type","traverseFields","fields","isTopLevel","localized","name","_block","blockReferences","blocks","block","find","b","slug","ref","blockType","_callbackStack","fieldsMatched","some","skip","next","push","currentRef","currentParentRef","tab","tabs","tabRef","en","key","Array","isArray","localeData","reverse","forEach","cb","Object","keys","includes","firstDotIndex","indexOf","fieldName","substring","remainingPath","nestedRef"],"mappings":"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"}},
    {"offset": {"line": 4456, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/utilities/createArrayFromCommaDelineated.ts"],"sourcesContent":["export function createArrayFromCommaDelineated(input: string): string[] {\n  if (Array.isArray(input)) {\n    return input\n  }\n\n  return input.split(',')\n}\n"],"names":["createArrayFromCommaDelineated","input","Array","isArray","split"],"mappings":";;;;AAAO,SAASA,+BAA+BC,KAAa;IAC1D,IAAIC,MAAMC,OAAO,CAACF,QAAQ;QACxB,OAAOA;IACT;IAEA,OAAOA,MAAMG,KAAK,CAAC;AACrB"}}]
}