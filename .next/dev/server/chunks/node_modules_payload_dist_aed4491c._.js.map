{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/errors/APIError.ts"],"sourcesContent":["import { status as httpStatus } from 'http-status'\n\n// This gets dynamically reassigned during compilation\nexport let APIErrorName = 'APIError'\n\nclass ExtendableError<TData extends object = { [key: string]: unknown }> extends Error {\n  data: TData\n\n  isOperational: boolean\n\n  isPublic: boolean\n\n  status: number\n\n  constructor(message: string, status: number, data: TData, isPublic: boolean) {\n    super(message, {\n      // show data in cause\n      cause: data,\n    })\n    APIErrorName = this.constructor.name\n    this.name = this.constructor.name\n    this.message = message\n    this.status = status\n    this.data = data\n    this.isPublic = isPublic\n    this.isOperational = true // This is required since bluebird 4 doesn't append it anymore.\n    Error.captureStackTrace(this, this.constructor)\n  }\n}\n\n/**\n * Class representing an API error.\n * @extends ExtendableError\n */\nexport class APIError<\n  TData extends null | object = { [key: string]: unknown } | null,\n  // @ts-expect-error - vestiges of when tsconfig was not strict. Feel free to improve\n> extends ExtendableError<TData> {\n  /**\n   * Creates an API error.\n   * @param {string} message - Error message.\n   * @param {number} status - HTTP status code of error.\n   * @param {object} data - response data to be returned.\n   * @param {boolean} isPublic - Whether the message should be visible to user or not.\n   */\n  constructor(\n    message: string,\n    status: number = httpStatus.INTERNAL_SERVER_ERROR,\n    data: TData = null!,\n    isPublic?: boolean,\n  ) {\n    super(\n      message,\n      status,\n      data,\n      typeof isPublic === 'boolean' ? isPublic : status !== httpStatus.INTERNAL_SERVER_ERROR,\n    )\n  }\n}\n"],"names":["status","httpStatus","APIErrorName","ExtendableError","Error","data","isOperational","isPublic","message","cause","name","captureStackTrace","APIError","INTERNAL_SERVER_ERROR"],"mappings":";;;;;;;AAAA,SAASA,UAAUC,UAAU,QAAQ,cAAa;;AAG3C,IAAIC,eAAe,WAAU;AAEpC,MAAMC,wBAA2EC;IAC/EC,KAAW;IAEXC,cAAsB;IAEtBC,SAAiB;IAEjBP,OAAc;IAEd,YAAYQ,OAAe,EAAER,MAAc,EAAEK,IAAW,EAAEE,QAAiB,CAAE;QAC3E,KAAK,CAACC,SAAS;YACb,qBAAqB;YACrBC,OAAOJ;QACT;QACAH,eAAe,IAAI,CAAC,WAAW,CAACQ,IAAI;QACpC,IAAI,CAACA,IAAI,GAAG,IAAI,CAAC,WAAW,CAACA,IAAI;QACjC,IAAI,CAACF,OAAO,GAAGA;QACf,IAAI,CAACR,MAAM,GAAGA;QACd,IAAI,CAACK,IAAI,GAAGA;QACZ,IAAI,CAACE,QAAQ,GAAGA;QAChB,IAAI,CAACD,aAAa,GAAG,MAAK,+DAA+D;QACzFF,MAAMO,iBAAiB,CAAC,IAAI,EAAE,IAAI,CAAC,WAAW;IAChD;AACF;AAMO,MAAMC,iBAGHT;IACR;;;;;;GAMC,GACD,YACEK,OAAe,EACfR,SAAiBC,sMAAAA,CAAWY,qBAAqB,EACjDR,OAAc,IAAK,EACnBE,QAAkB,CAClB;QACA,KAAK,CACHC,SACAR,QACAK,MACA,OAAOE,aAAa,YAAYA,WAAWP,WAAWC,sMAAAA,CAAWY,qBAAqB;IAE1F;AACF"}},
    {"offset": {"line": 49, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/errors/Forbidden.ts"],"sourcesContent":["import type { TFunction } from '@payloadcms/translations'\n\nimport { en } from '@payloadcms/translations/languages/en'\nimport { status as httpStatus } from 'http-status'\n\nimport { APIError } from './APIError.js'\n\nexport class Forbidden extends APIError {\n  constructor(t?: TFunction) {\n    super(\n      t ? t('error:notAllowedToPerformAction') : en.translations.error.notAllowedToPerformAction,\n      httpStatus.FORBIDDEN,\n    )\n  }\n}\n"],"names":["en","status","httpStatus","APIError","Forbidden","t","translations","error","notAllowedToPerformAction","FORBIDDEN"],"mappings":";;;;AAEA,SAASA,EAAE,QAAQ,wCAAuC;;AAC1D,SAASC,UAAUC,UAAU,QAAQ,cAAa;AAElD,SAASC,QAAQ,QAAQ,gBAAe;;;;AAEjC,MAAMC,kBAAkBD,mKAAAA;IAC7B,YAAYE,CAAa,CAAE;QACzB,KAAK,CACHA,IAAIA,EAAE,qCAAqCL,+KAAAA,CAAGM,YAAY,CAACC,KAAK,CAACC,yBAAyB,EAC1FN,sMAAAA,CAAWO,SAAS;IAExB;AACF"}},
    {"offset": {"line": 69, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/errors/AuthenticationError.ts"],"sourcesContent":["import type { TFunction } from '@payloadcms/translations'\n\nimport { en } from '@payloadcms/translations/languages/en'\nimport { status as httpStatus } from 'http-status'\n\nimport { APIError } from './APIError.js'\n\nexport class AuthenticationError extends APIError {\n  constructor(t?: TFunction, loginWithUsername?: boolean) {\n    super(\n      t\n        ? `${loginWithUsername ? t('error:usernameOrPasswordIncorrect') : t('error:emailOrPasswordIncorrect')}`\n        : en.translations.error.emailOrPasswordIncorrect,\n      httpStatus.UNAUTHORIZED,\n    )\n  }\n}\n"],"names":["en","status","httpStatus","APIError","AuthenticationError","t","loginWithUsername","translations","error","emailOrPasswordIncorrect","UNAUTHORIZED"],"mappings":";;;;AAEA,SAASA,EAAE,QAAQ,wCAAuC;;AAC1D,SAASC,UAAUC,UAAU,QAAQ,cAAa;AAElD,SAASC,QAAQ,QAAQ,gBAAe;;;;AAEjC,MAAMC,4BAA4BD,mKAAAA;IACvC,YAAYE,CAAa,EAAEC,iBAA2B,CAAE;QACtD,KAAK,CACHD,IACI,GAAGC,oBAAoBD,EAAE,uCAAuCA,EAAE,mCAAmC,GACrGL,+KAAAA,CAAGO,YAAY,CAACC,KAAK,CAACC,wBAAwB,EAClDP,sMAAAA,CAAWQ,YAAY;IAE3B;AACF"}},
    {"offset": {"line": 89, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/errors/LockedAuth.ts"],"sourcesContent":["import type { TFunction } from '@payloadcms/translations'\n\nimport { en } from '@payloadcms/translations/languages/en'\nimport { status as httpStatus } from 'http-status'\n\nimport { APIError } from './APIError.js'\n\nexport class LockedAuth extends APIError {\n  constructor(t?: TFunction) {\n    super(t ? t('error:userLocked') : en.translations.error.userLocked, httpStatus.UNAUTHORIZED)\n  }\n}\n"],"names":["en","status","httpStatus","APIError","LockedAuth","t","translations","error","userLocked","UNAUTHORIZED"],"mappings":";;;;AAEA,SAASA,EAAE,QAAQ,wCAAuC;;AAC1D,SAASC,UAAUC,UAAU,QAAQ,cAAa;AAElD,SAASC,QAAQ,QAAQ,gBAAe;;;;AAEjC,MAAMC,mBAAmBD,mKAAAA;IAC9B,YAAYE,CAAa,CAAE;QACzB,KAAK,CAACA,IAAIA,EAAE,sBAAsBL,+KAAAA,CAAGM,YAAY,CAACC,KAAK,CAACC,UAAU,EAAEN,sMAAAA,CAAWO,YAAY;IAC7F;AACF"}},
    {"offset": {"line": 109, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/errors/UnverifiedEmail.ts"],"sourcesContent":["import type { TFunction } from '@payloadcms/translations'\n\nimport { en } from '@payloadcms/translations/languages/en'\nimport { status as httpStatus } from 'http-status'\n\nimport { APIError } from './APIError.js'\n\nexport class UnverifiedEmail extends APIError {\n  constructor({ t }: { t?: TFunction }) {\n    super(\n      t ? t('error:unverifiedEmail') : en.translations.error.unverifiedEmail,\n      httpStatus.FORBIDDEN,\n    )\n  }\n}\n"],"names":["en","status","httpStatus","APIError","UnverifiedEmail","t","translations","error","unverifiedEmail","FORBIDDEN"],"mappings":";;;;AAEA,SAASA,EAAE,QAAQ,wCAAuC;;AAC1D,SAASC,UAAUC,UAAU,QAAQ,cAAa;AAElD,SAASC,QAAQ,QAAQ,gBAAe;;;;AAEjC,MAAMC,wBAAwBD,mKAAAA;IACnC,YAAY,EAAEE,CAAC,EAAqB,CAAE;QACpC,KAAK,CACHA,IAAIA,EAAE,2BAA2BL,+KAAAA,CAAGM,YAAY,CAACC,KAAK,CAACC,eAAe,EACtEN,sMAAAA,CAAWO,SAAS;IAExB;AACF"}},
    {"offset": {"line": 129, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/errors/ValidationError.ts"],"sourcesContent":["import type { TFunction } from '@payloadcms/translations'\n\nimport { en } from '@payloadcms/translations/languages/en'\nimport { status as httpStatus } from 'http-status'\n\nimport type { LabelFunction, StaticLabel } from '../config/types.js'\nimport type { PayloadRequest } from '../types/index.js'\n\nimport { APIError } from './APIError.js'\n\n// This gets dynamically reassigned during compilation\nexport let ValidationErrorName = 'ValidationError'\n\nexport type ValidationFieldError = {\n  label?: LabelFunction | StaticLabel\n  // The error message to display for this field\n  message: string\n  path: string\n}\n\nexport class ValidationError extends APIError<{\n  collection?: string\n  errors: ValidationFieldError[]\n  global?: string\n}> {\n  constructor(\n    results: {\n      collection?: string\n      errors: ValidationFieldError[]\n      global?: string\n      id?: number | string\n      /**\n       *  req needs to be passed through (if you have one) in order to resolve label functions that may be part of the errors array\n       */\n      req?: Partial<PayloadRequest>\n    },\n    t?: TFunction,\n  ) {\n    const message = t\n      ? t('error:followingFieldsInvalid', { count: results.errors.length })\n      : results.errors.length === 1\n        ? en.translations.error.followingFieldsInvalid_one\n        : en.translations.error.followingFieldsInvalid_other\n\n    const req = results.req\n    // delete to avoid logging the whole req\n    delete results['req']\n\n    super(\n      `${message} ${results.errors\n        .map((f) => {\n          if (f.label) {\n            if (typeof f.label === 'function') {\n              if (!req || !req.i18n || !req.t) {\n                return f.path\n              }\n\n              return f.label({ i18n: req.i18n, t: req.t })\n            }\n\n            if (typeof f.label === 'object') {\n              if (req?.i18n?.language) {\n                return f.label[req.i18n.language]\n              }\n\n              return f.label[Object.keys(f.label)[0]!]\n            }\n\n            return f.label\n          }\n\n          return f.path\n        })\n        .join(', ')}`,\n      httpStatus.BAD_REQUEST,\n      results,\n    )\n\n    ValidationErrorName = this.constructor.name\n  }\n}\n"],"names":["en","status","httpStatus","APIError","ValidationErrorName","ValidationError","results","t","message","count","errors","length","translations","error","followingFieldsInvalid_one","followingFieldsInvalid_other","req","map","f","label","i18n","path","language","Object","keys","join","BAD_REQUEST","name"],"mappings":";;;;;;AAEA,SAASA,EAAE,QAAQ,wCAAuC;;AAC1D,SAASC,UAAUC,UAAU,QAAQ,cAAa;AAKlD,SAASC,QAAQ,QAAQ,gBAAe;;;;AAGjC,IAAIC,sBAAsB,kBAAiB;AAS3C,MAAMC,wBAAwBF,mKAAAA;IAKnC,YACEG,OASC,EACDC,CAAa,CACb;QACA,MAAMC,UAAUD,IACZA,EAAE,gCAAgC;YAAEE,OAAOH,QAAQI,MAAM,CAACC,MAAM;QAAC,KACjEL,QAAQI,MAAM,CAACC,MAAM,KAAK,IACxBX,+KAAAA,CAAGY,YAAY,CAACC,KAAK,CAACC,0BAA0B,GAChDd,+KAAAA,CAAGY,YAAY,CAACC,KAAK,CAACE,4BAA4B;QAExD,MAAMC,MAAMV,QAAQU,GAAG;QACvB,wCAAwC;QACxC,OAAOV,OAAO,CAAC,MAAM;QAErB,KAAK,CACH,GAAGE,QAAQ,CAAC,EAAEF,QAAQI,MAAM,CACzBO,GAAG,CAAC,CAACC;YACJ,IAAIA,EAAEC,KAAK,EAAE;gBACX,IAAI,OAAOD,EAAEC,KAAK,KAAK,YAAY;oBACjC,IAAI,CAACH,OAAO,CAACA,IAAII,IAAI,IAAI,CAACJ,IAAIT,CAAC,EAAE;wBAC/B,OAAOW,EAAEG,IAAI;oBACf;oBAEA,OAAOH,EAAEC,KAAK,CAAC;wBAAEC,MAAMJ,IAAII,IAAI;wBAAEb,GAAGS,IAAIT,CAAC;oBAAC;gBAC5C;gBAEA,IAAI,OAAOW,EAAEC,KAAK,KAAK,UAAU;oBAC/B,IAAIH,KAAKI,MAAME,UAAU;wBACvB,OAAOJ,EAAEC,KAAK,CAACH,IAAII,IAAI,CAACE,QAAQ,CAAC;oBACnC;oBAEA,OAAOJ,EAAEC,KAAK,CAACI,OAAOC,IAAI,CAACN,EAAEC,KAAK,CAAC,CAAC,EAAE,CAAE;gBAC1C;gBAEA,OAAOD,EAAEC,KAAK;YAChB;YAEA,OAAOD,EAAEG,IAAI;QACf,GACCI,IAAI,CAAC,OAAO,EACfvB,sMAAAA,CAAWwB,WAAW,EACtBpB;QAGFF,sBAAsB,IAAI,CAAC,WAAW,CAACuB,IAAI;IAC7C;AACF"}},
    {"offset": {"line": 179, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/errors/MissingEditorProp.ts"],"sourcesContent":["import type { Field } from '../fields/config/types.js'\n\nimport { fieldAffectsData } from '../fields/config/types.js'\nimport { APIError } from './APIError.js'\n\nexport class MissingEditorProp extends APIError {\n  constructor(field: Field) {\n    super(\n      `RichText field${fieldAffectsData(field) ? ` \"${field.name}\"` : ''} is missing the editor prop. For sub-richText fields, the editor props is required, as it would otherwise create infinite recursion.`,\n    )\n  }\n}\n"],"names":["fieldAffectsData","APIError","MissingEditorProp","field","name"],"mappings":";;;;AAEA,SAASA,gBAAgB,QAAQ,4BAA2B;AAC5D,SAASC,QAAQ,QAAQ,gBAAe;;;AAEjC,MAAMC,0BAA0BD,mKAAAA;IACrC,YAAYE,KAAY,CAAE;QACxB,KAAK,CACH,CAAC,cAAc,MAAEH,kLAAAA,EAAiBG,SAAS,CAAC,EAAE,EAAEA,MAAMC,IAAI,CAAC,CAAC,CAAC,GAAG,GAAG,oIAAoI,CAAC;IAE5M;AACF"}},
    {"offset": {"line": 196, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/errors/TimestampsRequired.ts"],"sourcesContent":["import type { CollectionConfig } from '../collections/config/types.js'\n\nimport { APIError } from './APIError.js'\n\nexport class TimestampsRequired extends APIError {\n  constructor(collection: CollectionConfig) {\n    super(\n      `Timestamps are required in the collection ${collection.slug} because you have opted in to Versions.`,\n    )\n  }\n}\n"],"names":["APIError","TimestampsRequired","collection","slug"],"mappings":";;;;AAEA,SAASA,QAAQ,QAAQ,gBAAe;;AAEjC,MAAMC,2BAA2BD,mKAAAA;IACtC,YAAYE,UAA4B,CAAE;QACxC,KAAK,CACH,CAAC,0CAA0C,EAAEA,WAAWC,IAAI,CAAC,uCAAuC,CAAC;IAEzG;AACF"}},
    {"offset": {"line": 211, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/errors/DuplicateFieldName.ts"],"sourcesContent":["import { APIError } from './APIError.js'\n\nexport class DuplicateFieldName extends APIError {\n  constructor(fieldName: string) {\n    super(\n      `A field with the name '${fieldName}' was found multiple times on the same level. Field names must be unique.`,\n    )\n  }\n}\n"],"names":["APIError","DuplicateFieldName","fieldName"],"mappings":";;;;AAAA,SAASA,QAAQ,QAAQ,gBAAe;;AAEjC,MAAMC,2BAA2BD,mKAAAA;IACtC,YAAYE,SAAiB,CAAE;QAC7B,KAAK,CACH,CAAC,uBAAuB,EAAEA,UAAU,yEAAyE,CAAC;IAElH;AACF"}},
    {"offset": {"line": 226, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/errors/InvalidConfiguration.ts"],"sourcesContent":["import { status as httpStatus } from 'http-status'\n\nimport { APIError } from './APIError.js'\n\nexport class InvalidConfiguration extends APIError {\n  constructor(message: string) {\n    super(message, httpStatus.INTERNAL_SERVER_ERROR)\n  }\n}\n"],"names":["status","httpStatus","APIError","InvalidConfiguration","message","INTERNAL_SERVER_ERROR"],"mappings":";;;;;AAAA,SAASA,UAAUC,UAAU,QAAQ,cAAa;AAElD,SAASC,QAAQ,QAAQ,gBAAe;;;AAEjC,MAAMC,6BAA6BD,mKAAAA;IACxC,YAAYE,OAAe,CAAE;QAC3B,KAAK,CAACA,SAASH,sMAAAA,CAAWI,qBAAqB;IACjD;AACF"}},
    {"offset": {"line": 244, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/errors/InvalidFieldName.ts"],"sourcesContent":["import type { FieldAffectingData } from '../fields/config/types.js'\n\nimport { APIError } from './APIError.js'\n\nexport class InvalidFieldName extends APIError {\n  constructor(field: FieldAffectingData, fieldName: string) {\n    super(\n      `Field ${field.label} has invalid name '${fieldName}'. Field names can not include periods (.) and must be alphanumeric.`,\n    )\n  }\n}\n"],"names":["APIError","InvalidFieldName","field","fieldName","label"],"mappings":";;;;AAEA,SAASA,QAAQ,QAAQ,gBAAe;;AAEjC,MAAMC,yBAAyBD,mKAAAA;IACpC,YAAYE,KAAyB,EAAEC,SAAiB,CAAE;QACxD,KAAK,CACH,CAAC,MAAM,EAAED,MAAME,KAAK,CAAC,mBAAmB,EAAED,UAAU,oEAAoE,CAAC;IAE7H;AACF"}},
    {"offset": {"line": 259, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/errors/InvalidFieldRelationship.ts"],"sourcesContent":["import type { RelationshipField, UploadField } from '../fields/config/types.js'\n\nimport { APIError } from './APIError.js'\n\nexport class InvalidFieldRelationship extends APIError {\n  constructor(field: RelationshipField | UploadField, relationship: string) {\n    super(`Field ${field.label} has invalid relationship '${relationship}'.`)\n  }\n}\n"],"names":["APIError","InvalidFieldRelationship","field","relationship","label"],"mappings":";;;;AAEA,SAASA,QAAQ,QAAQ,gBAAe;;AAEjC,MAAMC,iCAAiCD,mKAAAA;IAC5C,YAAYE,KAAsC,EAAEC,YAAoB,CAAE;QACxE,KAAK,CAAC,CAAC,MAAM,EAAED,MAAME,KAAK,CAAC,2BAA2B,EAAED,aAAa,EAAE,CAAC;IAC1E;AACF"}},
    {"offset": {"line": 274, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/errors/MissingFieldType.ts"],"sourcesContent":["import type { Field } from '../fields/config/types.js'\n\nimport { fieldAffectsData } from '../fields/config/types.js'\nimport { APIError } from './APIError.js'\n\nexport class MissingFieldType extends APIError {\n  constructor(field: Field) {\n    super(\n      `Field${\n        fieldAffectsData(field) ? ` \"${field.name}\"` : ''\n      } is either missing a field type or it does not match an available field type`,\n    )\n  }\n}\n"],"names":["fieldAffectsData","APIError","MissingFieldType","field","name"],"mappings":";;;;AAEA,SAASA,gBAAgB,QAAQ,4BAA2B;AAC5D,SAASC,QAAQ,QAAQ,gBAAe;;;AAEjC,MAAMC,yBAAyBD,mKAAAA;IACpC,YAAYE,KAAY,CAAE;QACxB,KAAK,CACH,CAAC,KAAK,MACJH,kLAAAA,EAAiBG,SAAS,CAAC,EAAE,EAAEA,MAAMC,IAAI,CAAC,CAAC,CAAC,GAAG,GAChD,4EAA4E,CAAC;IAElF;AACF"}},
    {"offset": {"line": 291, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/errors/ReservedFieldName.ts"],"sourcesContent":["import type { FieldAffectingData } from '../fields/config/types.js'\n\nimport { APIError } from './APIError.js'\n\nexport class ReservedFieldName extends APIError {\n  constructor(field: FieldAffectingData, fieldName: string) {\n    super(`Field ${field.label} has reserved name '${fieldName}'.`)\n  }\n}\n"],"names":["APIError","ReservedFieldName","field","fieldName","label"],"mappings":";;;;AAEA,SAASA,QAAQ,QAAQ,gBAAe;;AAEjC,MAAMC,0BAA0BD,mKAAAA;IACrC,YAAYE,KAAyB,EAAEC,SAAiB,CAAE;QACxD,KAAK,CAAC,CAAC,MAAM,EAAED,MAAME,KAAK,CAAC,oBAAoB,EAAED,UAAU,EAAE,CAAC;IAChE;AACF"}},
    {"offset": {"line": 306, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/errors/InvalidFieldJoin.ts"],"sourcesContent":["import type { JoinField } from '../fields/config/types.js'\n\nimport { APIError } from './APIError.js'\n\nexport class InvalidFieldJoin extends APIError {\n  constructor(field: JoinField) {\n    super(\n      `Invalid join field ${field.name}. The config does not have a field '${field.on}' in collection '${field.collection}'.`,\n    )\n  }\n}\n"],"names":["APIError","InvalidFieldJoin","field","name","on","collection"],"mappings":";;;;AAEA,SAASA,QAAQ,QAAQ,gBAAe;;AAEjC,MAAMC,yBAAyBD,mKAAAA;IACpC,YAAYE,KAAgB,CAAE;QAC5B,KAAK,CACH,CAAC,mBAAmB,EAAEA,MAAMC,IAAI,CAAC,oCAAoC,EAAED,MAAME,EAAE,CAAC,iBAAiB,EAAEF,MAAMG,UAAU,CAAC,EAAE,CAAC;IAE3H;AACF"}},
    {"offset": {"line": 321, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/errors/QueryError.ts"],"sourcesContent":["import { status as httpStatus } from 'http-status'\n\nimport { APIError } from './APIError.js'\n\nexport class QueryError extends APIError<{ path: string }[]> {\n  constructor(results: { path: string }[]) {\n    const message = `The following path${results.length === 1 ? '' : 's'} cannot be queried:`\n\n    super(\n      `${message} ${results.map((err) => err.path).join(', ')}`,\n      httpStatus.BAD_REQUEST,\n      results,\n    )\n  }\n}\n"],"names":["status","httpStatus","APIError","QueryError","results","message","length","map","err","path","join","BAD_REQUEST"],"mappings":";;;;;AAAA,SAASA,UAAUC,UAAU,QAAQ,cAAa;AAElD,SAASC,QAAQ,QAAQ,gBAAe;;;AAEjC,MAAMC,mBAAmBD,mKAAAA;IAC9B,YAAYE,OAA2B,CAAE;QACvC,MAAMC,UAAU,CAAC,kBAAkB,EAAED,QAAQE,MAAM,KAAK,IAAI,KAAK,IAAI,mBAAmB,CAAC;QAEzF,KAAK,CACH,GAAGD,QAAQ,CAAC,EAAED,QAAQG,GAAG,CAAC,CAACC,MAAQA,IAAIC,IAAI,EAAEC,IAAI,CAAC,OAAO,EACzDT,sMAAAA,CAAWU,WAAW,EACtBP;IAEJ;AACF"}},
    {"offset": {"line": 340, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/errors/NotFound.ts"],"sourcesContent":["import type { TFunction } from '@payloadcms/translations'\n\nimport { en } from '@payloadcms/translations/languages/en'\nimport { status as httpStatus } from 'http-status'\n\nimport { APIError } from './APIError.js'\n\nexport class NotFound extends APIError {\n  constructor(t?: TFunction) {\n    super(t ? t('general:notFound') : en.translations.general.notFound, httpStatus.NOT_FOUND)\n  }\n}\n"],"names":["en","status","httpStatus","APIError","NotFound","t","translations","general","notFound","NOT_FOUND"],"mappings":";;;;AAEA,SAASA,EAAE,QAAQ,wCAAuC;;AAC1D,SAASC,UAAUC,UAAU,QAAQ,cAAa;AAElD,SAASC,QAAQ,QAAQ,gBAAe;;;;AAEjC,MAAMC,iBAAiBD,mKAAAA;IAC5B,YAAYE,CAAa,CAAE;QACzB,KAAK,CAACA,IAAIA,EAAE,sBAAsBL,+KAAAA,CAAGM,YAAY,CAACC,OAAO,CAACC,QAAQ,EAAEN,sMAAAA,CAAWO,SAAS;IAC1F;AACF"}},
    {"offset": {"line": 360, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/errors/FileRetrievalError.ts"],"sourcesContent":["import type { TFunction } from '@payloadcms/translations'\n\nimport { status as httpStatus } from 'http-status'\n\nimport { APIError } from './APIError.js'\n\nexport class FileRetrievalError extends APIError {\n  constructor(t?: TFunction, message?: string) {\n    let msg = t ? t('error:problemUploadingFile') : 'There was a problem while retrieving the file.'\n\n    if (message) {\n      msg += ` ${message}`\n    }\n    super(msg, httpStatus.INTERNAL_SERVER_ERROR)\n  }\n}\n"],"names":["status","httpStatus","APIError","FileRetrievalError","t","message","msg","INTERNAL_SERVER_ERROR"],"mappings":";;;;;AAEA,SAASA,UAAUC,UAAU,QAAQ,cAAa;AAElD,SAASC,QAAQ,QAAQ,gBAAe;;;AAEjC,MAAMC,2BAA2BD,mKAAAA;IACtC,YAAYE,CAAa,EAAEC,OAAgB,CAAE;QAC3C,IAAIC,MAAMF,IAAIA,EAAE,gCAAgC;QAEhD,IAAIC,SAAS;YACXC,OAAO,CAAC,CAAC,EAAED,SAAS;QACtB;QACA,KAAK,CAACC,KAAKL,sMAAAA,CAAWM,qBAAqB;IAC7C;AACF"}},
    {"offset": {"line": 382, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/errors/FileUploadError.ts"],"sourcesContent":["import type { TFunction } from '@payloadcms/translations'\n\nimport { en } from '@payloadcms/translations/languages/en'\nimport { status as httpStatus } from 'http-status'\n\nimport { APIError } from './APIError.js'\n\nexport class FileUploadError extends APIError {\n  constructor(t?: TFunction) {\n    super(\n      t ? t('error:problemUploadingFile') : en.translations.error.problemUploadingFile,\n      httpStatus.BAD_REQUEST,\n    )\n  }\n}\n"],"names":["en","status","httpStatus","APIError","FileUploadError","t","translations","error","problemUploadingFile","BAD_REQUEST"],"mappings":";;;;AAEA,SAASA,EAAE,QAAQ,wCAAuC;;AAC1D,SAASC,UAAUC,UAAU,QAAQ,cAAa;AAElD,SAASC,QAAQ,QAAQ,gBAAe;;;;AAEjC,MAAMC,wBAAwBD,mKAAAA;IACnC,YAAYE,CAAa,CAAE;QACzB,KAAK,CACHA,IAAIA,EAAE,gCAAgCL,+KAAAA,CAAGM,YAAY,CAACC,KAAK,CAACC,oBAAoB,EAChFN,sMAAAA,CAAWO,WAAW;IAE1B;AACF"}},
    {"offset": {"line": 402, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/errors/MissingFile.ts"],"sourcesContent":["import type { TFunction } from '@payloadcms/translations'\n\nimport { en } from '@payloadcms/translations/languages/en'\nimport { status as httpStatus } from 'http-status'\n\nimport { APIError } from './APIError.js'\n\nexport class MissingFile extends APIError {\n  constructor(t?: TFunction) {\n    super(\n      t ? t('error:noFilesUploaded') : en.translations.error.noFilesUploaded,\n      httpStatus.BAD_REQUEST,\n    )\n  }\n}\n"],"names":["en","status","httpStatus","APIError","MissingFile","t","translations","error","noFilesUploaded","BAD_REQUEST"],"mappings":";;;;AAEA,SAASA,EAAE,QAAQ,wCAAuC;;AAC1D,SAASC,UAAUC,UAAU,QAAQ,cAAa;AAElD,SAASC,QAAQ,QAAQ,gBAAe;;;;AAEjC,MAAMC,oBAAoBD,mKAAAA;IAC/B,YAAYE,CAAa,CAAE;QACzB,KAAK,CACHA,IAAIA,EAAE,2BAA2BL,+KAAAA,CAAGM,YAAY,CAACC,KAAK,CAACC,eAAe,EACtEN,sMAAAA,CAAWO,WAAW;IAE1B;AACF"}},
    {"offset": {"line": 422, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/errors/UnauthorizedError.ts"],"sourcesContent":["import type { TFunction } from '@payloadcms/translations'\n\nimport { en } from '@payloadcms/translations/languages/en'\nimport { status as httpStatus } from 'http-status'\n\nimport { APIError } from './APIError.js'\n\nexport class UnauthorizedError extends APIError {\n  constructor(t?: TFunction) {\n    super(t ? t('error:unauthorized') : en.translations.error.unauthorized, httpStatus.UNAUTHORIZED)\n  }\n}\n"],"names":["en","status","httpStatus","APIError","UnauthorizedError","t","translations","error","unauthorized","UNAUTHORIZED"],"mappings":";;;;AAEA,SAASA,EAAE,QAAQ,wCAAuC;;AAC1D,SAASC,UAAUC,UAAU,QAAQ,cAAa;AAElD,SAASC,QAAQ,QAAQ,gBAAe;;;;AAEjC,MAAMC,0BAA0BD,mKAAAA;IACrC,YAAYE,CAAa,CAAE;QACzB,KAAK,CAACA,IAAIA,EAAE,wBAAwBL,+KAAAA,CAAGM,YAAY,CAACC,KAAK,CAACC,YAAY,EAAEN,sMAAAA,CAAWO,YAAY;IACjG;AACF"}},
    {"offset": {"line": 442, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/errors/ErrorDeletingFile.ts"],"sourcesContent":["import type { TFunction } from '@payloadcms/translations'\n\nimport { en } from '@payloadcms/translations/languages/en'\nimport { status as httpStatus } from 'http-status'\n\nimport { APIError } from './APIError.js'\n\nexport class ErrorDeletingFile extends APIError {\n  constructor(t?: TFunction) {\n    super(\n      t ? t('error:deletingFile') : en.translations.error.deletingFile,\n      httpStatus.INTERNAL_SERVER_ERROR,\n    )\n  }\n}\n"],"names":["en","status","httpStatus","APIError","ErrorDeletingFile","t","translations","error","deletingFile","INTERNAL_SERVER_ERROR"],"mappings":";;;;AAEA,SAASA,EAAE,QAAQ,wCAAuC;;AAC1D,SAASC,UAAUC,UAAU,QAAQ,cAAa;AAElD,SAASC,QAAQ,QAAQ,gBAAe;;;;AAEjC,MAAMC,0BAA0BD,mKAAAA;IACrC,YAAYE,CAAa,CAAE;QACzB,KAAK,CACHA,IAAIA,EAAE,wBAAwBL,+KAAAA,CAAGM,YAAY,CAACC,KAAK,CAACC,YAAY,EAChEN,sMAAAA,CAAWO,qBAAqB;IAEpC;AACF"}},
    {"offset": {"line": 462, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/errors/Locked.ts"],"sourcesContent":["import { status as httpStatus } from 'http-status'\n\nimport { APIError } from './APIError.js'\n\nexport class Locked extends APIError {\n  constructor(message: string) {\n    super(message, httpStatus.LOCKED)\n  }\n}\n"],"names":["status","httpStatus","APIError","Locked","message","LOCKED"],"mappings":";;;;;AAAA,SAASA,UAAUC,UAAU,QAAQ,cAAa;AAElD,SAASC,QAAQ,QAAQ,gBAAe;;;AAEjC,MAAMC,eAAeD,mKAAAA;IAC1B,YAAYE,OAAe,CAAE;QAC3B,KAAK,CAACA,SAASH,sMAAAA,CAAWI,MAAM;IAClC;AACF"}},
    {"offset": {"line": 480, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/errors/DuplicateCollection.ts"],"sourcesContent":["import { APIError } from './APIError.js'\n\nexport class DuplicateCollection extends APIError {\n  constructor(propertyName: string, duplicate: string) {\n    super(`Collection ${propertyName} already in use: \"${duplicate}\"`)\n  }\n}\n"],"names":["APIError","DuplicateCollection","propertyName","duplicate"],"mappings":";;;;AAAA,SAASA,QAAQ,QAAQ,gBAAe;;AAEjC,MAAMC,4BAA4BD,mKAAAA;IACvC,YAAYE,YAAoB,EAAEC,SAAiB,CAAE;QACnD,KAAK,CAAC,CAAC,WAAW,EAAED,aAAa,kBAAkB,EAAEC,UAAU,CAAC,CAAC;IACnE;AACF"}},
    {"offset": {"line": 495, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/database/combineQueries.ts"],"sourcesContent":["import type { Where } from '../types/index.js'\n\nimport { hasWhereAccessResult } from '../auth/index.js'\n\n/**\n * Combines two queries into a single query, using an AND operator\n */\nexport const combineQueries = (where: Where, access: boolean | Where): Where => {\n  if (!where && !access) {\n    return {}\n  }\n\n  const and: Where[] = where ? [where] : []\n\n  if (hasWhereAccessResult(access)) {\n    and.push(access)\n  }\n\n  return {\n    and,\n  }\n}\n"],"names":["hasWhereAccessResult","combineQueries","where","access","and","push"],"mappings":";;;;AAEA,SAASA,oBAAoB,QAAQ,mBAAkB;;AAKhD,MAAMC,iBAAiB,CAACC,OAAcC;IAC3C,IAAI,CAACD,SAAS,CAACC,QAAQ;QACrB,OAAO,CAAC;IACV;IAEA,MAAMC,MAAeF,QAAQ;QAACA;KAAM,GAAG,EAAE;IAEzC,QAAIF,0KAAAA,EAAqBG,SAAS;QAChCC,IAAIC,IAAI,CAACF;IACX;IAEA,OAAO;QACLC;IACF;AACF,EAAC"}},
    {"offset": {"line": 519, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/database/getLocalizedPaths.ts"],"sourcesContent":["import type { PathToQuery } from './queryValidation/types.js'\n\nimport {\n  type Field,\n  fieldShouldBeLocalized,\n  type FlattenedBlock,\n  type FlattenedField,\n} from '../fields/config/types.js'\nimport { APIError, type Payload, type SanitizedCollectionConfig } from '../index.js'\n\nexport function getLocalizedPaths({\n  collectionSlug,\n  fields,\n  globalSlug,\n  incomingPath,\n  locale,\n  overrideAccess = false,\n  parentIsLocalized,\n  payload,\n}: {\n  collectionSlug?: string\n  fields: FlattenedField[]\n  globalSlug?: string\n  incomingPath: string\n  locale?: string\n  overrideAccess?: boolean\n  /**\n   * @todo make required in v4.0. Usually, you'd wanna pass this through\n   */\n  parentIsLocalized?: boolean\n  payload: Payload\n}): PathToQuery[] {\n  const pathSegments = incomingPath.split('.')\n  const localizationConfig = payload.config.localization\n\n  let paths: PathToQuery[] = [\n    {\n      collectionSlug,\n      complete: false,\n      // @ts-expect-error - vestiges of when tsconfig was not strict. Feel free to improve\n      field: undefined,\n      fields,\n      globalSlug,\n      invalid: false,\n      parentIsLocalized: parentIsLocalized!,\n      path: '',\n    },\n  ]\n\n  for (let i = 0; i < pathSegments.length; i += 1) {\n    const segment = pathSegments[i]\n\n    const lastIncompletePath = paths.find(({ complete }) => !complete)\n\n    if (lastIncompletePath) {\n      const { path } = lastIncompletePath\n      let currentPath = path ? `${path}.${segment}` : segment\n\n      let fieldsToSearch: FlattenedField[]\n      let _parentIsLocalized = parentIsLocalized\n\n      let matchedField!: FlattenedField\n\n      if (lastIncompletePath?.field?.type === 'blocks') {\n        if (segment === 'blockType') {\n          matchedField = {\n            name: 'blockType',\n            type: 'text',\n          }\n        } else {\n          for (const _block of lastIncompletePath.field.blockReferences ??\n            lastIncompletePath.field.blocks) {\n            let block: FlattenedBlock\n            if (typeof _block === 'string') {\n              block = payload.blocks[_block]!\n            } else {\n              block = _block\n            }\n\n            matchedField = block.flattenedFields.find((field) => field.name === segment)!\n            if (matchedField) {\n              break\n            }\n          }\n        }\n      } else {\n        if (lastIncompletePath?.field && 'flattenedFields' in lastIncompletePath.field) {\n          fieldsToSearch = lastIncompletePath.field.flattenedFields\n        } else {\n          fieldsToSearch = lastIncompletePath.fields!\n        }\n        _parentIsLocalized = parentIsLocalized || lastIncompletePath.field?.localized\n\n        matchedField = fieldsToSearch.find((field) => field.name === segment)!\n      }\n\n      lastIncompletePath.field = matchedField!\n\n      if (currentPath === 'globalType' && globalSlug) {\n        lastIncompletePath.path = currentPath\n        lastIncompletePath.complete = true\n        lastIncompletePath.field = {\n          name: 'globalType',\n          type: 'text',\n        }\n\n        return paths\n      }\n\n      if (currentPath === 'relationTo') {\n        lastIncompletePath.path = currentPath\n        lastIncompletePath.complete = true\n        lastIncompletePath.field = {\n          name: 'relationTo',\n          type: 'select',\n          options: Object.keys(payload.collections),\n        }\n\n        return paths\n      }\n\n      if (!matchedField && currentPath === 'id' && i === pathSegments.length - 1) {\n        lastIncompletePath.path = currentPath\n        const idField: Field = {\n          name: 'id',\n          type: payload.db.defaultIDType as 'text',\n        }\n        lastIncompletePath.field = idField\n        lastIncompletePath.complete = true\n        return paths\n      }\n\n      if (matchedField) {\n        if ('hidden' in matchedField && matchedField.hidden && !overrideAccess) {\n          lastIncompletePath.invalid = true\n        }\n\n        const nextSegment = pathSegments[i + 1]!\n        const currentFieldIsLocalized = fieldShouldBeLocalized({\n          field: matchedField,\n          parentIsLocalized: _parentIsLocalized!,\n        })\n\n        const nextSegmentIsLocale =\n          localizationConfig &&\n          localizationConfig.localeCodes.includes(nextSegment) &&\n          currentFieldIsLocalized\n\n        if (nextSegmentIsLocale) {\n          // Skip the next iteration, because it's a locale\n          i += 1\n          currentPath = `${currentPath}.${nextSegment}`\n        } else if (localizationConfig && currentFieldIsLocalized) {\n          currentPath = `${currentPath}.${locale}`\n        }\n\n        switch (matchedField.type) {\n          case 'join':\n          case 'relationship':\n          case 'upload': {\n            // If this is a polymorphic relation,\n            // We only support querying directly (no nested querying)\n            if (matchedField.type !== 'join' && typeof matchedField.relationTo !== 'string') {\n              lastIncompletePath.path = pathSegments.join('.')\n              if (![matchedField.name, 'relationTo', 'value'].includes(pathSegments.at(-1)!)) {\n                lastIncompletePath.invalid = true\n              } else {\n                lastIncompletePath.complete = true\n              }\n            } else {\n              lastIncompletePath.complete = true\n              lastIncompletePath.path = currentPath!\n\n              const nestedPathToQuery = pathSegments\n                .slice(nextSegmentIsLocale ? i + 2 : i + 1)\n                .join('.')\n\n              if (nestedPathToQuery) {\n                let relatedCollection: SanitizedCollectionConfig\n                if (matchedField.type === 'join') {\n                  if (Array.isArray(matchedField.collection)) {\n                    throw new APIError('Not supported')\n                  }\n\n                  relatedCollection = payload.collections[matchedField.collection]!.config\n                } else {\n                  relatedCollection = payload.collections[matchedField.relationTo as string]!.config\n                }\n\n                const remainingPaths = getLocalizedPaths({\n                  collectionSlug: relatedCollection.slug,\n                  fields: relatedCollection.flattenedFields,\n                  globalSlug,\n                  incomingPath: nestedPathToQuery,\n                  locale,\n                  parentIsLocalized: false,\n                  payload,\n                })\n\n                paths = [...paths, ...remainingPaths]\n              }\n\n              return paths\n            }\n\n            break\n          }\n          case 'json':\n          case 'richText': {\n            const upcomingSegments = pathSegments.slice(i + 1).join('.')\n            pathSegments.forEach((path) => {\n              if (!/^\\w+(?:\\.\\w+)*$/.test(path)) {\n                lastIncompletePath.invalid = true\n              }\n            })\n            lastIncompletePath.complete = true\n            lastIncompletePath.path = upcomingSegments\n              ? `${currentPath}.${upcomingSegments}`\n              : currentPath!\n            return paths\n          }\n\n          default: {\n            if (i + 1 === pathSegments.length) {\n              lastIncompletePath.complete = true\n            }\n            lastIncompletePath.path = currentPath!\n          }\n        }\n      } else {\n        lastIncompletePath.invalid = true\n        lastIncompletePath.path = currentPath!\n        return paths\n      }\n    }\n  }\n\n  return paths\n}\n"],"names":["fieldShouldBeLocalized","APIError","getLocalizedPaths","collectionSlug","fields","globalSlug","incomingPath","locale","overrideAccess","parentIsLocalized","payload","pathSegments","split","localizationConfig","config","localization","paths","complete","field","undefined","invalid","path","i","length","segment","lastIncompletePath","find","currentPath","fieldsToSearch","_parentIsLocalized","matchedField","type","name","_block","blockReferences","blocks","block","flattenedFields","localized","options","Object","keys","collections","idField","db","defaultIDType","hidden","nextSegment","currentFieldIsLocalized","nextSegmentIsLocale","localeCodes","includes","relationTo","join","at","nestedPathToQuery","slice","relatedCollection","Array","isArray","collection","remainingPaths","slug","upcomingSegments","forEach","test"],"mappings":"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"}},
    {"offset": {"line": 712, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/database/queryValidation/validateSearchParams.ts"],"sourcesContent":["import type { SanitizedCollectionConfig } from '../../collections/config/types.js'\nimport type { FlattenedField } from '../../fields/config/types.js'\nimport type { SanitizedGlobalConfig } from '../../globals/config/types.js'\nimport type { PayloadRequest, WhereField } from '../../types/index.js'\nimport type { EntityPolicies, PathToQuery } from './types.js'\n\nimport { fieldAffectsData } from '../../fields/config/types.js'\nimport { getEntityPermissions } from '../../utilities/getEntityPermissions/getEntityPermissions.js'\nimport { isolateObjectProperty } from '../../utilities/isolateObjectProperty.js'\nimport { getLocalizedPaths } from '../getLocalizedPaths.js'\nimport { validateQueryPaths } from './validateQueryPaths.js'\n\ntype Args = {\n  collectionConfig?: SanitizedCollectionConfig\n  constraint: WhereField\n  errors: { path: string }[]\n  fields: FlattenedField[]\n  globalConfig?: SanitizedGlobalConfig\n  operator: string\n  overrideAccess: boolean\n  parentIsLocalized?: boolean\n  path: string\n  // TODO: Rename to permissions or entityPermissions in 4.0\n  policies: EntityPolicies\n  polymorphicJoin?: boolean\n  req: PayloadRequest\n  val: unknown\n  versionFields?: FlattenedField[]\n}\n\n/**\n * Validate the Payload key / value / operator\n */\nexport async function validateSearchParam({\n  collectionConfig,\n  constraint,\n  errors,\n  fields,\n  globalConfig,\n  operator,\n  overrideAccess,\n  parentIsLocalized,\n  path: incomingPath,\n  policies,\n  polymorphicJoin,\n  req,\n  val,\n  versionFields,\n}: Args): Promise<void> {\n  // Replace GraphQL nested field double underscore formatting\n  let sanitizedPath\n  if (incomingPath === '_id') {\n    sanitizedPath = 'id'\n  } else {\n    sanitizedPath = incomingPath.replace(/__/g, '.')\n  }\n  let paths: PathToQuery[] = []\n  const { slug } = (collectionConfig || globalConfig)!\n\n  const blockReferencesPermissions = {}\n\n  if (globalConfig && !policies.globals![slug]) {\n    policies.globals![slug] = await getEntityPermissions({\n      blockReferencesPermissions,\n      entity: globalConfig,\n      entityType: 'global',\n      fetchData: false,\n      operations: ['read'],\n      req,\n    })\n  }\n\n  if (sanitizedPath !== 'id') {\n    paths = getLocalizedPaths({\n      collectionSlug: collectionConfig?.slug,\n      fields,\n      globalSlug: globalConfig?.slug,\n      incomingPath: sanitizedPath,\n      locale: req.locale!,\n      overrideAccess,\n      parentIsLocalized,\n      payload: req.payload,\n    })\n  }\n  const promises: Promise<void>[] = []\n\n  // Sanitize relation.otherRelation.id to relation.otherRelation\n  if (paths.at(-1)?.path === 'id') {\n    const previousField = paths.at(-2)?.field\n    if (\n      previousField &&\n      (previousField.type === 'relationship' || previousField.type === 'upload') &&\n      typeof previousField.relationTo === 'string'\n    ) {\n      paths.pop()\n    }\n  }\n\n  promises.push(\n    ...paths.map(async ({ collectionSlug, field, invalid, path }, i) => {\n      if (invalid) {\n        if (!polymorphicJoin) {\n          errors.push({ path })\n        }\n\n        return\n      }\n\n      // where: { relatedPosts: { equals: 1}} -> { 'relatedPosts.id': { equals: 1}}\n      if (field.type === 'join' && path === incomingPath) {\n        constraint[`${path}.id` as keyof WhereField] = constraint[path as keyof WhereField]\n        delete constraint[path as keyof WhereField]\n      }\n\n      if ('virtual' in field && field.virtual) {\n        if (field.virtual === true) {\n          errors.push({ path })\n        }\n      }\n\n      if (polymorphicJoin && path === 'relationTo') {\n        return\n      }\n\n      if (!overrideAccess && fieldAffectsData(field)) {\n        if (collectionSlug) {\n          if (!policies.collections![collectionSlug]) {\n            policies.collections![collectionSlug] = await getEntityPermissions({\n              blockReferencesPermissions,\n              entity: req.payload.collections[collectionSlug]!.config,\n              entityType: 'collection',\n              fetchData: false,\n              operations: ['read'],\n              req: isolateObjectProperty(req, 'transactionID'),\n            })\n          }\n\n          if (\n            ['hash', 'salt'].includes(incomingPath) &&\n            collectionConfig!.auth &&\n            !collectionConfig!.auth?.disableLocalStrategy\n          ) {\n            errors.push({ path: incomingPath })\n          }\n        }\n        let fieldPath = path\n        // remove locale from end of path\n        if (path.endsWith(`.${req.locale}`)) {\n          fieldPath = path.slice(0, -(req.locale!.length + 1))\n        }\n        // remove \".value\" from ends of polymorphic relationship paths\n        if (\n          (field.type === 'relationship' || field.type === 'upload') &&\n          Array.isArray(field.relationTo)\n        ) {\n          fieldPath = fieldPath.replace('.value', '')\n        }\n\n        const entityType: 'collections' | 'globals' = globalConfig ? 'globals' : 'collections'\n        const entitySlug = collectionSlug || globalConfig!.slug\n        const segments = fieldPath.split('.')\n\n        let fieldAccess: any\n\n        if (versionFields) {\n          fieldAccess = policies[entityType]![entitySlug]!.fields\n\n          if (\n            segments[0] === 'parent' ||\n            segments[0] === 'version' ||\n            segments[0] === 'snapshot' ||\n            segments[0] === 'latest'\n          ) {\n            segments.shift()\n          }\n        } else {\n          fieldAccess = policies[entityType]![entitySlug]!.fields\n        }\n\n        if (segments.length) {\n          segments.forEach((segment) => {\n            if (fieldAccess[segment]) {\n              if ('fields' in fieldAccess[segment]) {\n                fieldAccess = fieldAccess[segment].fields\n              } else {\n                fieldAccess = fieldAccess[segment]\n              }\n            }\n          })\n\n          if (!fieldAccess?.read?.permission) {\n            errors.push({ path: fieldPath })\n          }\n        }\n      }\n\n      if (i > 1) {\n        // Remove top collection and reverse array\n        // to work backwards from top\n        const pathsToQuery = paths.slice(1).reverse()\n\n        pathsToQuery.forEach(\n          ({ collectionSlug: pathCollectionSlug, path: subPath }, pathToQueryIndex) => {\n            // On the \"deepest\" collection,\n            // validate query of the relationship\n            if (pathToQueryIndex === 0) {\n              promises.push(\n                validateQueryPaths({\n                  collectionConfig: req.payload.collections[pathCollectionSlug!]!.config,\n                  errors,\n                  globalConfig: undefined,\n                  overrideAccess,\n                  policies,\n                  req,\n                  where: {\n                    [subPath]: {\n                      [operator]: val,\n                    },\n                  },\n                }),\n              )\n            }\n          },\n        )\n      }\n    }),\n  )\n  await Promise.all(promises)\n}\n"],"names":["fieldAffectsData","getEntityPermissions","isolateObjectProperty","getLocalizedPaths","validateQueryPaths","validateSearchParam","collectionConfig","constraint","errors","fields","globalConfig","operator","overrideAccess","parentIsLocalized","path","incomingPath","policies","polymorphicJoin","req","val","versionFields","sanitizedPath","replace","paths","slug","blockReferencesPermissions","globals","entity","entityType","fetchData","operations","collectionSlug","globalSlug","locale","payload","promises","at","previousField","field","type","relationTo","pop","push","map","invalid","i","virtual","collections","config","includes","auth","disableLocalStrategy","fieldPath","endsWith","slice","length","Array","isArray","entitySlug","segments","split","fieldAccess","shift","forEach","segment","read","permission","pathsToQuery","reverse","pathCollectionSlug","subPath","pathToQueryIndex","undefined","where","Promise","all"],"mappings":"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"}},
    {"offset": {"line": 885, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/database/queryValidation/validateQueryPaths.ts"],"sourcesContent":["import type { SanitizedCollectionConfig } from '../../collections/config/types.js'\nimport type { FlattenedField } from '../../fields/config/types.js'\nimport type { SanitizedGlobalConfig } from '../../globals/config/types.js'\nimport type { Operator, PayloadRequest, Where, WhereField } from '../../types/index.js'\nimport type { EntityPolicies } from './types.js'\n\nimport { QueryError } from '../../errors/QueryError.js'\nimport { validOperatorSet } from '../../types/constants.js'\nimport { validateSearchParam } from './validateSearchParams.js'\n\ntype Args = {\n  errors?: { path: string }[]\n  overrideAccess: boolean\n  // TODO: Rename to permissions or entityPermissions in 4.0\n  policies?: EntityPolicies\n  polymorphicJoin?: boolean\n  req: PayloadRequest\n  versionFields?: FlattenedField[]\n  where: Where\n} & (\n  | {\n      collectionConfig: SanitizedCollectionConfig\n      globalConfig?: never | undefined\n    }\n  | {\n      collectionConfig?: never | undefined\n      globalConfig: SanitizedGlobalConfig\n    }\n)\n\nexport async function validateQueryPaths({\n  collectionConfig,\n  errors = [],\n  globalConfig,\n  overrideAccess,\n  policies = {\n    collections: {},\n    globals: {},\n  },\n  polymorphicJoin,\n  req,\n  versionFields,\n  where,\n}: Args): Promise<void> {\n  const fields = versionFields || (globalConfig || collectionConfig).flattenedFields\n\n  if (typeof where === 'object') {\n    // We need to determine if the whereKey is an AND, OR, or a schema path\n    const promises: Promise<void>[] = []\n    for (const path in where) {\n      const constraint = where[path]\n\n      if ((path === 'and' || path === 'or') && Array.isArray(constraint)) {\n        for (const item of constraint) {\n          if (collectionConfig) {\n            promises.push(\n              validateQueryPaths({\n                collectionConfig,\n                errors,\n                overrideAccess,\n                policies,\n                polymorphicJoin,\n                req,\n                versionFields,\n                where: item,\n              }),\n            )\n          } else {\n            promises.push(\n              validateQueryPaths({\n                errors,\n                globalConfig,\n                overrideAccess,\n                policies,\n                polymorphicJoin,\n                req,\n                versionFields,\n                where: item,\n              }),\n            )\n          }\n        }\n      } else if (!Array.isArray(constraint)) {\n        for (const operator in constraint) {\n          const val = constraint[operator as keyof typeof constraint]\n          if (validOperatorSet.has(operator as Operator)) {\n            promises.push(\n              validateSearchParam({\n                collectionConfig,\n                constraint: where as WhereField,\n                errors,\n                fields,\n                globalConfig,\n                operator,\n                overrideAccess,\n                path,\n                policies,\n                polymorphicJoin,\n                req,\n                val,\n                versionFields,\n              }),\n            )\n          }\n        }\n      }\n    }\n\n    await Promise.all(promises)\n    if (errors.length > 0) {\n      throw new QueryError(errors)\n    }\n  }\n}\n"],"names":["QueryError","validOperatorSet","validateSearchParam","validateQueryPaths","collectionConfig","errors","globalConfig","overrideAccess","policies","collections","globals","polymorphicJoin","req","versionFields","where","fields","flattenedFields","promises","path","constraint","Array","isArray","item","push","operator","val","has","Promise","all","length"],"mappings":";;;;AAMA,SAASA,UAAU,QAAQ,6BAA4B;AACvD,SAASC,gBAAgB,QAAQ,2BAA0B;AAC3D,SAASC,mBAAmB,QAAQ,4BAA2B;;;;AAsBxD,eAAeC,mBAAmB,EACvCC,gBAAgB,EAChBC,SAAS,EAAE,EACXC,YAAY,EACZC,cAAc,EACdC,WAAW;IACTC,aAAa,CAAC;IACdC,SAAS,CAAC;AACZ,CAAC,EACDC,eAAe,EACfC,GAAG,EACHC,aAAa,EACbC,KAAK,EACA;IACL,MAAMC,SAASF,iBAAkBP,CAAAA,gBAAgBF,gBAAe,EAAGY,eAAe;IAElF,IAAI,OAAOF,UAAU,UAAU;QAC7B,uEAAuE;QACvE,MAAMG,WAA4B,EAAE;QACpC,IAAK,MAAMC,QAAQJ,MAAO;YACxB,MAAMK,aAAaL,KAAK,CAACI,KAAK;YAE9B,IAAKA,CAAAA,SAAS,SAASA,SAAS,IAAG,KAAME,MAAMC,OAAO,CAACF,aAAa;gBAClE,KAAK,MAAMG,QAAQH,WAAY;oBAC7B,IAAIf,kBAAkB;wBACpBa,SAASM,IAAI,CACXpB,mBAAmB;4BACjBC;4BACAC;4BACAE;4BACAC;4BACAG;4BACAC;4BACAC;4BACAC,OAAOQ;wBACT;oBAEJ,OAAO;wBACLL,SAASM,IAAI,CACXpB,mBAAmB;4BACjBE;4BACAC;4BACAC;4BACAC;4BACAG;4BACAC;4BACAC;4BACAC,OAAOQ;wBACT;oBAEJ;gBACF;YACF,OAAO,IAAI,CAACF,MAAMC,OAAO,CAACF,aAAa;gBACrC,IAAK,MAAMK,YAAYL,WAAY;oBACjC,MAAMM,MAAMN,UAAU,CAACK,SAAoC;oBAC3D,IAAIvB,2KAAAA,CAAiByB,GAAG,CAACF,WAAuB;wBAC9CP,SAASM,IAAI,KACXrB,+MAAAA,EAAoB;4BAClBE;4BACAe,YAAYL;4BACZT;4BACAU;4BACAT;4BACAkB;4BACAjB;4BACAW;4BACAV;4BACAG;4BACAC;4BACAa;4BACAZ;wBACF;oBAEJ;gBACF;YACF;QACF;QAEA,MAAMc,QAAQC,GAAG,CAACX;QAClB,IAAIZ,OAAOwB,MAAM,GAAG,GAAG;YACrB,MAAM,IAAI7B,uKAAAA,CAAWK;QACvB;IACF;AACF"}},
    {"offset": {"line": 964, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/database/sanitizeWhereQuery.ts"],"sourcesContent":["import type { FlattenedField } from '../fields/config/types.js'\nimport type { Payload, Where } from '../types/index.js'\n\n/**\n * Currently used only for virtual fields linked with relationships\n */\nexport const sanitizeWhereQuery = ({\n  fields,\n  payload,\n  where,\n}: {\n  fields: FlattenedField[]\n  payload: Payload\n  where: Where\n}) => {\n  for (const key in where) {\n    const value = where[key]\n\n    if (['and', 'or'].includes(key.toLowerCase()) && Array.isArray(value)) {\n      for (const where of value) {\n        sanitizeWhereQuery({ fields, payload, where })\n      }\n      continue\n    }\n\n    const paths = key.split('.')\n    let pathHasChanged = false\n\n    let currentFields = fields\n\n    for (let i = 0; i < paths.length; i++) {\n      const path = paths[i]!\n      const field = currentFields.find((each) => each.name === path)\n\n      if (!field) {\n        break\n      }\n\n      if ('virtual' in field && field.virtual && typeof field.virtual === 'string') {\n        paths[i] = field.virtual\n        pathHasChanged = true\n      }\n\n      if ('flattenedFields' in field) {\n        currentFields = field.flattenedFields\n      }\n\n      if (\n        (field.type === 'relationship' || field.type === 'upload') &&\n        typeof field.relationTo === 'string'\n      ) {\n        const relatedCollection = payload.collections[field.relationTo]\n        if (relatedCollection) {\n          currentFields = relatedCollection.config.flattenedFields\n        }\n      }\n    }\n\n    if (pathHasChanged) {\n      where[paths.join('.')] = where[key]!\n      delete where[key]\n    }\n  }\n}\n"],"names":["sanitizeWhereQuery","fields","payload","where","key","value","includes","toLowerCase","Array","isArray","paths","split","pathHasChanged","currentFields","i","length","path","field","find","each","name","virtual","flattenedFields","type","relationTo","relatedCollection","collections","config","join"],"mappings":"AAGA;;CAEC,GACD;;;;AAAO,MAAMA,qBAAqB,CAAC,EACjCC,MAAM,EACNC,OAAO,EACPC,KAAK,EAKN;IACC,IAAK,MAAMC,OAAOD,MAAO;QACvB,MAAME,QAAQF,KAAK,CAACC,IAAI;QAExB,IAAI;YAAC;YAAO;SAAK,CAACE,QAAQ,CAACF,IAAIG,WAAW,OAAOC,MAAMC,OAAO,CAACJ,QAAQ;YACrE,KAAK,MAAMF,SAASE,MAAO;gBACzBL,mBAAmB;oBAAEC;oBAAQC;oBAASC;gBAAM;YAC9C;YACA;QACF;QAEA,MAAMO,QAAQN,IAAIO,KAAK,CAAC;QACxB,IAAIC,iBAAiB;QAErB,IAAIC,gBAAgBZ;QAEpB,IAAK,IAAIa,IAAI,GAAGA,IAAIJ,MAAMK,MAAM,EAAED,IAAK;YACrC,MAAME,OAAON,KAAK,CAACI,EAAE;YACrB,MAAMG,QAAQJ,cAAcK,IAAI,CAAC,CAACC,OAASA,KAAKC,IAAI,KAAKJ;YAEzD,IAAI,CAACC,OAAO;gBACV;YACF;YAEA,IAAI,aAAaA,SAASA,MAAMI,OAAO,IAAI,OAAOJ,MAAMI,OAAO,KAAK,UAAU;gBAC5EX,KAAK,CAACI,EAAE,GAAGG,MAAMI,OAAO;gBACxBT,iBAAiB;YACnB;YAEA,IAAI,qBAAqBK,OAAO;gBAC9BJ,gBAAgBI,MAAMK,eAAe;YACvC;YAEA,IACGL,CAAAA,MAAMM,IAAI,KAAK,kBAAkBN,MAAMM,IAAI,KAAK,QAAO,KACxD,OAAON,MAAMO,UAAU,KAAK,UAC5B;gBACA,MAAMC,oBAAoBvB,QAAQwB,WAAW,CAACT,MAAMO,UAAU,CAAC;gBAC/D,IAAIC,mBAAmB;oBACrBZ,gBAAgBY,kBAAkBE,MAAM,CAACL,eAAe;gBAC1D;YACF;QACF;QAEA,IAAIV,gBAAgB;YAClBT,KAAK,CAACO,MAAMkB,IAAI,CAAC,KAAK,GAAGzB,KAAK,CAACC,IAAI;YACnC,OAAOD,KAAK,CAACC,IAAI;QACnB;IACF;AACF,EAAC"}},
    {"offset": {"line": 1019, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/database/sanitizeJoinQuery.ts"],"sourcesContent":["import type { SanitizedCollectionConfig, SanitizedJoin } from '../collections/config/types.js'\nimport type { JoinQuery, PayloadRequest } from '../types/index.js'\n\nimport { executeAccess } from '../auth/executeAccess.js'\nimport { QueryError } from '../errors/QueryError.js'\nimport { combineQueries } from './combineQueries.js'\nimport { validateQueryPaths } from './queryValidation/validateQueryPaths.js'\n\ntype Args = {\n  collectionConfig: SanitizedCollectionConfig\n  joins?: JoinQuery\n  overrideAccess: boolean\n  req: PayloadRequest\n}\n\nconst sanitizeJoinFieldQuery = async ({\n  collectionSlug,\n  errors,\n  join,\n  joinsQuery,\n  overrideAccess,\n  promises,\n  req,\n}: {\n  collectionSlug: string\n  errors: { path: string }[]\n  join: SanitizedJoin\n  joinsQuery: JoinQuery\n  overrideAccess: boolean\n  promises: Promise<void>[]\n  req: PayloadRequest\n}) => {\n  const { joinPath } = join\n\n  // TODO: fix any's in joinsQuery[joinPath]\n\n  if ((joinsQuery as any)[joinPath] === false) {\n    return\n  }\n\n  const joinCollectionConfig = req.payload.collections[collectionSlug]!.config\n\n  const accessResult = !overrideAccess\n    ? await executeAccess({ disableErrors: true, req }, joinCollectionConfig.access.read)\n    : true\n\n  if (accessResult === false) {\n    ;(joinsQuery as any)[joinPath] = false\n    return\n  }\n\n  if (!(joinsQuery as any)[joinPath]) {\n    ;(joinsQuery as any)[joinPath] = {}\n  }\n\n  const joinQuery = (joinsQuery as any)[joinPath]\n\n  if (!joinQuery.where) {\n    joinQuery.where = {}\n  }\n\n  if (join.field.where) {\n    joinQuery.where = combineQueries(joinQuery.where, join.field.where)\n  }\n\n  promises.push(\n    validateQueryPaths({\n      collectionConfig: joinCollectionConfig,\n      errors,\n      overrideAccess,\n      polymorphicJoin: Array.isArray(join.field.collection),\n      req,\n      // incoming where input, but we shouldn't validate generated from the access control.\n      where: joinQuery.where,\n    }),\n  )\n\n  if (typeof accessResult === 'object') {\n    joinQuery.where = combineQueries(joinQuery.where, accessResult)\n  }\n}\n\n/**\n * * Validates `where` for each join\n * * Combines the access result for joined collection\n * * Combines the default join's `where`\n */\nexport const sanitizeJoinQuery = async ({\n  collectionConfig,\n  joins: joinsQuery,\n  overrideAccess,\n  req,\n}: Args) => {\n  if (joinsQuery === false) {\n    return false\n  }\n\n  if (!joinsQuery) {\n    joinsQuery = {}\n  }\n\n  const errors: { path: string }[] = []\n  const promises: Promise<void>[] = []\n\n  for (const collectionSlug in collectionConfig.joins) {\n    for (const join of collectionConfig.joins[collectionSlug]!) {\n      await sanitizeJoinFieldQuery({\n        collectionSlug,\n        errors,\n        join,\n        joinsQuery,\n        overrideAccess,\n        promises,\n        req,\n      })\n    }\n  }\n\n  for (const join of collectionConfig.polymorphicJoins) {\n    for (const collectionSlug of join.field.collection) {\n      await sanitizeJoinFieldQuery({\n        collectionSlug,\n        errors,\n        join,\n        joinsQuery,\n        overrideAccess,\n        promises,\n        req,\n      })\n    }\n  }\n\n  await Promise.all(promises)\n\n  if (errors.length > 0) {\n    throw new QueryError(errors)\n  }\n\n  return joinsQuery\n}\n"],"names":["executeAccess","QueryError","combineQueries","validateQueryPaths","sanitizeJoinFieldQuery","collectionSlug","errors","join","joinsQuery","overrideAccess","promises","req","joinPath","joinCollectionConfig","payload","collections","config","accessResult","disableErrors","access","read","joinQuery","where","field","push","collectionConfig","polymorphicJoin","Array","isArray","collection","sanitizeJoinQuery","joins","polymorphicJoins","Promise","all","length"],"mappings":";;;;AAGA,SAASA,aAAa,QAAQ,2BAA0B;AACxD,SAASC,UAAU,QAAQ,0BAAyB;AACpD,SAASC,cAAc,QAAQ,sBAAqB;AACpD,SAASC,kBAAkB,QAAQ,0CAAyC;;;;;AAS5E,MAAMC,yBAAyB,OAAO,EACpCC,cAAc,EACdC,MAAM,EACNC,IAAI,EACJC,UAAU,EACVC,cAAc,EACdC,QAAQ,EACRC,GAAG,EASJ;IACC,MAAM,EAAEC,QAAQ,EAAE,GAAGL;IAErB,0CAA0C;IAE1C,IAAKC,UAAkB,CAACI,SAAS,KAAK,OAAO;QAC3C;IACF;IAEA,MAAMC,uBAAuBF,IAAIG,OAAO,CAACC,WAAW,CAACV,eAAe,CAAEW,MAAM;IAE5E,MAAMC,eAAe,CAACR,iBAClB,UAAMT,2KAAAA,EAAc;QAAEkB,eAAe;QAAMP;IAAI,GAAGE,qBAAqBM,MAAM,CAACC,IAAI,IAClF;IAEJ,IAAIH,iBAAiB,OAAO;;QACxBT,UAAkB,CAACI,SAAS,GAAG;QACjC;IACF;IAEA,IAAI,CAAEJ,UAAkB,CAACI,SAAS,EAAE;;QAChCJ,UAAkB,CAACI,SAAS,GAAG,CAAC;IACpC;IAEA,MAAMS,YAAab,UAAkB,CAACI,SAAS;IAE/C,IAAI,CAACS,UAAUC,KAAK,EAAE;QACpBD,UAAUC,KAAK,GAAG,CAAC;IACrB;IAEA,IAAIf,KAAKgB,KAAK,CAACD,KAAK,EAAE;QACpBD,UAAUC,KAAK,OAAGpB,iLAAAA,EAAemB,UAAUC,KAAK,EAAEf,KAAKgB,KAAK,CAACD,KAAK;IACpE;IAEAZ,SAASc,IAAI,KACXrB,4MAAAA,EAAmB;QACjBsB,kBAAkBZ;QAClBP;QACAG;QACAiB,iBAAiBC,MAAMC,OAAO,CAACrB,KAAKgB,KAAK,CAACM,UAAU;QACpDlB;QACA,qFAAqF;QACrFW,OAAOD,UAAUC,KAAK;IACxB;IAGF,IAAI,OAAOL,iBAAiB,UAAU;QACpCI,UAAUC,KAAK,OAAGpB,iLAAAA,EAAemB,UAAUC,KAAK,EAAEL;IACpD;AACF;AAOO,MAAMa,oBAAoB,OAAO,EACtCL,gBAAgB,EAChBM,OAAOvB,UAAU,EACjBC,cAAc,EACdE,GAAG,EACE;IACL,IAAIH,eAAe,OAAO;QACxB,OAAO;IACT;IAEA,IAAI,CAACA,YAAY;QACfA,aAAa,CAAC;IAChB;IAEA,MAAMF,SAA6B,EAAE;IACrC,MAAMI,WAA4B,EAAE;IAEpC,IAAK,MAAML,kBAAkBoB,iBAAiBM,KAAK,CAAE;QACnD,KAAK,MAAMxB,QAAQkB,iBAAiBM,KAAK,CAAC1B,eAAe,CAAG;YAC1D,MAAMD,uBAAuB;gBAC3BC;gBACAC;gBACAC;gBACAC;gBACAC;gBACAC;gBACAC;YACF;QACF;IACF;IAEA,KAAK,MAAMJ,QAAQkB,iBAAiBO,gBAAgB,CAAE;QACpD,KAAK,MAAM3B,kBAAkBE,KAAKgB,KAAK,CAACM,UAAU,CAAE;YAClD,MAAMzB,uBAAuB;gBAC3BC;gBACAC;gBACAC;gBACAC;gBACAC;gBACAC;gBACAC;YACF;QACF;IACF;IAEA,MAAMsB,QAAQC,GAAG,CAACxB;IAElB,IAAIJ,OAAO6B,MAAM,GAAG,GAAG;QACrB,MAAM,IAAIlC,uKAAAA,CAAWK;IACvB;IAEA,OAAOE;AACT,EAAC"}},
    {"offset": {"line": 1116, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/database/migrations/migrationsCollection.ts"],"sourcesContent":["import type { CollectionConfig } from '../../collections/config/types.js'\n\nexport const migrationsCollection: CollectionConfig = {\n  slug: 'payload-migrations',\n  admin: {\n    hidden: true,\n  },\n  endpoints: false,\n  fields: [\n    {\n      name: 'name',\n      type: 'text',\n    },\n    {\n      name: 'batch',\n      type: 'number',\n      // NOTE: This value is -1 if it is a \"dev push\"\n    },\n  ],\n  graphQL: false,\n  lockDocuments: false,\n}\n"],"names":["migrationsCollection","slug","admin","hidden","endpoints","fields","name","type","graphQL","lockDocuments"],"mappings":";;;;AAEO,MAAMA,uBAAyC;IACpDC,MAAM;IACNC,OAAO;QACLC,QAAQ;IACV;IACAC,WAAW;IACXC,QAAQ;QACN;YACEC,MAAM;YACNC,MAAM;QACR;QACA;YACED,MAAM;YACNC,MAAM;QAER;KACD;IACDC,SAAS;IACTC,eAAe;AACjB,EAAC"}},
    {"offset": {"line": 1143, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/database/migrations/getPredefinedMigration.ts"],"sourcesContent":["import fs from 'fs'\nimport path from 'path'\n\nimport type { Payload } from '../../index.js'\nimport type { MigrationTemplateArgs } from '../types.js'\n\nimport { dynamicImport } from '../../utilities/dynamicImport.js'\n\n/**\n * Get predefined migration 'up', 'down' and 'imports'.\n *\n * Supports two import methods:\n * 1. @payloadcms/db-* packages: Loads from adapter's predefinedMigrations folder directly (no package.json export needed)\n *    Example: `--file @payloadcms/db-mongodb/relationships-v2-v3`\n * 2. Any other package/path: Uses dynamic import via package.json exports or absolute file paths\n *    Example: `--file @payloadcms/plugin-seo/someMigration` or `--file /absolute/path/to/migration.ts`\n */\nexport const getPredefinedMigration = async ({\n  dirname,\n  file,\n  migrationName: migrationNameArg,\n  payload,\n}: {\n  dirname: string\n  file?: string\n  migrationName?: string\n  payload: Payload\n}): Promise<MigrationTemplateArgs> => {\n  const importPath = file ?? migrationNameArg\n\n  // Path 1: @payloadcms/db-* adapters - load directly from predefinedMigrations folder\n  // These don't need package.json exports; files are resolved relative to adapter's dirname\n  if (importPath?.startsWith('@payloadcms/db-')) {\n    const migrationName = importPath.split('/').slice(2).join('/')\n    let cleanPath = path.join(dirname, `./predefinedMigrations/${migrationName}`)\n    if (fs.existsSync(`${cleanPath}.mjs`)) {\n      cleanPath = `${cleanPath}.mjs`\n    } else if (fs.existsSync(`${cleanPath}.js`)) {\n      cleanPath = `${cleanPath}.js`\n    } else if (fs.existsSync(`${cleanPath}.ts`)) {\n      // Support .ts in development when running from source\n      cleanPath = `${cleanPath}.ts`\n    } else {\n      payload.logger.error({\n        msg: `Canned migration ${migrationName} not found.`,\n      })\n      process.exit(1)\n    }\n    cleanPath = cleanPath.replaceAll('\\\\', '/')\n    try {\n      const { downSQL, dynamic, imports, upSQL } =\n        await dynamicImport<MigrationTemplateArgs>(cleanPath)\n      return {\n        downSQL,\n        dynamic,\n        imports,\n        upSQL,\n      }\n    } catch (err) {\n      payload.logger.error({\n        err,\n        msg: `Error loading predefined migration ${migrationName}`,\n      })\n      process.exit(1)\n    }\n  } else if (importPath) {\n    // Path 2: Any other package or file path - use dynamic import\n    // Supports: package.json exports (e.g. @payloadcms/plugin-seo/migration) or absolute file paths\n    try {\n      const { downSQL, dynamic, imports, upSQL } =\n        await dynamicImport<MigrationTemplateArgs>(importPath)\n      return {\n        downSQL,\n        dynamic,\n        imports,\n        upSQL,\n      }\n    } catch (_err) {\n      if (importPath?.includes('/')) {\n        // We can assume that the intent was to import a file, thus we throw an error.\n        throw new Error(`Error importing migration file from ${importPath}`)\n      }\n      // Silently fail. If the migration cannot be imported, it will be created as a blank migration and the import path will be used as the migration name.\n      return {}\n    }\n  }\n  return {}\n}\n"],"names":["fs","path","dynamicImport","getPredefinedMigration","dirname","file","migrationName","migrationNameArg","payload","importPath","startsWith","split","slice","join","cleanPath","existsSync","logger","error","msg","process","exit","replaceAll","downSQL","dynamic","imports","upSQL","err","_err","includes","Error"],"mappings":";;;;AAAA,OAAOA,QAAQ,KAAI;AACnB,OAAOC,UAAU,OAAM;AAKvB,SAASC,aAAa,QAAQ,mCAAkC;;;;AAWzD,MAAMC,yBAAyB,OAAO,EAC3CC,OAAO,EACPC,IAAI,EACJC,eAAeC,gBAAgB,EAC/BC,OAAO,EAMR;IACC,MAAMC,aAAaJ,QAAQE;IAE3B,qFAAqF;IACrF,0FAA0F;IAC1F,IAAIE,YAAYC,WAAW,oBAAoB;QAC7C,MAAMJ,gBAAgBG,WAAWE,KAAK,CAAC,KAAKC,KAAK,CAAC,GAAGC,IAAI,CAAC;QAC1D,IAAIC,YAAYb,4GAAAA,CAAKY,IAAI,CAACT,SAAS,CAAC,uBAAuB,EAAEE,eAAe;QAC5E,IAAIN,wGAAAA,CAAGe,UAAU,CAAC,GAAGD,UAAU,IAAI,CAAC,GAAG;YACrCA,YAAY,GAAGA,UAAU,IAAI,CAAC;QAChC,OAAO,IAAId,wGAAAA,CAAGe,UAAU,CAAC,GAAGD,UAAU,GAAG,CAAC,GAAG;YAC3CA,YAAY,GAAGA,UAAU,GAAG,CAAC;QAC/B,OAAO,IAAId,wGAAAA,CAAGe,UAAU,CAAC,GAAGD,UAAU,GAAG,CAAC,GAAG;YAC3C,sDAAsD;YACtDA,YAAY,GAAGA,UAAU,GAAG,CAAC;QAC/B,OAAO;YACLN,QAAQQ,MAAM,CAACC,KAAK,CAAC;gBACnBC,KAAK,CAAC,iBAAiB,EAAEZ,cAAc,WAAW,CAAC;YACrD;YACAa,QAAQC,IAAI,CAAC;QACf;QACAN,YAAYA,UAAUO,UAAU,CAAC,MAAM;QACvC,IAAI;YACF,MAAM,EAAEC,OAAO,EAAEC,OAAO,EAAEC,OAAO,EAAEC,KAAK,EAAE,GACxC,UAAMvB,gLAAAA,EAAqCY;YAC7C,OAAO;gBACLQ;gBACAC;gBACAC;gBACAC;YACF;QACF,EAAE,OAAOC,KAAK;YACZlB,QAAQQ,MAAM,CAACC,KAAK,CAAC;gBACnBS;gBACAR,KAAK,CAAC,mCAAmC,EAAEZ,eAAe;YAC5D;YACAa,QAAQC,IAAI,CAAC;QACf;IACF,OAAO,IAAIX,YAAY;QACrB,8DAA8D;QAC9D,gGAAgG;QAChG,IAAI;YACF,MAAM,EAAEa,OAAO,EAAEC,OAAO,EAAEC,OAAO,EAAEC,KAAK,EAAE,GACxC,UAAMvB,gLAAAA,EAAqCO;YAC7C,OAAO;gBACLa;gBACAC;gBACAC;gBACAC;YACF;QACF,EAAE,OAAOE,MAAM;YACb,IAAIlB,YAAYmB,SAAS,MAAM;gBAC7B,8EAA8E;gBAC9E,MAAM,IAAIC,MAAM,CAAC,oCAAoC,EAAEpB,YAAY;YACrE;YACA,sJAAsJ;YACtJ,OAAO,CAAC;QACV;IACF;IACA,OAAO,CAAC;AACV,EAAC"}},
    {"offset": {"line": 1215, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/database/migrations/writeMigrationIndex.ts"],"sourcesContent":["import fs from 'fs'\nimport { getTsconfig } from 'get-tsconfig'\nimport path from 'path'\n\n// Function to get all migration files (TS or JS) excluding 'index'\nconst getMigrationFiles = (dir: string) => {\n  return fs\n    .readdirSync(dir)\n    .filter(\n      (file) =>\n        (file.endsWith('.ts') || file.endsWith('.js')) &&\n        file !== 'index.ts' &&\n        file !== 'index.js',\n    )\n    .sort()\n}\n\n// Function to generate the index.ts content\nconst generateIndexContent = (files: string[]) => {\n  const tsconfig = getTsconfig()\n  const importExt = tsconfig?.config?.compilerOptions?.moduleResolution === 'NodeNext' ? '.js' : ''\n\n  let imports = ''\n  let exportsArray = 'export const migrations = [\\n'\n\n  files.forEach((file, index) => {\n    const fileNameWithoutExt = file.replace(/\\.[^/.]+$/, '')\n    imports += `import * as migration_${fileNameWithoutExt} from './${fileNameWithoutExt}${importExt}';\\n`\n    exportsArray += `  {\n    up: migration_${fileNameWithoutExt}.up,\n    down: migration_${fileNameWithoutExt}.down,\n    name: '${fileNameWithoutExt}'${index !== files.length - 1 ? ',' : ''}\\n  },\\n`\n  })\n\n  exportsArray += '];\\n'\n  return imports + '\\n' + exportsArray\n}\n\n// Main function to create the index.ts file\nexport const writeMigrationIndex = (args: { migrationsDir: string }) => {\n  const migrationFiles = getMigrationFiles(args.migrationsDir)\n  const indexContent = generateIndexContent(migrationFiles)\n\n  fs.writeFileSync(path.join(args.migrationsDir, 'index.ts'), indexContent)\n}\n"],"names":["fs","getTsconfig","path","getMigrationFiles","dir","readdirSync","filter","file","endsWith","sort","generateIndexContent","files","tsconfig","importExt","config","compilerOptions","moduleResolution","imports","exportsArray","forEach","index","fileNameWithoutExt","replace","length","writeMigrationIndex","args","migrationFiles","migrationsDir","indexContent","writeFileSync","join"],"mappings":";;;;AAAA,OAAOA,QAAQ,KAAI;AACnB,SAASC,WAAW,QAAQ,eAAc;AAC1C,OAAOC,UAAU,OAAM;;;;AAEvB,mEAAmE;AACnE,MAAMC,oBAAoB,CAACC;IACzB,OAAOJ,wGAAAA,CACJK,WAAW,CAACD,KACZE,MAAM,CACL,CAACC,OACEA,CAAAA,KAAKC,QAAQ,CAAC,UAAUD,KAAKC,QAAQ,CAAC,MAAK,KAC5CD,SAAS,cACTA,SAAS,YAEZE,IAAI;AACT;AAEA,4CAA4C;AAC5C,MAAMC,uBAAuB,CAACC;IAC5B,MAAMC,eAAWX,6LAAAA;IACjB,MAAMY,YAAYD,UAAUE,QAAQC,iBAAiBC,qBAAqB,aAAa,QAAQ;IAE/F,IAAIC,UAAU;IACd,IAAIC,eAAe;IAEnBP,MAAMQ,OAAO,CAAC,CAACZ,MAAMa;QACnB,MAAMC,qBAAqBd,KAAKe,OAAO,CAAC,aAAa;QACrDL,WAAW,CAAC,sBAAsB,EAAEI,mBAAmB,SAAS,EAAEA,qBAAqBR,UAAU,IAAI,CAAC;QACtGK,gBAAgB,CAAC;kBACH,EAAEG,mBAAmB;oBACnB,EAAEA,mBAAmB;WAC9B,EAAEA,mBAAmB,CAAC,EAAED,UAAUT,MAAMY,MAAM,GAAG,IAAI,MAAM,GAAG,QAAQ,CAAC;IAChF;IAEAL,gBAAgB;IAChB,OAAOD,UAAU,OAAOC;AAC1B;AAGO,MAAMM,sBAAsB,CAACC;IAClC,MAAMC,iBAAiBvB,kBAAkBsB,KAAKE,aAAa;IAC3D,MAAMC,eAAelB,qBAAqBgB;IAE1C1B,wGAAAA,CAAG6B,aAAa,CAAC3B,4GAAAA,CAAK4B,IAAI,CAACL,KAAKE,aAAa,EAAE,aAAaC;AAC9D,EAAC"}},
    {"offset": {"line": 1255, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/database/migrations/readMigrationFiles.ts"],"sourcesContent":["import fs from 'fs'\nimport path from 'path'\n\nimport type { Payload } from '../../index.js'\nimport type { Migration } from '../types.js'\n\nimport { dynamicImport } from '../../utilities/dynamicImport.js'\n\n/**\n * Read the migration files from disk\n */\nexport const readMigrationFiles = async ({\n  payload,\n}: {\n  payload: Payload\n}): Promise<Migration[]> => {\n  if (!fs.existsSync(payload.db.migrationDir)) {\n    payload.logger.error({\n      msg: `No migration directory found at ${payload.db.migrationDir}`,\n    })\n    return []\n  }\n\n  payload.logger.info({\n    msg: `Reading migration files from ${payload.db.migrationDir}`,\n  })\n\n  const files = fs\n    .readdirSync(payload.db.migrationDir)\n    .sort()\n    .filter((f) => {\n      return (f.endsWith('.ts') || f.endsWith('.js')) && f !== 'index.js' && f !== 'index.ts'\n    })\n    .map((file) => {\n      return path.resolve(payload.db.migrationDir, file)\n    })\n\n  return Promise.all(\n    files.map(async (filePath) => {\n      const migrationModule = await dynamicImport<\n        | {\n            default: Migration\n          }\n        | Migration\n      >(filePath)\n      const migration = 'default' in migrationModule ? migrationModule.default : migrationModule\n\n      const result: Migration = {\n        name: path.basename(filePath).split('.')[0]!,\n        down: migration.down,\n        up: migration.up,\n      }\n\n      return result\n    }),\n  )\n}\n"],"names":["fs","path","dynamicImport","readMigrationFiles","payload","existsSync","db","migrationDir","logger","error","msg","info","files","readdirSync","sort","filter","f","endsWith","map","file","resolve","Promise","all","filePath","migrationModule","migration","default","result","name","basename","split","down","up"],"mappings":";;;;AAAA,OAAOA,QAAQ,KAAI;AACnB,OAAOC,UAAU,OAAM;AAKvB,SAASC,aAAa,QAAQ,mCAAkC;;;;AAKzD,MAAMC,qBAAqB,OAAO,EACvCC,OAAO,EAGR;IACC,IAAI,CAACJ,wGAAAA,CAAGK,UAAU,CAACD,QAAQE,EAAE,CAACC,YAAY,GAAG;QAC3CH,QAAQI,MAAM,CAACC,KAAK,CAAC;YACnBC,KAAK,CAAC,gCAAgC,EAAEN,QAAQE,EAAE,CAACC,YAAY,EAAE;QACnE;QACA,OAAO,EAAE;IACX;IAEAH,QAAQI,MAAM,CAACG,IAAI,CAAC;QAClBD,KAAK,CAAC,6BAA6B,EAAEN,QAAQE,EAAE,CAACC,YAAY,EAAE;IAChE;IAEA,MAAMK,QAAQZ,wGAAAA,CACXa,WAAW,CAACT,QAAQE,EAAE,CAACC,YAAY,EACnCO,IAAI,GACJC,MAAM,CAAC,CAACC;QACP,OAAQA,CAAAA,EAAEC,QAAQ,CAAC,UAAUD,EAAEC,QAAQ,CAAC,MAAK,KAAMD,MAAM,cAAcA,MAAM;IAC/E,GACCE,GAAG,CAAC,CAACC;QACJ,OAAOlB,4GAAAA,CAAKmB,OAAO,CAAChB,QAAQE,EAAE,CAACC,YAAY,EAAEY;IAC/C;IAEF,OAAOE,QAAQC,GAAG,CAChBV,MAAMM,GAAG,CAAC,OAAOK;QACf,MAAMC,kBAAkB,UAAMtB,gLAAAA,EAK5BqB;QACF,MAAME,YAAY,aAAaD,kBAAkBA,gBAAgBE,OAAO,GAAGF;QAE3E,MAAMG,SAAoB;YACxBC,MAAM3B,4GAAAA,CAAK4B,QAAQ,CAACN,UAAUO,KAAK,CAAC,IAAI,CAAC,EAAE;YAC3CC,MAAMN,UAAUM,IAAI;YACpBC,IAAIP,UAAUO,EAAE;QAClB;QAEA,OAAOL;IACT;AAEJ,EAAC"}},
    {"offset": {"line": 1295, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/database/migrations/getMigrations.ts"],"sourcesContent":["import type { Payload } from '../../index.js'\nimport type { MigrationData } from '../types.js'\n\n/**\n * Gets all existing migrations from the database, excluding the dev migration\n */\nexport async function getMigrations({\n  payload,\n}: {\n  payload: Payload\n}): Promise<{ existingMigrations: MigrationData[]; latestBatch: number }> {\n  const migrationQuery = await payload.find({\n    collection: 'payload-migrations',\n    limit: 0,\n    sort: ['-batch', '-name'],\n    where: {\n      batch: {\n        not_equals: -1,\n      },\n    },\n  })\n\n  const existingMigrations = migrationQuery.docs as unknown as MigrationData[]\n\n  // Get the highest batch number from existing migrations\n  const latestBatch = Number(existingMigrations?.[0]?.batch) || 0\n\n  return {\n    existingMigrations,\n    latestBatch,\n  }\n}\n"],"names":["getMigrations","payload","migrationQuery","find","collection","limit","sort","where","batch","not_equals","existingMigrations","docs","latestBatch","Number"],"mappings":"AAGA;;CAEC,GACD;;;;AAAO,eAAeA,cAAc,EAClCC,OAAO,EAGR;IACC,MAAMC,iBAAiB,MAAMD,QAAQE,IAAI,CAAC;QACxCC,YAAY;QACZC,OAAO;QACPC,MAAM;YAAC;YAAU;SAAQ;QACzBC,OAAO;YACLC,OAAO;gBACLC,YAAY,CAAC;YACf;QACF;IACF;IAEA,MAAMC,qBAAqBR,eAAeS,IAAI;IAE9C,wDAAwD;IACxD,MAAMC,cAAcC,OAAOH,oBAAoB,CAAC,EAAE,EAAEF,UAAU;IAE9D,OAAO;QACLE;QACAE;IACF;AACF"}},
    {"offset": {"line": 1327, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/database/defaultUpdateJobs.ts"],"sourcesContent":["import type { DatabaseAdapter, Job } from '../index.js'\nimport type { UpdateJobs } from './types.js'\n\nimport { jobsCollectionSlug } from '../queues/config/collection.js'\n\nexport const defaultUpdateJobs: UpdateJobs = async function updateMany(\n  this: DatabaseAdapter,\n  { id, data, limit, req, returning, where },\n) {\n  const updatedJobs: Job[] | null = []\n\n  const jobsToUpdate: Job[] = (\n    id\n      ? [\n          await this.findOne({\n            collection: jobsCollectionSlug,\n            req,\n            where: { id: { equals: id } },\n          }),\n        ]\n      : (\n          await this.find({\n            collection: jobsCollectionSlug,\n            limit,\n            pagination: false,\n            req,\n            where,\n          })\n        ).docs\n  ).filter(Boolean) as Job[]\n\n  if (!jobsToUpdate) {\n    return null\n  }\n\n  for (const job of jobsToUpdate) {\n    const updateData = {\n      ...job,\n      ...data,\n    }\n    const updatedJob = await this.updateOne({\n      id: job.id,\n      collection: jobsCollectionSlug,\n      data: updateData,\n      req,\n      returning,\n    })\n    updatedJobs.push(updatedJob)\n  }\n\n  return updatedJobs\n}\n"],"names":["jobsCollectionSlug","defaultUpdateJobs","updateMany","id","data","limit","req","returning","where","updatedJobs","jobsToUpdate","findOne","collection","equals","find","pagination","docs","filter","Boolean","job","updateData","updatedJob","updateOne","push"],"mappings":";;;;AAGA,SAASA,kBAAkB,QAAQ,iCAAgC;;AAE5D,MAAMC,oBAAgC,eAAeC,WAE1D,EAAEC,EAAE,EAAEC,IAAI,EAAEC,KAAK,EAAEC,GAAG,EAAEC,SAAS,EAAEC,KAAK,EAAE;IAE1C,MAAMC,cAA4B,EAAE;IAEpC,MAAMC,eACJP,CAAAA,KACI;QACE,MAAM,IAAI,CAACQ,OAAO,CAAC;YACjBC,YAAYZ,yLAAAA;YACZM;YACAE,OAAO;gBAAEL,IAAI;oBAAEU,QAAQV;gBAAG;YAAE;QAC9B;KACD,GAEC,CAAA,MAAM,IAAI,CAACW,IAAI,CAAC;QACdF,YAAYZ,yLAAAA;QACZK;QACAU,YAAY;QACZT;QACAE;IACF,EAAC,EACDQ,IAAG,EACTC,MAAM,CAACC;IAET,IAAI,CAACR,cAAc;QACjB,OAAO;IACT;IAEA,KAAK,MAAMS,OAAOT,aAAc;QAC9B,MAAMU,aAAa;YACjB,GAAGD,GAAG;YACN,GAAGf,IAAI;QACT;QACA,MAAMiB,aAAa,MAAM,IAAI,CAACC,SAAS,CAAC;YACtCnB,IAAIgB,IAAIhB,EAAE;YACVS,YAAYZ,yLAAAA;YACZI,MAAMgB;YACNd;YACAC;QACF;QACAE,YAAYc,IAAI,CAACF;IACnB;IAEA,OAAOZ;AACT,EAAC"}},
    {"offset": {"line": 1375, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/database/migrations/migrationTemplate.ts"],"sourcesContent":["export const migrationTemplate = `\nimport {\n  MigrateUpArgs,\n  MigrateDownArgs,\n} from \"@payloadcms/db-mongodb\";\n\nexport async function up({ payload, req }: MigrateUpArgs): Promise<void> {\n  // Migration code\n};\n\nexport async function down({ payload, req }: MigrateDownArgs): Promise<void> {\n  // Migration code\n};\n`\n"],"names":["migrationTemplate"],"mappings":";;;;AAAO,MAAMA,oBAAoB,CAAC;;;;;;;;;;;;;AAalC,CAAC,CAAA"}},
    {"offset": {"line": 1397, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/database/migrations/createMigration.ts"],"sourcesContent":["import fs from 'fs'\n\nimport type { CreateMigration } from '../types.js'\n\nimport { writeMigrationIndex } from '../../index.js'\nimport { migrationTemplate } from './migrationTemplate.js'\n\nexport const createMigration: CreateMigration = function createMigration({\n  migrationName,\n  payload,\n}) {\n  const dir = payload.db.migrationDir\n  if (!fs.existsSync(dir)) {\n    fs.mkdirSync(dir)\n  }\n\n  const [yyymmdd, hhmmss] = new Date().toISOString().split('T')\n  const formattedDate = yyymmdd!.replace(/\\D/g, '')\n  const formattedTime = hhmmss!.split('.')[0]!.replace(/\\D/g, '')\n\n  const timestamp = `${formattedDate}_${formattedTime}`\n\n  const formattedName = migrationName!.replace(/\\W/g, '_')\n  const fileName = `${timestamp}_${formattedName}.ts`\n  const filePath = `${dir}/${fileName}`\n  fs.writeFileSync(filePath, migrationTemplate)\n\n  writeMigrationIndex({ migrationsDir: payload.db.migrationDir })\n\n  payload.logger.info({ msg: `Migration created at ${filePath}` })\n}\n"],"names":["fs","writeMigrationIndex","migrationTemplate","createMigration","migrationName","payload","dir","db","migrationDir","existsSync","mkdirSync","yyymmdd","hhmmss","Date","toISOString","split","formattedDate","replace","formattedTime","timestamp","formattedName","fileName","filePath","writeFileSync","migrationsDir","logger","info","msg"],"mappings":";;;;AAAA,OAAOA,QAAQ,KAAI;AAInB,SAASC,mBAAmB,QAAQ,iBAAgB;AACpD,SAASC,iBAAiB,QAAQ,yBAAwB;;;;AAEnD,MAAMC,kBAAmC,SAASA,gBAAgB,EACvEC,aAAa,EACbC,OAAO,EACR;IACC,MAAMC,MAAMD,QAAQE,EAAE,CAACC,YAAY;IACnC,IAAI,CAACR,wGAAAA,CAAGS,UAAU,CAACH,MAAM;QACvBN,wGAAAA,CAAGU,SAAS,CAACJ;IACf;IAEA,MAAM,CAACK,SAASC,OAAO,GAAG,IAAIC,OAAOC,WAAW,GAAGC,KAAK,CAAC;IACzD,MAAMC,gBAAgBL,QAASM,OAAO,CAAC,OAAO;IAC9C,MAAMC,gBAAgBN,OAAQG,KAAK,CAAC,IAAI,CAAC,EAAE,CAAEE,OAAO,CAAC,OAAO;IAE5D,MAAME,YAAY,GAAGH,cAAc,CAAC,EAAEE,eAAe;IAErD,MAAME,gBAAgBhB,cAAea,OAAO,CAAC,OAAO;IACpD,MAAMI,WAAW,GAAGF,UAAU,CAAC,EAAEC,cAAc,GAAG,CAAC;IACnD,MAAME,WAAW,GAAGhB,IAAI,CAAC,EAAEe,UAAU;IACrCrB,wGAAAA,CAAGuB,aAAa,CAACD,UAAUpB,qMAAAA;QAE3BD,yMAAAA,EAAoB;QAAEuB,eAAenB,QAAQE,EAAE,CAACC,YAAY;IAAC;IAE7DH,QAAQoB,MAAM,CAACC,IAAI,CAAC;QAAEC,KAAK,CAAC,qBAAqB,EAAEL,UAAU;IAAC;AAChE,EAAC"}},
    {"offset": {"line": 1431, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/database/migrations/migrate.ts"],"sourcesContent":["import type { BaseDatabaseAdapter } from '../types.js'\n\nimport { commitTransaction } from '../../utilities/commitTransaction.js'\nimport { createLocalReq } from '../../utilities/createLocalReq.js'\nimport { initTransaction } from '../../utilities/initTransaction.js'\nimport { killTransaction } from '../../utilities/killTransaction.js'\nimport { getMigrations } from './getMigrations.js'\nimport { readMigrationFiles } from './readMigrationFiles.js'\n\nexport const migrate: BaseDatabaseAdapter['migrate'] = async function migrate(\n  this: BaseDatabaseAdapter,\n  args,\n): Promise<void> {\n  const { payload } = this\n  const migrationFiles = args?.migrations || (await readMigrationFiles({ payload }))\n  const { existingMigrations, latestBatch } = await getMigrations({ payload })\n\n  const newBatch = latestBatch + 1\n\n  // Execute 'up' function for each migration sequentially\n  for (const migration of migrationFiles) {\n    const existingMigration = existingMigrations.find(\n      (existing) => existing.name === migration.name,\n    )\n\n    // Run migration if not found in database\n    if (existingMigration) {\n      continue\n    }\n\n    const start = Date.now()\n    const req = await createLocalReq({}, payload)\n\n    payload.logger.info({ msg: `Migrating: ${migration.name}` })\n\n    try {\n      await initTransaction(req)\n      const session = payload.db.sessions?.[await req.transactionID!]\n      await migration.up({ payload, req, session })\n      payload.logger.info({ msg: `Migrated:  ${migration.name} (${Date.now() - start}ms)` })\n      await payload.create({\n        collection: 'payload-migrations',\n        data: {\n          name: migration.name,\n          batch: newBatch,\n        },\n        req,\n      })\n      await commitTransaction(req)\n    } catch (err: unknown) {\n      await killTransaction(req)\n      payload.logger.error({ err, msg: `Error running migration ${migration.name}` })\n      throw err\n    }\n  }\n}\n"],"names":["commitTransaction","createLocalReq","initTransaction","killTransaction","getMigrations","readMigrationFiles","migrate","args","payload","migrationFiles","migrations","existingMigrations","latestBatch","newBatch","migration","existingMigration","find","existing","name","start","Date","now","req","logger","info","msg","session","db","sessions","transactionID","up","create","collection","data","batch","err","error"],"mappings":";;;;AAEA,SAASA,iBAAiB,QAAQ,uCAAsC;AACxE,SAASC,cAAc,QAAQ,oCAAmC;AAClE,SAASC,eAAe,QAAQ,qCAAoC;AACpE,SAASC,eAAe,QAAQ,qCAAoC;AACpE,SAASC,aAAa,QAAQ,qBAAoB;AAClD,SAASC,kBAAkB,QAAQ,0BAAyB;;;;;;;AAErD,MAAMC,UAA0C,eAAeA,QAEpEC,IAAI;IAEJ,MAAM,EAAEC,OAAO,EAAE,GAAG,IAAI;IACxB,MAAMC,iBAAiBF,MAAMG,cAAe,UAAML,uMAAAA,EAAmB;QAAEG;IAAQ;IAC/E,MAAM,EAAEG,kBAAkB,EAAEC,WAAW,EAAE,GAAG,UAAMR,6LAAAA,EAAc;QAAEI;IAAQ;IAE1E,MAAMK,WAAWD,cAAc;IAE/B,wDAAwD;IACxD,KAAK,MAAME,aAAaL,eAAgB;QACtC,MAAMM,oBAAoBJ,mBAAmBK,IAAI,CAC/C,CAACC,WAAaA,SAASC,IAAI,KAAKJ,UAAUI,IAAI;QAGhD,yCAAyC;QACzC,IAAIH,mBAAmB;YACrB;QACF;QAEA,MAAMI,QAAQC,KAAKC,GAAG;QACtB,MAAMC,MAAM,UAAMrB,kLAAAA,EAAe,CAAC,GAAGO;QAErCA,QAAQe,MAAM,CAACC,IAAI,CAAC;YAAEC,KAAK,CAAC,WAAW,EAAEX,UAAUI,IAAI,EAAE;QAAC;QAE1D,IAAI;YACF,UAAMhB,oLAAAA,EAAgBoB;YACtB,MAAMI,UAAUlB,QAAQmB,EAAE,CAACC,QAAQ,EAAE,CAAC,MAAMN,IAAIO,aAAa,CAAE;YAC/D,MAAMf,UAAUgB,EAAE,CAAC;gBAAEtB;gBAASc;gBAAKI;YAAQ;YAC3ClB,QAAQe,MAAM,CAACC,IAAI,CAAC;gBAAEC,KAAK,CAAC,WAAW,EAAEX,UAAUI,IAAI,CAAC,EAAE,EAAEE,KAAKC,GAAG,KAAKF,MAAM,GAAG,CAAC;YAAC;YACpF,MAAMX,QAAQuB,MAAM,CAAC;gBACnBC,YAAY;gBACZC,MAAM;oBACJf,MAAMJ,UAAUI,IAAI;oBACpBgB,OAAOrB;gBACT;gBACAS;YACF;YACA,UAAMtB,wLAAAA,EAAkBsB;QAC1B,EAAE,OAAOa,KAAc;YACrB,UAAMhC,oLAAAA,EAAgBmB;YACtBd,QAAQe,MAAM,CAACa,KAAK,CAAC;gBAAED;gBAAKV,KAAK,CAAC,wBAAwB,EAAEX,UAAUI,IAAI,EAAE;YAAC;YAC7E,MAAMiB;QACR;IACF;AACF,EAAC"}},
    {"offset": {"line": 1502, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/database/migrations/migrateDown.ts"],"sourcesContent":["import type { BaseDatabaseAdapter } from '../types.js'\n\nimport { commitTransaction } from '../../utilities/commitTransaction.js'\nimport { createLocalReq } from '../../utilities/createLocalReq.js'\nimport { initTransaction } from '../../utilities/initTransaction.js'\nimport { killTransaction } from '../../utilities/killTransaction.js'\nimport { getMigrations } from './getMigrations.js'\nimport { readMigrationFiles } from './readMigrationFiles.js'\n\nexport async function migrateDown(this: BaseDatabaseAdapter): Promise<void> {\n  const { payload } = this\n  const migrationFiles = await readMigrationFiles({ payload })\n\n  const { existingMigrations, latestBatch } = await getMigrations({\n    payload,\n  })\n\n  if (!existingMigrations?.length) {\n    payload.logger.info({ msg: 'No migrations to rollback.' })\n    return\n  }\n\n  payload.logger.info({\n    msg: `Rolling back batch ${latestBatch} consisting of ${existingMigrations.length} migration(s).`,\n  })\n\n  const latestBatchMigrations = existingMigrations.filter(({ batch }) => batch === latestBatch)\n\n  for (const migration of latestBatchMigrations) {\n    const migrationFile = migrationFiles.find((m) => m.name === migration.name)\n    if (!migrationFile) {\n      throw new Error(`Migration ${migration.name} not found locally.`)\n    }\n\n    const start = Date.now()\n    const req = await createLocalReq({}, payload)\n\n    try {\n      payload.logger.info({ msg: `Migrating down: ${migrationFile.name}` })\n      await initTransaction(req)\n      const session = payload.db.sessions?.[await req.transactionID!]\n      await migrationFile.down({ payload, req, session })\n      payload.logger.info({\n        msg: `Migrated down:  ${migrationFile.name} (${Date.now() - start}ms)`,\n      })\n      // Waiting for implementation here\n      await payload.delete({\n        id: migration.id!,\n        collection: 'payload-migrations',\n        req,\n      })\n\n      await commitTransaction(req)\n    } catch (err: unknown) {\n      await killTransaction(req)\n      payload.logger.error({\n        err,\n        msg: `Error running migration ${migrationFile.name}`,\n      })\n      process.exit(1)\n    }\n  }\n}\n"],"names":["commitTransaction","createLocalReq","initTransaction","killTransaction","getMigrations","readMigrationFiles","migrateDown","payload","migrationFiles","existingMigrations","latestBatch","length","logger","info","msg","latestBatchMigrations","filter","batch","migration","migrationFile","find","m","name","Error","start","Date","now","req","session","db","sessions","transactionID","down","delete","id","collection","err","error","process","exit"],"mappings":";;;;AAEA,SAASA,iBAAiB,QAAQ,uCAAsC;AACxE,SAASC,cAAc,QAAQ,oCAAmC;AAClE,SAASC,eAAe,QAAQ,qCAAoC;AACpE,SAASC,eAAe,QAAQ,qCAAoC;AACpE,SAASC,aAAa,QAAQ,qBAAoB;AAClD,SAASC,kBAAkB,QAAQ,0BAAyB;;;;;;;AAErD,eAAeC;IACpB,MAAM,EAAEC,OAAO,EAAE,GAAG,IAAI;IACxB,MAAMC,iBAAiB,UAAMH,uMAAAA,EAAmB;QAAEE;IAAQ;IAE1D,MAAM,EAAEE,kBAAkB,EAAEC,WAAW,EAAE,GAAG,UAAMN,6LAAAA,EAAc;QAC9DG;IACF;IAEA,IAAI,CAACE,oBAAoBE,QAAQ;QAC/BJ,QAAQK,MAAM,CAACC,IAAI,CAAC;YAAEC,KAAK;QAA6B;QACxD;IACF;IAEAP,QAAQK,MAAM,CAACC,IAAI,CAAC;QAClBC,KAAK,CAAC,mBAAmB,EAAEJ,YAAY,eAAe,EAAED,mBAAmBE,MAAM,CAAC,cAAc,CAAC;IACnG;IAEA,MAAMI,wBAAwBN,mBAAmBO,MAAM,CAAC,CAAC,EAAEC,KAAK,EAAE,GAAKA,UAAUP;IAEjF,KAAK,MAAMQ,aAAaH,sBAAuB;QAC7C,MAAMI,gBAAgBX,eAAeY,IAAI,CAAC,CAACC,IAAMA,EAAEC,IAAI,KAAKJ,UAAUI,IAAI;QAC1E,IAAI,CAACH,eAAe;YAClB,MAAM,IAAII,MAAM,CAAC,UAAU,EAAEL,UAAUI,IAAI,CAAC,mBAAmB,CAAC;QAClE;QAEA,MAAME,QAAQC,KAAKC,GAAG;QACtB,MAAMC,MAAM,UAAM1B,kLAAAA,EAAe,CAAC,GAAGM;QAErC,IAAI;YACFA,QAAQK,MAAM,CAACC,IAAI,CAAC;gBAAEC,KAAK,CAAC,gBAAgB,EAAEK,cAAcG,IAAI,EAAE;YAAC;YACnE,UAAMpB,oLAAAA,EAAgByB;YACtB,MAAMC,UAAUrB,QAAQsB,EAAE,CAACC,QAAQ,EAAE,CAAC,MAAMH,IAAII,aAAa,CAAE;YAC/D,MAAMZ,cAAca,IAAI,CAAC;gBAAEzB;gBAASoB;gBAAKC;YAAQ;YACjDrB,QAAQK,MAAM,CAACC,IAAI,CAAC;gBAClBC,KAAK,CAAC,gBAAgB,EAAEK,cAAcG,IAAI,CAAC,EAAE,EAAEG,KAAKC,GAAG,KAAKF,MAAM,GAAG,CAAC;YACxE;YACA,kCAAkC;YAClC,MAAMjB,QAAQ0B,MAAM,CAAC;gBACnBC,IAAIhB,UAAUgB,EAAE;gBAChBC,YAAY;gBACZR;YACF;YAEA,UAAM3B,wLAAAA,EAAkB2B;QAC1B,EAAE,OAAOS,KAAc;YACrB,UAAMjC,oLAAAA,EAAgBwB;YACtBpB,QAAQK,MAAM,CAACyB,KAAK,CAAC;gBACnBD;gBACAtB,KAAK,CAAC,wBAAwB,EAAEK,cAAcG,IAAI,EAAE;YACtD;YACAgB,QAAQC,IAAI,CAAC;QACf;IACF;AACF"}},
    {"offset": {"line": 1578, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/database/migrations/migrateRefresh.ts"],"sourcesContent":["import type { BaseDatabaseAdapter } from '../types.js'\n\nimport { commitTransaction } from '../../utilities/commitTransaction.js'\nimport { createLocalReq } from '../../utilities/createLocalReq.js'\nimport { initTransaction } from '../../utilities/initTransaction.js'\nimport { killTransaction } from '../../utilities/killTransaction.js'\nimport { getMigrations } from './getMigrations.js'\nimport { readMigrationFiles } from './readMigrationFiles.js'\n\n/**\n * Run all migration down functions before running up\n */\nexport async function migrateRefresh(this: BaseDatabaseAdapter) {\n  const { payload } = this\n  const migrationFiles = await readMigrationFiles({ payload })\n\n  const { existingMigrations } = await getMigrations({\n    payload,\n  })\n\n  const req = await createLocalReq({}, payload)\n\n  if (existingMigrations?.length) {\n    payload.logger.info({\n      msg: `Rolling back all ${existingMigrations.length} migration(s).`,\n    })\n    // Reverse order of migrations to rollback\n    existingMigrations.reverse()\n\n    for (const migration of existingMigrations) {\n      try {\n        const migrationFile = migrationFiles.find((m) => m.name === migration.name)\n        if (!migrationFile) {\n          throw new Error(`Migration ${migration.name} not found locally.`)\n        }\n\n        payload.logger.info({ msg: `Migrating down: ${migration.name}` })\n        const start = Date.now()\n        await initTransaction(req)\n        const session = payload.db.sessions?.[await req.transactionID!]\n        await migrationFile.down({ payload, req, session })\n        payload.logger.info({\n          msg: `Migrated down:  ${migration.name} (${Date.now() - start}ms)`,\n        })\n        await payload.delete({\n          collection: 'payload-migrations',\n          req,\n          where: {\n            name: {\n              equals: migration.name,\n            },\n          },\n        })\n      } catch (err: unknown) {\n        await killTransaction(req)\n        let msg = `Error running migration ${migration.name}. Rolling back.`\n        if (err instanceof Error) {\n          msg += ` ${err.message}`\n        }\n        payload.logger.error({\n          err,\n          msg,\n        })\n        process.exit(1)\n      }\n    }\n  } else {\n    payload.logger.info({ msg: 'No migrations to rollback.' })\n  }\n\n  // Run all migrate up\n  for (const migration of migrationFiles) {\n    payload.logger.info({ msg: `Migrating: ${migration.name}` })\n    try {\n      const start = Date.now()\n      await initTransaction(req)\n      await migration.up({ payload, req })\n      await payload.create({\n        collection: 'payload-migrations',\n        data: {\n          name: migration.name,\n          executed: true,\n        },\n        req,\n      })\n      await commitTransaction(req)\n\n      payload.logger.info({ msg: `Migrated:  ${migration.name} (${Date.now() - start}ms)` })\n    } catch (err: unknown) {\n      await killTransaction(req)\n      let msg = `Error running migration ${migration.name}. Rolling back.`\n      if (err instanceof Error) {\n        msg += ` ${err.message}`\n      }\n      payload.logger.error({\n        err,\n        msg,\n      })\n      process.exit(1)\n    }\n  }\n}\n"],"names":["commitTransaction","createLocalReq","initTransaction","killTransaction","getMigrations","readMigrationFiles","migrateRefresh","payload","migrationFiles","existingMigrations","req","length","logger","info","msg","reverse","migration","migrationFile","find","m","name","Error","start","Date","now","session","db","sessions","transactionID","down","delete","collection","where","equals","err","message","error","process","exit","up","create","data","executed"],"mappings":"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"}},
    {"offset": {"line": 1698, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/database/migrations/migrateReset.ts"],"sourcesContent":["import type { BaseDatabaseAdapter } from '../types.js'\n\nimport { commitTransaction } from '../../utilities/commitTransaction.js'\nimport { createLocalReq } from '../../utilities/createLocalReq.js'\nimport { initTransaction } from '../../utilities/initTransaction.js'\nimport { killTransaction } from '../../utilities/killTransaction.js'\nimport { getMigrations } from './getMigrations.js'\nimport { readMigrationFiles } from './readMigrationFiles.js'\n\nexport async function migrateReset(this: BaseDatabaseAdapter): Promise<void> {\n  const { payload } = this\n  const migrationFiles = await readMigrationFiles({ payload })\n\n  const { existingMigrations } = await getMigrations({ payload })\n\n  if (!existingMigrations?.length) {\n    payload.logger.info({ msg: 'No migrations to reset.' })\n    return\n  }\n\n  const req = await createLocalReq({}, payload)\n\n  migrationFiles.reverse()\n\n  // Rollback all migrations in order\n  for (const migration of migrationFiles) {\n    // Create or update migration in database\n    const existingMigration = existingMigrations.find(\n      (existing) => existing.name === migration.name,\n    )\n    if (existingMigration) {\n      payload.logger.info({ msg: `Migrating down: ${migration.name}` })\n      try {\n        const start = Date.now()\n        await initTransaction(req)\n        const session = payload.db.sessions?.[await req.transactionID!]\n        await migration.down({ payload, req, session })\n        await payload.delete({\n          collection: 'payload-migrations',\n          req,\n          where: {\n            id: {\n              equals: existingMigration.id,\n            },\n          },\n        })\n        await commitTransaction(req)\n        payload.logger.info({ msg: `Migrated down:  ${migration.name} (${Date.now() - start}ms)` })\n      } catch (err: unknown) {\n        await killTransaction(req)\n        payload.logger.error({ err, msg: `Error running migration ${migration.name}` })\n        throw err\n      }\n    }\n  }\n\n  // Delete dev migration\n  try {\n    await payload.delete({\n      collection: 'payload-migrations',\n      where: {\n        batch: {\n          equals: -1,\n        },\n      },\n    })\n  } catch (err: unknown) {\n    payload.logger.error({ err, msg: 'Error deleting dev migration' })\n  }\n}\n"],"names":["commitTransaction","createLocalReq","initTransaction","killTransaction","getMigrations","readMigrationFiles","migrateReset","payload","migrationFiles","existingMigrations","length","logger","info","msg","req","reverse","migration","existingMigration","find","existing","name","start","Date","now","session","db","sessions","transactionID","down","delete","collection","where","id","equals","err","error","batch"],"mappings":";;;;AAEA,SAASA,iBAAiB,QAAQ,uCAAsC;AACxE,SAASC,cAAc,QAAQ,oCAAmC;AAClE,SAASC,eAAe,QAAQ,qCAAoC;AACpE,SAASC,eAAe,QAAQ,qCAAoC;AACpE,SAASC,aAAa,QAAQ,qBAAoB;AAClD,SAASC,kBAAkB,QAAQ,0BAAyB;;;;;;;AAErD,eAAeC;IACpB,MAAM,EAAEC,OAAO,EAAE,GAAG,IAAI;IACxB,MAAMC,iBAAiB,UAAMH,uMAAAA,EAAmB;QAAEE;IAAQ;IAE1D,MAAM,EAAEE,kBAAkB,EAAE,GAAG,UAAML,6LAAAA,EAAc;QAAEG;IAAQ;IAE7D,IAAI,CAACE,oBAAoBC,QAAQ;QAC/BH,QAAQI,MAAM,CAACC,IAAI,CAAC;YAAEC,KAAK;QAA0B;QACrD;IACF;IAEA,MAAMC,MAAM,UAAMb,kLAAAA,EAAe,CAAC,GAAGM;IAErCC,eAAeO,OAAO;IAEtB,mCAAmC;IACnC,KAAK,MAAMC,aAAaR,eAAgB;QACtC,yCAAyC;QACzC,MAAMS,oBAAoBR,mBAAmBS,IAAI,CAC/C,CAACC,WAAaA,SAASC,IAAI,KAAKJ,UAAUI,IAAI;QAEhD,IAAIH,mBAAmB;YACrBV,QAAQI,MAAM,CAACC,IAAI,CAAC;gBAAEC,KAAK,CAAC,gBAAgB,EAAEG,UAAUI,IAAI,EAAE;YAAC;YAC/D,IAAI;gBACF,MAAMC,QAAQC,KAAKC,GAAG;gBACtB,UAAMrB,oLAAAA,EAAgBY;gBACtB,MAAMU,UAAUjB,QAAQkB,EAAE,CAACC,QAAQ,EAAE,CAAC,MAAMZ,IAAIa,aAAa,CAAE;gBAC/D,MAAMX,UAAUY,IAAI,CAAC;oBAAErB;oBAASO;oBAAKU;gBAAQ;gBAC7C,MAAMjB,QAAQsB,MAAM,CAAC;oBACnBC,YAAY;oBACZhB;oBACAiB,OAAO;wBACLC,IAAI;4BACFC,QAAQhB,kBAAkBe,EAAE;wBAC9B;oBACF;gBACF;gBACA,UAAMhC,wLAAAA,EAAkBc;gBACxBP,QAAQI,MAAM,CAACC,IAAI,CAAC;oBAAEC,KAAK,CAAC,gBAAgB,EAAEG,UAAUI,IAAI,CAAC,EAAE,EAAEE,KAAKC,GAAG,KAAKF,MAAM,GAAG,CAAC;gBAAC;YAC3F,EAAE,OAAOa,KAAc;gBACrB,UAAM/B,oLAAAA,EAAgBW;gBACtBP,QAAQI,MAAM,CAACwB,KAAK,CAAC;oBAAED;oBAAKrB,KAAK,CAAC,wBAAwB,EAAEG,UAAUI,IAAI,EAAE;gBAAC;gBAC7E,MAAMc;YACR;QACF;IACF;IAEA,uBAAuB;IACvB,IAAI;QACF,MAAM3B,QAAQsB,MAAM,CAAC;YACnBC,YAAY;YACZC,OAAO;gBACLK,OAAO;oBACLH,QAAQ,CAAC;gBACX;YACF;QACF;IACF,EAAE,OAAOC,KAAc;QACrB3B,QAAQI,MAAM,CAACwB,KAAK,CAAC;YAAED;YAAKrB,KAAK;QAA+B;IAClE;AACF"}},
    {"offset": {"line": 1791, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/database/migrations/migrateStatus.ts"],"sourcesContent":["import { Table } from 'console-table-printer'\n\nimport type { BaseDatabaseAdapter } from '../types.js'\n\nimport { getMigrations } from './getMigrations.js'\nimport { readMigrationFiles } from './readMigrationFiles.js'\n\nexport async function migrateStatus(this: BaseDatabaseAdapter): Promise<void> {\n  const { payload } = this\n  const migrationFiles = await readMigrationFiles({ payload })\n\n  payload.logger.debug({\n    msg: `Found ${migrationFiles.length} migration files.`,\n  })\n\n  const { existingMigrations } = await getMigrations({ payload })\n\n  if (!migrationFiles.length) {\n    payload.logger.info({ msg: 'No migrations found.' })\n    return\n  }\n\n  // Compare migration files to existing migrations\n  const statuses = migrationFiles.map((migration) => {\n    const existingMigration = existingMigrations.find((m) => m.name === migration.name)\n    return {\n      Name: migration.name,\n\n      Batch: existingMigration?.batch,\n      Ran: existingMigration ? 'Yes' : 'No',\n    }\n  })\n\n  const p = new Table()\n\n  statuses.forEach((s) => {\n    p.addRow(s, {\n      color: s.Ran === 'Yes' ? 'green' : 'red',\n    })\n  })\n  p.printTable()\n}\n"],"names":["Table","getMigrations","readMigrationFiles","migrateStatus","payload","migrationFiles","logger","debug","msg","length","existingMigrations","info","statuses","map","migration","existingMigration","find","m","name","Name","Batch","batch","Ran","p","forEach","s","addRow","color","printTable"],"mappings":";;;;AAAA,SAASA,KAAK,QAAQ,wBAAuB;AAI7C,SAASC,aAAa,QAAQ,qBAAoB;AAClD,SAASC,kBAAkB,QAAQ,0BAAyB;;;;AAErD,eAAeC;IACpB,MAAM,EAAEC,OAAO,EAAE,GAAG,IAAI;IACxB,MAAMC,iBAAiB,UAAMH,uMAAAA,EAAmB;QAAEE;IAAQ;IAE1DA,QAAQE,MAAM,CAACC,KAAK,CAAC;QACnBC,KAAK,CAAC,MAAM,EAAEH,eAAeI,MAAM,CAAC,iBAAiB,CAAC;IACxD;IAEA,MAAM,EAAEC,kBAAkB,EAAE,GAAG,UAAMT,6LAAAA,EAAc;QAAEG;IAAQ;IAE7D,IAAI,CAACC,eAAeI,MAAM,EAAE;QAC1BL,QAAQE,MAAM,CAACK,IAAI,CAAC;YAAEH,KAAK;QAAuB;QAClD;IACF;IAEA,iDAAiD;IACjD,MAAMI,WAAWP,eAAeQ,GAAG,CAAC,CAACC;QACnC,MAAMC,oBAAoBL,mBAAmBM,IAAI,CAAC,CAACC,IAAMA,EAAEC,IAAI,KAAKJ,UAAUI,IAAI;QAClF,OAAO;YACLC,MAAML,UAAUI,IAAI;YAEpBE,OAAOL,mBAAmBM;YAC1BC,KAAKP,oBAAoB,QAAQ;QACnC;IACF;IAEA,MAAMQ,IAAI,IAAIvB,uKAAAA;IAEdY,SAASY,OAAO,CAAC,CAACC;QAChBF,EAAEG,MAAM,CAACD,GAAG;YACVE,OAAOF,EAAEH,GAAG,KAAK,QAAQ,UAAU;QACrC;IACF;IACAC,EAAEK,UAAU;AACd"}},
    {"offset": {"line": 1839, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/database/createDatabaseAdapter.ts"],"sourcesContent":["import type { MarkOptional } from 'ts-essentials'\n\nimport type {\n  BaseDatabaseAdapter,\n  BeginTransaction,\n  CommitTransaction,\n  RollbackTransaction,\n} from './types.js'\n\nimport { defaultUpdateJobs } from './defaultUpdateJobs.js'\nimport { createMigration } from './migrations/createMigration.js'\nimport { migrate } from './migrations/migrate.js'\nimport { migrateDown } from './migrations/migrateDown.js'\nimport { migrateRefresh } from './migrations/migrateRefresh.js'\nimport { migrateReset } from './migrations/migrateReset.js'\nimport { migrateStatus } from './migrations/migrateStatus.js'\n\nconst beginTransaction: BeginTransaction = () => Promise.resolve(null)\n// @ts-expect-error - vestiges of when tsconfig was not strict. Feel free to improve\nconst rollbackTransaction: RollbackTransaction = () => Promise.resolve(null)\n// @ts-expect-error - vestiges of when tsconfig was not strict. Feel free to improve\nconst commitTransaction: CommitTransaction = () => Promise.resolve(null)\n\nexport function createDatabaseAdapter<T extends BaseDatabaseAdapter>(\n  args: MarkOptional<\n    T,\n    | 'allowIDOnCreate'\n    | 'bulkOperationsSingleTransaction'\n    | 'createMigration'\n    | 'migrate'\n    | 'migrateDown'\n    | 'migrateFresh'\n    | 'migrateRefresh'\n    | 'migrateReset'\n    | 'migrateStatus'\n    | 'migrationDir'\n    | 'updateJobs'\n  >,\n): T {\n  return {\n    // Default 'null' transaction functions\n    // @ts-expect-error - vestiges of when tsconfig was not strict. Feel free to improve\n    beginTransaction,\n    // @ts-expect-error - vestiges of when tsconfig was not strict. Feel free to improve\n    commitTransaction,\n    createMigration,\n    migrate,\n    migrateDown,\n    migrateFresh: () => Promise.resolve(null),\n    migrateRefresh,\n    migrateReset,\n    migrateStatus,\n    // @ts-expect-error - vestiges of when tsconfig was not strict. Feel free to improve\n    rollbackTransaction,\n    updateJobs: defaultUpdateJobs,\n\n    ...args,\n    // Ensure migrationDir is set\n    migrationDir: args.migrationDir || 'migrations',\n    // Set default for bulkOperationsSingleTransaction if not provided\n    bulkOperationsSingleTransaction: args.bulkOperationsSingleTransaction ?? false,\n  } as T\n}\n"],"names":["defaultUpdateJobs","createMigration","migrate","migrateDown","migrateRefresh","migrateReset","migrateStatus","beginTransaction","Promise","resolve","rollbackTransaction","commitTransaction","createDatabaseAdapter","args","migrateFresh","updateJobs","migrationDir","bulkOperationsSingleTransaction"],"mappings":";;;;AASA,SAASA,iBAAiB,QAAQ,yBAAwB;AAC1D,SAASC,eAAe,QAAQ,kCAAiC;AACjE,SAASC,OAAO,QAAQ,0BAAyB;AACjD,SAASC,WAAW,QAAQ,8BAA6B;AACzD,SAASC,cAAc,QAAQ,iCAAgC;AAC/D,SAASC,YAAY,QAAQ,+BAA8B;AAC3D,SAASC,aAAa,QAAQ,gCAA+B;;;;;;;;AAE7D,MAAMC,mBAAqC,IAAMC,QAAQC,OAAO,CAAC;AACjE,oFAAoF;AACpF,MAAMC,sBAA2C,IAAMF,QAAQC,OAAO,CAAC;AACvE,oFAAoF;AACpF,MAAME,oBAAuC,IAAMH,QAAQC,OAAO,CAAC;AAE5D,SAASG,sBACdC,IAaC;IAED,OAAO;QACL,uCAAuC;QACvC,oFAAoF;QACpFN;QACA,oFAAoF;QACpFI;yBACAV,iMAAAA;iBACAC,iLAAAA;qBACAC,yLAAAA;QACAW,cAAc,IAAMN,QAAQC,OAAO,CAAC;wBACpCL,+LAAAA;sBACAC,2LAAAA;uBACAC,6LAAAA;QACA,oFAAoF;QACpFI;QACAK,YAAYf,uLAAAA;QAEZ,GAAGa,IAAI;QACP,6BAA6B;QAC7BG,cAAcH,KAAKG,YAAY,IAAI;QACnC,kEAAkE;QAClEC,iCAAiCJ,KAAKI,+BAA+B,IAAI;IAC3E;AACF"}},
    {"offset": {"line": 1890, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/database/defaultBeginTransaction.ts"],"sourcesContent":["import type { BeginTransaction } from './types.js'\n\n/**\n * Default implementation of `beginTransaction` that returns a resolved promise of null\n */\nexport function defaultBeginTransaction(): BeginTransaction {\n  const promiseSingleton: Promise<null> = Promise.resolve(null)\n  return () => promiseSingleton\n}\n"],"names":["defaultBeginTransaction","promiseSingleton","Promise","resolve"],"mappings":"AAEA;;CAEC,GACD;;;;AAAO,SAASA;IACd,MAAMC,mBAAkCC,QAAQC,OAAO,CAAC;IACxD,OAAO,IAAMF;AACf"}},
    {"offset": {"line": 1904, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/database/migrations/findMigrationDir.ts"],"sourcesContent":["import fs from 'fs'\nimport path from 'path'\n\n/**\n * Attempt to find migrations directory.\n *\n * Checks for the following directories in order:\n * - `migrationDir` argument from Payload config\n * - `src/migrations`\n * - `dist/migrations`\n * - `migrations`\n *\n * @param migrationDir\n * @default src/migrations`, if the src folder does not exists - migrations.\n * @returns\n */\nexport const findMigrationDir = (migrationDir?: string): string => {\n  const cwd = process.cwd()\n\n  const srcMigrationsDir = path.resolve(cwd, 'src/migrations')\n  const distMigrationsDir = path.resolve(cwd, 'dist/migrations')\n  const relativeMigrations = path.resolve(cwd, 'migrations')\n\n  // Use arg if provided\n  if (migrationDir) {\n    return migrationDir\n  }\n\n  // Check other common locations\n  if (fs.existsSync(srcMigrationsDir)) {\n    return srcMigrationsDir\n  }\n\n  if (fs.existsSync(distMigrationsDir)) {\n    return distMigrationsDir\n  }\n\n  if (fs.existsSync(relativeMigrations)) {\n    return relativeMigrations\n  }\n\n  if (fs.existsSync(path.resolve(cwd, 'src'))) {\n    return srcMigrationsDir\n  }\n\n  return relativeMigrations\n}\n"],"names":["fs","path","findMigrationDir","migrationDir","cwd","process","srcMigrationsDir","resolve","distMigrationsDir","relativeMigrations","existsSync"],"mappings":";;;;AAAA,OAAOA,QAAQ,KAAI;AACnB,OAAOC,UAAU,OAAM;;;AAehB,MAAMC,mBAAmB,CAACC;IAC/B,MAAMC,MAAMC,QAAQD,GAAG;IAEvB,MAAME,mBAAmBL,4GAAAA,CAAKM,OAAO,CAACH,KAAK;IAC3C,MAAMI,oBAAoBP,4GAAAA,CAAKM,OAAO,CAACH,KAAK;IAC5C,MAAMK,qBAAqBR,4GAAAA,CAAKM,OAAO,CAACH,KAAK;IAE7C,sBAAsB;IACtB,IAAID,cAAc;QAChB,OAAOA;IACT;IAEA,+BAA+B;IAC/B,IAAIH,wGAAAA,CAAGU,UAAU,CAACJ,mBAAmB;QACnC,OAAOA;IACT;IAEA,IAAIN,wGAAAA,CAAGU,UAAU,CAACF,oBAAoB;QACpC,OAAOA;IACT;IAEA,IAAIR,wGAAAA,CAAGU,UAAU,CAACD,qBAAqB;QACrC,OAAOA;IACT;IAEA,IAAIT,wGAAAA,CAAGU,UAAU,CAACT,4GAAAA,CAAKM,OAAO,CAACH,KAAK,SAAS;QAC3C,OAAOE;IACT;IAEA,OAAOG;AACT,EAAC"}},
    {"offset": {"line": 1940, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/versions/baseFields.ts"],"sourcesContent":["// @ts-strict-ignore\nimport type { CheckboxField, Field, Option } from '../fields/config/types.js'\n\nexport const statuses: Option[] = [\n  {\n    label: ({ t }) => t('version:draft'),\n    value: 'draft',\n  },\n  {\n    label: ({ t }) => t('version:published'),\n    value: 'published',\n  },\n]\n\nexport const baseVersionFields = ({ localized }: { localized: boolean }): Field[] => [\n  {\n    name: '_status',\n    type: 'select',\n    admin: {\n      components: {\n        Field: false,\n      },\n      disableBulkEdit: true,\n    },\n    defaultValue: 'draft',\n    index: true,\n    label: ({ t }) => t('version:status'),\n    localized: Boolean(localized),\n    options: statuses,\n  },\n]\n\n// When publishing a specific locale,\n// we need to create a new draft which acts as a\n// \"snapshot\" to retain all existing draft data.\n// This field will be used to exclude any snapshot versions\n// from the admin Versions list\nexport const versionSnapshotField: CheckboxField = {\n  name: 'snapshot',\n  type: 'checkbox',\n  admin: {\n    disableBulkEdit: true,\n    disabled: true,\n  },\n  index: true,\n}\n"],"names":["statuses","label","t","value","baseVersionFields","localized","name","type","admin","components","Field","disableBulkEdit","defaultValue","index","Boolean","options","versionSnapshotField","disabled"],"mappings":"AAAA,oBAAoB;;;;;;;;;AAGb,MAAMA,WAAqB;IAChC;QACEC,OAAO,CAAC,EAAEC,CAAC,EAAE,GAAKA,EAAE;QACpBC,OAAO;IACT;IACA;QACEF,OAAO,CAAC,EAAEC,CAAC,EAAE,GAAKA,EAAE;QACpBC,OAAO;IACT;CACD,CAAA;AAEM,MAAMC,oBAAoB,CAAC,EAAEC,SAAS,EAA0B,GAAc;QACnF;YACEC,MAAM;YACNC,MAAM;YACNC,OAAO;gBACLC,YAAY;oBACVC,OAAO;gBACT;gBACAC,iBAAiB;YACnB;YACAC,cAAc;YACdC,OAAO;YACPZ,OAAO,CAAC,EAAEC,CAAC,EAAE,GAAKA,EAAE;YACpBG,WAAWS,QAAQT;YACnBU,SAASf;QACX;KACD,CAAA;AAOM,MAAMgB,uBAAsC;IACjDV,MAAM;IACNC,MAAM;IACNC,OAAO;QACLG,iBAAiB;QACjBM,UAAU;IACZ;IACAJ,OAAO;AACT,EAAC"}},
    {"offset": {"line": 1989, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/versions/defaults.ts"],"sourcesContent":["export const versionDefaults = {\n  autosaveInterval: 2000,\n}\n"],"names":["versionDefaults","autosaveInterval"],"mappings":";;;;AAAO,MAAMA,kBAAkB;IAC7BC,kBAAkB;AACpB,EAAC"}},
    {"offset": {"line": 2000, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/versions/drafts/appendVersionToQueryKey.ts"],"sourcesContent":["import type { Where } from '../../types/index.js'\n\nexport const appendVersionToQueryKey = (query: Where = {}): Where => {\n  return Object.entries(query).reduce((res, [key, val]) => {\n    if (['AND', 'and', 'OR', 'or'].includes(key) && Array.isArray(val)) {\n      return {\n        ...res,\n        [key.toLowerCase()]: val.map((subQuery) => appendVersionToQueryKey(subQuery)),\n      }\n    }\n\n    if (key !== 'id') {\n      return {\n        ...res,\n        [`version.${key}`]: val,\n      }\n    }\n\n    return {\n      ...res,\n      parent: val,\n    }\n  }, {})\n}\n"],"names":["appendVersionToQueryKey","query","Object","entries","reduce","res","key","val","includes","Array","isArray","toLowerCase","map","subQuery","parent"],"mappings":";;;;AAEO,MAAMA,0BAA0B,CAACC,QAAe,CAAC,CAAC;IACvD,OAAOC,OAAOC,OAAO,CAACF,OAAOG,MAAM,CAAC,CAACC,KAAK,CAACC,KAAKC,IAAI;QAClD,IAAI;YAAC;YAAO;YAAO;YAAM;SAAK,CAACC,QAAQ,CAACF,QAAQG,MAAMC,OAAO,CAACH,MAAM;YAClE,OAAO;gBACL,GAAGF,GAAG;gBACN,CAACC,IAAIK,WAAW,GAAG,EAAEJ,IAAIK,GAAG,CAAC,CAACC,WAAab,wBAAwBa;YACrE;QACF;QAEA,IAAIP,QAAQ,MAAM;YAChB,OAAO;gBACL,GAAGD,GAAG;gBACN,CAAC,CAAC,QAAQ,EAAEC,KAAK,CAAC,EAAEC;YACtB;QACF;QAEA,OAAO;YACL,GAAGF,GAAG;YACNS,QAAQP;QACV;IACF,GAAG,CAAC;AACN,EAAC"}},
    {"offset": {"line": 2033, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/versions/getLatestCollectionVersion.ts"],"sourcesContent":["import type { SanitizedCollectionConfig, TypeWithID } from '../collections/config/types.js'\nimport type { FindOneArgs } from '../database/types.js'\nimport type { Payload, PayloadRequest, Where } from '../types/index.js'\nimport type { TypeWithVersion } from './types.js'\n\nimport { combineQueries } from '../database/combineQueries.js'\nimport { hasDraftsEnabled } from '../utilities/getVersionsConfig.js'\nimport { appendVersionToQueryKey } from './drafts/appendVersionToQueryKey.js'\n\ntype Args = {\n  config: SanitizedCollectionConfig\n  id: number | string\n  payload: Payload\n  published?: boolean\n  query: FindOneArgs\n  req?: PayloadRequest\n}\n\nexport const getLatestCollectionVersion = async <T extends TypeWithID = any>({\n  id,\n  config,\n  payload,\n  published,\n  query,\n  req,\n}: Args): Promise<T | undefined> => {\n  let latestVersion!: TypeWithVersion<T>\n\n  const whereQuery = published\n    ? { and: [{ parent: { equals: id } }, { 'version._status': { equals: 'published' } }] }\n    : { and: [{ parent: { equals: id } }, { latest: { equals: true } }] }\n\n  if (hasDraftsEnabled(config)) {\n    const { docs } = await payload.db.findVersions<T>({\n      collection: config.slug,\n      limit: 1,\n      locale: req?.locale || query.locale,\n      pagination: false,\n      req,\n      sort: '-updatedAt',\n      where: combineQueries(appendVersionToQueryKey(query.where), whereQuery as unknown as Where),\n    })\n    latestVersion = docs[0]!\n  }\n\n  if (!latestVersion) {\n    if (!published) {\n      const doc = await payload.db.findOne<T>({ ...query, req })\n\n      return doc ?? undefined\n    }\n\n    return undefined\n  }\n\n  latestVersion.version.id = id\n\n  return latestVersion.version\n}\n"],"names":["combineQueries","hasDraftsEnabled","appendVersionToQueryKey","getLatestCollectionVersion","id","config","payload","published","query","req","latestVersion","whereQuery","and","parent","equals","latest","docs","db","findVersions","collection","slug","limit","locale","pagination","sort","where","doc","findOne","undefined","version"],"mappings":";;;;AAKA,SAASA,cAAc,QAAQ,gCAA+B;AAC9D,SAASC,gBAAgB,QAAQ,oCAAmC;AACpE,SAASC,uBAAuB,QAAQ,sCAAqC;;;;AAWtE,MAAMC,6BAA6B,OAAmC,EAC3EC,EAAE,EACFC,MAAM,EACNC,OAAO,EACPC,SAAS,EACTC,KAAK,EACLC,GAAG,EACE;IACL,IAAIC;IAEJ,MAAMC,aAAaJ,YACf;QAAEK,KAAK;YAAC;gBAAEC,QAAQ;oBAAEC,QAAQV;gBAAG;YAAE;YAAG;gBAAE,mBAAmB;oBAAEU,QAAQ;gBAAY;YAAE;SAAE;IAAC,IACpF;QAAEF,KAAK;YAAC;gBAAEC,QAAQ;oBAAEC,QAAQV;gBAAG;YAAE;YAAG;gBAAEW,QAAQ;oBAAED,QAAQ;gBAAK;YAAE;SAAE;IAAC;IAEtE,QAAIb,uLAAAA,EAAiBI,SAAS;QAC5B,MAAM,EAAEW,IAAI,EAAE,GAAG,MAAMV,QAAQW,EAAE,CAACC,YAAY,CAAI;YAChDC,YAAYd,OAAOe,IAAI;YACvBC,OAAO;YACPC,QAAQb,KAAKa,UAAUd,MAAMc,MAAM;YACnCC,YAAY;YACZd;YACAe,MAAM;YACNC,WAAOzB,iLAAAA,MAAeE,6MAAAA,EAAwBM,MAAMiB,KAAK,GAAGd;QAC9D;QACAD,gBAAgBM,IAAI,CAAC,EAAE;IACzB;IAEA,IAAI,CAACN,eAAe;QAClB,IAAI,CAACH,WAAW;YACd,MAAMmB,MAAM,MAAMpB,QAAQW,EAAE,CAACU,OAAO,CAAI;gBAAE,GAAGnB,KAAK;gBAAEC;YAAI;YAExD,OAAOiB,OAAOE;QAChB;QAEA,OAAOA;IACT;IAEAlB,cAAcmB,OAAO,CAACzB,EAAE,GAAGA;IAE3B,OAAOM,cAAcmB,OAAO;AAC9B,EAAC"}},
    {"offset": {"line": 2101, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/versions/drafts/getQueryDraftsSelect.ts"],"sourcesContent":["import type { SelectType } from '../../types/index.js'\n\nimport { getSelectMode } from '../../utilities/getSelectMode.js'\n\nexport const getQueryDraftsSelect = ({\n  select,\n}: {\n  select?: SelectType\n}): SelectType | undefined => {\n  if (!select) {\n    return\n  }\n\n  const mode = getSelectMode(select)\n\n  if (mode === 'include') {\n    return {\n      parent: true,\n      version: select,\n    } as SelectType\n  }\n\n  return {\n    version: select,\n  } as SelectType\n}\n"],"names":["getSelectMode","getQueryDraftsSelect","select","mode","parent","version"],"mappings":";;;;AAEA,SAASA,aAAa,QAAQ,mCAAkC;;AAEzD,MAAMC,uBAAuB,CAAC,EACnCC,MAAM,EAGP;IACC,IAAI,CAACA,QAAQ;QACX;IACF;IAEA,MAAMC,WAAOH,gLAAAA,EAAcE;IAE3B,IAAIC,SAAS,WAAW;QACtB,OAAO;YACLC,QAAQ;YACRC,SAASH;QACX;IACF;IAEA,OAAO;QACLG,SAASH;IACX;AACF,EAAC"}},
    {"offset": {"line": 2126, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/versions/enforceMaxVersions.ts"],"sourcesContent":["import type { SanitizedCollectionConfig } from '../collections/config/types.js'\nimport type { DeleteVersionsArgs } from '../database/types.js'\nimport type { SanitizedGlobalConfig } from '../globals/config/types.js'\nimport type { Payload, PayloadRequest, Where } from '../types/index.js'\n\ntype Args = {\n  collection?: SanitizedCollectionConfig\n  global?: SanitizedGlobalConfig\n  id?: number | string\n  max: number\n  payload: Payload\n  req?: PayloadRequest\n}\n\nexport const enforceMaxVersions = async ({\n  id,\n  collection,\n  global: globalConfig,\n  max,\n  payload,\n  req,\n}: Args): Promise<void> => {\n  const entityType = collection ? 'collection' : 'global'\n  const slug = collection ? collection.slug : globalConfig?.slug\n\n  try {\n    const where: Where = {}\n    let oldestAllowedDoc\n\n    if (collection) {\n      where.parent = {\n        equals: id,\n      }\n\n      const query = await payload.db.findVersions({\n        collection: collection.slug,\n        limit: 1,\n        page: max + 1,\n        pagination: false,\n        req,\n        sort: '-updatedAt',\n        where,\n      })\n\n      ;[oldestAllowedDoc] = query.docs\n    } else if (globalConfig) {\n      const query = await payload.db.findGlobalVersions({\n        global: globalConfig.slug,\n        limit: 1,\n        page: max + 1,\n        pagination: false,\n        req,\n        sort: '-updatedAt',\n        where,\n      })\n\n      ;[oldestAllowedDoc] = query.docs\n    }\n\n    if (oldestAllowedDoc?.updatedAt) {\n      const deleteQuery: Where = {\n        updatedAt: {\n          less_than_equal: oldestAllowedDoc.updatedAt,\n        },\n      }\n\n      if (collection) {\n        deleteQuery.parent = {\n          equals: id,\n        }\n      }\n\n      const deleteVersionsArgs: DeleteVersionsArgs = { req, where: deleteQuery }\n\n      if (globalConfig) {\n        deleteVersionsArgs.globalSlug = slug\n      } else {\n        deleteVersionsArgs.collection = slug\n      }\n\n      await payload.db.deleteVersions(deleteVersionsArgs)\n    }\n  } catch (err) {\n    payload.logger.error(err)\n    payload.logger.error(\n      `There was an error cleaning up old versions for the ${entityType} ${slug}`,\n    )\n  }\n}\n"],"names":["enforceMaxVersions","id","collection","global","globalConfig","max","payload","req","entityType","slug","where","oldestAllowedDoc","parent","equals","query","db","findVersions","limit","page","pagination","sort","docs","findGlobalVersions","updatedAt","deleteQuery","less_than_equal","deleteVersionsArgs","globalSlug","deleteVersions","err","logger","error"],"mappings":";;;;AAcO,MAAMA,qBAAqB,OAAO,EACvCC,EAAE,EACFC,UAAU,EACVC,QAAQC,YAAY,EACpBC,GAAG,EACHC,OAAO,EACPC,GAAG,EACE;IACL,MAAMC,aAAaN,aAAa,eAAe;IAC/C,MAAMO,OAAOP,aAAaA,WAAWO,IAAI,GAAGL,cAAcK;IAE1D,IAAI;QACF,MAAMC,QAAe,CAAC;QACtB,IAAIC;QAEJ,IAAIT,YAAY;YACdQ,MAAME,MAAM,GAAG;gBACbC,QAAQZ;YACV;YAEA,MAAMa,QAAQ,MAAMR,QAAQS,EAAE,CAACC,YAAY,CAAC;gBAC1Cd,YAAYA,WAAWO,IAAI;gBAC3BQ,OAAO;gBACPC,MAAMb,MAAM;gBACZc,YAAY;gBACZZ;gBACAa,MAAM;gBACNV;YACF;YAEC,CAACC,iBAAiB,GAAGG,MAAMO,IAAI;QAClC,OAAO,IAAIjB,cAAc;YACvB,MAAMU,QAAQ,MAAMR,QAAQS,EAAE,CAACO,kBAAkB,CAAC;gBAChDnB,QAAQC,aAAaK,IAAI;gBACzBQ,OAAO;gBACPC,MAAMb,MAAM;gBACZc,YAAY;gBACZZ;gBACAa,MAAM;gBACNV;YACF;YAEC,CAACC,iBAAiB,GAAGG,MAAMO,IAAI;QAClC;QAEA,IAAIV,kBAAkBY,WAAW;YAC/B,MAAMC,cAAqB;gBACzBD,WAAW;oBACTE,iBAAiBd,iBAAiBY,SAAS;gBAC7C;YACF;YAEA,IAAIrB,YAAY;gBACdsB,YAAYZ,MAAM,GAAG;oBACnBC,QAAQZ;gBACV;YACF;YAEA,MAAMyB,qBAAyC;gBAAEnB;gBAAKG,OAAOc;YAAY;YAEzE,IAAIpB,cAAc;gBAChBsB,mBAAmBC,UAAU,GAAGlB;YAClC,OAAO;gBACLiB,mBAAmBxB,UAAU,GAAGO;YAClC;YAEA,MAAMH,QAAQS,EAAE,CAACa,cAAc,CAACF;QAClC;IACF,EAAE,OAAOG,KAAK;QACZvB,QAAQwB,MAAM,CAACC,KAAK,CAACF;QACrBvB,QAAQwB,MAAM,CAACC,KAAK,CAClB,CAAC,oDAAoD,EAAEvB,WAAW,CAAC,EAAEC,MAAM;IAE/E;AACF,EAAC"}},
    {"offset": {"line": 2193, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/versions/saveSnapshot.ts"],"sourcesContent":["import type { SanitizedCollectionConfig } from '../collections/config/types.js'\nimport type { SanitizedGlobalConfig } from '../globals/config/types.js'\nimport type { Payload, TypeWithVersion } from '../index.js'\nimport type { JsonObject, PayloadRequest, SelectType } from '../types/index.js'\n\nimport { deepCopyObjectSimple } from '../index.js'\nimport { getQueryDraftsSelect } from './drafts/getQueryDraftsSelect.js'\n\ntype Args<T extends JsonObject = JsonObject> = {\n  autosave?: boolean\n  collection?: SanitizedCollectionConfig\n  data?: T\n  global?: SanitizedGlobalConfig\n  id?: number | string\n  payload: Payload\n  publishSpecificLocale?: string\n  req?: PayloadRequest\n  select?: SelectType\n}\n\nexport const saveSnapshot = async <T extends JsonObject = JsonObject>({\n  id,\n  autosave,\n  collection,\n  data,\n  global,\n  payload,\n  publishSpecificLocale,\n  req,\n  select,\n}: Args<T>): Promise<Omit<TypeWithVersion<T>, 'parent'> | TypeWithVersion<T> | undefined> => {\n  const docData: {\n    _status?: 'draft'\n  } & T = deepCopyObjectSimple<T>(data || ({} as T))\n\n  if (docData._id) {\n    delete docData._id\n  }\n\n  const snapshotDate = new Date().toISOString()\n\n  const sharedCreateVersionArgs = {\n    autosave: Boolean(autosave),\n    createdAt: snapshotDate,\n    publishedLocale: publishSpecificLocale || undefined,\n    req,\n    returning: false,\n    select: getQueryDraftsSelect({ select }),\n    updatedAt: snapshotDate,\n    versionData: docData,\n  }\n\n  if (collection && id) {\n    return payload.db.createVersion<T>({\n      ...sharedCreateVersionArgs,\n      collectionSlug: collection.slug,\n      parent: id,\n      snapshot: true,\n    })\n  }\n  if (global) {\n    return payload.db.createGlobalVersion<T>({\n      ...sharedCreateVersionArgs,\n      globalSlug: global.slug,\n      snapshot: true,\n    })\n  }\n}\n"],"names":["deepCopyObjectSimple","getQueryDraftsSelect","saveSnapshot","id","autosave","collection","data","global","payload","publishSpecificLocale","req","select","docData","_id","snapshotDate","Date","toISOString","sharedCreateVersionArgs","Boolean","createdAt","publishedLocale","undefined","returning","updatedAt","versionData","db","createVersion","collectionSlug","slug","parent","snapshot","createGlobalVersion","globalSlug"],"mappings":";;;;AAKA,SAASA,oBAAoB,QAAQ,cAAa;AAClD,SAASC,oBAAoB,QAAQ,mCAAkC;;;AAchE,MAAMC,eAAe,OAA0C,EACpEC,EAAE,EACFC,QAAQ,EACRC,UAAU,EACVC,IAAI,EACJC,MAAM,EACNC,OAAO,EACPC,qBAAqB,EACrBC,GAAG,EACHC,MAAM,EACE;IACR,MAAMC,cAEEZ,wLAAAA,EAAwBM,QAAS,CAAC;IAE1C,IAAIM,QAAQC,GAAG,EAAE;QACf,OAAOD,QAAQC,GAAG;IACpB;IAEA,MAAMC,eAAe,IAAIC,OAAOC,WAAW;IAE3C,MAAMC,0BAA0B;QAC9Bb,UAAUc,QAAQd;QAClBe,WAAWL;QACXM,iBAAiBX,yBAAyBY;QAC1CX;QACAY,WAAW;QACXX,YAAQV,uMAAAA,EAAqB;YAAEU;QAAO;QACtCY,WAAWT;QACXU,aAAaZ;IACf;IAEA,IAAIP,cAAcF,IAAI;QACpB,OAAOK,QAAQiB,EAAE,CAACC,aAAa,CAAI;YACjC,GAAGT,uBAAuB;YAC1BU,gBAAgBtB,WAAWuB,IAAI;YAC/BC,QAAQ1B;YACR2B,UAAU;QACZ;IACF;IACA,IAAIvB,QAAQ;QACV,OAAOC,QAAQiB,EAAE,CAACM,mBAAmB,CAAI;YACvC,GAAGd,uBAAuB;YAC1Be,YAAYzB,OAAOqB,IAAI;YACvBE,UAAU;QACZ;IACF;AACF,EAAC"}},
    {"offset": {"line": 2239, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/versions/saveVersion.ts"],"sourcesContent":["import type { SanitizedCollectionConfig } from '../collections/config/types.js'\nimport type { SanitizedGlobalConfig } from '../globals/config/types.js'\nimport type { CreateGlobalVersionArgs, CreateVersionArgs, Payload } from '../index.js'\nimport type { JsonObject, PayloadRequest, SelectType } from '../types/index.js'\n\nimport { deepCopyObjectSimple } from '../index.js'\nimport { getVersionsMax } from '../utilities/getVersionsConfig.js'\nimport { sanitizeInternalFields } from '../utilities/sanitizeInternalFields.js'\nimport { getQueryDraftsSelect } from './drafts/getQueryDraftsSelect.js'\nimport { enforceMaxVersions } from './enforceMaxVersions.js'\nimport { saveSnapshot } from './saveSnapshot.js'\n\ntype Args<T extends JsonObject = JsonObject> = {\n  autosave?: boolean\n  collection?: SanitizedCollectionConfig\n  docWithLocales: T\n  draft?: boolean\n  global?: SanitizedGlobalConfig\n  id?: number | string\n  operation?: 'create' | 'restoreVersion' | 'update'\n  payload: Payload\n  publishSpecificLocale?: string\n  req?: PayloadRequest\n  returning?: boolean\n  select?: SelectType\n  snapshot?: any\n}\n\nexport async function saveVersion<TData extends JsonObject = JsonObject>(\n  args: { returning: false } & Args<TData>,\n): Promise<null>\nexport async function saveVersion<TData extends JsonObject = JsonObject>(\n  args: { returning: true } & Args<TData>,\n): Promise<JsonObject>\nexport async function saveVersion<TData extends JsonObject = JsonObject>(\n  args: Omit<Args<TData>, 'returning'>,\n): Promise<JsonObject>\nexport async function saveVersion<TData extends JsonObject = JsonObject>({\n  id,\n  autosave,\n  collection,\n  docWithLocales,\n  draft,\n  global,\n  operation,\n  payload,\n  publishSpecificLocale,\n  req,\n  returning,\n  select,\n  snapshot,\n}: Args<TData>): Promise<JsonObject | null> {\n  let result: JsonObject | undefined\n  let createNewVersion = true\n  const now = new Date().toISOString()\n  const versionData: {\n    _status?: 'draft'\n    updatedAt?: string\n  } & TData = deepCopyObjectSimple(docWithLocales)\n\n  if (collection?.timestamps && draft) {\n    versionData.updatedAt = now\n  }\n\n  if (versionData._id) {\n    delete versionData._id\n  }\n\n  try {\n    if (autosave) {\n      let docs\n      const findVersionArgs = {\n        limit: 1,\n        pagination: false,\n        req,\n        sort: '-updatedAt',\n      }\n\n      if (collection) {\n        ;({ docs } = await payload.db.findVersions<TData>({\n          ...findVersionArgs,\n          collection: collection.slug,\n          limit: 1,\n          pagination: false,\n          req,\n          where: {\n            parent: {\n              equals: id,\n            },\n          },\n        }))\n      } else {\n        ;({ docs } = await payload.db.findGlobalVersions<TData>({\n          ...findVersionArgs,\n          global: global!.slug,\n          limit: 1,\n          pagination: false,\n          req,\n        }))\n      }\n      const [latestVersion] = docs\n\n      // overwrite the latest version if it's set to autosave\n      if (latestVersion && 'autosave' in latestVersion && latestVersion.autosave === true) {\n        createNewVersion = false\n\n        const updateVersionArgs = {\n          id: latestVersion.id,\n          req,\n          versionData: {\n            createdAt: new Date(latestVersion.createdAt).toISOString(),\n            latest: true,\n            parent: id,\n            updatedAt: now,\n            version: {\n              ...versionData,\n            },\n          },\n        }\n\n        if (collection) {\n          result = await payload.db.updateVersion<TData>({\n            ...updateVersionArgs,\n            collection: collection.slug,\n            req,\n          })\n        } else {\n          result = await payload.db.updateGlobalVersion<TData>({\n            ...updateVersionArgs,\n            global: global!.slug,\n            req,\n          })\n        }\n      }\n    }\n\n    if (createNewVersion) {\n      const createVersionArgs = {\n        autosave: Boolean(autosave),\n        collectionSlug: undefined as string | undefined,\n        createdAt: operation === 'restoreVersion' ? versionData.createdAt : now,\n        globalSlug: undefined as string | undefined,\n        parent: collection ? id : undefined,\n        publishedLocale: publishSpecificLocale || undefined,\n        req,\n        returning,\n        select: getQueryDraftsSelect({ select }),\n        updatedAt: now,\n        versionData,\n      }\n\n      if (collection) {\n        createVersionArgs.collectionSlug = collection.slug\n        result = await payload.db.createVersion(createVersionArgs as CreateVersionArgs)\n      }\n\n      if (global) {\n        createVersionArgs.globalSlug = global.slug\n        result = await payload.db.createGlobalVersion(createVersionArgs as CreateGlobalVersionArgs)\n      }\n\n      if (snapshot) {\n        await saveSnapshot<TData>({\n          id,\n          autosave,\n          collection,\n          data: snapshot,\n          global,\n          payload,\n          publishSpecificLocale,\n          req,\n          select,\n        })\n      }\n    }\n  } catch (err) {\n    let errorMessage: string | undefined\n\n    if (collection) {\n      errorMessage = `There was an error while saving a version for the ${typeof collection.labels.singular === 'string' ? collection.labels.singular : collection.slug} with ID ${id}.`\n    }\n    if (global) {\n      errorMessage = `There was an error while saving a version for the global ${typeof global.label === 'string' ? global.label : global.slug}.`\n    }\n    payload.logger.error({ err, msg: errorMessage })\n    return undefined!\n  }\n\n  const max = getVersionsMax(collection || global!)\n\n  if (createNewVersion && max > 0) {\n    await enforceMaxVersions({\n      id,\n      collection,\n      global,\n      max,\n      payload,\n      req,\n    })\n  }\n  if (returning === false) {\n    return null\n  }\n\n  let createdVersion = (result as any).version\n\n  createdVersion = sanitizeInternalFields(createdVersion)\n  createdVersion.id = (result as any).parent\n\n  return createdVersion\n}\n"],"names":["deepCopyObjectSimple","getVersionsMax","sanitizeInternalFields","getQueryDraftsSelect","enforceMaxVersions","saveSnapshot","saveVersion","id","autosave","collection","docWithLocales","draft","global","operation","payload","publishSpecificLocale","req","returning","select","snapshot","result","createNewVersion","now","Date","toISOString","versionData","timestamps","updatedAt","_id","docs","findVersionArgs","limit","pagination","sort","db","findVersions","slug","where","parent","equals","findGlobalVersions","latestVersion","updateVersionArgs","createdAt","latest","version","updateVersion","updateGlobalVersion","createVersionArgs","Boolean","collectionSlug","undefined","globalSlug","publishedLocale","createVersion","createGlobalVersion","data","err","errorMessage","labels","singular","label","logger","error","msg","max","createdVersion"],"mappings":"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"}},
    {"offset": {"line": 2406, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/versions/deleteCollectionVersions.ts"],"sourcesContent":["import type { PayloadRequest } from '../types/index.js'\n\nimport { type Payload } from '../index.js'\n\ntype Args = {\n  id?: number | string\n  payload: Payload\n  req?: PayloadRequest\n  slug: string\n}\n\nexport const deleteCollectionVersions = async ({ id, slug, payload, req }: Args): Promise<void> => {\n  try {\n    await payload.db.deleteVersions({\n      collection: slug,\n      req,\n      where: {\n        parent: {\n          equals: id,\n        },\n      },\n    })\n  } catch (err) {\n    payload.logger.error({\n      err,\n      msg: `There was an error removing versions for the deleted ${slug} document with ID ${id}.`,\n    })\n  }\n}\n"],"names":["deleteCollectionVersions","id","slug","payload","req","db","deleteVersions","collection","where","parent","equals","err","logger","error","msg"],"mappings":";;;;AAWO,MAAMA,2BAA2B,OAAO,EAAEC,EAAE,EAAEC,IAAI,EAAEC,OAAO,EAAEC,GAAG,EAAQ;IAC7E,IAAI;QACF,MAAMD,QAAQE,EAAE,CAACC,cAAc,CAAC;YAC9BC,YAAYL;YACZE;YACAI,OAAO;gBACLC,QAAQ;oBACNC,QAAQT;gBACV;YACF;QACF;IACF,EAAE,OAAOU,KAAK;QACZR,QAAQS,MAAM,CAACC,KAAK,CAAC;YACnBF;YACAG,KAAK,CAAC,qDAAqD,EAAEZ,KAAK,kBAAkB,EAAED,GAAG,CAAC,CAAC;QAC7F;IACF;AACF,EAAC"}},
    {"offset": {"line": 2432, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/versions/deleteScheduledPublishJobs.ts"],"sourcesContent":["import type { PayloadRequest } from '../types/index.js'\n\nimport { type Payload } from '../index.js'\nimport { jobsCollectionSlug } from '../queues/config/collection.js'\n\ntype Args = {\n  id?: number | string\n  payload: Payload\n  req?: PayloadRequest\n  slug: string\n}\n\nexport const deleteScheduledPublishJobs = async ({\n  id,\n  slug,\n  payload,\n  req,\n}: Args): Promise<void> => {\n  try {\n    await payload.db.deleteMany({\n      collection: jobsCollectionSlug,\n      req,\n      where: {\n        and: [\n          // only want to delete jobs have not run yet\n          {\n            completedAt: {\n              exists: false,\n            },\n          },\n          {\n            processing: {\n              equals: false,\n            },\n          },\n          {\n            'input.doc.value': {\n              equals: id,\n            },\n          },\n          {\n            'input.doc.relationTo': {\n              equals: slug,\n            },\n          },\n          // data.type narrows scheduled publish jobs in case of another job having input.doc.value\n          {\n            taskSlug: {\n              equals: 'schedulePublish',\n            },\n          },\n        ],\n      },\n    })\n  } catch (err) {\n    payload.logger.error({\n      err,\n      msg: `There was an error deleting scheduled publish jobs from the queue for ${slug} document with ID ${id}.`,\n    })\n  }\n}\n"],"names":["jobsCollectionSlug","deleteScheduledPublishJobs","id","slug","payload","req","db","deleteMany","collection","where","and","completedAt","exists","processing","equals","taskSlug","err","logger","error","msg"],"mappings":";;;;AAGA,SAASA,kBAAkB,QAAQ,iCAAgC;;AAS5D,MAAMC,6BAA6B,OAAO,EAC/CC,EAAE,EACFC,IAAI,EACJC,OAAO,EACPC,GAAG,EACE;IACL,IAAI;QACF,MAAMD,QAAQE,EAAE,CAACC,UAAU,CAAC;YAC1BC,YAAYR,yLAAAA;YACZK;YACAI,OAAO;gBACLC,KAAK;oBACH,4CAA4C;oBAC5C;wBACEC,aAAa;4BACXC,QAAQ;wBACV;oBACF;oBACA;wBACEC,YAAY;4BACVC,QAAQ;wBACV;oBACF;oBACA;wBACE,mBAAmB;4BACjBA,QAAQZ;wBACV;oBACF;oBACA;wBACE,wBAAwB;4BACtBY,QAAQX;wBACV;oBACF;oBACA,yFAAyF;oBACzF;wBACEY,UAAU;4BACRD,QAAQ;wBACV;oBACF;iBACD;YACH;QACF;IACF,EAAE,OAAOE,KAAK;QACZZ,QAAQa,MAAM,CAACC,KAAK,CAAC;YACnBF;YACAG,KAAK,CAAC,sEAAsE,EAAEhB,KAAK,kBAAkB,EAAED,GAAG,CAAC,CAAC;QAC9G;IACF;AACF,EAAC"}},
    {"offset": {"line": 2486, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/versions/buildCollectionFields.ts"],"sourcesContent":["import type { SanitizedCollectionConfig } from '../collections/config/types.js'\nimport type { SanitizedConfig } from '../config/types.js'\nimport type { Field, FlattenedField } from '../fields/config/types.js'\n\nimport { hasAutosaveEnabled, hasDraftsEnabled } from '../utilities/getVersionsConfig.js'\nimport { versionSnapshotField } from './baseFields.js'\n\nexport const buildVersionCollectionFields = <T extends boolean = false>(\n  config: SanitizedConfig,\n  collection: SanitizedCollectionConfig,\n  flatten?: T,\n): true extends T ? FlattenedField[] : Field[] => {\n  const fields: FlattenedField[] = [\n    {\n      name: 'parent',\n      type: 'relationship',\n      index: true,\n      relationTo: collection.slug,\n    },\n    {\n      name: 'version',\n      type: 'group',\n      fields: collection.fields.filter((field) => !('name' in field) || field.name !== 'id'),\n      ...(flatten && {\n        flattenedFields: collection.flattenedFields.filter((each) => each.name !== 'id'),\n      })!,\n    },\n    {\n      name: 'createdAt',\n      type: 'date',\n      admin: {\n        disabled: true,\n      },\n      index: true,\n    },\n    {\n      name: 'updatedAt',\n      type: 'date',\n      admin: {\n        disabled: true,\n      },\n      index: true,\n    },\n  ]\n\n  if (hasDraftsEnabled(collection)) {\n    if (config.localization) {\n      fields.push(versionSnapshotField)\n\n      fields.push({\n        name: 'publishedLocale',\n        type: 'select',\n        admin: {\n          disableBulkEdit: true,\n          disabled: true,\n        },\n        index: true,\n        options: config.localization.locales.map((locale) => {\n          if (typeof locale === 'string') {\n            return locale\n          }\n\n          return locale.code\n        }),\n      })\n    }\n\n    fields.push({\n      name: 'latest',\n      type: 'checkbox',\n      admin: {\n        disabled: true,\n      },\n      index: true,\n    })\n\n    if (hasAutosaveEnabled(collection)) {\n      fields.push({\n        name: 'autosave',\n        type: 'checkbox',\n        index: true,\n      })\n    }\n  }\n\n  return fields as true extends T ? FlattenedField[] : Field[]\n}\n"],"names":["hasAutosaveEnabled","hasDraftsEnabled","versionSnapshotField","buildVersionCollectionFields","config","collection","flatten","fields","name","type","index","relationTo","slug","filter","field","flattenedFields","each","admin","disabled","localization","push","disableBulkEdit","options","locales","map","locale","code"],"mappings":";;;;AAIA,SAASA,kBAAkB,EAAEC,gBAAgB,QAAQ,oCAAmC;AACxF,SAASC,oBAAoB,QAAQ,kBAAiB;;;AAE/C,MAAMC,+BAA+B,CAC1CC,QACAC,YACAC;IAEA,MAAMC,SAA2B;QAC/B;YACEC,MAAM;YACNC,MAAM;YACNC,OAAO;YACPC,YAAYN,WAAWO,IAAI;QAC7B;QACA;YACEJ,MAAM;YACNC,MAAM;YACNF,QAAQF,WAAWE,MAAM,CAACM,MAAM,CAAC,CAACC,QAAU,CAAE,CAAA,UAAUA,KAAI,KAAMA,MAAMN,IAAI,KAAK;YACjF,GAAIF,WAAW;gBACbS,iBAAiBV,WAAWU,eAAe,CAACF,MAAM,CAAC,CAACG,OAASA,KAAKR,IAAI,KAAK;YAC7E,CAAC;QACH;QACA;YACEA,MAAM;YACNC,MAAM;YACNQ,OAAO;gBACLC,UAAU;YACZ;YACAR,OAAO;QACT;QACA;YACEF,MAAM;YACNC,MAAM;YACNQ,OAAO;gBACLC,UAAU;YACZ;YACAR,OAAO;QACT;KACD;IAED,QAAIT,uLAAAA,EAAiBI,aAAa;QAChC,IAAID,OAAOe,YAAY,EAAE;YACvBZ,OAAOa,IAAI,CAAClB,mLAAAA;YAEZK,OAAOa,IAAI,CAAC;gBACVZ,MAAM;gBACNC,MAAM;gBACNQ,OAAO;oBACLI,iBAAiB;oBACjBH,UAAU;gBACZ;gBACAR,OAAO;gBACPY,SAASlB,OAAOe,YAAY,CAACI,OAAO,CAACC,GAAG,CAAC,CAACC;oBACxC,IAAI,OAAOA,WAAW,UAAU;wBAC9B,OAAOA;oBACT;oBAEA,OAAOA,OAAOC,IAAI;gBACpB;YACF;QACF;QAEAnB,OAAOa,IAAI,CAAC;YACVZ,MAAM;YACNC,MAAM;YACNQ,OAAO;gBACLC,UAAU;YACZ;YACAR,OAAO;QACT;QAEA,QAAIV,yLAAAA,EAAmBK,aAAa;YAClCE,OAAOa,IAAI,CAAC;gBACVZ,MAAM;gBACNC,MAAM;gBACNC,OAAO;YACT;QACF;IACF;IAEA,OAAOH;AACT,EAAC"}},
    {"offset": {"line": 2568, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/versions/drafts/getQueryDraftsSort.ts"],"sourcesContent":["import type { SanitizedCollectionConfig } from '../../collections/config/types.js'\nimport type { Sort } from '../../types/index.js'\n\n/**\n * Takes the incoming sort argument and prefixes it with `versions.` and preserves any `-` prefixes for descending order\n * @param sort\n */\nexport const getQueryDraftsSort = ({\n  collectionConfig,\n  sort,\n}: {\n  collectionConfig: SanitizedCollectionConfig\n  sort?: Sort\n}): Sort => {\n  if (!sort) {\n    if (collectionConfig.defaultSort) {\n      sort = collectionConfig.defaultSort\n    } else {\n      sort = '-createdAt'\n    }\n  }\n\n  if (typeof sort === 'string') {\n    sort = [sort]\n  }\n\n  return sort.map((field: string) => {\n    let orderBy: string\n    let direction = ''\n    if (field[0] === '-') {\n      orderBy = field.substring(1)\n      direction = '-'\n    } else {\n      orderBy = field\n    }\n\n    if (orderBy === 'id') {\n      return `${direction}parent`\n    }\n\n    return `${direction}version.${orderBy}`\n  })\n}\n"],"names":["getQueryDraftsSort","collectionConfig","sort","defaultSort","map","field","orderBy","direction","substring"],"mappings":"AAGA;;;CAGC,GACD;;;;AAAO,MAAMA,qBAAqB,CAAC,EACjCC,gBAAgB,EAChBC,IAAI,EAIL;IACC,IAAI,CAACA,MAAM;QACT,IAAID,iBAAiBE,WAAW,EAAE;YAChCD,OAAOD,iBAAiBE,WAAW;QACrC,OAAO;YACLD,OAAO;QACT;IACF;IAEA,IAAI,OAAOA,SAAS,UAAU;QAC5BA,OAAO;YAACA;SAAK;IACf;IAEA,OAAOA,KAAKE,GAAG,CAAC,CAACC;QACf,IAAIC;QACJ,IAAIC,YAAY;QAChB,IAAIF,KAAK,CAAC,EAAE,KAAK,KAAK;YACpBC,UAAUD,MAAMG,SAAS,CAAC;YAC1BD,YAAY;QACd,OAAO;YACLD,UAAUD;QACZ;QAEA,IAAIC,YAAY,MAAM;YACpB,OAAO,GAAGC,UAAU,MAAM,CAAC;QAC7B;QAEA,OAAO,GAAGA,UAAU,QAAQ,EAAED,SAAS;IACzC;AACF,EAAC"}},
    {"offset": {"line": 2607, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/versions/drafts/replaceWithDraftIfAvailable.ts"],"sourcesContent":["// @ts-strict-ignore\nimport type { SanitizedCollectionConfig, TypeWithID } from '../../collections/config/types.js'\nimport type { AccessResult } from '../../config/types.js'\nimport type { FindGlobalVersionsArgs, FindVersionsArgs } from '../../database/types.js'\nimport type { SanitizedGlobalConfig } from '../../globals/config/types.js'\nimport type { PayloadRequest, SelectType, Where } from '../../types/index.js'\n\nimport { hasWhereAccessResult } from '../../auth/index.js'\nimport { combineQueries } from '../../database/combineQueries.js'\nimport { docHasTimestamps } from '../../types/index.js'\nimport { hasLocalizeStatusEnabled } from '../../utilities/getVersionsConfig.js'\nimport { sanitizeInternalFields } from '../../utilities/sanitizeInternalFields.js'\nimport { appendVersionToQueryKey } from './appendVersionToQueryKey.js'\nimport { getQueryDraftsSelect } from './getQueryDraftsSelect.js'\n\ntype Arguments<T> = {\n  accessResult: AccessResult\n  doc: T\n  entity: SanitizedCollectionConfig | SanitizedGlobalConfig\n  entityType: 'collection' | 'global'\n  overrideAccess: boolean\n  req: PayloadRequest\n  select?: SelectType\n}\n\nexport const replaceWithDraftIfAvailable = async <T extends TypeWithID>({\n  accessResult,\n  doc,\n  entity,\n  entityType,\n  req,\n  select,\n}: Arguments<T>): Promise<T> => {\n  const { locale, payload } = req\n\n  let queryToBuild: Where = {\n    and: [\n      {\n        'version._status': {\n          equals: 'draft',\n        },\n      },\n    ],\n  }\n\n  if (hasLocalizeStatusEnabled(entity)) {\n    if (locale === 'all') {\n      queryToBuild = {\n        and: [\n          {\n            or: (\n              (payload.config.localization && payload.config.localization.localeCodes) ||\n              []\n            ).map((localeCode) => ({\n              [`version._status.${localeCode}`]: {\n                equals: 'draft',\n              },\n            })),\n          },\n        ],\n      }\n    } else if (locale) {\n      queryToBuild = {\n        and: [\n          {\n            [`version._status.${locale}`]: {\n              equals: 'draft',\n            },\n          },\n        ],\n      }\n    }\n  }\n\n  if (entityType === 'collection') {\n    queryToBuild.and!.push({\n      parent: {\n        equals: doc.id,\n      },\n    })\n  }\n\n  if (docHasTimestamps(doc)) {\n    queryToBuild.and!.push({\n      or: [\n        {\n          updatedAt: {\n            greater_than: doc.updatedAt,\n          },\n        },\n        {\n          latest: {\n            equals: true,\n          },\n        },\n      ],\n    })\n  }\n\n  let versionAccessResult: undefined | Where\n\n  if (hasWhereAccessResult(accessResult)) {\n    versionAccessResult = appendVersionToQueryKey(accessResult)\n  }\n\n  const findVersionsArgs: FindGlobalVersionsArgs & FindVersionsArgs = {\n    collection: entity.slug,\n    global: entity.slug,\n    limit: 1,\n    locale: locale!,\n    pagination: false,\n    req,\n    select: getQueryDraftsSelect({ select }),\n    sort: '-updatedAt',\n    where: combineQueries(queryToBuild, versionAccessResult!),\n  }\n\n  let versionDocs\n  if (entityType === 'global') {\n    versionDocs = (await req.payload.db.findGlobalVersions<T>(findVersionsArgs)).docs\n  } else {\n    versionDocs = (await req.payload.db.findVersions<T>(findVersionsArgs)).docs\n  }\n\n  let draft = versionDocs[0]\n\n  if (!draft) {\n    return doc\n  }\n\n  draft = sanitizeInternalFields(draft)\n\n  // Patch globalType onto version doc\n  if (entityType === 'global' && 'globalType' in doc) {\n    // @ts-expect-error - vestiges of when tsconfig was not strict. Feel free to improve\n    draft.version.globalType = doc.globalType\n  }\n\n  // handle when .version wasn't selected due to projection\n  if (!draft.version) {\n    draft.version = {} as T\n  }\n\n  // Disregard all other draft content at this point,\n  // Only interested in the version itself.\n  // Operations will handle firing hooks, etc.\n\n  draft.version.id = doc.id\n\n  return draft.version\n}\n"],"names":["hasWhereAccessResult","combineQueries","docHasTimestamps","hasLocalizeStatusEnabled","sanitizeInternalFields","appendVersionToQueryKey","getQueryDraftsSelect","replaceWithDraftIfAvailable","accessResult","doc","entity","entityType","req","select","locale","payload","queryToBuild","and","equals","or","config","localization","localeCodes","map","localeCode","push","parent","id","updatedAt","greater_than","latest","versionAccessResult","findVersionsArgs","collection","slug","global","limit","pagination","sort","where","versionDocs","db","findGlobalVersions","docs","findVersions","draft","version","globalType"],"mappings":"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"}},
    {"offset": {"line": 2732, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/versions/buildGlobalFields.ts"],"sourcesContent":["import type { SanitizedConfig } from '../config/types.js'\nimport type { Field, FlattenedField } from '../fields/config/types.js'\nimport type { SanitizedGlobalConfig } from '../globals/config/types.js'\n\nimport { hasAutosaveEnabled, hasDraftsEnabled } from '../utilities/getVersionsConfig.js'\nimport { versionSnapshotField } from './baseFields.js'\n\nexport const buildVersionGlobalFields = <T extends boolean = false>(\n  config: SanitizedConfig,\n  global: SanitizedGlobalConfig,\n  flatten?: T,\n): true extends T ? FlattenedField[] : Field[] => {\n  const fields: FlattenedField[] = [\n    {\n      name: 'version',\n      type: 'group',\n      fields: global.fields,\n      ...(flatten && {\n        flattenedFields: global.flattenedFields,\n      })!,\n    },\n    {\n      name: 'createdAt',\n      type: 'date',\n      admin: {\n        disabled: true,\n      },\n      index: true,\n    },\n    {\n      name: 'updatedAt',\n      type: 'date',\n      admin: {\n        disabled: true,\n      },\n      index: true,\n    },\n  ]\n\n  if (hasDraftsEnabled(global)) {\n    if (config.localization) {\n      fields.push(versionSnapshotField)\n\n      fields.push({\n        name: 'publishedLocale',\n        type: 'select',\n        admin: {\n          disableBulkEdit: true,\n          disabled: true,\n        },\n        index: true,\n        options: config.localization.locales.map((locale) => {\n          if (typeof locale === 'string') {\n            return locale\n          }\n\n          return locale.code\n        }),\n      })\n    }\n\n    fields.push({\n      name: 'latest',\n      type: 'checkbox',\n      admin: {\n        disabled: true,\n      },\n      index: true,\n    })\n\n    if (hasAutosaveEnabled(global)) {\n      fields.push({\n        name: 'autosave',\n        type: 'checkbox',\n        index: true,\n      })\n    }\n  }\n\n  return fields as true extends T ? FlattenedField[] : Field[]\n}\n"],"names":["hasAutosaveEnabled","hasDraftsEnabled","versionSnapshotField","buildVersionGlobalFields","config","global","flatten","fields","name","type","flattenedFields","admin","disabled","index","localization","push","disableBulkEdit","options","locales","map","locale","code"],"mappings":";;;;AAIA,SAASA,kBAAkB,EAAEC,gBAAgB,QAAQ,oCAAmC;AACxF,SAASC,oBAAoB,QAAQ,kBAAiB;;;AAE/C,MAAMC,2BAA2B,CACtCC,QACAC,QACAC;IAEA,MAAMC,SAA2B;QAC/B;YACEC,MAAM;YACNC,MAAM;YACNF,QAAQF,OAAOE,MAAM;YACrB,GAAID,WAAW;gBACbI,iBAAiBL,OAAOK,eAAe;YACzC,CAAC;QACH;QACA;YACEF,MAAM;YACNC,MAAM;YACNE,OAAO;gBACLC,UAAU;YACZ;YACAC,OAAO;QACT;QACA;YACEL,MAAM;YACNC,MAAM;YACNE,OAAO;gBACLC,UAAU;YACZ;YACAC,OAAO;QACT;KACD;IAED,QAAIZ,uLAAAA,EAAiBI,SAAS;QAC5B,IAAID,OAAOU,YAAY,EAAE;YACvBP,OAAOQ,IAAI,CAACb,mLAAAA;YAEZK,OAAOQ,IAAI,CAAC;gBACVP,MAAM;gBACNC,MAAM;gBACNE,OAAO;oBACLK,iBAAiB;oBACjBJ,UAAU;gBACZ;gBACAC,OAAO;gBACPI,SAASb,OAAOU,YAAY,CAACI,OAAO,CAACC,GAAG,CAAC,CAACC;oBACxC,IAAI,OAAOA,WAAW,UAAU;wBAC9B,OAAOA;oBACT;oBAEA,OAAOA,OAAOC,IAAI;gBACpB;YACF;QACF;QAEAd,OAAOQ,IAAI,CAAC;YACVP,MAAM;YACNC,MAAM;YACNE,OAAO;gBACLC,UAAU;YACZ;YACAC,OAAO;QACT;QAEA,QAAIb,yLAAAA,EAAmBK,SAAS;YAC9BE,OAAOQ,IAAI,CAAC;gBACVP,MAAM;gBACNC,MAAM;gBACNI,OAAO;YACT;QACF;IACF;IAEA,OAAON;AACT,EAAC"}},
    {"offset": {"line": 2808, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/versions/getLatestGlobalVersion.ts"],"sourcesContent":["import type { SanitizedGlobalConfig } from '../globals/config/types.js'\nimport type { Document, Payload, PayloadRequest, Where } from '../types/index.js'\nimport type { TypeWithVersion } from './types.js'\n\nimport { hasDraftsEnabled } from '../utilities/getVersionsConfig.js'\n\ntype Args = {\n  config: SanitizedGlobalConfig\n  locale?: string\n  payload: Payload\n  published?: boolean\n  req?: PayloadRequest\n  slug: string\n  where: Where\n}\n\nexport const getLatestGlobalVersion = async ({\n  slug,\n  config,\n  locale,\n  payload,\n  published,\n  req,\n  where,\n}: Args): Promise<{ global: Document; globalExists: boolean }> => {\n  let latestVersion: TypeWithVersion<Document> | undefined\n\n  const whereQuery = published\n    ? { 'version._status': { equals: 'published' } }\n    : { latest: { equals: true } }\n\n  if (hasDraftsEnabled(config)) {\n    latestVersion = (\n      await payload.db.findGlobalVersions({\n        global: slug,\n        limit: 1,\n        locale: locale || req?.locale || undefined,\n        pagination: false,\n        req,\n        where: whereQuery as unknown as Where,\n      })\n    ).docs[0]\n  }\n\n  const global = await payload.db.findGlobal({\n    slug,\n    locale,\n    req,\n    where,\n  })\n  const globalExists = Boolean(global)\n\n  if (!latestVersion) {\n    return {\n      global,\n      globalExists,\n    }\n  }\n\n  if (!latestVersion.version.createdAt) {\n    latestVersion.version.createdAt = latestVersion.createdAt\n  }\n\n  if (!latestVersion.version.updatedAt) {\n    latestVersion.version.updatedAt = latestVersion.updatedAt\n  }\n\n  return {\n    global: latestVersion.version,\n    globalExists,\n  }\n}\n"],"names":["hasDraftsEnabled","getLatestGlobalVersion","slug","config","locale","payload","published","req","where","latestVersion","whereQuery","equals","latest","db","findGlobalVersions","global","limit","undefined","pagination","docs","findGlobal","globalExists","Boolean","version","createdAt","updatedAt"],"mappings":";;;;AAIA,SAASA,gBAAgB,QAAQ,oCAAmC;;AAY7D,MAAMC,yBAAyB,OAAO,EAC3CC,IAAI,EACJC,MAAM,EACNC,MAAM,EACNC,OAAO,EACPC,SAAS,EACTC,GAAG,EACHC,KAAK,EACA;IACL,IAAIC;IAEJ,MAAMC,aAAaJ,YACf;QAAE,mBAAmB;YAAEK,QAAQ;QAAY;IAAE,IAC7C;QAAEC,QAAQ;YAAED,QAAQ;QAAK;IAAE;IAE/B,QAAIX,uLAAAA,EAAiBG,SAAS;QAC5BM,gBACE,CAAA,MAAMJ,QAAQQ,EAAE,CAACC,kBAAkB,CAAC;YAClCC,QAAQb;YACRc,OAAO;YACPZ,QAAQA,UAAUG,KAAKH,UAAUa;YACjCC,YAAY;YACZX;YACAC,OAAOE;QACT,EAAC,EACDS,IAAI,CAAC,EAAE;IACX;IAEA,MAAMJ,SAAS,MAAMV,QAAQQ,EAAE,CAACO,UAAU,CAAC;QACzClB;QACAE;QACAG;QACAC;IACF;IACA,MAAMa,eAAeC,QAAQP;IAE7B,IAAI,CAACN,eAAe;QAClB,OAAO;YACLM;YACAM;QACF;IACF;IAEA,IAAI,CAACZ,cAAcc,OAAO,CAACC,SAAS,EAAE;QACpCf,cAAcc,OAAO,CAACC,SAAS,GAAGf,cAAce,SAAS;IAC3D;IAEA,IAAI,CAACf,cAAcc,OAAO,CAACE,SAAS,EAAE;QACpChB,cAAcc,OAAO,CAACE,SAAS,GAAGhB,cAAcgB,SAAS;IAC3D;IAEA,OAAO;QACLV,QAAQN,cAAcc,OAAO;QAC7BF;IACF;AACF,EAAC"}},
    {"offset": {"line": 2863, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/versions/schedule/job.ts"],"sourcesContent":["import type { Field } from '../../fields/config/types.js'\nimport type { TypedUser } from '../../index.js'\nimport type { TaskConfig } from '../../queues/config/types/taskTypes.js'\nimport type { SchedulePublishTaskInput } from './types.js'\n\ntype Args = {\n  adminUserSlug: string\n  collections: string[]\n  globals: string[]\n}\n\nexport const getSchedulePublishTask = ({\n  adminUserSlug,\n  collections,\n  globals,\n}: Args): TaskConfig<{ input: SchedulePublishTaskInput; output: object }> => {\n  return {\n    slug: 'schedulePublish',\n    handler: async ({ input, req }) => {\n      const _status = input?.type === 'publish' || !input?.type ? 'published' : 'draft'\n\n      const userID = input.user\n\n      let user: null | TypedUser = null\n\n      if (userID) {\n        user = (await req.payload.findByID({\n          id: userID,\n          collection: adminUserSlug,\n          depth: 0,\n        })) as TypedUser\n\n        user.collection = adminUserSlug\n      }\n\n      let publishSpecificLocale: string\n\n      if (input?.type === 'publish' && input.locale && req.payload.config.localization) {\n        const matchedLocale = req.payload.config.localization.locales.find(\n          ({ code }) => code === input.locale,\n        )\n\n        if (matchedLocale) {\n          publishSpecificLocale = input.locale\n        }\n      }\n\n      if (input.doc) {\n        await req.payload.update({\n          id: input.doc.value,\n          collection: input.doc.relationTo,\n          data: {\n            _status,\n          },\n          depth: 0,\n          overrideAccess: user === null,\n          publishSpecificLocale: publishSpecificLocale!,\n          user,\n        })\n      }\n\n      if (input.global) {\n        await req.payload.updateGlobal({\n          slug: input.global,\n          data: {\n            _status,\n          },\n          depth: 0,\n          overrideAccess: user === null,\n          publishSpecificLocale: publishSpecificLocale!,\n          user,\n        })\n      }\n\n      return {\n        output: {},\n      }\n    },\n    inputSchema: [\n      {\n        name: 'type',\n        type: 'radio',\n        defaultValue: 'publish',\n        options: ['publish', 'unpublish'],\n      },\n      {\n        name: 'locale',\n        type: 'text',\n      },\n      ...(collections.length > 0\n        ? [\n            {\n              name: 'doc',\n              type: 'relationship',\n              relationTo: collections,\n            } satisfies Field,\n          ]\n        : []),\n      {\n        name: 'global',\n        type: 'select',\n        options: globals,\n      },\n      {\n        name: 'user',\n        type: 'relationship',\n        relationTo: adminUserSlug,\n      },\n    ],\n  }\n}\n"],"names":["getSchedulePublishTask","adminUserSlug","collections","globals","slug","handler","input","req","_status","type","userID","user","payload","findByID","id","collection","depth","publishSpecificLocale","locale","config","localization","matchedLocale","locales","find","code","doc","update","value","relationTo","data","overrideAccess","global","updateGlobal","output","inputSchema","name","defaultValue","options","length"],"mappings":";;;;AAWO,MAAMA,yBAAyB,CAAC,EACrCC,aAAa,EACbC,WAAW,EACXC,OAAO,EACF;IACL,OAAO;QACLC,MAAM;QACNC,SAAS,OAAO,EAAEC,KAAK,EAAEC,GAAG,EAAE;YAC5B,MAAMC,UAAUF,OAAOG,SAAS,aAAa,CAACH,OAAOG,OAAO,cAAc;YAE1E,MAAMC,SAASJ,MAAMK,IAAI;YAEzB,IAAIA,OAAyB;YAE7B,IAAID,QAAQ;gBACVC,OAAQ,MAAMJ,IAAIK,OAAO,CAACC,QAAQ,CAAC;oBACjCC,IAAIJ;oBACJK,YAAYd;oBACZe,OAAO;gBACT;gBAEAL,KAAKI,UAAU,GAAGd;YACpB;YAEA,IAAIgB;YAEJ,IAAIX,OAAOG,SAAS,aAAaH,MAAMY,MAAM,IAAIX,IAAIK,OAAO,CAACO,MAAM,CAACC,YAAY,EAAE;gBAChF,MAAMC,gBAAgBd,IAAIK,OAAO,CAACO,MAAM,CAACC,YAAY,CAACE,OAAO,CAACC,IAAI,CAChE,CAAC,EAAEC,IAAI,EAAE,GAAKA,SAASlB,MAAMY,MAAM;gBAGrC,IAAIG,eAAe;oBACjBJ,wBAAwBX,MAAMY,MAAM;gBACtC;YACF;YAEA,IAAIZ,MAAMmB,GAAG,EAAE;gBACb,MAAMlB,IAAIK,OAAO,CAACc,MAAM,CAAC;oBACvBZ,IAAIR,MAAMmB,GAAG,CAACE,KAAK;oBACnBZ,YAAYT,MAAMmB,GAAG,CAACG,UAAU;oBAChCC,MAAM;wBACJrB;oBACF;oBACAQ,OAAO;oBACPc,gBAAgBnB,SAAS;oBACzBM,uBAAuBA;oBACvBN;gBACF;YACF;YAEA,IAAIL,MAAMyB,MAAM,EAAE;gBAChB,MAAMxB,IAAIK,OAAO,CAACoB,YAAY,CAAC;oBAC7B5B,MAAME,MAAMyB,MAAM;oBAClBF,MAAM;wBACJrB;oBACF;oBACAQ,OAAO;oBACPc,gBAAgBnB,SAAS;oBACzBM,uBAAuBA;oBACvBN;gBACF;YACF;YAEA,OAAO;gBACLsB,QAAQ,CAAC;YACX;QACF;QACAC,aAAa;YACX;gBACEC,MAAM;gBACN1B,MAAM;gBACN2B,cAAc;gBACdC,SAAS;oBAAC;oBAAW;iBAAY;YACnC;YACA;gBACEF,MAAM;gBACN1B,MAAM;YACR;eACIP,YAAYoC,MAAM,GAAG,IACrB;gBACE;oBACEH,MAAM;oBACN1B,MAAM;oBACNmB,YAAY1B;gBACd;aACD,GACD,EAAE;YACN;gBACEiC,MAAM;gBACN1B,MAAM;gBACN4B,SAASlC;YACX;YACA;gBACEgC,MAAM;gBACN1B,MAAM;gBACNmB,YAAY3B;YACd;SACD;IACH;AACF,EAAC"}},
    {"offset": {"line": 2956, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/versions/buildVersionCompoundIndexes.ts"],"sourcesContent":["import type { SanitizedCompoundIndex } from '../collections/config/types.js'\n\nexport const buildVersionCompoundIndexes = ({\n  indexes,\n}: {\n  indexes: SanitizedCompoundIndex[]\n}): SanitizedCompoundIndex[] => {\n  return indexes.map((each) => ({\n    fields: each.fields.map(({ field, localizedPath, path, pathHasLocalized }) => ({\n      field,\n      localizedPath: `version.${localizedPath}`,\n      path: `version.${path}`,\n      pathHasLocalized,\n    })),\n    unique: false,\n  }))\n}\n"],"names":["buildVersionCompoundIndexes","indexes","map","each","fields","field","localizedPath","path","pathHasLocalized","unique"],"mappings":";;;;AAEO,MAAMA,8BAA8B,CAAC,EAC1CC,OAAO,EAGR;IACC,OAAOA,QAAQC,GAAG,CAAC,CAACC,OAAU,CAAA;YAC5BC,QAAQD,KAAKC,MAAM,CAACF,GAAG,CAAC,CAAC,EAAEG,KAAK,EAAEC,aAAa,EAAEC,IAAI,EAAEC,gBAAgB,EAAE,GAAM,CAAA;oBAC7EH;oBACAC,eAAe,CAAC,QAAQ,EAAEA,eAAe;oBACzCC,MAAM,CAAC,QAAQ,EAAEA,MAAM;oBACvBC;gBACF,CAAA;YACAC,QAAQ;QACV,CAAA;AACF,EAAC"}},
    {"offset": {"line": 2975, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/types/constants.ts"],"sourcesContent":["export const validOperators = [\n  'equals',\n  'contains',\n  'not_equals',\n  'in',\n  'all',\n  'not_in',\n  'exists',\n  'greater_than',\n  'greater_than_equal',\n  'less_than',\n  'less_than_equal',\n  'like',\n  'not_like',\n  'within',\n  'intersects',\n  'near',\n] as const\n\nexport type Operator = (typeof validOperators)[number]\n\nexport const validOperatorSet = new Set<Operator>(validOperators)\n"],"names":["validOperators","validOperatorSet","Set"],"mappings":";;;;;;AAAO,MAAMA,iBAAiB;IAC5B;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;CACD,CAAS;AAIH,MAAMC,mBAAmB,IAAIC,IAAcF,gBAAe"}},
    {"offset": {"line": 3004, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/types/index.ts"],"sourcesContent":["import type { I18n, TFunction } from '@payloadcms/translations'\nimport type DataLoader from 'dataloader'\nimport type { OptionalKeys, RequiredKeys } from 'ts-essentials'\nimport type { URL } from 'url'\n\nimport type {\n  DataFromCollectionSlug,\n  QueryDraftDataFromCollectionSlug,\n  TypeWithID,\n  TypeWithTimestamps,\n} from '../collections/config/types.js'\nimport type payload from '../index.js'\nimport type {\n  CollectionSlug,\n  DataFromGlobalSlug,\n  GlobalSlug,\n  Payload,\n  RequestContext,\n  TypedCollectionJoins,\n  TypedCollectionSelect,\n  TypedFallbackLocale,\n  TypedLocale,\n  TypedUser,\n} from '../index.js'\nimport type { Operator } from './constants.js'\nexport type { Payload } from '../index.js'\n\nexport type CustomPayloadRequestProperties = {\n  context: RequestContext\n  /** The locale that should be used for a field when it is not translated to the requested locale */\n  fallbackLocale?: TypedFallbackLocale\n  i18n: I18n\n  /**\n   * The requested locale if specified\n   * Only available for localized collections\n   *\n   * Suppressing warning below as it is a valid use case - won't be an issue if generated types exist\n   */\n  // eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents\n  locale?: 'all' | TypedLocale\n  /**\n   * The payload object\n   */\n  payload: typeof payload\n  /**\n   * The context in which the request is being made\n   */\n  payloadAPI: 'GraphQL' | 'local' | 'REST'\n  /** Optimized document loader */\n  payloadDataLoader: {\n    /**\n     * Wraps `payload.find` with a cache to deduplicate requests\n     * @experimental This is may be replaced by a more robust cache strategy in future versions\n     * By calling this method with the same arguments many times in one request, it will only be handled one time\n     * const result = await req.payloadDataLoader.find({\n     *  collection,\n     *  req,\n     *  where: findWhere,\n     * })\n     */\n    find: Payload['find']\n  } & DataLoader<string, TypeWithID>\n  /** Resized versions of the image that was uploaded during this request */\n  payloadUploadSizes?: Record<string, Buffer>\n  /** Query params on the request */\n  query: Record<string, unknown>\n  /** Any response headers that are required to be set when a response is sent */\n  responseHeaders?: Headers\n  /** The route parameters\n   * @example\n   * /:collection/:id -> /posts/123\n   * { collection: 'posts', id: '123' }\n   */\n  routeParams?: Record<string, unknown>\n  /** Translate function - duplicate of i18n.t */\n  t: TFunction\n  /**\n   * Identifier for the database transaction for interactions in a single, all-or-nothing operation.\n   * Can also be used to ensure consistency when multiple operations try to create a transaction concurrently on the same request.\n   */\n  transactionID?: number | Promise<number | string> | string\n  /**\n   * Used to ensure consistency when multiple operations try to create a transaction concurrently on the same request\n   * @deprecated This is not used anywhere, instead `transactionID` is used for the above. Will be removed in next major version.\n   */\n  transactionIDPromise?: Promise<void>\n  /** The signed-in user */\n  user: null | TypedUser\n} & Pick<\n  URL,\n  'hash' | 'host' | 'href' | 'origin' | 'pathname' | 'port' | 'protocol' | 'search' | 'searchParams'\n>\ntype PayloadRequestData = {\n  /**\n   * Data from the request body\n   *\n   * Within Payload operations, i.e. hooks, data will be there\n   * BUT in custom endpoints it will not be, you will need to\n   * use either:\n   *  1. `const data = await req.json()`\n   *\n   *  2. import { addDataAndFileToRequest } from 'payload'\n   *    `await addDataAndFileToRequest(req)`\n   *\n   * You should not expect this object to be the document data. It is the request data.\n   * */\n  data?: JsonObject\n  /** The file on the request, same rules apply as the `data` property */\n  file?: {\n    /**\n     * Context of the file when it was uploaded via client side.\n     */\n    clientUploadContext?: unknown\n    data: Buffer\n    mimetype: string\n    name: string\n    size: number\n    tempFilePath?: string\n  }\n}\nexport interface PayloadRequest\n  extends CustomPayloadRequestProperties,\n    Partial<Request>,\n    PayloadRequestData {\n  headers: Request['headers']\n}\n\nexport type { Operator }\n\n// Makes it so things like passing new Date() will error\nexport type JsonValue = JsonArray | JsonObject | unknown //Date | JsonArray | JsonObject | boolean | null | number | string // TODO: Evaluate proper, strong type for this\n\nexport type JsonArray = Array<JsonValue>\n\nexport interface JsonObject {\n  [key: string]: any\n}\n\nexport type WhereField = {\n  // any json-serializable value\n  [key in Operator]?: JsonValue\n}\n\nexport type Where = {\n  [key: string]: Where[] | WhereField\n  // @ts-expect-error - vestiges of when tsconfig was not strict. Feel free to improve\n  and?: Where[]\n  // @ts-expect-error - vestiges of when tsconfig was not strict. Feel free to improve\n  or?: Where[]\n}\n\nexport type Sort = Array<string> | string\n\ntype SerializableValue = boolean | number | object | string\nexport type DefaultValue =\n  | ((args: {\n      locale?: TypedLocale\n      req: PayloadRequest\n      user: PayloadRequest['user']\n    }) => SerializableValue)\n  | SerializableValue\n\n/**\n * Applies pagination for join fields for including collection relationships\n */\nexport type JoinQuery<TSlug extends CollectionSlug = string> =\n  TypedCollectionJoins[TSlug] extends Record<string, string>\n    ?\n        | false\n        | Partial<{\n            [K in keyof TypedCollectionJoins[TSlug]]:\n              | {\n                  count?: boolean\n                  limit?: number\n                  page?: number\n                  sort?: string\n                  where?: Where\n                }\n              | false\n          }>\n    : never\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type Document = any\n\nexport type Operation = 'create' | 'delete' | 'read' | 'update'\nexport type VersionOperations = 'readVersions'\nexport type AuthOperations = 'unlock'\nexport type AllOperations = AuthOperations | Operation | VersionOperations\n\nexport function docHasTimestamps(doc: any): doc is TypeWithTimestamps {\n  return doc?.createdAt && doc?.updatedAt\n}\n\nexport type IfAny<T, Y, N> = 0 extends 1 & T ? Y : N // This is a commonly used trick to detect 'any'\nexport type IsAny<T> = IfAny<T, true, false>\nexport type ReplaceAny<T, DefaultType> = IsAny<T> extends true ? DefaultType : T\n\nexport type SelectIncludeType = {\n  [k: string]: SelectIncludeType | true\n}\n\nexport type SelectExcludeType = {\n  [k: string]: false | SelectExcludeType\n}\n\nexport type SelectMode = 'exclude' | 'include'\n\nexport type SelectType = SelectExcludeType | SelectIncludeType\n\nexport type ApplyDisableErrors<T, DisableErrors = false> = false extends DisableErrors\n  ? T\n  : null | T\n\nexport type TransformDataWithSelect<\n  Data extends Record<string, any>,\n  Select extends SelectType,\n> = Select extends never\n  ? Data\n  : string extends keyof Select\n    ? Data\n    : // START Handle types when they aren't generated\n      // For example in any package in this repository outside of tests / plugins\n      // This stil gives us autocomplete when using include select mode, i.e select: {title :true} returns type {title: any, id: string | number}\n      string extends keyof Omit<Data, 'id'>\n      ? Select extends SelectIncludeType\n        ? {\n            [K in Data extends TypeWithID ? 'id' | keyof Select : keyof Select]: K extends 'id'\n              ? number | string\n              : unknown\n          }\n        : Data\n      : // END Handle types when they aren't generated\n        // Handle include mode\n        Select extends SelectIncludeType\n        ? {\n            [K in keyof Data as K extends keyof Select\n              ? Select[K] extends object | true\n                ? K\n                : never\n              : // select 'id' always\n                K extends 'id'\n                ? K\n                : never]: Data[K]\n          }\n        : // Handle exclude mode\n          {\n            [K in keyof Data as K extends keyof Select\n              ? Select[K] extends object | undefined\n                ? K\n                : never\n              : K]: Data[K]\n          }\n\nexport type TransformCollectionWithSelect<\n  TSlug extends CollectionSlug,\n  TSelect extends SelectType,\n> = TSelect extends SelectType\n  ? TransformDataWithSelect<DataFromCollectionSlug<TSlug>, TSelect>\n  : DataFromCollectionSlug<TSlug>\n\nexport type DraftTransformCollectionWithSelect<\n  TSlug extends CollectionSlug,\n  TSelect extends SelectType,\n> = TSelect extends SelectType\n  ? TransformDataWithSelect<QueryDraftDataFromCollectionSlug<TSlug>, TSelect>\n  : QueryDraftDataFromCollectionSlug<TSlug>\n\nexport type TransformGlobalWithSelect<\n  TSlug extends GlobalSlug,\n  TSelect extends SelectType,\n> = TSelect extends SelectType\n  ? TransformDataWithSelect<DataFromGlobalSlug<TSlug>, TSelect>\n  : DataFromGlobalSlug<TSlug>\n\nexport type PopulateType = Partial<TypedCollectionSelect>\n\nexport type ResolvedFilterOptions = { [collection: string]: Where }\n\nexport type PickPreserveOptional<T, K extends keyof T> = Partial<\n  Pick<T, Extract<K, OptionalKeys<T>>>\n> &\n  Pick<T, Extract<K, RequiredKeys<T>>>\n\nexport type MaybePromise<T> = Promise<T> | T\n"],"names":["docHasTimestamps","doc","createdAt","updatedAt"],"mappings":";;;;AA8LO,SAASA,iBAAiBC,GAAQ;IACvC,OAAOA,KAAKC,aAAaD,KAAKE;AAChC"}},
    {"offset": {"line": 3015, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/duplicateDocument/index.ts"],"sourcesContent":["import type { SanitizedCollectionConfig } from '../collections/config/types.js'\nimport type { FindOneArgs } from '../database/types.js'\nimport type { JsonObject, PayloadRequest } from '../types/index.js'\n\nimport { executeAccess } from '../auth/executeAccess.js'\nimport { hasWhereAccessResult } from '../auth/types.js'\nimport { combineQueries } from '../database/combineQueries.js'\nimport { Forbidden } from '../errors/Forbidden.js'\nimport { NotFound } from '../errors/NotFound.js'\nimport { afterRead } from '../fields/hooks/afterRead/index.js'\nimport { beforeDuplicate } from '../fields/hooks/beforeDuplicate/index.js'\nimport { deepCopyObjectSimple } from '../utilities/deepCopyObject.js'\nimport { filterDataToSelectedLocales } from '../utilities/filterDataToSelectedLocales.js'\nimport { getLatestCollectionVersion } from '../versions/getLatestCollectionVersion.js'\n\ntype GetDuplicateDocumentArgs = {\n  collectionConfig: SanitizedCollectionConfig\n  draftArg?: boolean\n  id: number | string\n  overrideAccess?: boolean\n  req: PayloadRequest\n  selectedLocales?: string[]\n}\nexport const getDuplicateDocumentData = async ({\n  id,\n  collectionConfig,\n  draftArg,\n  overrideAccess,\n  req,\n  selectedLocales,\n}: GetDuplicateDocumentArgs): Promise<{\n  duplicatedFromDoc: JsonObject\n  duplicatedFromDocWithLocales: JsonObject\n}> => {\n  const { payload } = req\n  // /////////////////////////////////////\n  // Read Access\n  // /////////////////////////////////////\n\n  const accessResults = !overrideAccess\n    ? await executeAccess({ id, req }, collectionConfig.access.read)\n    : true\n  const hasWherePolicy = hasWhereAccessResult(accessResults)\n\n  // /////////////////////////////////////\n  // Retrieve document\n  // /////////////////////////////////////\n  const findOneArgs: FindOneArgs = {\n    collection: collectionConfig.slug,\n    locale: req.locale!,\n    req,\n    where: combineQueries({ id: { equals: id } }, accessResults),\n  }\n\n  let duplicatedFromDocWithLocales = await getLatestCollectionVersion({\n    id,\n    config: collectionConfig,\n    payload,\n    query: findOneArgs,\n    req,\n  })\n\n  if (selectedLocales && selectedLocales.length > 0 && duplicatedFromDocWithLocales) {\n    duplicatedFromDocWithLocales = filterDataToSelectedLocales({\n      configBlockReferences: payload.config.blocks,\n      docWithLocales: duplicatedFromDocWithLocales,\n      fields: collectionConfig.fields,\n      selectedLocales,\n    })\n  }\n\n  if (!duplicatedFromDocWithLocales && !hasWherePolicy) {\n    throw new NotFound(req.t)\n  }\n  if (!duplicatedFromDocWithLocales && hasWherePolicy) {\n    throw new Forbidden(req.t)\n  }\n\n  // remove the createdAt timestamp and rely on the db to set it\n  if ('createdAt' in duplicatedFromDocWithLocales) {\n    delete duplicatedFromDocWithLocales.createdAt\n  }\n  // remove the id and rely on the db to set it\n  if ('id' in duplicatedFromDocWithLocales) {\n    delete duplicatedFromDocWithLocales.id\n  }\n\n  duplicatedFromDocWithLocales = await beforeDuplicate({\n    id,\n    collection: collectionConfig,\n    context: req.context,\n    doc: duplicatedFromDocWithLocales,\n    overrideAccess: overrideAccess!,\n    req,\n  })\n\n  const duplicatedFromDoc = await afterRead({\n    collection: collectionConfig,\n    context: req.context,\n    depth: 0,\n    doc: deepCopyObjectSimple(duplicatedFromDocWithLocales),\n    draft: draftArg!,\n    fallbackLocale: null,\n    global: null,\n    locale: req.locale!,\n    overrideAccess: true,\n    req,\n    showHiddenFields: true,\n  })\n\n  return { duplicatedFromDoc, duplicatedFromDocWithLocales }\n}\n"],"names":["executeAccess","hasWhereAccessResult","combineQueries","Forbidden","NotFound","afterRead","beforeDuplicate","deepCopyObjectSimple","filterDataToSelectedLocales","getLatestCollectionVersion","getDuplicateDocumentData","id","collectionConfig","draftArg","overrideAccess","req","selectedLocales","payload","accessResults","access","read","hasWherePolicy","findOneArgs","collection","slug","locale","where","equals","duplicatedFromDocWithLocales","config","query","length","configBlockReferences","blocks","docWithLocales","fields","t","createdAt","context","doc","duplicatedFromDoc","depth","draft","fallbackLocale","global","showHiddenFields"],"mappings":";;;;AAIA,SAASA,aAAa,QAAQ,2BAA0B;AACxD,SAASC,oBAAoB,QAAQ,mBAAkB;AACvD,SAASC,cAAc,QAAQ,gCAA+B;AAC9D,SAASC,SAAS,QAAQ,yBAAwB;AAClD,SAASC,QAAQ,QAAQ,wBAAuB;AAChD,SAASC,SAAS,QAAQ,qCAAoC;AAC9D,SAASC,eAAe,QAAQ,2CAA0C;AAC1E,SAASC,oBAAoB,QAAQ,iCAAgC;AACrE,SAASC,2BAA2B,QAAQ,8CAA6C;AACzF,SAASC,0BAA0B,QAAQ,4CAA2C;;;;;;;;;;;AAU/E,MAAMC,2BAA2B,OAAO,EAC7CC,EAAE,EACFC,gBAAgB,EAChBC,QAAQ,EACRC,cAAc,EACdC,GAAG,EACHC,eAAe,EACU;IAIzB,MAAM,EAAEC,OAAO,EAAE,GAAGF;IACpB,wCAAwC;IACxC,cAAc;IACd,wCAAwC;IAExC,MAAMG,gBAAgB,CAACJ,iBACnB,UAAMd,2KAAAA,EAAc;QAAEW;QAAII;IAAI,GAAGH,iBAAiBO,MAAM,CAACC,IAAI,IAC7D;IACJ,MAAMC,qBAAiBpB,0KAAAA,EAAqBiB;IAE5C,wCAAwC;IACxC,oBAAoB;IACpB,wCAAwC;IACxC,MAAMI,cAA2B;QAC/BC,YAAYX,iBAAiBY,IAAI;QACjCC,QAAQV,IAAIU,MAAM;QAClBV;QACAW,WAAOxB,iLAAAA,EAAe;YAAES,IAAI;gBAAEgB,QAAQhB;YAAG;QAAE,GAAGO;IAChD;IAEA,IAAIU,+BAA+B,UAAMnB,yMAAAA,EAA2B;QAClEE;QACAkB,QAAQjB;QACRK;QACAa,OAAOR;QACPP;IACF;IAEA,IAAIC,mBAAmBA,gBAAgBe,MAAM,GAAG,KAAKH,8BAA8B;QACjFA,mCAA+BpB,4MAAAA,EAA4B;YACzDwB,uBAAuBf,QAAQY,MAAM,CAACI,MAAM;YAC5CC,gBAAgBN;YAChBO,QAAQvB,iBAAiBuB,MAAM;YAC/BnB;QACF;IACF;IAEA,IAAI,CAACY,gCAAgC,CAACP,gBAAgB;QACpD,MAAM,IAAIjB,mKAAAA,CAASW,IAAIqB,CAAC;IAC1B;IACA,IAAI,CAACR,gCAAgCP,gBAAgB;QACnD,MAAM,IAAIlB,qKAAAA,CAAUY,IAAIqB,CAAC;IAC3B;IAEA,8DAA8D;IAC9D,IAAI,eAAeR,8BAA8B;QAC/C,OAAOA,6BAA6BS,SAAS;IAC/C;IACA,6CAA6C;IAC7C,IAAI,QAAQT,8BAA8B;QACxC,OAAOA,6BAA6BjB,EAAE;IACxC;IAEAiB,+BAA+B,UAAMtB,mMAAAA,EAAgB;QACnDK;QACAY,YAAYX;QACZ0B,SAASvB,IAAIuB,OAAO;QACpBC,KAAKX;QACLd,gBAAgBA;QAChBC;IACF;IAEA,MAAMyB,oBAAoB,UAAMnC,uLAAAA,EAAU;QACxCkB,YAAYX;QACZ0B,SAASvB,IAAIuB,OAAO;QACpBG,OAAO;QACPF,SAAKhC,wLAAAA,EAAqBqB;QAC1Bc,OAAO7B;QACP8B,gBAAgB;QAChBC,QAAQ;QACRnB,QAAQV,IAAIU,MAAM;QAClBX,gBAAgB;QAChBC;QACA8B,kBAAkB;IACpB;IAEA,OAAO;QAAEL;QAAmBZ;IAA6B;AAC3D,EAAC"}},
    {"offset": {"line": 3121, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/preferences/operations/delete.ts"],"sourcesContent":["import type { Document, Where } from '../../types/index.js'\nimport type { PreferenceRequest } from '../types.js'\n\nimport { NotFound } from '../../errors/NotFound.js'\nimport { UnauthorizedError } from '../../errors/UnauthorizedError.js'\nimport { preferencesCollectionSlug } from '../config.js'\n\nexport async function deleteOperation(args: PreferenceRequest): Promise<Document> {\n  const {\n    key,\n    req: { payload },\n    req,\n    user,\n  } = args\n\n  if (!user) {\n    throw new UnauthorizedError(req.t)\n  }\n\n  const where: Where = {\n    and: [\n      { key: { equals: key } },\n      { 'user.value': { equals: user.id } },\n      { 'user.relationTo': { equals: user.collection } },\n    ],\n  }\n\n  const result = await payload.db.deleteOne({\n    collection: preferencesCollectionSlug,\n    req,\n    where,\n  })\n\n  if (result) {\n    return result\n  }\n  throw new NotFound(req.t)\n}\n"],"names":["NotFound","UnauthorizedError","preferencesCollectionSlug","deleteOperation","args","key","req","payload","user","t","where","and","equals","id","collection","result","db","deleteOne"],"mappings":";;;;AAGA,SAASA,QAAQ,QAAQ,2BAA0B;AACnD,SAASC,iBAAiB,QAAQ,oCAAmC;AACrE,SAASC,yBAAyB,QAAQ,eAAc;;;;AAEjD,eAAeC,gBAAgBC,IAAuB;IAC3D,MAAM,EACJC,GAAG,EACHC,KAAK,EAAEC,OAAO,EAAE,EAChBD,GAAG,EACHE,IAAI,EACL,GAAGJ;IAEJ,IAAI,CAACI,MAAM;QACT,MAAM,IAAIP,qLAAAA,CAAkBK,IAAIG,CAAC;IACnC;IAEA,MAAMC,QAAe;QACnBC,KAAK;YACH;gBAAEN,KAAK;oBAAEO,QAAQP;gBAAI;YAAE;YACvB;gBAAE,cAAc;oBAAEO,QAAQJ,KAAKK,EAAE;gBAAC;YAAE;YACpC;gBAAE,mBAAmB;oBAAED,QAAQJ,KAAKM,UAAU;gBAAC;YAAE;SAClD;IACH;IAEA,MAAMC,SAAS,MAAMR,QAAQS,EAAE,CAACC,SAAS,CAAC;QACxCH,YAAYZ,uLAAAA;QACZI;QACAI;IACF;IAEA,IAAIK,QAAQ;QACV,OAAOA;IACT;IACA,MAAM,IAAIf,mKAAAA,CAASM,IAAIG,CAAC;AAC1B"}},
    {"offset": {"line": 3169, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/preferences/requestHandlers/delete.ts"],"sourcesContent":["import { status as httpStatus } from 'http-status'\n\nimport type { PayloadHandler } from '../../config/types.js'\nimport type { PayloadRequest } from '../../types/index.js'\n\nimport { deleteOperation } from '../operations/delete.js'\n\nexport const deleteHandler: PayloadHandler = async (incomingReq): Promise<Response> => {\n  // We cannot import the addDataAndFileToRequest utility here from the 'next' package because of dependency issues\n  // However that utility should be used where possible instead of manually appending the data\n  let data\n\n  try {\n    data = await incomingReq.json?.()\n  } catch (ignore) {\n    data = {}\n  }\n\n  const reqWithData: PayloadRequest = incomingReq\n\n  if (data) {\n    reqWithData.data = data\n    // @ts-expect-error\n    reqWithData.json = () => Promise.resolve(data)\n  }\n\n  const result = await deleteOperation({\n    key: reqWithData.routeParams?.key as string,\n    req: reqWithData,\n    user: reqWithData.user,\n  })\n\n  return Response.json(\n    {\n      ...result,\n      message: reqWithData.t('general:deletedSuccessfully'),\n    },\n    {\n      status: httpStatus.OK,\n    },\n  )\n}\n"],"names":["status","httpStatus","deleteOperation","deleteHandler","incomingReq","data","json","ignore","reqWithData","Promise","resolve","result","key","routeParams","req","user","Response","message","t","OK"],"mappings":";;;;;AAAA,SAASA,UAAUC,UAAU,QAAQ,cAAa;AAKlD,SAASC,eAAe,QAAQ,0BAAyB;;;AAElD,MAAMC,gBAAgC,OAAOC;IAClD,iHAAiH;IACjH,4FAA4F;IAC5F,IAAIC;IAEJ,IAAI;QACFA,OAAO,MAAMD,YAAYE,IAAI;IAC/B,EAAE,OAAOC,QAAQ;QACfF,OAAO,CAAC;IACV;IAEA,MAAMG,cAA8BJ;IAEpC,IAAIC,MAAM;QACRG,YAAYH,IAAI,GAAGA;QACnB,mBAAmB;QACnBG,YAAYF,IAAI,GAAG,IAAMG,QAAQC,OAAO,CAACL;IAC3C;IAEA,MAAMM,SAAS,UAAMT,2LAAAA,EAAgB;QACnCU,KAAKJ,YAAYK,WAAW,EAAED;QAC9BE,KAAKN;QACLO,MAAMP,YAAYO,IAAI;IACxB;IAEA,OAAOC,SAASV,IAAI,CAClB;QACE,GAAGK,MAAM;QACTM,SAAST,YAAYU,CAAC,CAAC;IACzB,GACA;QACElB,QAAQC,sMAAAA,CAAWkB,EAAE;IACvB;AAEJ,EAAC"}},
    {"offset": {"line": 3209, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/preferences/operations/findOne.ts"],"sourcesContent":["import type { TypedCollection } from '../../index.js'\nimport type { Where } from '../../types/index.js'\nimport type { PreferenceRequest } from '../types.js'\n\nimport { preferencesCollectionSlug } from '../config.js'\n\nexport async function findOne(args: PreferenceRequest): Promise<TypedCollection['_preference']> {\n  const {\n    key,\n    req: { payload },\n    req,\n    user,\n  } = args\n\n  if (!user) {\n    return null!\n  }\n\n  const where: Where = {\n    and: [\n      { key: { equals: key } },\n      { 'user.value': { equals: user.id } },\n      { 'user.relationTo': { equals: user.collection } },\n    ],\n  }\n\n  const { docs } = await payload.db.find({\n    collection: preferencesCollectionSlug,\n    limit: 1,\n    pagination: false,\n    req,\n    sort: '-updatedAt',\n    where,\n  })\n\n  return docs?.[0] || null!\n}\n"],"names":["preferencesCollectionSlug","findOne","args","key","req","payload","user","where","and","equals","id","collection","docs","db","find","limit","pagination","sort"],"mappings":";;;;AAIA,SAASA,yBAAyB,QAAQ,eAAc;;AAEjD,eAAeC,QAAQC,IAAuB;IACnD,MAAM,EACJC,GAAG,EACHC,KAAK,EAAEC,OAAO,EAAE,EAChBD,GAAG,EACHE,IAAI,EACL,GAAGJ;IAEJ,IAAI,CAACI,MAAM;QACT,OAAO;IACT;IAEA,MAAMC,QAAe;QACnBC,KAAK;YACH;gBAAEL,KAAK;oBAAEM,QAAQN;gBAAI;YAAE;YACvB;gBAAE,cAAc;oBAAEM,QAAQH,KAAKI,EAAE;gBAAC;YAAE;YACpC;gBAAE,mBAAmB;oBAAED,QAAQH,KAAKK,UAAU;gBAAC;YAAE;SAClD;IACH;IAEA,MAAM,EAAEC,IAAI,EAAE,GAAG,MAAMP,QAAQQ,EAAE,CAACC,IAAI,CAAC;QACrCH,YAAYX,uLAAAA;QACZe,OAAO;QACPC,YAAY;QACZZ;QACAa,MAAM;QACNV;IACF;IAEA,OAAOK,MAAM,CAAC,EAAE,IAAI;AACtB"}},
    {"offset": {"line": 3253, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/preferences/requestHandlers/findOne.ts"],"sourcesContent":["import { status as httpStatus } from 'http-status'\n\nimport type { PayloadHandler } from '../../config/types.js'\nimport type { PayloadRequest } from '../../types/index.js'\n\nimport { findOne } from '../operations/findOne.js'\n\nexport const findByIDHandler: PayloadHandler = async (incomingReq): Promise<Response> => {\n  // We cannot import the addDataAndFileToRequest utility here from the 'next' package because of dependency issues\n  // However that utility should be used where possible instead of manually appending the data\n  let data\n\n  try {\n    data = await incomingReq.json?.()\n  } catch (ignore) {\n    data = {}\n  }\n\n  const reqWithData: PayloadRequest = incomingReq\n\n  if (data) {\n    reqWithData.data = data\n    // @ts-expect-error\n    reqWithData.json = () => Promise.resolve(data)\n  }\n\n  const result = await findOne({\n    key: reqWithData.routeParams?.key as string,\n    req: reqWithData,\n    user: reqWithData.user,\n  })\n\n  return Response.json(\n    {\n      ...(result\n        ? result\n        : {\n            message: reqWithData.t('general:notFound'),\n            value: null,\n          }),\n    },\n    {\n      status: httpStatus.OK,\n    },\n  )\n}\n"],"names":["status","httpStatus","findOne","findByIDHandler","incomingReq","data","json","ignore","reqWithData","Promise","resolve","result","key","routeParams","req","user","Response","message","t","value","OK"],"mappings":";;;;;AAAA,SAASA,UAAUC,UAAU,QAAQ,cAAa;AAKlD,SAASC,OAAO,QAAQ,2BAA0B;;;AAE3C,MAAMC,kBAAkC,OAAOC;IACpD,iHAAiH;IACjH,4FAA4F;IAC5F,IAAIC;IAEJ,IAAI;QACFA,OAAO,MAAMD,YAAYE,IAAI;IAC/B,EAAE,OAAOC,QAAQ;QACfF,OAAO,CAAC;IACV;IAEA,MAAMG,cAA8BJ;IAEpC,IAAIC,MAAM;QACRG,YAAYH,IAAI,GAAGA;QACnB,mBAAmB;QACnBG,YAAYF,IAAI,GAAG,IAAMG,QAAQC,OAAO,CAACL;IAC3C;IAEA,MAAMM,SAAS,UAAMT,oLAAAA,EAAQ;QAC3BU,KAAKJ,YAAYK,WAAW,EAAED;QAC9BE,KAAKN;QACLO,MAAMP,YAAYO,IAAI;IACxB;IAEA,OAAOC,SAASV,IAAI,CAClB;QACE,GAAIK,SACAA,SACA;YACEM,SAAST,YAAYU,CAAC,CAAC;YACvBC,OAAO;QACT,CAAC;IACP,GACA;QACEnB,QAAQC,sMAAAA,CAAWmB,EAAE;IACvB;AAEJ,EAAC"}},
    {"offset": {"line": 3295, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/preferences/operations/update.ts"],"sourcesContent":["import type { Where } from '../../types/index.js'\nimport type { PreferenceUpdateRequest } from '../types.js'\n\nimport { UnauthorizedError } from '../../errors/UnauthorizedError.js'\nimport { preferencesCollectionSlug } from '../config.js'\n\nexport async function update(args: PreferenceUpdateRequest) {\n  const {\n    key,\n    req: { payload },\n    req,\n    user,\n    value,\n  } = args\n\n  if (!user) {\n    throw new UnauthorizedError(req.t)\n  }\n\n  const where: Where = {\n    and: [\n      { key: { equals: key } },\n      { 'user.value': { equals: user.id } },\n      { 'user.relationTo': { equals: user.collection } },\n    ],\n  }\n\n  const preference = {\n    key,\n    user: {\n      relationTo: user.collection,\n      value: user.id,\n    },\n    value,\n  }\n\n  return await payload.db.upsert({\n    collection: preferencesCollectionSlug,\n    data: preference,\n    req,\n    where,\n  })\n}\n"],"names":["UnauthorizedError","preferencesCollectionSlug","update","args","key","req","payload","user","value","t","where","and","equals","id","collection","preference","relationTo","db","upsert","data"],"mappings":";;;;AAGA,SAASA,iBAAiB,QAAQ,oCAAmC;AACrE,SAASC,yBAAyB,QAAQ,eAAc;;;AAEjD,eAAeC,OAAOC,IAA6B;IACxD,MAAM,EACJC,GAAG,EACHC,KAAK,EAAEC,OAAO,EAAE,EAChBD,GAAG,EACHE,IAAI,EACJC,KAAK,EACN,GAAGL;IAEJ,IAAI,CAACI,MAAM;QACT,MAAM,IAAIP,qLAAAA,CAAkBK,IAAII,CAAC;IACnC;IAEA,MAAMC,QAAe;QACnBC,KAAK;YACH;gBAAEP,KAAK;oBAAEQ,QAAQR;gBAAI;YAAE;YACvB;gBAAE,cAAc;oBAAEQ,QAAQL,KAAKM,EAAE;gBAAC;YAAE;YACpC;gBAAE,mBAAmB;oBAAED,QAAQL,KAAKO,UAAU;gBAAC;YAAE;SAClD;IACH;IAEA,MAAMC,aAAa;QACjBX;QACAG,MAAM;YACJS,YAAYT,KAAKO,UAAU;YAC3BN,OAAOD,KAAKM,EAAE;QAChB;QACAL;IACF;IAEA,OAAO,MAAMF,QAAQW,EAAE,CAACC,MAAM,CAAC;QAC7BJ,YAAYb,uLAAAA;QACZkB,MAAMJ;QACNV;QACAK;IACF;AACF"}},
    {"offset": {"line": 3346, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/preferences/requestHandlers/update.ts"],"sourcesContent":["import { status as httpStatus } from 'http-status'\n\nimport type { PayloadHandler } from '../../config/types.js'\nimport type { PayloadRequest } from '../../types/index.js'\n\nimport { update } from '../operations/update.js'\n\nexport const updateHandler: PayloadHandler = async (incomingReq) => {\n  // We cannot import the addDataAndFileToRequest utility here from the 'next' package because of dependency issues\n  // However that utility should be used where possible instead of manually appending the data\n  let data\n\n  try {\n    data = await incomingReq.json?.()\n  } catch (_err) {\n    data = {}\n  }\n\n  const reqWithData: PayloadRequest = incomingReq\n\n  if (data) {\n    reqWithData.data = data\n    // @ts-expect-error\n    reqWithData.json = () => Promise.resolve(data)\n  }\n\n  const doc = await update({\n    key: reqWithData.routeParams?.key as string,\n    req: reqWithData,\n    user: reqWithData?.user,\n    value: reqWithData.data?.value || reqWithData.data,\n  })\n\n  return Response.json(\n    {\n      doc,\n      message: reqWithData.t('general:updatedSuccessfully'),\n    },\n    {\n      status: httpStatus.OK,\n    },\n  )\n}\n"],"names":["status","httpStatus","update","updateHandler","incomingReq","data","json","_err","reqWithData","Promise","resolve","doc","key","routeParams","req","user","value","Response","message","t","OK"],"mappings":";;;;;AAAA,SAASA,UAAUC,UAAU,QAAQ,cAAa;AAKlD,SAASC,MAAM,QAAQ,0BAAyB;;;AAEzC,MAAMC,gBAAgC,OAAOC;IAClD,iHAAiH;IACjH,4FAA4F;IAC5F,IAAIC;IAEJ,IAAI;QACFA,OAAO,MAAMD,YAAYE,IAAI;IAC/B,EAAE,OAAOC,MAAM;QACbF,OAAO,CAAC;IACV;IAEA,MAAMG,cAA8BJ;IAEpC,IAAIC,MAAM;QACRG,YAAYH,IAAI,GAAGA;QACnB,mBAAmB;QACnBG,YAAYF,IAAI,GAAG,IAAMG,QAAQC,OAAO,CAACL;IAC3C;IAEA,MAAMM,MAAM,UAAMT,kLAAAA,EAAO;QACvBU,KAAKJ,YAAYK,WAAW,EAAED;QAC9BE,KAAKN;QACLO,MAAMP,aAAaO;QACnBC,OAAOR,YAAYH,IAAI,EAAEW,SAASR,YAAYH,IAAI;IACpD;IAEA,OAAOY,SAASX,IAAI,CAClB;QACEK;QACAO,SAASV,YAAYW,CAAC,CAAC;IACzB,GACA;QACEnB,QAAQC,sMAAAA,CAAWmB,EAAE;IACvB;AAEJ,EAAC"}},
    {"offset": {"line": 3387, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/preferences/config.ts"],"sourcesContent":["import type { CollectionConfig } from '../collections/config/types.js'\nimport type { Access, Config } from '../config/types.js'\nimport type { Where } from '../types/index.js'\n\nimport { deleteHandler } from './requestHandlers/delete.js'\nimport { findByIDHandler } from './requestHandlers/findOne.js'\nimport { updateHandler } from './requestHandlers/update.js'\n\nconst preferenceAccess: Access = ({ req }) => {\n  if (!req.user) {\n    return false\n  }\n\n  const userValueCondition: Where = {\n    'user.value': {\n      equals: req.user.id,\n    },\n  }\n\n  const userRelationCondition: Where = {\n    'user.relationTo': {\n      equals: req.user.collection,\n    },\n  }\n\n  return {\n    and: [userValueCondition, userRelationCondition],\n  }\n}\n\nexport const preferencesCollectionSlug = 'payload-preferences'\n\nexport const getPreferencesCollection = (config: Config): CollectionConfig => ({\n  slug: preferencesCollectionSlug,\n  access: {\n    delete: preferenceAccess,\n    read: preferenceAccess,\n  },\n  admin: {\n    hidden: true,\n  },\n  endpoints: [\n    {\n      handler: findByIDHandler,\n      method: 'get',\n      path: '/:key',\n    },\n    {\n      handler: deleteHandler,\n      method: 'delete',\n      path: '/:key',\n    },\n    {\n      handler: updateHandler,\n      method: 'post',\n      path: '/:key',\n    },\n  ],\n  fields: [\n    {\n      name: 'user',\n      type: 'relationship',\n      hooks: {\n        beforeValidate: [\n          ({ req }) => {\n            if (!req?.user) {\n              return null\n            }\n\n            return {\n              relationTo: req?.user.collection,\n              value: req?.user.id,\n            }\n          },\n        ],\n      },\n      index: true,\n      relationTo: config\n        .collections!.filter((collectionConfig) => collectionConfig.auth)\n        .map((collectionConfig) => collectionConfig.slug),\n      required: true,\n    },\n    {\n      name: 'key',\n      type: 'text',\n      index: true,\n    },\n    {\n      name: 'value',\n      type: 'json',\n      validate: (value) => {\n        if (value) {\n          try {\n            JSON.parse(JSON.stringify(value))\n          } catch {\n            return 'Invalid JSON'\n          }\n        }\n\n        return true\n      },\n    },\n  ],\n  lockDocuments: false,\n})\n"],"names":["deleteHandler","findByIDHandler","updateHandler","preferenceAccess","req","user","userValueCondition","equals","id","userRelationCondition","collection","and","preferencesCollectionSlug","getPreferencesCollection","config","slug","access","delete","read","admin","hidden","endpoints","handler","method","path","fields","name","type","hooks","beforeValidate","relationTo","value","index","collections","filter","collectionConfig","auth","map","required","validate","JSON","parse","stringify","lockDocuments"],"mappings":";;;;;;AAIA,SAASA,aAAa,QAAQ,8BAA6B;AAC3D,SAASC,eAAe,QAAQ,+BAA8B;AAC9D,SAASC,aAAa,QAAQ,8BAA6B;;;;AAE3D,MAAMC,mBAA2B,CAAC,EAAEC,GAAG,EAAE;IACvC,IAAI,CAACA,IAAIC,IAAI,EAAE;QACb,OAAO;IACT;IAEA,MAAMC,qBAA4B;QAChC,cAAc;YACZC,QAAQH,IAAIC,IAAI,CAACG,EAAE;QACrB;IACF;IAEA,MAAMC,wBAA+B;QACnC,mBAAmB;YACjBF,QAAQH,IAAIC,IAAI,CAACK,UAAU;QAC7B;IACF;IAEA,OAAO;QACLC,KAAK;YAACL;YAAoBG;SAAsB;IAClD;AACF;AAEO,MAAMG,4BAA4B,sBAAqB;AAEvD,MAAMC,2BAA2B,CAACC,SAAsC,CAAA;QAC7EC,MAAMH;QACNI,QAAQ;YACNC,QAAQd;YACRe,MAAMf;QACR;QACAgB,OAAO;YACLC,QAAQ;QACV;QACAC,WAAW;YACT;gBACEC,SAASrB,iMAAAA;gBACTsB,QAAQ;gBACRC,MAAM;YACR;YACA;gBACEF,SAAStB,8LAAAA;gBACTuB,QAAQ;gBACRC,MAAM;YACR;YACA;gBACEF,SAASpB,8LAAAA;gBACTqB,QAAQ;gBACRC,MAAM;YACR;SACD;QACDC,QAAQ;YACN;gBACEC,MAAM;gBACNC,MAAM;gBACNC,OAAO;oBACLC,gBAAgB;wBACd,CAAC,EAAEzB,GAAG,EAAE;4BACN,IAAI,CAACA,KAAKC,MAAM;gCACd,OAAO;4BACT;4BAEA,OAAO;gCACLyB,YAAY1B,KAAKC,KAAKK;gCACtBqB,OAAO3B,KAAKC,KAAKG;4BACnB;wBACF;qBACD;gBACH;gBACAwB,OAAO;gBACPF,YAAYhB,OACTmB,WAAW,CAAEC,MAAM,CAAC,CAACC,mBAAqBA,iBAAiBC,IAAI,EAC/DC,GAAG,CAAC,CAACF,mBAAqBA,iBAAiBpB,IAAI;gBAClDuB,UAAU;YACZ;YACA;gBACEZ,MAAM;gBACNC,MAAM;gBACNK,OAAO;YACT;YACA;gBACEN,MAAM;gBACNC,MAAM;gBACNY,UAAU,CAACR;oBACT,IAAIA,OAAO;wBACT,IAAI;4BACFS,KAAKC,KAAK,CAACD,KAAKE,SAAS,CAACX;wBAC5B,EAAE,OAAM;4BACN,OAAO;wBACT;oBACF;oBAEA,OAAO;gBACT;YACF;SACD;QACDY,eAAe;IACjB,CAAA,EAAE"}},
    {"offset": {"line": 3494, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/preferences/deleteUserPreferences.ts"],"sourcesContent":["import type { SanitizedCollectionConfig } from '../collections/config/types.js'\nimport type { Payload } from '../index.js'\nimport type { PayloadRequest } from '../types/index.js'\n\nimport { preferencesCollectionSlug } from './config.js'\n\ntype Args = {\n  collectionConfig: SanitizedCollectionConfig\n  /**\n   * User IDs to delete\n   */\n  ids: (number | string)[]\n  payload: Payload\n  req: PayloadRequest\n}\nexport const deleteUserPreferences = async ({ collectionConfig, ids, payload, req }: Args) => {\n  if (collectionConfig.auth) {\n    await payload.db.deleteMany({\n      collection: preferencesCollectionSlug,\n      req,\n      where: {\n        or: [\n          {\n            and: [\n              {\n                'user.value': { in: ids },\n              },\n              {\n                'user.relationTo': { equals: collectionConfig.slug },\n              },\n            ],\n          },\n          {\n            key: { in: ids.map((id) => `collection-${collectionConfig.slug}-${id}`) },\n          },\n        ],\n      },\n    })\n  } else {\n    await payload.db.deleteMany({\n      collection: preferencesCollectionSlug,\n      req,\n      where: {\n        key: { in: ids.map((id) => `collection-${collectionConfig.slug}-${id}`) },\n      },\n    })\n  }\n}\n"],"names":["preferencesCollectionSlug","deleteUserPreferences","collectionConfig","ids","payload","req","auth","db","deleteMany","collection","where","or","and","in","equals","slug","key","map","id"],"mappings":";;;;AAIA,SAASA,yBAAyB,QAAQ,cAAa;;AAWhD,MAAMC,wBAAwB,OAAO,EAAEC,gBAAgB,EAAEC,GAAG,EAAEC,OAAO,EAAEC,GAAG,EAAQ;IACvF,IAAIH,iBAAiBI,IAAI,EAAE;QACzB,MAAMF,QAAQG,EAAE,CAACC,UAAU,CAAC;YAC1BC,YAAYT,uLAAAA;YACZK;YACAK,OAAO;gBACLC,IAAI;oBACF;wBACEC,KAAK;4BACH;gCACE,cAAc;oCAAEC,IAAIV;gCAAI;4BAC1B;4BACA;gCACE,mBAAmB;oCAAEW,QAAQZ,iBAAiBa,IAAI;gCAAC;4BACrD;yBACD;oBACH;oBACA;wBACEC,KAAK;4BAAEH,IAAIV,IAAIc,GAAG,CAAC,CAACC,KAAO,CAAC,WAAW,EAAEhB,iBAAiBa,IAAI,CAAC,CAAC,EAAEG,IAAI;wBAAE;oBAC1E;iBACD;YACH;QACF;IACF,OAAO;QACL,MAAMd,QAAQG,EAAE,CAACC,UAAU,CAAC;YAC1BC,YAAYT,uLAAAA;YACZK;YACAK,OAAO;gBACLM,KAAK;oBAAEH,IAAIV,IAAIc,GAAG,CAAC,CAACC,KAAO,CAAC,WAAW,EAAEhB,iBAAiBa,IAAI,CAAC,CAAC,EAAEG,IAAI;gBAAE;YAC1E;QACF;IACF;AACF,EAAC"}},
    {"offset": {"line": 3545, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/locked-documents/config.ts"],"sourcesContent":["import type { CollectionConfig } from '../collections/config/types.js'\nimport type { Config } from '../config/types.js'\n\nimport { defaultAccess } from '../auth/defaultAccess.js'\n\nexport const lockedDocumentsCollectionSlug = 'payload-locked-documents'\n\nexport const getLockedDocumentsCollection = (config: Config): CollectionConfig | null => {\n  const lockableCollections = config\n    .collections!.filter((collectionConfig) => collectionConfig.lockDocuments !== false)\n    .map((collectionConfig) => collectionConfig.slug)\n\n  const lockableGlobals = config.globals\n    ? config.globals.filter((globalConfig) => globalConfig.lockDocuments !== false)\n    : []\n\n  const authCollections = config\n    .collections!.filter((collectionConfig) => collectionConfig.auth)\n    .map((collectionConfig) => collectionConfig.slug)\n\n  // If there are no lockable collections AND no lockable globals, don't create the collection\n  if (lockableCollections.length === 0 && lockableGlobals.length === 0) {\n    return null\n  }\n\n  // If there are no auth collections, we can't track who locked the document\n  // so we shouldn't create the locked-documents collection\n  if (authCollections.length === 0) {\n    return null\n  }\n\n  const fields: CollectionConfig['fields'] = []\n\n  // Only include the document field if there are lockable collections\n  if (lockableCollections.length > 0) {\n    fields.push({\n      name: 'document',\n      type: 'relationship',\n      index: true,\n      maxDepth: 0,\n      relationTo: lockableCollections,\n    })\n  }\n\n  // Always include globalSlug field for tracking global locks\n  fields.push({\n    name: 'globalSlug',\n    type: 'text',\n    index: true,\n  })\n\n  // Always include user field\n  fields.push({\n    name: 'user',\n    type: 'relationship',\n    maxDepth: 1,\n    relationTo: authCollections,\n    required: true,\n  })\n\n  return {\n    slug: lockedDocumentsCollectionSlug,\n    access: {\n      create: defaultAccess,\n      delete: defaultAccess,\n      read: defaultAccess,\n      update: defaultAccess,\n    },\n    admin: {\n      hidden: true,\n    },\n    fields,\n    lockDocuments: false,\n  }\n}\n"],"names":["defaultAccess","lockedDocumentsCollectionSlug","getLockedDocumentsCollection","config","lockableCollections","collections","filter","collectionConfig","lockDocuments","map","slug","lockableGlobals","globals","globalConfig","authCollections","auth","length","fields","push","name","type","index","maxDepth","relationTo","required","access","create","delete","read","update","admin","hidden"],"mappings":";;;;;;AAGA,SAASA,aAAa,QAAQ,2BAA0B;;AAEjD,MAAMC,gCAAgC,2BAA0B;AAEhE,MAAMC,+BAA+B,CAACC;IAC3C,MAAMC,sBAAsBD,OACzBE,WAAW,CAAEC,MAAM,CAAC,CAACC,mBAAqBA,iBAAiBC,aAAa,KAAK,OAC7EC,GAAG,CAAC,CAACF,mBAAqBA,iBAAiBG,IAAI;IAElD,MAAMC,kBAAkBR,OAAOS,OAAO,GAClCT,OAAOS,OAAO,CAACN,MAAM,CAAC,CAACO,eAAiBA,aAAaL,aAAa,KAAK,SACvE,EAAE;IAEN,MAAMM,kBAAkBX,OACrBE,WAAW,CAAEC,MAAM,CAAC,CAACC,mBAAqBA,iBAAiBQ,IAAI,EAC/DN,GAAG,CAAC,CAACF,mBAAqBA,iBAAiBG,IAAI;IAElD,4FAA4F;IAC5F,IAAIN,oBAAoBY,MAAM,KAAK,KAAKL,gBAAgBK,MAAM,KAAK,GAAG;QACpE,OAAO;IACT;IAEA,2EAA2E;IAC3E,yDAAyD;IACzD,IAAIF,gBAAgBE,MAAM,KAAK,GAAG;QAChC,OAAO;IACT;IAEA,MAAMC,SAAqC,EAAE;IAE7C,oEAAoE;IACpE,IAAIb,oBAAoBY,MAAM,GAAG,GAAG;QAClCC,OAAOC,IAAI,CAAC;YACVC,MAAM;YACNC,MAAM;YACNC,OAAO;YACPC,UAAU;YACVC,YAAYnB;QACd;IACF;IAEA,4DAA4D;IAC5Da,OAAOC,IAAI,CAAC;QACVC,MAAM;QACNC,MAAM;QACNC,OAAO;IACT;IAEA,4BAA4B;IAC5BJ,OAAOC,IAAI,CAAC;QACVC,MAAM;QACNC,MAAM;QACNE,UAAU;QACVC,YAAYT;QACZU,UAAU;IACZ;IAEA,OAAO;QACLd,MAAMT;QACNwB,QAAQ;YACNC,QAAQ1B,2KAAAA;YACR2B,QAAQ3B,2KAAAA;YACR4B,MAAM5B,2KAAAA;YACN6B,QAAQ7B,2KAAAA;QACV;QACA8B,OAAO;YACLC,QAAQ;QACV;QACAd;QACAT,eAAe;IACjB;AACF,EAAC"}},
    {"offset": {"line": 3611, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/queues/config/global.ts"],"sourcesContent":["import type { Config } from '../../config/types.js'\nimport type { GlobalConfig } from '../../globals/config/types.js'\nimport type { TaskType } from './types/taskTypes.js'\nimport type { WorkflowTypes } from './types/workflowTypes.js'\n\nexport const jobStatsGlobalSlug = 'payload-jobs-stats'\n\n/**\n * Type for data stored in the payload-jobs-stats global.\n */\nexport type JobStats = {\n  stats?: {\n    scheduledRuns?: {\n      queues?: {\n        [queueSlug: string]: {\n          tasks?: {\n            [taskSlug: TaskType]: {\n              lastScheduledRun: string\n            }\n          }\n          workflows?: {\n            [workflowSlug: WorkflowTypes]: {\n              lastScheduledRun: string\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\n/**\n * Global config for job statistics.\n */\nexport const getJobStatsGlobal: (config: Config) => GlobalConfig = (config) => {\n  return {\n    slug: jobStatsGlobalSlug,\n    admin: {\n      group: 'System',\n      hidden: true,\n    },\n    fields: [\n      {\n        name: 'stats',\n        type: 'json',\n      },\n    ],\n  }\n}\n"],"names":["jobStatsGlobalSlug","getJobStatsGlobal","config","slug","admin","group","hidden","fields","name","type"],"mappings":";;;;;;AAKO,MAAMA,qBAAqB,qBAAoB;AA6B/C,MAAMC,oBAAsD,CAACC;IAClE,OAAO;QACLC,MAAMH;QACNI,OAAO;YACLC,OAAO;YACPC,QAAQ;QACV;QACAC,QAAQ;YACN;gBACEC,MAAM;gBACNC,MAAM;YACR;SACD;IACH;AACF,EAAC"}},
    {"offset": {"line": 3637, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/queues/utilities/getCurrentDate.ts"],"sourcesContent":["/**\n * Globals that are used by our integration tests to modify the behavior of the job system during runtime.\n * This is useful to avoid having to wait for the cron jobs to run, or to pause auto-running jobs.\n */\nexport const _internal_jobSystemGlobals = {\n  getCurrentDate: () => {\n    return new Date()\n  },\n  shouldAutoRun: true,\n  shouldAutoSchedule: true,\n}\n\nexport function _internal_resetJobSystemGlobals() {\n  _internal_jobSystemGlobals.getCurrentDate = () => new Date()\n  _internal_jobSystemGlobals.shouldAutoRun = true\n  _internal_jobSystemGlobals.shouldAutoSchedule = true\n}\n\nexport const getCurrentDate: () => Date = () => {\n  return _internal_jobSystemGlobals.getCurrentDate()\n}\n"],"names":["_internal_jobSystemGlobals","getCurrentDate","Date","shouldAutoRun","shouldAutoSchedule","_internal_resetJobSystemGlobals"],"mappings":"AAAA;;;CAGC,GACD;;;;;;;;AAAO,MAAMA,6BAA6B;IACxCC,gBAAgB;QACd,OAAO,IAAIC;IACb;IACAC,eAAe;IACfC,oBAAoB;AACtB,EAAC;AAEM,SAASC;IACdL,2BAA2BC,cAAc,GAAG,IAAM,IAAIC;IACtDF,2BAA2BG,aAAa,GAAG;IAC3CH,2BAA2BI,kBAAkB,GAAG;AAClD;AAEO,MAAMH,iBAA6B;IACxC,OAAOD,2BAA2BC,cAAc;AAClD,EAAC"}},
    {"offset": {"line": 3667, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/queues/operations/handleSchedules/defaultAfterSchedule.ts"],"sourcesContent":["import type { AfterScheduleFn } from '../../config/types/index.js'\n\nimport { type JobStats, jobStatsGlobalSlug } from '../../config/global.js'\nimport { getCurrentDate } from '../../utilities/getCurrentDate.js'\n\ntype JobStatsScheduledRuns = NonNullable<\n  NonNullable<NonNullable<JobStats['stats']>['scheduledRuns']>['queues']\n>[string]\n\nexport const defaultAfterSchedule: AfterScheduleFn = async ({ jobStats, queueable, req }) => {\n  const existingQueuesConfig =\n    jobStats?.stats?.scheduledRuns?.queues?.[queueable.scheduleConfig.queue] || {}\n\n  const queueConfig: JobStatsScheduledRuns = {\n    ...existingQueuesConfig,\n  }\n  if (queueable.taskConfig) {\n    ;(queueConfig.tasks ??= {})[queueable.taskConfig.slug] = {\n      lastScheduledRun: getCurrentDate().toISOString(),\n    }\n  } else if (queueable.workflowConfig) {\n    ;(queueConfig.workflows ??= {})[queueable.workflowConfig.slug] = {\n      lastScheduledRun: getCurrentDate().toISOString(),\n    }\n  }\n\n  // Add to payload-jobs-stats global regardless of the status\n  if (jobStats) {\n    await req.payload.db.updateGlobal({\n      slug: jobStatsGlobalSlug,\n      data: {\n        ...(jobStats || {}),\n        stats: {\n          ...(jobStats?.stats || {}),\n          scheduledRuns: {\n            ...(jobStats?.stats?.scheduledRuns || {}),\n            queues: {\n              ...(jobStats?.stats?.scheduledRuns?.queues || {}),\n              [queueable.scheduleConfig.queue]: queueConfig,\n            },\n          },\n        },\n        updatedAt: new Date().toISOString(),\n      } as JobStats,\n      req,\n      returning: false,\n    })\n  } else {\n    await req.payload.db.createGlobal({\n      slug: jobStatsGlobalSlug,\n      data: {\n        createdAt: getCurrentDate().toISOString(),\n        stats: {\n          scheduledRuns: {\n            queues: {\n              [queueable.scheduleConfig.queue]: queueConfig,\n            },\n          },\n        },\n      } as JobStats,\n      req,\n      returning: false,\n    })\n  }\n}\n"],"names":["jobStatsGlobalSlug","getCurrentDate","defaultAfterSchedule","jobStats","queueable","req","existingQueuesConfig","stats","scheduledRuns","queues","scheduleConfig","queue","queueConfig","taskConfig","tasks","slug","lastScheduledRun","toISOString","workflowConfig","workflows","payload","db","updateGlobal","data","updatedAt","Date","returning","createGlobal","createdAt"],"mappings":";;;;AAEA,SAAwBA,kBAAkB,QAAQ,yBAAwB;AAC1E,SAASC,cAAc,QAAQ,oCAAmC;;;AAM3D,MAAMC,uBAAwC,OAAO,EAAEC,QAAQ,EAAEC,SAAS,EAAEC,GAAG,EAAE;IACtF,MAAMC,uBACJH,UAAUI,OAAOC,eAAeC,QAAQ,CAACL,UAAUM,cAAc,CAACC,KAAK,CAAC,IAAI,CAAC;IAE/E,MAAMC,cAAqC;QACzC,GAAGN,oBAAoB;IACzB;IACA,IAAIF,UAAUS,UAAU,EAAE;;QACtBD,CAAAA,YAAYE,KAAK,KAAK,CAAC,CAAA,CAAE,CAACV,UAAUS,UAAU,CAACE,IAAI,CAAC,GAAG;YACvDC,sBAAkBf,4LAAAA,IAAiBgB,WAAW;QAChD;IACF,OAAO,IAAIb,UAAUc,cAAc,EAAE;;QACjCN,CAAAA,YAAYO,SAAS,KAAK,CAAC,CAAA,CAAE,CAACf,UAAUc,cAAc,CAACH,IAAI,CAAC,GAAG;YAC/DC,sBAAkBf,4LAAAA,IAAiBgB,WAAW;QAChD;IACF;IAEA,4DAA4D;IAC5D,IAAId,UAAU;QACZ,MAAME,IAAIe,OAAO,CAACC,EAAE,CAACC,YAAY,CAAC;YAChCP,MAAMf,qLAAAA;YACNuB,MAAM;gBACJ,GAAIpB,YAAY,CAAC,CAAC;gBAClBI,OAAO;oBACL,GAAIJ,UAAUI,SAAS,CAAC,CAAC;oBACzBC,eAAe;wBACb,GAAIL,UAAUI,OAAOC,iBAAiB,CAAC,CAAC;wBACxCC,QAAQ;4BACN,GAAIN,UAAUI,OAAOC,eAAeC,UAAU,CAAC,CAAC;4BAChD,CAACL,UAAUM,cAAc,CAACC,KAAK,CAAC,EAAEC;wBACpC;oBACF;gBACF;gBACAY,WAAW,IAAIC,OAAOR,WAAW;YACnC;YACAZ;YACAqB,WAAW;QACb;IACF,OAAO;QACL,MAAMrB,IAAIe,OAAO,CAACC,EAAE,CAACM,YAAY,CAAC;YAChCZ,MAAMf,qLAAAA;YACNuB,MAAM;gBACJK,eAAW3B,4LAAAA,IAAiBgB,WAAW;gBACvCV,OAAO;oBACLC,eAAe;wBACbC,QAAQ;4BACN,CAACL,UAAUM,cAAc,CAACC,KAAK,CAAC,EAAEC;wBACpC;oBACF;gBACF;YACF;YACAP;YACAqB,WAAW;QACb;IACF;AACF,EAAC"}},
    {"offset": {"line": 3734, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/queues/operations/handleSchedules/countRunnableOrActiveJobsForQueue.ts"],"sourcesContent":["import type { PayloadRequest, Where } from '../../../types/index.js'\nimport type { TaskType } from '../../config/types/taskTypes.js'\nimport type { WorkflowTypes } from '../../config/types/workflowTypes.js'\n\n/**\n * Gets all queued jobs that can be run. This means they either:\n * - failed but do not have a definitive error => can be retried\n * - are currently processing\n * - have not been started yet\n */\nexport async function countRunnableOrActiveJobsForQueue({\n  onlyScheduled = false,\n  queue,\n  req,\n  taskSlug,\n  workflowSlug,\n}: {\n  /**\n   * If true, this counts only jobs that have been created through the scheduling system.\n   *\n   * @default false\n   */\n  onlyScheduled?: boolean\n  queue: string\n  req: PayloadRequest\n  taskSlug?: TaskType\n  workflowSlug?: WorkflowTypes\n}): Promise<number> {\n  const and: Where[] = [\n    {\n      queue: {\n        equals: queue,\n      },\n    },\n\n    {\n      completedAt: { exists: false },\n    },\n    {\n      error: { exists: false },\n    },\n  ]\n\n  if (taskSlug) {\n    and.push({\n      taskSlug: {\n        equals: taskSlug,\n      },\n    })\n  } else if (workflowSlug) {\n    and.push({\n      workflowSlug: {\n        equals: workflowSlug,\n      },\n    })\n  }\n  if (onlyScheduled) {\n    and.push({\n      'meta.scheduled': {\n        equals: true,\n      },\n    })\n  }\n\n  const runnableOrActiveJobsForQueue = await req.payload.db.count({\n    collection: 'payload-jobs',\n    req,\n    where: {\n      and,\n    },\n  })\n\n  return runnableOrActiveJobsForQueue.totalDocs\n}\n"],"names":["countRunnableOrActiveJobsForQueue","onlyScheduled","queue","req","taskSlug","workflowSlug","and","equals","completedAt","exists","error","push","runnableOrActiveJobsForQueue","payload","db","count","collection","where","totalDocs"],"mappings":"AAIA;;;;;CAKC,GACD;;;;AAAO,eAAeA,kCAAkC,EACtDC,gBAAgB,KAAK,EACrBC,KAAK,EACLC,GAAG,EACHC,QAAQ,EACRC,YAAY,EAYb;IACC,MAAMC,MAAe;QACnB;YACEJ,OAAO;gBACLK,QAAQL;YACV;QACF;QAEA;YACEM,aAAa;gBAAEC,QAAQ;YAAM;QAC/B;QACA;YACEC,OAAO;gBAAED,QAAQ;YAAM;QACzB;KACD;IAED,IAAIL,UAAU;QACZE,IAAIK,IAAI,CAAC;YACPP,UAAU;gBACRG,QAAQH;YACV;QACF;IACF,OAAO,IAAIC,cAAc;QACvBC,IAAIK,IAAI,CAAC;YACPN,cAAc;gBACZE,QAAQF;YACV;QACF;IACF;IACA,IAAIJ,eAAe;QACjBK,IAAIK,IAAI,CAAC;YACP,kBAAkB;gBAChBJ,QAAQ;YACV;QACF;IACF;IAEA,MAAMK,+BAA+B,MAAMT,IAAIU,OAAO,CAACC,EAAE,CAACC,KAAK,CAAC;QAC9DC,YAAY;QACZb;QACAc,OAAO;YACLX;QACF;IACF;IAEA,OAAOM,6BAA6BM,SAAS;AAC/C"}},
    {"offset": {"line": 3794, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/queues/operations/handleSchedules/defaultBeforeSchedule.ts"],"sourcesContent":["import type { BeforeScheduleFn } from '../../config/types/index.js'\n\nimport { countRunnableOrActiveJobsForQueue } from './countRunnableOrActiveJobsForQueue.js'\n\nexport const defaultBeforeSchedule: BeforeScheduleFn = async ({ queueable, req }) => {\n  // All tasks in that queue that are either currently processing or can be run\n  const runnableOrActiveJobsForQueue = await countRunnableOrActiveJobsForQueue({\n    onlyScheduled: true,\n    queue: queueable.scheduleConfig.queue,\n    req,\n    taskSlug: queueable.taskConfig?.slug,\n    workflowSlug: queueable.workflowConfig?.slug,\n  })\n\n  return {\n    input: {},\n    shouldSchedule: runnableOrActiveJobsForQueue === 0,\n    waitUntil: queueable.waitUntil,\n  }\n}\n"],"names":["countRunnableOrActiveJobsForQueue","defaultBeforeSchedule","queueable","req","runnableOrActiveJobsForQueue","onlyScheduled","queue","scheduleConfig","taskSlug","taskConfig","slug","workflowSlug","workflowConfig","input","shouldSchedule","waitUntil"],"mappings":";;;;AAEA,SAASA,iCAAiC,QAAQ,yCAAwC;;AAEnF,MAAMC,wBAA0C,OAAO,EAAEC,SAAS,EAAEC,GAAG,EAAE;IAC9E,6EAA6E;IAC7E,MAAMC,+BAA+B,UAAMJ,sPAAAA,EAAkC;QAC3EK,eAAe;QACfC,OAAOJ,UAAUK,cAAc,CAACD,KAAK;QACrCH;QACAK,UAAUN,UAAUO,UAAU,EAAEC;QAChCC,cAAcT,UAAUU,cAAc,EAAEF;IAC1C;IAEA,OAAO;QACLG,OAAO,CAAC;QACRC,gBAAgBV,iCAAiC;QACjDW,WAAWb,UAAUa,SAAS;IAChC;AACF,EAAC"}},
    {"offset": {"line": 3819, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/queues/operations/handleSchedules/getQueuesWithSchedules.ts"],"sourcesContent":["import type { SanitizedJobsConfig, ScheduleConfig } from '../../config/types/index.js'\nimport type { TaskConfig } from '../../config/types/taskTypes.js'\nimport type { WorkflowConfig } from '../../config/types/workflowTypes.js'\n\ntype QueuesWithSchedules = {\n  [queue: string]: {\n    schedules: {\n      scheduleConfig: ScheduleConfig\n      taskConfig?: TaskConfig\n      workflowConfig?: WorkflowConfig\n    }[]\n  }\n}\n\nexport const getQueuesWithSchedules = ({\n  jobsConfig,\n}: {\n  jobsConfig: SanitizedJobsConfig\n}): QueuesWithSchedules => {\n  const tasksWithSchedules =\n    jobsConfig.tasks?.filter((task) => {\n      return task.schedule?.length\n    }) ?? []\n\n  const workflowsWithSchedules =\n    jobsConfig.workflows?.filter((workflow) => {\n      return workflow.schedule?.length\n    }) ?? []\n\n  const queuesWithSchedules: QueuesWithSchedules = {}\n\n  for (const task of tasksWithSchedules) {\n    for (const schedule of task.schedule ?? []) {\n      ;(queuesWithSchedules[schedule.queue] ??= { schedules: [] }).schedules.push({\n        scheduleConfig: schedule,\n        taskConfig: task,\n      })\n    }\n  }\n  for (const workflow of workflowsWithSchedules) {\n    for (const schedule of workflow.schedule ?? []) {\n      ;(queuesWithSchedules[schedule.queue] ??= { schedules: [] }).schedules.push({\n        scheduleConfig: schedule,\n        workflowConfig: workflow,\n      })\n    }\n  }\n\n  return queuesWithSchedules\n}\n"],"names":["getQueuesWithSchedules","jobsConfig","tasksWithSchedules","tasks","filter","task","schedule","length","workflowsWithSchedules","workflows","workflow","queuesWithSchedules","queue","schedules","push","scheduleConfig","taskConfig","workflowConfig"],"mappings":";;;;AAcO,MAAMA,yBAAyB,CAAC,EACrCC,UAAU,EAGX;IACC,MAAMC,qBACJD,WAAWE,KAAK,EAAEC,OAAO,CAACC;QACxB,OAAOA,KAAKC,QAAQ,EAAEC;IACxB,MAAM,EAAE;IAEV,MAAMC,yBACJP,WAAWQ,SAAS,EAAEL,OAAO,CAACM;QAC5B,OAAOA,SAASJ,QAAQ,EAAEC;IAC5B,MAAM,EAAE;IAEV,MAAMI,sBAA2C,CAAC;IAElD,KAAK,MAAMN,QAAQH,mBAAoB;QACrC,KAAK,MAAMI,YAAYD,KAAKC,QAAQ,IAAI,EAAE,CAAE;;YACxCK,CAAAA,mBAAmB,CAACL,SAASM,KAAK,CAAC,KAAK;gBAAEC,WAAW,EAAE;YAAC,CAAA,EAAGA,SAAS,CAACC,IAAI,CAAC;gBAC1EC,gBAAgBT;gBAChBU,YAAYX;YACd;QACF;IACF;IACA,KAAK,MAAMK,YAAYF,uBAAwB;QAC7C,KAAK,MAAMF,YAAYI,SAASJ,QAAQ,IAAI,EAAE,CAAE;;YAC5CK,CAAAA,mBAAmB,CAACL,SAASM,KAAK,CAAC,KAAK;gBAAEC,WAAW,EAAE;YAAC,CAAA,EAAGA,SAAS,CAACC,IAAI,CAAC;gBAC1EC,gBAAgBT;gBAChBW,gBAAgBP;YAClB;QACF;IACF;IAEA,OAAOC;AACT,EAAC"}},
    {"offset": {"line": 3859, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/queues/operations/handleSchedules/index.ts"],"sourcesContent":["import { Cron } from 'croner'\n\nimport type { Job, TaskConfig, WorkflowConfig } from '../../../index.js'\nimport type { PayloadRequest } from '../../../types/index.js'\nimport type { BeforeScheduleFn, Queueable, ScheduleConfig } from '../../config/types/index.js'\n\nimport { type JobStats, jobStatsGlobalSlug } from '../../config/global.js'\nimport { defaultAfterSchedule } from './defaultAfterSchedule.js'\nimport { defaultBeforeSchedule } from './defaultBeforeSchedule.js'\nimport { getQueuesWithSchedules } from './getQueuesWithSchedules.js'\n\nexport type HandleSchedulesResult = {\n  errored: Queueable[]\n  queued: Queueable[]\n  skipped: Queueable[]\n}\n\n/**\n * On vercel, we cannot auto-schedule jobs using a Cron - instead, we'll use this same endpoint that can\n * also be called from Vercel Cron for auto-running jobs.\n *\n * The benefit of doing it like this instead of a separate endpoint is that we can run jobs immediately\n * after they are scheduled\n */\nexport async function handleSchedules({\n  allQueues = false,\n  queue: _queue,\n  req,\n}: {\n  /**\n   * If you want to schedule jobs from all queues, set this to true.\n   * If you set this to true, the `queue` property will be ignored.\n   *\n   * @default false\n   */\n  allQueues?: boolean\n  /**\n   * If you want to only schedule jobs that are set to schedule in a specific queue, set this to the queue name.\n   *\n   * @default jobs from the `default` queue will be executed.\n   */\n  queue?: string\n  req: PayloadRequest\n}): Promise<HandleSchedulesResult> {\n  const queue = _queue ?? 'default'\n  const jobsConfig = req.payload.config.jobs\n  const queuesWithSchedules = getQueuesWithSchedules({\n    jobsConfig,\n  })\n\n  if (Object.keys(queuesWithSchedules).length === 0) {\n    // No schedules defined => return early, before fetching jobsStatsGlobal, as the global may not even exist\n    return {\n      errored: [],\n      queued: [],\n      skipped: [],\n    }\n  }\n\n  const stats: JobStats = await req.payload.db.findGlobal({\n    slug: jobStatsGlobalSlug,\n    req,\n  })\n\n  /**\n   * Almost last step! Tasks and Workflows added here just need to be constraint-checked (e.g max. 1 running task etc.),\n   * before we can queue them\n   */\n  const queueables: Queueable[] = []\n\n  // Need to know when that particular job was last scheduled in that particular queue\n\n  for (const [queueName, { schedules }] of Object.entries(queuesWithSchedules)) {\n    if (!allQueues && queueName !== queue) {\n      // If a queue is specified, only schedule jobs for that queue\n      continue\n    }\n    for (const schedulable of schedules) {\n      const queuable = checkQueueableTimeConstraints({\n        queue: queueName,\n        scheduleConfig: schedulable.scheduleConfig,\n        stats,\n        taskConfig: schedulable.taskConfig,\n        workflowConfig: schedulable.workflowConfig,\n      })\n      if (queuable) {\n        queueables.push(queuable)\n      }\n    }\n  }\n\n  const queued: Queueable[] = []\n  const skipped: Queueable[] = []\n  const errored: Queueable[] = []\n\n  /**\n   * Now queue, but check for constraints (= beforeSchedule) first.\n   * Default constraint (= defaultBeforeSchedule): max. 1 running / scheduled task or workflow per queue\n   */\n  for (const queueable of queueables) {\n    const { status } = await scheduleQueueable({\n      queueable,\n      req,\n      stats,\n    })\n    switch (status) {\n      case 'error':\n        errored.push(queueable)\n        break\n      case 'skipped':\n        skipped.push(queueable)\n        break\n      case 'success':\n        queued.push(queueable)\n        break\n    }\n  }\n  return {\n    errored,\n    queued,\n    skipped,\n  }\n}\n\nexport function checkQueueableTimeConstraints({\n  queue,\n  scheduleConfig,\n  stats,\n  taskConfig,\n  workflowConfig,\n}: {\n  queue: string\n  scheduleConfig: ScheduleConfig\n  stats: JobStats\n  taskConfig?: TaskConfig\n  workflowConfig?: WorkflowConfig\n}): false | Queueable {\n  const queueScheduleStats = stats?.stats?.scheduledRuns?.queues?.[queue]\n\n  const lastScheduledRun = taskConfig\n    ? queueScheduleStats?.tasks?.[taskConfig.slug]?.lastScheduledRun\n    : queueScheduleStats?.workflows?.[workflowConfig?.slug ?? '']?.lastScheduledRun\n\n  const nextRun = new Cron(scheduleConfig.cron).nextRun(lastScheduledRun ?? undefined)\n\n  if (!nextRun) {\n    return false\n  }\n  return {\n    scheduleConfig,\n    taskConfig,\n    waitUntil: nextRun,\n    workflowConfig,\n  }\n}\n\nexport async function scheduleQueueable({\n  queueable,\n  req,\n  stats,\n}: {\n  queueable: Queueable\n  req: PayloadRequest\n  stats: JobStats\n}): Promise<{\n  job?: Job<false>\n  status: 'error' | 'skipped' | 'success'\n}> {\n  if (!queueable.taskConfig && !queueable.workflowConfig) {\n    return {\n      status: 'error',\n    }\n  }\n\n  const beforeScheduleFn = queueable.scheduleConfig.hooks?.beforeSchedule\n  const afterScheduleFN = queueable.scheduleConfig.hooks?.afterSchedule\n\n  try {\n    const beforeScheduleResult: Awaited<ReturnType<BeforeScheduleFn>> = await (\n      beforeScheduleFn ?? defaultBeforeSchedule\n    )({\n      // @ts-expect-error we know defaultBeforeSchedule will never call itself => pass null\n      defaultBeforeSchedule: beforeScheduleFn ? defaultBeforeSchedule : null,\n      jobStats: stats,\n      queueable,\n      req,\n    })\n\n    if (!beforeScheduleResult.shouldSchedule) {\n      await (afterScheduleFN ?? defaultAfterSchedule)({\n        // @ts-expect-error we know defaultAfterchedule will never call itself => pass null\n        defaultAfterSchedule: afterScheduleFN ? defaultAfterSchedule : null,\n        jobStats: stats,\n        queueable,\n        req,\n        status: 'skipped',\n      })\n      return {\n        status: 'skipped',\n      }\n    }\n\n    const job = (await req.payload.jobs.queue({\n      input: beforeScheduleResult.input ?? {},\n      meta: {\n        scheduled: true,\n      },\n      queue: queueable.scheduleConfig.queue,\n      req,\n      task: queueable?.taskConfig?.slug,\n      waitUntil: beforeScheduleResult.waitUntil,\n      workflow: queueable.workflowConfig?.slug,\n    } as Parameters<typeof req.payload.jobs.queue>[0])) as unknown as Job<false>\n\n    await (afterScheduleFN ?? defaultAfterSchedule)({\n      // @ts-expect-error we know defaultAfterchedule will never call itself => pass null\n      defaultAfterSchedule: afterScheduleFN ? defaultAfterSchedule : null,\n      job,\n      jobStats: stats,\n      queueable,\n      req,\n      status: 'success',\n    })\n    return {\n      status: 'success',\n    }\n  } catch (error) {\n    await (afterScheduleFN ?? defaultAfterSchedule)({\n      // @ts-expect-error we know defaultAfterchedule will never call itself => pass null\n      defaultAfterSchedule: afterScheduleFN ? defaultAfterSchedule : null,\n      error: error as Error,\n      jobStats: stats,\n      queueable,\n      req,\n      status: 'error',\n    })\n    return {\n      status: 'error',\n    }\n  }\n}\n"],"names":["Cron","jobStatsGlobalSlug","defaultAfterSchedule","defaultBeforeSchedule","getQueuesWithSchedules","handleSchedules","allQueues","queue","_queue","req","jobsConfig","payload","config","jobs","queuesWithSchedules","Object","keys","length","errored","queued","skipped","stats","db","findGlobal","slug","queueables","queueName","schedules","entries","schedulable","queuable","checkQueueableTimeConstraints","scheduleConfig","taskConfig","workflowConfig","push","queueable","status","scheduleQueueable","queueScheduleStats","scheduledRuns","queues","lastScheduledRun","tasks","workflows","nextRun","cron","undefined","waitUntil","beforeScheduleFn","hooks","beforeSchedule","afterScheduleFN","afterSchedule","beforeScheduleResult","jobStats","shouldSchedule","job","input","meta","scheduled","task","workflow","error"],"mappings":"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"}},
    {"offset": {"line": 4032, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/queues/errors/index.ts"],"sourcesContent":["import type { Job, SingleTaskStatus, WorkflowConfig } from '../../index.js'\nimport type { RetryConfig, TaskConfig } from '../config/types/taskTypes.js'\nimport type { TaskParent } from '../operations/runJobs/runJob/getRunTaskFunction.js'\n\nexport type TaskErrorArgs = {\n  executedAt: Date\n  input?: object\n  job: Job\n  message: string\n  output?: object\n  parent?: TaskParent\n  retriesConfig: RetryConfig\n  taskConfig?: TaskConfig<string>\n  taskID: string\n  taskSlug: string\n  taskStatus: null | SingleTaskStatus<string>\n  workflowConfig: WorkflowConfig\n}\n\nexport type WorkflowErrorArgs = {\n  job: Job\n  message: string\n  workflowConfig: WorkflowConfig\n}\n\nexport class TaskError extends Error {\n  args: TaskErrorArgs\n  constructor(args: TaskErrorArgs) {\n    super(args.message)\n    this.args = args\n  }\n}\nexport class WorkflowError extends Error {\n  args: WorkflowErrorArgs\n\n  constructor(args: WorkflowErrorArgs) {\n    super(args.message)\n    this.args = args\n  }\n}\n\n/**\n * Throw this error from within a task or workflow handler to cancel the job.\n * Unlike failing a job (e.g. by throwing any other error), a cancelled job will not be retried.\n */\nexport class JobCancelledError extends Error {\n  constructor(message: string) {\n    super(message)\n  }\n}\n"],"names":["TaskError","Error","args","message","WorkflowError","JobCancelledError"],"mappings":";;;;;;;;AAyBO,MAAMA,kBAAkBC;IAC7BC,KAAmB;IACnB,YAAYA,IAAmB,CAAE;QAC/B,KAAK,CAACA,KAAKC,OAAO;QAClB,IAAI,CAACD,IAAI,GAAGA;IACd;AACF;AACO,MAAME,sBAAsBH;IACjCC,KAAuB;IAEvB,YAAYA,IAAuB,CAAE;QACnC,KAAK,CAACA,KAAKC,OAAO;QAClB,IAAI,CAACD,IAAI,GAAGA;IACd;AACF;AAMO,MAAMG,0BAA0BJ;IACrC,YAAYE,OAAe,CAAE;QAC3B,KAAK,CAACA;IACR;AACF"}},
    {"offset": {"line": 4063, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/queues/utilities/updateJob.ts"],"sourcesContent":["import type { ManyOptions } from '../../collections/operations/local/update.js'\nimport type { UpdateJobsArgs } from '../../database/types.js'\nimport type { Job } from '../../index.js'\nimport type { PayloadRequest, Sort, Where } from '../../types/index.js'\n\nimport { jobAfterRead, jobsCollectionSlug } from '../config/collection.js'\n\ntype BaseArgs = {\n  data: Partial<Job>\n  depth?: number\n  disableTransaction?: boolean\n  limit?: number\n  req: PayloadRequest\n  returning?: boolean\n}\n\ntype ArgsByID = {\n  id: number | string\n  limit?: never\n  sort?: never\n  where?: never\n}\n\ntype ArgsWhere = {\n  id?: never\n  limit?: number\n  sort?: Sort\n  where: Where\n}\n\ntype RunJobsArgs = (ArgsByID | ArgsWhere) & BaseArgs\n\n/**\n * Convenience method for updateJobs by id\n */\nexport async function updateJob(args: ArgsByID & BaseArgs) {\n  const result = await updateJobs(args)\n  if (result) {\n    return result[0]\n  }\n}\n\n/**\n * Helper for updating jobs in the most performant way possible.\n * Handles deciding whether it can used direct db methods or not, and if so,\n * manually runs the afterRead hook that populates the `taskStatus` property.\n */\nexport async function updateJobs({\n  id,\n  data,\n  depth,\n  disableTransaction,\n  limit: limitArg,\n  req,\n  returning,\n  sort,\n  where: whereArg,\n}: RunJobsArgs): Promise<Job[] | null> {\n  const limit = id ? 1 : limitArg\n  const where = id ? { id: { equals: id } } : whereArg\n\n  if (depth || req.payload.config?.jobs?.runHooks) {\n    const result = await req.payload.update({\n      id,\n      collection: jobsCollectionSlug,\n      data,\n      depth,\n      disableTransaction,\n      limit,\n      req,\n      where,\n    } as ManyOptions<any, any>)\n    if (returning === false || !result) {\n      return null\n    }\n    return result.docs as Job[]\n  }\n\n  const jobReq = {\n    transactionID:\n      req.payload.db.name !== 'mongoose'\n        ? ((await req.payload.db.beginTransaction()) as string)\n        : undefined,\n  }\n\n  if (typeof data.updatedAt === 'undefined') {\n    // Ensure updatedAt date is always updated\n    data.updatedAt = new Date().toISOString()\n  }\n\n  const args: UpdateJobsArgs = id\n    ? {\n        id,\n        data,\n        req: jobReq,\n        returning,\n      }\n    : {\n        data,\n        limit,\n        req: jobReq,\n        returning,\n        sort,\n        where: where as Where,\n      }\n\n  const updatedJobs: Job[] | null = await req.payload.db.updateJobs(args)\n\n  if (req.payload.db.name !== 'mongoose' && jobReq.transactionID) {\n    await req.payload.db.commitTransaction(jobReq.transactionID)\n  }\n\n  if (returning === false || !updatedJobs?.length) {\n    return null\n  }\n\n  return updatedJobs.map((updatedJob) => {\n    return jobAfterRead({\n      config: req.payload.config,\n      doc: updatedJob,\n    })\n  })\n}\n"],"names":["jobAfterRead","jobsCollectionSlug","updateJob","args","result","updateJobs","id","data","depth","disableTransaction","limit","limitArg","req","returning","sort","where","whereArg","equals","payload","config","jobs","runHooks","update","collection","docs","jobReq","transactionID","db","name","beginTransaction","undefined","updatedAt","Date","toISOString","updatedJobs","commitTransaction","length","map","updatedJob","doc"],"mappings":";;;;;;AAKA,SAASA,YAAY,EAAEC,kBAAkB,QAAQ,0BAAyB;;AA8BnE,eAAeC,UAAUC,IAAyB;IACvD,MAAMC,SAAS,MAAMC,WAAWF;IAChC,IAAIC,QAAQ;QACV,OAAOA,MAAM,CAAC,EAAE;IAClB;AACF;AAOO,eAAeC,WAAW,EAC/BC,EAAE,EACFC,IAAI,EACJC,KAAK,EACLC,kBAAkB,EAClBC,OAAOC,QAAQ,EACfC,GAAG,EACHC,SAAS,EACTC,IAAI,EACJC,OAAOC,QAAQ,EACH;IACZ,MAAMN,QAAQJ,KAAK,IAAIK;IACvB,MAAMI,QAAQT,KAAK;QAAEA,IAAI;YAAEW,QAAQX;QAAG;IAAE,IAAIU;IAE5C,IAAIR,SAASI,IAAIM,OAAO,CAACC,MAAM,EAAEC,MAAMC,UAAU;QAC/C,MAAMjB,SAAS,MAAMQ,IAAIM,OAAO,CAACI,MAAM,CAAC;YACtChB;YACAiB,YAAYtB,yLAAAA;YACZM;YACAC;YACAC;YACAC;YACAE;YACAG;QACF;QACA,IAAIF,cAAc,SAAS,CAACT,QAAQ;YAClC,OAAO;QACT;QACA,OAAOA,OAAOoB,IAAI;IACpB;IAEA,MAAMC,SAAS;QACbC,eACEd,IAAIM,OAAO,CAACS,EAAE,CAACC,IAAI,KAAK,aAClB,MAAMhB,IAAIM,OAAO,CAACS,EAAE,CAACE,gBAAgB,KACvCC;IACR;IAEA,IAAI,OAAOvB,KAAKwB,SAAS,KAAK,aAAa;QACzC,0CAA0C;QAC1CxB,KAAKwB,SAAS,GAAG,IAAIC,OAAOC,WAAW;IACzC;IAEA,MAAM9B,OAAuBG,KACzB;QACEA;QACAC;QACAK,KAAKa;QACLZ;IACF,IACA;QACEN;QACAG;QACAE,KAAKa;QACLZ;QACAC;QACAC,OAAOA;IACT;IAEJ,MAAMmB,cAA4B,MAAMtB,IAAIM,OAAO,CAACS,EAAE,CAACtB,UAAU,CAACF;IAElE,IAAIS,IAAIM,OAAO,CAACS,EAAE,CAACC,IAAI,KAAK,cAAcH,OAAOC,aAAa,EAAE;QAC9D,MAAMd,IAAIM,OAAO,CAACS,EAAE,CAACQ,iBAAiB,CAACV,OAAOC,aAAa;IAC7D;IAEA,IAAIb,cAAc,SAAS,CAACqB,aAAaE,QAAQ;QAC/C,OAAO;IACT;IAEA,OAAOF,YAAYG,GAAG,CAAC,CAACC;QACtB,WAAOtC,mLAAAA,EAAa;YAClBmB,QAAQP,IAAIM,OAAO,CAACC,MAAM;YAC1BoB,KAAKD;QACP;IACF;AACF"}},
    {"offset": {"line": 4138, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/queues/operations/runJobs/runJob/getUpdateJobFunction.ts"],"sourcesContent":["import type { Job } from '../../../../index.js'\nimport type { PayloadRequest } from '../../../../types/index.js'\n\nimport { JobCancelledError } from '../../../errors/index.js'\nimport { updateJob } from '../../../utilities/updateJob.js'\n\nexport type UpdateJobFunction = (jobData: Partial<Job>) => Promise<Job>\n\n/**\n * Helper for updating a job that does the following, additionally to updating the job:\n * - Merges incoming data from the updated job into the original job object\n * - Handles job cancellation by throwing a `JobCancelledError` if the job was cancelled.\n */\nexport function getUpdateJobFunction(job: Job, req: PayloadRequest): UpdateJobFunction {\n  return async (jobData) => {\n    const updatedJob = await updateJob({\n      id: job.id,\n      data: jobData,\n      depth: req.payload.config.jobs.depth,\n      disableTransaction: true,\n      req,\n    })\n\n    if (!updatedJob) {\n      return job\n    }\n\n    // Update job object like this to modify the original object - that way, incoming changes (e.g. taskStatus field that will be re-generated through the hook) will be reflected in the calling function\n    for (const key in updatedJob) {\n      if (key === 'log') {\n        // Add all new log entries to the original job.log object. Do not delete any existing log entries.\n        // Do not update existing log entries, as existing log entries should be immutable.\n        for (const logEntry of updatedJob?.log ?? []) {\n          if (!job.log || !job.log.some((entry) => entry.id === logEntry.id)) {\n            ;(job.log ??= []).push(logEntry)\n          }\n        }\n      } else {\n        ;(job as any)[key] = updatedJob[key as keyof Job]\n      }\n    }\n\n    if ((updatedJob?.error as Record<string, unknown>)?.cancelled) {\n      throw new JobCancelledError(`Job ${job.id} was cancelled`)\n    }\n\n    return updatedJob\n  }\n}\n"],"names":["JobCancelledError","updateJob","getUpdateJobFunction","job","req","jobData","updatedJob","id","data","depth","payload","config","jobs","disableTransaction","key","logEntry","log","some","entry","push","error","cancelled"],"mappings":";;;;AAGA,SAASA,iBAAiB,QAAQ,2BAA0B;AAC5D,SAASC,SAAS,QAAQ,kCAAiC;;;AASpD,SAASC,qBAAqBC,GAAQ,EAAEC,GAAmB;IAChE,OAAO,OAAOC;QACZ,MAAMC,aAAa,UAAML,kLAAAA,EAAU;YACjCM,IAAIJ,IAAII,EAAE;YACVC,MAAMH;YACNI,OAAOL,IAAIM,OAAO,CAACC,MAAM,CAACC,IAAI,CAACH,KAAK;YACpCI,oBAAoB;YACpBT;QACF;QAEA,IAAI,CAACE,YAAY;YACf,OAAOH;QACT;QAEA,sMAAsM;QACtM,IAAK,MAAMW,OAAOR,WAAY;YAC5B,IAAIQ,QAAQ,OAAO;gBACjB,kGAAkG;gBAClG,mFAAmF;gBACnF,KAAK,MAAMC,YAAYT,YAAYU,OAAO,EAAE,CAAE;oBAC5C,IAAI,CAACb,IAAIa,GAAG,IAAI,CAACb,IAAIa,GAAG,CAACC,IAAI,CAAC,CAACC,QAAUA,MAAMX,EAAE,KAAKQ,SAASR,EAAE,GAAG;;wBAChEJ,CAAAA,IAAIa,GAAG,KAAK,EAAC,EAAGG,IAAI,CAACJ;oBACzB;gBACF;YACF,OAAO;;gBACHZ,GAAW,CAACW,IAAI,GAAGR,UAAU,CAACQ,IAAiB;YACnD;QACF;QAEA,IAAKR,YAAYc,OAAmCC,WAAW;YAC7D,MAAM,IAAIrB,mLAAAA,CAAkB,CAAC,IAAI,EAAEG,IAAII,EAAE,CAAC,cAAc,CAAC;QAC3D;QAEA,OAAOD;IACT;AACF"}},
    {"offset": {"line": 4184, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/queues/operations/runJobs/runJob/importHandlerPath.ts"],"sourcesContent":["import type { TaskConfig, TaskHandler, TaskType } from '../../../config/types/taskTypes.js'\n\nimport { dynamicImport } from '../../../../utilities/dynamicImport.js'\n\n/**\n * Imports a handler function from a given path.\n */\nexport async function importHandlerPath<T>(path: string): Promise<T> {\n  let runner!: T\n  const [runnerPath, runnerImportName] = path.split('#')\n\n  let runnerModule: Record<string, unknown>\n  try {\n    runnerModule = await dynamicImport<Record<string, unknown>>(runnerPath!)\n  } catch (e) {\n    throw new Error(\n      `Error importing job queue handler module for path ${path}. This is an advanced feature that may require a sophisticated build pipeline, especially when using it in production or within Next.js, e.g. by calling opening the /api/payload-jobs/run endpoint. You will have to transpile the handler files separately and ensure they are available in the same location when the job is run. If you're using an endpoint to execute your jobs, it's recommended to define your handlers as functions directly in your Payload Config, or use import paths handlers outside of Next.js. Import Error: \\n${e instanceof Error ? e.message : 'Unknown error'}`,\n    )\n  }\n\n  // If the path has indicated an #exportName, try to get it\n  if (runnerImportName && runnerModule[runnerImportName]) {\n    runner = runnerModule[runnerImportName] as T\n  }\n\n  // If there is a default export, use it\n  if (!runner && runnerModule.default) {\n    runner = runnerModule.default as T\n  }\n\n  // Finally, use whatever was imported\n  if (!runner) {\n    runner = runnerModule as T\n  }\n\n  return runner\n}\n\n/**\n * The `handler` property of a task config can either be a function or a path to a module that exports a function.\n * This function resolves the handler to a function, either by importing it from the path or returning the function directly\n * if it is already a function.\n */\nexport async function getTaskHandlerFromConfig(taskConfig?: TaskConfig) {\n  if (!taskConfig) {\n    throw new Error('Task config is required to get the task handler')\n  }\n  if (typeof taskConfig.handler === 'function') {\n    return taskConfig.handler\n  } else {\n    return await importHandlerPath<TaskHandler<TaskType>>(taskConfig.handler)\n  }\n}\n"],"names":["dynamicImport","importHandlerPath","path","runner","runnerPath","runnerImportName","split","runnerModule","e","Error","message","default","getTaskHandlerFromConfig","taskConfig","handler"],"mappings":";;;;;;AAEA,SAASA,aAAa,QAAQ,yCAAwC;;AAK/D,eAAeC,kBAAqBC,IAAY;IACrD,IAAIC;IACJ,MAAM,CAACC,YAAYC,iBAAiB,GAAGH,KAAKI,KAAK,CAAC;IAElD,IAAIC;IACJ,IAAI;QACFA,eAAe,UAAMP,gLAAAA,EAAuCI;IAC9D,EAAE,OAAOI,GAAG;QACV,MAAM,IAAIC,MACR,CAAC,kDAAkD,EAAEP,KAAK,+gBAA+gB,EAAEM,aAAaC,QAAQD,EAAEE,OAAO,GAAG,iBAAiB;IAEjoB;IAEA,0DAA0D;IAC1D,IAAIL,oBAAoBE,YAAY,CAACF,iBAAiB,EAAE;QACtDF,SAASI,YAAY,CAACF,iBAAiB;IACzC;IAEA,uCAAuC;IACvC,IAAI,CAACF,UAAUI,aAAaI,OAAO,EAAE;QACnCR,SAASI,aAAaI,OAAO;IAC/B;IAEA,qCAAqC;IACrC,IAAI,CAACR,QAAQ;QACXA,SAASI;IACX;IAEA,OAAOJ;AACT;AAOO,eAAeS,yBAAyBC,UAAuB;IACpE,IAAI,CAACA,YAAY;QACf,MAAM,IAAIJ,MAAM;IAClB;IACA,IAAI,OAAOI,WAAWC,OAAO,KAAK,YAAY;QAC5C,OAAOD,WAAWC,OAAO;IAC3B,OAAO;QACL,OAAO,MAAMb,kBAAyCY,WAAWC,OAAO;IAC1E;AACF"}},
    {"offset": {"line": 4229, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/queues/errors/calculateBackoffWaitUntil.ts"],"sourcesContent":["import type { RetryConfig } from '../config/types/taskTypes.js'\n\nimport { getCurrentDate } from '../utilities/getCurrentDate.js'\n\nexport function calculateBackoffWaitUntil({\n  retriesConfig,\n  totalTried,\n}: {\n  retriesConfig: number | RetryConfig\n  totalTried: number\n}): Date {\n  let waitUntil: Date = getCurrentDate()\n  if (typeof retriesConfig === 'object') {\n    if (retriesConfig.backoff) {\n      if (retriesConfig.backoff.type === 'fixed') {\n        waitUntil = retriesConfig.backoff.delay\n          ? new Date(getCurrentDate().getTime() + retriesConfig.backoff.delay)\n          : getCurrentDate()\n      } else if (retriesConfig.backoff.type === 'exponential') {\n        // 2 ^ (attempts - 1) * delay (current attempt is not included in totalTried, thus no need for -1)\n        const delay = retriesConfig.backoff.delay ? retriesConfig.backoff.delay : 0\n        waitUntil = new Date(getCurrentDate().getTime() + Math.pow(2, totalTried) * delay)\n      }\n    }\n  }\n\n  /*\n  const differenceInMSBetweenNowAndWaitUntil = waitUntil.getTime() - getCurrentDate().getTime()\n\n  const differenceInSBetweenNowAndWaitUntil = differenceInMSBetweenNowAndWaitUntil / 1000\n  console.log('Calculated backoff', {\n    differenceInMSBetweenNowAndWaitUntil,\n    differenceInSBetweenNowAndWaitUntil,\n    retriesConfig,\n    totalTried,\n  })*/\n  return waitUntil\n}\n"],"names":["getCurrentDate","calculateBackoffWaitUntil","retriesConfig","totalTried","waitUntil","backoff","type","delay","Date","getTime","Math","pow"],"mappings":";;;;AAEA,SAASA,cAAc,QAAQ,iCAAgC;;AAExD,SAASC,0BAA0B,EACxCC,aAAa,EACbC,UAAU,EAIX;IACC,IAAIC,gBAAkBJ,4LAAAA;IACtB,IAAI,OAAOE,kBAAkB,UAAU;QACrC,IAAIA,cAAcG,OAAO,EAAE;YACzB,IAAIH,cAAcG,OAAO,CAACC,IAAI,KAAK,SAAS;gBAC1CF,YAAYF,cAAcG,OAAO,CAACE,KAAK,GACnC,IAAIC,SAAKR,4LAAAA,IAAiBS,OAAO,KAAKP,cAAcG,OAAO,CAACE,KAAK,QACjEP,4LAAAA;YACN,OAAO,IAAIE,cAAcG,OAAO,CAACC,IAAI,KAAK,eAAe;gBACvD,kGAAkG;gBAClG,MAAMC,QAAQL,cAAcG,OAAO,CAACE,KAAK,GAAGL,cAAcG,OAAO,CAACE,KAAK,GAAG;gBAC1EH,YAAY,IAAII,SAAKR,4LAAAA,IAAiBS,OAAO,KAAKC,KAAKC,GAAG,CAAC,GAAGR,cAAcI;YAC9E;QACF;IACF;IAEA;;;;;;;;;IASE,GACF,OAAOH;AACT"}},
    {"offset": {"line": 4263, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/queues/errors/getWorkflowRetryBehavior.ts"],"sourcesContent":["import type { Job } from '../../index.js'\nimport type { RetryConfig } from '../config/types/taskTypes.js'\n\nimport { calculateBackoffWaitUntil } from './calculateBackoffWaitUntil.js'\n\n/**\n * Assuming there is no task that has already reached max retries,\n * this function determines if the workflow should retry the job\n * and if so, when it should retry.\n */\nexport function getWorkflowRetryBehavior({\n  job,\n  retriesConfig,\n}: {\n  job: Job\n  retriesConfig?: number | RetryConfig\n}):\n  | {\n      hasFinalError: false\n      maxWorkflowRetries?: number\n      waitUntil?: Date\n    }\n  | {\n      hasFinalError: true\n      maxWorkflowRetries?: number\n      waitUntil?: Date\n    } {\n  const maxWorkflowRetries = (\n    typeof retriesConfig === 'object' ? retriesConfig.attempts : retriesConfig\n  )!\n\n  if (\n    maxWorkflowRetries !== undefined &&\n    maxWorkflowRetries !== null &&\n    job.totalTried >= maxWorkflowRetries\n  ) {\n    return {\n      hasFinalError: true,\n      maxWorkflowRetries,\n    }\n  }\n\n  if (!retriesConfig) {\n    // No retries provided => assuming no task reached max retries, we can retry\n    return {\n      hasFinalError: false,\n      maxWorkflowRetries: undefined,\n      waitUntil: undefined,\n    }\n  }\n\n  // Job will retry. Let's determine when!\n  const waitUntil: Date = calculateBackoffWaitUntil({\n    retriesConfig,\n    totalTried: job.totalTried ?? 0,\n  })\n\n  return {\n    hasFinalError: false,\n    maxWorkflowRetries,\n    waitUntil,\n  }\n}\n"],"names":["calculateBackoffWaitUntil","getWorkflowRetryBehavior","job","retriesConfig","maxWorkflowRetries","attempts","undefined","totalTried","hasFinalError","waitUntil"],"mappings":";;;;AAGA,SAASA,yBAAyB,QAAQ,iCAAgC;;AAOnE,SAASC,yBAAyB,EACvCC,GAAG,EACHC,aAAa,EAId;IAWC,MAAMC,qBACJ,OAAOD,kBAAkB,WAAWA,cAAcE,QAAQ,GAAGF;IAG/D,IACEC,uBAAuBE,aACvBF,uBAAuB,QACvBF,IAAIK,UAAU,IAAIH,oBAClB;QACA,OAAO;YACLI,eAAe;YACfJ;QACF;IACF;IAEA,IAAI,CAACD,eAAe;QAClB,4EAA4E;QAC5E,OAAO;YACLK,eAAe;YACfJ,oBAAoBE;YACpBG,WAAWH;QACb;IACF;IAEA,wCAAwC;IACxC,MAAMG,gBAAkBT,+MAAAA,EAA0B;QAChDG;QACAI,YAAYL,IAAIK,UAAU,IAAI;IAChC;IAEA,OAAO;QACLC,eAAe;QACfJ;QACAK;IACF;AACF"}},
    {"offset": {"line": 4300, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/queues/errors/handleTaskError.ts"],"sourcesContent":["import ObjectIdImport from 'bson-objectid'\n\nimport type { JobLog, PayloadRequest } from '../../index.js'\nimport type { RunJobsSilent } from '../localAPI.js'\nimport type { UpdateJobFunction } from '../operations/runJobs/runJob/getUpdateJobFunction.js'\nimport type { TaskError } from './index.js'\n\nimport { getCurrentDate } from '../utilities/getCurrentDate.js'\nimport { calculateBackoffWaitUntil } from './calculateBackoffWaitUntil.js'\nimport { getWorkflowRetryBehavior } from './getWorkflowRetryBehavior.js'\n\nconst ObjectId = 'default' in ObjectIdImport ? ObjectIdImport.default : ObjectIdImport\n\nexport async function handleTaskError({\n  error,\n  req,\n  silent = false,\n  updateJob,\n}: {\n  error: TaskError\n  req: PayloadRequest\n  /**\n   * If set to true, the job system will not log any output to the console (for both info and error logs).\n   * Can be an option for more granular control over logging.\n   *\n   * This will not automatically affect user-configured logs (e.g. if you call `console.log` or `payload.logger.info` in your job code).\n   *\n   * @default false\n   */\n  silent?: RunJobsSilent\n  updateJob: UpdateJobFunction\n}): Promise<{\n  hasFinalError: boolean\n}> {\n  const {\n    executedAt,\n    input,\n    job,\n    output,\n    parent,\n    retriesConfig,\n    taskConfig,\n    taskID,\n    taskSlug,\n    taskStatus,\n    workflowConfig,\n  } = error.args\n\n  if (taskConfig?.onFail) {\n    await taskConfig.onFail({\n      input,\n      job,\n      req,\n      taskStatus,\n    })\n  }\n\n  const errorJSON = {\n    name: error.name,\n    cancelled: Boolean('cancelled' in error && error.cancelled),\n    message: error.message,\n    stack: error.stack,\n  }\n\n  const currentDate = getCurrentDate()\n\n  if (job.waitUntil) {\n    // Check if waitUntil is in the past\n    const waitUntil = new Date(job.waitUntil)\n    if (waitUntil < currentDate) {\n      // Outdated waitUntil, remove it\n      delete job.waitUntil\n    }\n  }\n\n  let maxRetries: number = 0\n\n  if (retriesConfig?.attempts === undefined || retriesConfig?.attempts === null) {\n    // Inherit retries from workflow config, if they are undefined and the workflow config has retries configured\n    if (workflowConfig.retries !== undefined && workflowConfig.retries !== null) {\n      maxRetries =\n        typeof workflowConfig.retries === 'object'\n          ? typeof workflowConfig.retries.attempts === 'number'\n            ? workflowConfig.retries.attempts\n            : 0\n          : workflowConfig.retries\n    } else {\n      maxRetries = 0\n    }\n  } else {\n    maxRetries = retriesConfig.attempts\n  }\n\n  const taskLogToPush: JobLog = {\n    id: new ObjectId().toHexString(),\n    completedAt: currentDate.toISOString(),\n    error: errorJSON,\n    executedAt: executedAt.toISOString(),\n    input,\n    output: output ?? {},\n    parent: req.payload.config.jobs.addParentToTaskLog ? parent : undefined,\n    state: 'failed',\n    taskID,\n    taskSlug,\n  }\n\n  if (!taskStatus?.complete && (taskStatus?.totalTried ?? 0) >= maxRetries) {\n    /**\n     * Task reached max retries => workflow will not retry\n     */\n\n    await updateJob({\n      error: errorJSON,\n      hasError: true,\n      log: {\n        $push: taskLogToPush,\n      } as any,\n      processing: false,\n      totalTried: (job.totalTried ?? 0) + 1,\n      waitUntil: job.waitUntil,\n    })\n\n    if (!silent || (typeof silent === 'object' && !silent.error)) {\n      req.payload.logger.error({\n        err: error,\n        job,\n        msg: `Error running task ${taskID}. Attempt ${job.totalTried} - max retries reached`,\n        taskSlug,\n      })\n    }\n    return {\n      hasFinalError: true,\n    }\n  }\n\n  /**\n   * Task can retry:\n   * - If workflow can retry, allow it to retry\n   * - If workflow reached max retries, do not retry and set final error\n   */\n\n  // First set task waitUntil - if the workflow waitUntil is later, it will be updated later\n  const taskWaitUntil: Date = calculateBackoffWaitUntil({\n    retriesConfig,\n    totalTried: taskStatus?.totalTried ?? 0,\n  })\n\n  // Update job's waitUntil only if this waitUntil is later than the current one\n  if (!job.waitUntil || taskWaitUntil > new Date(job.waitUntil)) {\n    job.waitUntil = taskWaitUntil.toISOString()\n  }\n\n  const { hasFinalError, maxWorkflowRetries, waitUntil } = getWorkflowRetryBehavior({\n    job,\n    retriesConfig: workflowConfig.retries,\n  })\n\n  if (!silent || (typeof silent === 'object' && !silent.error)) {\n    req.payload.logger.error({\n      err: error,\n      job,\n      msg: `Error running task ${taskID}. Attempt ${job.totalTried + 1}${maxWorkflowRetries !== undefined ? '/' + (maxWorkflowRetries + 1) : ''}`,\n      taskSlug,\n    })\n  }\n\n  // Update job's waitUntil only if this waitUntil is later than the current one\n  if (waitUntil && (!job.waitUntil || waitUntil > new Date(job.waitUntil))) {\n    job.waitUntil = waitUntil.toISOString()\n  }\n\n  // Tasks update the job if they error - but in case there is an unhandled error (e.g. in the workflow itself, not in a task)\n  // we need to ensure the job is updated to reflect the error\n  await updateJob({\n    error: hasFinalError ? errorJSON : undefined,\n    hasError: hasFinalError, // If reached max retries => final error. If hasError is true this job will not be retried\n    log: {\n      $push: taskLogToPush,\n    } as any,\n    processing: false,\n    totalTried: (job.totalTried ?? 0) + 1,\n    waitUntil: job.waitUntil,\n  })\n\n  return {\n    hasFinalError,\n  }\n}\n"],"names":["ObjectIdImport","getCurrentDate","calculateBackoffWaitUntil","getWorkflowRetryBehavior","ObjectId","default","handleTaskError","error","req","silent","updateJob","executedAt","input","job","output","parent","retriesConfig","taskConfig","taskID","taskSlug","taskStatus","workflowConfig","args","onFail","errorJSON","name","cancelled","Boolean","message","stack","currentDate","waitUntil","Date","maxRetries","attempts","undefined","retries","taskLogToPush","id","toHexString","completedAt","toISOString","payload","config","jobs","addParentToTaskLog","state","complete","totalTried","hasError","log","$push","processing","logger","err","msg","hasFinalError","taskWaitUntil","maxWorkflowRetries"],"mappings":"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"}},
    {"offset": {"line": 4435, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/queues/errors/handleWorkflowError.ts"],"sourcesContent":["import type { PayloadRequest } from '../../index.js'\nimport type { RunJobsSilent } from '../localAPI.js'\nimport type { UpdateJobFunction } from '../operations/runJobs/runJob/getUpdateJobFunction.js'\nimport type { WorkflowError } from './index.js'\n\nimport { getCurrentDate } from '../utilities/getCurrentDate.js'\nimport { getWorkflowRetryBehavior } from './getWorkflowRetryBehavior.js'\n\n/**\n * This is called if a workflow catches an error. It determines if it's a final error\n * or not and handles logging.\n * A Workflow error = error that happens anywhere in between running tasks.\n *\n * This function assumes that the error is not a TaskError, but a WorkflowError. If a task errors,\n * only a TaskError should be thrown, not a WorkflowError.\n */\nexport async function handleWorkflowError({\n  error,\n  req,\n  silent = false,\n  updateJob,\n}: {\n  error: WorkflowError\n  req: PayloadRequest\n  /**\n   * If set to true, the job system will not log any output to the console (for both info and error logs).\n   * Can be an option for more granular control over logging.\n   *\n   * This will not automatically affect user-configured logs (e.g. if you call `console.log` or `payload.logger.info` in your job code).\n   *\n   * @default false\n   */\n  silent?: RunJobsSilent\n  updateJob: UpdateJobFunction\n}): Promise<{\n  hasFinalError: boolean\n}> {\n  const { job, workflowConfig } = error.args\n\n  const errorJSON = {\n    name: error.name,\n    cancelled: Boolean('cancelled' in error && error.cancelled),\n    message: error.message,\n    stack: error.stack,\n  }\n\n  const { hasFinalError, maxWorkflowRetries, waitUntil } = getWorkflowRetryBehavior({\n    job,\n    retriesConfig: workflowConfig.retries!,\n  })\n\n  if (!hasFinalError) {\n    if (job.waitUntil) {\n      // Check if waitUntil is in the past\n      const waitUntil = new Date(job.waitUntil)\n      if (waitUntil < getCurrentDate()) {\n        // Outdated waitUntil, remove it\n        delete job.waitUntil\n      }\n    }\n\n    // Update job's waitUntil only if this waitUntil is later than the current one\n    if (waitUntil && (!job.waitUntil || waitUntil > new Date(job.waitUntil))) {\n      job.waitUntil = waitUntil.toISOString()\n    }\n  }\n\n  const jobLabel = job.workflowSlug || `Task: ${job.taskSlug}`\n\n  if (!silent || (typeof silent === 'object' && !silent.error)) {\n    req.payload.logger.error({\n      err: error,\n      msg: `Error running job ${jobLabel} id: ${job.id} attempt ${job.totalTried + 1}${maxWorkflowRetries !== undefined ? '/' + (maxWorkflowRetries + 1) : ''}`,\n    })\n  }\n\n  // Tasks update the job if they error - but in case there is an unhandled error (e.g. in the workflow itself, not in a task)\n  // we need to ensure the job is updated to reflect the error\n  await updateJob({\n    error: errorJSON,\n    hasError: hasFinalError, // If reached max retries => final error. If hasError is true this job will not be retried\n    processing: false,\n    totalTried: (job.totalTried ?? 0) + 1,\n    waitUntil: job.waitUntil,\n  })\n\n  return {\n    hasFinalError,\n  }\n}\n"],"names":["getCurrentDate","getWorkflowRetryBehavior","handleWorkflowError","error","req","silent","updateJob","job","workflowConfig","args","errorJSON","name","cancelled","Boolean","message","stack","hasFinalError","maxWorkflowRetries","waitUntil","retriesConfig","retries","Date","toISOString","jobLabel","workflowSlug","taskSlug","payload","logger","err","msg","id","totalTried","undefined","hasError","processing"],"mappings":";;;;AAKA,SAASA,cAAc,QAAQ,iCAAgC;AAC/D,SAASC,wBAAwB,QAAQ,gCAA+B;;;AAUjE,eAAeC,oBAAoB,EACxCC,KAAK,EACLC,GAAG,EACHC,SAAS,KAAK,EACdC,SAAS,EAcV;IAGC,MAAM,EAAEC,GAAG,EAAEC,cAAc,EAAE,GAAGL,MAAMM,IAAI;IAE1C,MAAMC,YAAY;QAChBC,MAAMR,MAAMQ,IAAI;QAChBC,WAAWC,QAAQ,eAAeV,SAASA,MAAMS,SAAS;QAC1DE,SAASX,MAAMW,OAAO;QACtBC,OAAOZ,MAAMY,KAAK;IACpB;IAEA,MAAM,EAAEC,aAAa,EAAEC,kBAAkB,EAAEC,SAAS,EAAE,OAAGjB,6MAAAA,EAAyB;QAChFM;QACAY,eAAeX,eAAeY,OAAO;IACvC;IAEA,IAAI,CAACJ,eAAe;QAClB,IAAIT,IAAIW,SAAS,EAAE;YACjB,oCAAoC;YACpC,MAAMA,YAAY,IAAIG,KAAKd,IAAIW,SAAS;YACxC,IAAIA,gBAAYlB,4LAAAA,KAAkB;gBAChC,gCAAgC;gBAChC,OAAOO,IAAIW,SAAS;YACtB;QACF;QAEA,8EAA8E;QAC9E,IAAIA,aAAc,CAAA,CAACX,IAAIW,SAAS,IAAIA,YAAY,IAAIG,KAAKd,IAAIW,SAAS,CAAA,GAAI;YACxEX,IAAIW,SAAS,GAAGA,UAAUI,WAAW;QACvC;IACF;IAEA,MAAMC,WAAWhB,IAAIiB,YAAY,IAAI,CAAC,MAAM,EAAEjB,IAAIkB,QAAQ,EAAE;IAE5D,IAAI,CAACpB,UAAW,OAAOA,WAAW,YAAY,CAACA,OAAOF,KAAK,EAAG;QAC5DC,IAAIsB,OAAO,CAACC,MAAM,CAACxB,KAAK,CAAC;YACvByB,KAAKzB;YACL0B,KAAK,CAAC,kBAAkB,EAAEN,SAAS,KAAK,EAAEhB,IAAIuB,EAAE,CAAC,SAAS,EAAEvB,IAAIwB,UAAU,GAAG,IAAId,uBAAuBe,YAAY,MAAOf,CAAAA,qBAAqB,CAAA,IAAK,IAAI;QAC3J;IACF;IAEA,4HAA4H;IAC5H,4DAA4D;IAC5D,MAAMX,UAAU;QACdH,OAAOO;QACPuB,UAAUjB;QACVkB,YAAY;QACZH,YAAaxB,CAAAA,IAAIwB,UAAU,IAAI,CAAA,IAAK;QACpCb,WAAWX,IAAIW,SAAS;IAC1B;IAEA,OAAO;QACLF;IACF;AACF"}},
    {"offset": {"line": 4493, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/queues/operations/runJobs/runJob/getRunTaskFunction.ts"],"sourcesContent":["import ObjectIdImport from 'bson-objectid'\n\nimport type { Job } from '../../../../index.js'\nimport type { JsonObject, PayloadRequest } from '../../../../types/index.js'\nimport type {\n  RetryConfig,\n  RunInlineTaskFunction,\n  RunTaskFunction,\n  RunTaskFunctions,\n  TaskConfig,\n  TaskHandler,\n  TaskHandlerResult,\n  TaskType,\n} from '../../../config/types/taskTypes.js'\nimport type {\n  JobLog,\n  SingleTaskStatus,\n  WorkflowConfig,\n  WorkflowTypes,\n} from '../../../config/types/workflowTypes.js'\nimport type { UpdateJobFunction } from './getUpdateJobFunction.js'\n\nimport { JobCancelledError, TaskError } from '../../../errors/index.js'\nimport { getCurrentDate } from '../../../utilities/getCurrentDate.js'\nimport { getTaskHandlerFromConfig } from './importHandlerPath.js'\n\nconst ObjectId = 'default' in ObjectIdImport ? ObjectIdImport.default : ObjectIdImport\n\nexport type TaskParent = {\n  taskID: string\n  taskSlug: string\n}\n\nexport const getRunTaskFunction = <TIsInline extends boolean>(\n  job: Job,\n  workflowConfig: WorkflowConfig,\n  req: PayloadRequest,\n  isInline: TIsInline,\n  updateJob: UpdateJobFunction,\n  parent?: TaskParent,\n): TIsInline extends true ? RunInlineTaskFunction : RunTaskFunctions => {\n  const jobConfig = req.payload.config.jobs\n\n  const runTask: <TTaskSlug extends string>(\n    taskSlug: TTaskSlug,\n  ) => TTaskSlug extends 'inline' ? RunInlineTaskFunction : RunTaskFunction<TTaskSlug> = (\n    taskSlug,\n  ) =>\n    (async (\n      taskID: Parameters<RunInlineTaskFunction>[0],\n      {\n        input,\n        retries,\n        // Only available for inline tasks:\n        task,\n      }: Parameters<RunInlineTaskFunction>[1] & Parameters<RunTaskFunction<string>>[1],\n    ) => {\n      const executedAt = getCurrentDate()\n\n      let taskConfig: TaskConfig | undefined\n      if (!isInline) {\n        taskConfig = (jobConfig.tasks?.length &&\n          jobConfig.tasks.find((t) => t.slug === taskSlug)) as TaskConfig<string>\n\n        if (!taskConfig) {\n          throw new Error(`Task ${taskSlug} not found in workflow ${job.workflowSlug}`)\n        }\n      }\n\n      const retriesConfigFromPropsNormalized =\n        retries == undefined || retries == null\n          ? {}\n          : typeof retries === 'number'\n            ? { attempts: retries }\n            : retries\n      const retriesConfigFromTaskConfigNormalized = taskConfig\n        ? typeof taskConfig.retries === 'number'\n          ? { attempts: taskConfig.retries }\n          : taskConfig.retries\n        : {}\n\n      const finalRetriesConfig: RetryConfig = {\n        ...retriesConfigFromTaskConfigNormalized,\n        ...retriesConfigFromPropsNormalized, // Retry config from props takes precedence\n      }\n\n      const taskStatus: null | SingleTaskStatus<string> = job?.taskStatus?.[taskSlug]\n        ? job.taskStatus[taskSlug][taskID]!\n        : null\n\n      // Handle restoration of task if it succeeded in a previous run\n      if (taskStatus && taskStatus.complete === true) {\n        let shouldRestore = true\n        if (finalRetriesConfig?.shouldRestore === false) {\n          shouldRestore = false\n        } else if (typeof finalRetriesConfig?.shouldRestore === 'function') {\n          shouldRestore = await finalRetriesConfig.shouldRestore({\n            input,\n            job,\n            req,\n            taskStatus,\n          })\n        }\n        if (shouldRestore) {\n          return taskStatus.output\n        }\n      }\n\n      const runner = isInline\n        ? (task as TaskHandler<TaskType>)\n        : await getTaskHandlerFromConfig(taskConfig)\n\n      if (!runner || typeof runner !== 'function') {\n        throw new TaskError({\n          executedAt,\n          input,\n          job,\n          message: isInline\n            ? `Inline task with ID ${taskID} does not have a valid handler.`\n            : `Task with slug ${taskSlug} in workflow ${job.workflowSlug} does not have a valid handler.`,\n          parent,\n          retriesConfig: finalRetriesConfig,\n          taskConfig,\n          taskID,\n          taskSlug,\n          taskStatus,\n          workflowConfig,\n        })\n      }\n\n      let taskHandlerResult: TaskHandlerResult<string>\n      let output: JsonObject | undefined = {}\n\n      try {\n        taskHandlerResult = await runner({\n          inlineTask: getRunTaskFunction(job, workflowConfig, req, true, updateJob, {\n            taskID,\n            taskSlug,\n          }),\n          input,\n          job: job as unknown as Job<WorkflowTypes>,\n          req,\n          tasks: getRunTaskFunction(job, workflowConfig, req, false, updateJob, {\n            taskID,\n            taskSlug,\n          }),\n        })\n      } catch (err: any) {\n        if (err instanceof JobCancelledError) {\n          // Re-throw JobCancelledError to be handled by the top-level error handler\n          throw err\n        }\n        throw new TaskError({\n          executedAt,\n          input: input!,\n          job,\n          message: err.message || 'Task handler threw an error',\n          output,\n          parent,\n          retriesConfig: finalRetriesConfig,\n          taskConfig,\n          taskID,\n          taskSlug,\n          taskStatus,\n          workflowConfig,\n        })\n      }\n\n      if (taskHandlerResult.state === 'failed') {\n        throw new TaskError({\n          executedAt,\n          input: input!,\n          job,\n          message: taskHandlerResult.errorMessage ?? 'Task handler returned a failed state',\n          output,\n          parent,\n          retriesConfig: finalRetriesConfig,\n          taskConfig,\n          taskID,\n          taskSlug,\n          taskStatus,\n          workflowConfig,\n        })\n      } else {\n        output = taskHandlerResult.output\n      }\n\n      if (taskConfig?.onSuccess) {\n        await taskConfig.onSuccess({\n          input,\n          job,\n          req,\n          taskStatus,\n        })\n      }\n\n      const newLogItem: JobLog = {\n        id: new ObjectId().toHexString(),\n        completedAt: getCurrentDate().toISOString(),\n        executedAt: executedAt.toISOString(),\n        input,\n        output,\n        parent: jobConfig.addParentToTaskLog ? parent : undefined,\n        state: 'succeeded',\n        taskID,\n        taskSlug,\n      }\n\n      await updateJob({\n        log: {\n          $push: newLogItem,\n        } as any,\n        // Set to null to skip main row update on postgres. 2 => 1 db round trips\n        updatedAt: null as any,\n      })\n\n      return output\n    }) as any\n\n  if (isInline) {\n    return runTask('inline') as TIsInline extends true ? RunInlineTaskFunction : RunTaskFunctions\n  } else {\n    const tasks: RunTaskFunctions = {}\n    for (const task of jobConfig.tasks ?? []) {\n      tasks[task.slug] = runTask(task.slug) as RunTaskFunction<string>\n    }\n    return tasks as TIsInline extends true ? RunInlineTaskFunction : RunTaskFunctions\n  }\n}\n"],"names":["ObjectIdImport","JobCancelledError","TaskError","getCurrentDate","getTaskHandlerFromConfig","ObjectId","default","getRunTaskFunction","job","workflowConfig","req","isInline","updateJob","parent","jobConfig","payload","config","jobs","runTask","taskSlug","taskID","input","retries","task","executedAt","taskConfig","tasks","length","find","t","slug","Error","workflowSlug","retriesConfigFromPropsNormalized","undefined","attempts","retriesConfigFromTaskConfigNormalized","finalRetriesConfig","taskStatus","complete","shouldRestore","output","runner","message","retriesConfig","taskHandlerResult","inlineTask","err","state","errorMessage","onSuccess","newLogItem","id","toHexString","completedAt","toISOString","addParentToTaskLog","log","$push","updatedAt"],"mappings":"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"}},
    {"offset": {"line": 4657, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/queues/operations/runJobs/runJob/index.ts"],"sourcesContent":["import type { Job } from '../../../../index.js'\nimport type { PayloadRequest } from '../../../../types/index.js'\nimport type { WorkflowConfig, WorkflowHandler } from '../../../config/types/workflowTypes.js'\nimport type { RunJobsSilent } from '../../../localAPI.js'\nimport type { UpdateJobFunction } from './getUpdateJobFunction.js'\n\nimport { handleTaskError } from '../../../errors/handleTaskError.js'\nimport { handleWorkflowError } from '../../../errors/handleWorkflowError.js'\nimport { JobCancelledError, TaskError, WorkflowError } from '../../../errors/index.js'\nimport { getCurrentDate } from '../../../utilities/getCurrentDate.js'\nimport { getRunTaskFunction } from './getRunTaskFunction.js'\n\ntype Args = {\n  job: Job\n  req: PayloadRequest\n  /**\n   * If set to true, the job system will not log any output to the console (for both info and error logs).\n   * Can be an option for more granular control over logging.\n   *\n   * This will not automatically affect user-configured logs (e.g. if you call `console.log` or `payload.logger.info` in your job code).\n   *\n   * @default false\n   */\n  silent?: RunJobsSilent\n  updateJob: UpdateJobFunction\n  workflowConfig: WorkflowConfig\n  workflowHandler: WorkflowHandler\n}\n\nexport type JobRunStatus = 'error' | 'error-reached-max-retries' | 'success'\n\nexport type RunJobResult = {\n  status: JobRunStatus\n}\n\nexport const runJob = async ({\n  job,\n  req,\n  silent,\n  updateJob,\n  workflowConfig,\n  workflowHandler,\n}: Args): Promise<RunJobResult> => {\n  // Run the job\n  try {\n    await workflowHandler({\n      inlineTask: getRunTaskFunction(job, workflowConfig, req, true, updateJob),\n      job,\n      req,\n      tasks: getRunTaskFunction(job, workflowConfig, req, false, updateJob),\n    })\n  } catch (error) {\n    if (error instanceof JobCancelledError) {\n      throw error // Job cancellation is handled in a top-level error handler, as higher up code may themselves throw this error\n    }\n    if (error instanceof TaskError) {\n      const { hasFinalError } = await handleTaskError({\n        error,\n        req,\n        silent,\n        updateJob,\n      })\n\n      return {\n        status: hasFinalError ? 'error-reached-max-retries' : 'error',\n      }\n    }\n\n    const { hasFinalError } = await handleWorkflowError({\n      error:\n        error instanceof WorkflowError\n          ? error\n          : new WorkflowError({\n              job,\n              message:\n                typeof error === 'object' && error && 'message' in error\n                  ? (error.message as string)\n                  : 'An unhandled error occurred',\n              workflowConfig,\n            }),\n      req,\n      silent,\n      updateJob,\n    })\n\n    return {\n      status: hasFinalError ? 'error-reached-max-retries' : 'error',\n    }\n  }\n\n  // Workflow has completed successfully\n  // Do not update the job log here, as that would result in unnecessary db calls when using postgres.\n  // Solely updating simple fields here will result in optimized db calls.\n  // Job log modifications are already updated at the end of the runTask function.\n  await updateJob({\n    completedAt: getCurrentDate().toISOString(),\n    processing: false,\n    totalTried: (job.totalTried ?? 0) + 1,\n  })\n\n  return {\n    status: 'success',\n  }\n}\n"],"names":["handleTaskError","handleWorkflowError","JobCancelledError","TaskError","WorkflowError","getCurrentDate","getRunTaskFunction","runJob","job","req","silent","updateJob","workflowConfig","workflowHandler","inlineTask","tasks","error","hasFinalError","status","message","completedAt","toISOString","processing","totalTried"],"mappings":";;;;AAMA,SAASA,eAAe,QAAQ,qCAAoC;AACpE,SAASC,mBAAmB,QAAQ,yCAAwC;AAC5E,SAASC,iBAAiB,EAAEC,SAAS,EAAEC,aAAa,QAAQ,2BAA0B;AACtF,SAASC,cAAc,QAAQ,uCAAsC;AACrE,SAASC,kBAAkB,QAAQ,0BAAyB;;;;;;AAyBrD,MAAMC,SAAS,OAAO,EAC3BC,GAAG,EACHC,GAAG,EACHC,MAAM,EACNC,SAAS,EACTC,cAAc,EACdC,eAAe,EACV;IACL,cAAc;IACd,IAAI;QACF,MAAMA,gBAAgB;YACpBC,gBAAYR,0NAAAA,EAAmBE,KAAKI,gBAAgBH,KAAK,MAAME;YAC/DH;YACAC;YACAM,WAAOT,0NAAAA,EAAmBE,KAAKI,gBAAgBH,KAAK,OAAOE;QAC7D;IACF,EAAE,OAAOK,OAAO;QACd,IAAIA,iBAAiBd,mLAAAA,EAAmB;YACtC,MAAMc,MAAM,8GAA8G;;QAC5H;QACA,IAAIA,iBAAiBb,2KAAAA,EAAW;YAC9B,MAAM,EAAEc,aAAa,EAAE,GAAG,UAAMjB,2LAAAA,EAAgB;gBAC9CgB;gBACAP;gBACAC;gBACAC;YACF;YAEA,OAAO;gBACLO,QAAQD,gBAAgB,8BAA8B;YACxD;QACF;QAEA,MAAM,EAAEA,aAAa,EAAE,GAAG,UAAMhB,mMAAAA,EAAoB;YAClDe,OACEA,iBAAiBZ,+KAAAA,GACbY,QACA,IAAIZ,+KAAAA,CAAc;gBAChBI;gBACAW,SACE,OAAOH,UAAU,YAAYA,SAAS,aAAaA,QAC9CA,MAAMG,OAAO,GACd;gBACNP;YACF;YACNH;YACAC;YACAC;QACF;QAEA,OAAO;YACLO,QAAQD,gBAAgB,8BAA8B;QACxD;IACF;IAEA,sCAAsC;IACtC,oGAAoG;IACpG,wEAAwE;IACxE,gFAAgF;IAChF,MAAMN,UAAU;QACdS,iBAAaf,4LAAAA,IAAiBgB,WAAW;QACzCC,YAAY;QACZC,YAAaf,CAAAA,IAAIe,UAAU,IAAI,CAAA,IAAK;IACtC;IAEA,OAAO;QACLL,QAAQ;IACV;AACF,EAAC"}},
    {"offset": {"line": 4727, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/queues/operations/runJobs/runJSONJob/index.ts"],"sourcesContent":["import type { Job } from '../../../../index.js'\nimport type { PayloadRequest } from '../../../../types/index.js'\nimport type { WorkflowJSON, WorkflowStep } from '../../../config/types/workflowJSONTypes.js'\nimport type { WorkflowConfig } from '../../../config/types/workflowTypes.js'\nimport type { RunJobsSilent } from '../../../localAPI.js'\nimport type { UpdateJobFunction } from '../runJob/getUpdateJobFunction.js'\nimport type { JobRunStatus } from '../runJob/index.js'\n\nimport { handleWorkflowError } from '../../../errors/handleWorkflowError.js'\nimport { WorkflowError } from '../../../errors/index.js'\nimport { getCurrentDate } from '../../../utilities/getCurrentDate.js'\nimport { getRunTaskFunction } from '../runJob/getRunTaskFunction.js'\n\ntype Args = {\n  job: Job\n  req: PayloadRequest\n  /**\n   * If set to true, the job system will not log any output to the console (for both info and error logs).\n   * Can be an option for more granular control over logging.\n   *\n   * This will not automatically affect user-configured logs (e.g. if you call `console.log` or `payload.logger.info` in your job code).\n   *\n   * @default false\n   */\n  silent?: RunJobsSilent\n  updateJob: UpdateJobFunction\n  workflowConfig: WorkflowConfig\n  workflowHandler: WorkflowJSON\n}\n\nexport type RunJSONJobResult = {\n  status: JobRunStatus\n}\n\nexport const runJSONJob = async ({\n  job,\n  req,\n  silent = false,\n  updateJob,\n  workflowConfig,\n  workflowHandler,\n}: Args): Promise<RunJSONJobResult> => {\n  const stepsToRun: WorkflowStep<string>[] = []\n\n  for (const step of workflowHandler) {\n    if ('task' in step) {\n      if (job?.taskStatus?.[step.task]?.[step.id]?.complete) {\n        continue\n      }\n    } else {\n      if (job?.taskStatus?.['inline']?.[step.id]?.complete) {\n        continue\n      }\n    }\n    if (step.condition && !step.condition({ job })) {\n      continue\n    }\n    stepsToRun.push(step)\n  }\n\n  const tasks = getRunTaskFunction(job, workflowConfig, req, false, updateJob)\n  const inlineTask = getRunTaskFunction(job, workflowConfig, req, true, updateJob)\n\n  // Run the job\n  try {\n    await Promise.all(\n      stepsToRun.map(async (step) => {\n        if ('task' in step) {\n          await tasks[step.task]!(step.id, {\n            input: step.input ? step.input({ job }) : {},\n            retries: step.retries,\n          })\n        } else {\n          await inlineTask(step.id, {\n            retries: step.retries,\n            task: step.inlineTask as any, // TODO: Fix type\n          })\n        }\n      }),\n    )\n  } catch (error) {\n    const { hasFinalError } = await handleWorkflowError({\n      error:\n        error instanceof WorkflowError\n          ? error\n          : new WorkflowError({\n              job,\n              message:\n                typeof error === 'object' && error && 'message' in error\n                  ? (error.message as string)\n                  : 'An unhandled error occurred',\n              workflowConfig,\n            }),\n      silent,\n\n      req,\n      updateJob,\n    })\n\n    return {\n      status: hasFinalError ? 'error-reached-max-retries' : 'error',\n    }\n  }\n\n  // Check if workflow has completed\n  let workflowCompleted = false\n  for (const [slug, map] of Object.entries(job.taskStatus)) {\n    for (const [id, taskStatus] of Object.entries(map)) {\n      if (taskStatus.complete) {\n        const step = workflowHandler.find((step) => {\n          if ('task' in step) {\n            return step.task === slug && step.id === id\n          } else {\n            return step.id === id && slug === 'inline'\n          }\n        })\n        if (step?.completesJob) {\n          workflowCompleted = true\n          break\n        }\n      }\n    }\n  }\n\n  if (workflowCompleted) {\n    await updateJob({\n      completedAt: getCurrentDate().toISOString(),\n      processing: false,\n      totalTried: (job.totalTried ?? 0) + 1,\n    })\n\n    return {\n      status: 'success',\n    }\n  } else {\n    // Retry the job - no need to bump processing or totalTried as this does not count as a retry. A condition of a different task might have just opened up!\n    return await runJSONJob({\n      job,\n      req,\n      updateJob,\n      workflowConfig,\n      workflowHandler,\n    })\n  }\n}\n"],"names":["handleWorkflowError","WorkflowError","getCurrentDate","getRunTaskFunction","runJSONJob","job","req","silent","updateJob","workflowConfig","workflowHandler","stepsToRun","step","taskStatus","task","id","complete","condition","push","tasks","inlineTask","Promise","all","map","input","retries","error","hasFinalError","message","status","workflowCompleted","slug","Object","entries","find","completesJob","completedAt","toISOString","processing","totalTried"],"mappings":"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"}},
    {"offset": {"line": 4835, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/queues/operations/runJobs/index.ts"],"sourcesContent":["import type { Job } from '../../../index.js'\nimport type { PayloadRequest, Sort, Where } from '../../../types/index.js'\nimport type { WorkflowJSON } from '../../config/types/workflowJSONTypes.js'\nimport type { WorkflowConfig, WorkflowHandler } from '../../config/types/workflowTypes.js'\nimport type { RunJobsSilent } from '../../localAPI.js'\nimport type { RunJobResult } from './runJob/index.js'\n\nimport { Forbidden } from '../../../errors/Forbidden.js'\nimport { isolateObjectProperty } from '../../../utilities/isolateObjectProperty.js'\nimport { jobsCollectionSlug } from '../../config/collection.js'\nimport { JobCancelledError } from '../../errors/index.js'\nimport { getCurrentDate } from '../../utilities/getCurrentDate.js'\nimport { updateJob, updateJobs } from '../../utilities/updateJob.js'\nimport { getUpdateJobFunction } from './runJob/getUpdateJobFunction.js'\nimport { importHandlerPath } from './runJob/importHandlerPath.js'\nimport { runJob } from './runJob/index.js'\nimport { runJSONJob } from './runJSONJob/index.js'\n\nexport type RunJobsArgs = {\n  /**\n   * If you want to run jobs from all queues, set this to true.\n   * If you set this to true, the `queue` property will be ignored.\n   *\n   * @default false\n   */\n  allQueues?: boolean\n  /**\n   * ID of the job to run\n   */\n  id?: number | string\n  /**\n   * The maximum number of jobs to run in this invocation\n   *\n   * @default 10\n   */\n  limit?: number\n  overrideAccess?: boolean\n  /**\n   * Adjust the job processing order\n   *\n   * FIFO would equal `createdAt` and LIFO would equal `-createdAt`.\n   *\n   * @default all jobs for all queues will be executed in FIFO order.\n   */\n  processingOrder?: Sort\n  /**\n   * If you want to run jobs from a specific queue, set this to the queue name.\n   *\n   * @default jobs from the `default` queue will be executed.\n   */\n  queue?: string\n  req: PayloadRequest\n  /**\n   * By default, jobs are run in parallel.\n   * If you want to run them in sequence, set this to true.\n   */\n  sequential?: boolean\n  /**\n   * If set to true, the job system will not log any output to the console (for both info and error logs).\n   * Can be an option for more granular control over logging.\n   *\n   * This will not automatically affect user-configured logs (e.g. if you call `console.log` or `payload.logger.info` in your job code).\n   *\n   * @default false\n   */\n  silent?: RunJobsSilent\n  where?: Where\n}\n\nexport type RunJobsResult = {\n  jobStatus?: Record<string, RunJobResult>\n  /**\n   * If this is true, there for sure are no jobs remaining, regardless of the limit\n   */\n  noJobsRemaining?: boolean\n  /**\n   * Out of the jobs that were queried & processed (within the set limit), how many are remaining and retryable?\n   */\n  remainingJobsFromQueried: number\n}\n\nexport const runJobs = async (args: RunJobsArgs): Promise<RunJobsResult> => {\n  const {\n    id,\n    allQueues = false,\n    limit = 10,\n    overrideAccess,\n    processingOrder,\n    queue = 'default',\n    req,\n    req: {\n      payload,\n      payload: {\n        config: { jobs: jobsConfig },\n      },\n    },\n    sequential,\n    silent = false,\n    where: whereFromProps,\n  } = args\n\n  if (!overrideAccess) {\n    /**\n     * By default, jobsConfig.access.run will be `defaultAccess` which is a function that returns `true` if the user is logged in.\n     */\n    const accessFn = jobsConfig?.access?.run ?? (() => true)\n    const hasAccess = await accessFn({ req })\n    if (!hasAccess) {\n      throw new Forbidden(req.t)\n    }\n  }\n  const and: Where[] = [\n    {\n      completedAt: {\n        exists: false,\n      },\n    },\n    {\n      hasError: {\n        not_equals: true,\n      },\n    },\n    {\n      processing: {\n        equals: false,\n      },\n    },\n    {\n      or: [\n        {\n          waitUntil: {\n            exists: false,\n          },\n        },\n        {\n          waitUntil: {\n            less_than: getCurrentDate().toISOString(),\n          },\n        },\n      ],\n    },\n  ]\n\n  if (allQueues !== true) {\n    and.push({\n      queue: {\n        equals: queue ?? 'default',\n      },\n    })\n  }\n\n  if (whereFromProps) {\n    and.push(whereFromProps)\n  }\n\n  // Only enforce concurrency controls if the feature is enabled\n  if (jobsConfig.enableConcurrencyControl) {\n    // Find currently running jobs with concurrency keys to enforce exclusive concurrency\n    // Jobs with the same concurrencyKey should not run in parallel\n    const runningJobsWithConcurrency = await payload.db.find({\n      collection: jobsCollectionSlug,\n      limit: 0,\n      pagination: false,\n      req: { transactionID: undefined },\n      select: {\n        concurrencyKey: true,\n      },\n      where: {\n        and: [{ processing: { equals: true } }, { concurrencyKey: { exists: true } }],\n      },\n    })\n\n    const runningConcurrencyKeys = new Set<string>()\n    if (runningJobsWithConcurrency?.docs) {\n      for (const doc of runningJobsWithConcurrency.docs) {\n        const concurrencyKey = (doc as Job).concurrencyKey\n        if (concurrencyKey) {\n          runningConcurrencyKeys.add(concurrencyKey)\n        }\n      }\n    }\n\n    // Exclude jobs whose concurrencyKey is already running\n    if (runningConcurrencyKeys.size > 0) {\n      and.push({\n        or: [\n          // Jobs without a concurrency key can always run\n          { concurrencyKey: { exists: false } },\n          // Jobs with a concurrency key that is not currently running can run\n          { concurrencyKey: { not_in: [...runningConcurrencyKeys] } },\n        ],\n      })\n    }\n  }\n\n  // Find all jobs and ensure we set job to processing: true as early as possible to reduce the chance of\n  // the same job being picked up by another worker\n  let jobs: Job[] = []\n\n  if (id) {\n    // Only one job to run\n    const job = await updateJob({\n      id,\n      data: {\n        processing: true,\n      },\n      depth: jobsConfig.depth,\n      disableTransaction: true,\n      req,\n      returning: true,\n    })\n    if (job) {\n      jobs = [job]\n    }\n  } else {\n    let defaultProcessingOrder: Sort =\n      payload.collections[jobsCollectionSlug]?.config.defaultSort ?? 'createdAt'\n\n    const processingOrderConfig = jobsConfig.processingOrder\n    if (typeof processingOrderConfig === 'function') {\n      defaultProcessingOrder = await processingOrderConfig(args)\n    } else if (typeof processingOrderConfig === 'object' && !Array.isArray(processingOrderConfig)) {\n      if (\n        !allQueues &&\n        queue &&\n        processingOrderConfig.queues &&\n        processingOrderConfig.queues[queue]\n      ) {\n        defaultProcessingOrder = processingOrderConfig.queues[queue]\n      } else if (processingOrderConfig.default) {\n        defaultProcessingOrder = processingOrderConfig.default\n      }\n    } else if (typeof processingOrderConfig === 'string') {\n      defaultProcessingOrder = processingOrderConfig\n    }\n    const updatedDocs = await updateJobs({\n      data: {\n        processing: true,\n      },\n      depth: jobsConfig.depth,\n      disableTransaction: true,\n      limit,\n      req,\n      returning: true,\n      sort: processingOrder ?? defaultProcessingOrder,\n      where: { and },\n    })\n\n    if (updatedDocs) {\n      jobs = updatedDocs\n    }\n  }\n\n  if (!jobs.length) {\n    return {\n      noJobsRemaining: true,\n      remainingJobsFromQueried: 0,\n    }\n  }\n\n  // Only handle concurrency deduplication if the feature is enabled\n  if (jobsConfig.enableConcurrencyControl) {\n    // Handle the case where multiple jobs with the same concurrencyKey were picked up in the same batch\n    // We should only run one job per concurrencyKey, release the others back to pending\n    const seenConcurrencyKeys = new Set<string>()\n    const jobsToRun: Job[] = []\n    const jobsToRelease: Job[] = []\n\n    for (const job of jobs) {\n      if (job.concurrencyKey) {\n        if (seenConcurrencyKeys.has(job.concurrencyKey)) {\n          // This job has the same concurrencyKey as another job we're already running\n          jobsToRelease.push(job)\n        } else {\n          seenConcurrencyKeys.add(job.concurrencyKey)\n          jobsToRun.push(job)\n        }\n      } else {\n        jobsToRun.push(job)\n      }\n    }\n\n    // Release duplicate concurrencyKey jobs back to pending state\n    if (jobsToRelease.length > 0) {\n      const releaseIds = jobsToRelease.map((job) => job.id)\n      await updateJobs({\n        data: { processing: false },\n        disableTransaction: true,\n        req,\n        returning: false,\n        where: { id: { in: releaseIds } },\n      })\n    }\n\n    // Use only the filtered jobs going forward\n    jobs = jobsToRun\n  }\n\n  if (!jobs.length) {\n    return {\n      noJobsRemaining: false,\n      remainingJobsFromQueried: 0,\n    }\n  }\n\n  /**\n   * Just for logging purposes, we want to know how many jobs are new and how many are existing (= already been tried).\n   * This is only for logs - in the end we still want to run all jobs, regardless of whether they are new or existing.\n   */\n  const { existingJobs, newJobs } = jobs.reduce(\n    (acc, job) => {\n      if (job.totalTried > 0) {\n        acc.existingJobs.push(job)\n      } else {\n        acc.newJobs.push(job)\n      }\n      return acc\n    },\n    { existingJobs: [] as Job[], newJobs: [] as Job[] },\n  )\n\n  if (!silent || (typeof silent === 'object' && !silent.info)) {\n    payload.logger.info({\n      msg: `Running ${jobs.length} jobs.`,\n      new: newJobs?.length,\n      retrying: existingJobs?.length,\n    })\n  }\n\n  const successfullyCompletedJobs: (number | string)[] = []\n\n  const runSingleJob = async (\n    job: Job,\n  ): Promise<{\n    id: number | string\n    result: RunJobResult\n  }> => {\n    if (!job.workflowSlug && !job.taskSlug) {\n      throw new Error('Job must have either a workflowSlug or a taskSlug')\n    }\n    const jobReq = isolateObjectProperty(req, 'transactionID')\n\n    const workflowConfig: WorkflowConfig =\n      job.workflowSlug && jobsConfig.workflows?.length\n        ? jobsConfig.workflows.find(({ slug }) => slug === job.workflowSlug)!\n        : {\n            slug: 'singleTask',\n            handler: async ({ job, tasks }) => {\n              await tasks[job.taskSlug as string]!('1', {\n                input: job.input,\n              })\n            },\n          }\n\n    if (!workflowConfig) {\n      return {\n        id: job.id,\n        result: {\n          status: 'error',\n        },\n      } // Skip jobs with no workflow configuration\n    }\n\n    try {\n      const updateJob = getUpdateJobFunction(job, jobReq)\n\n      // the runner will either be passed to the config\n      // OR it will be a path, which we will need to import via eval to avoid\n      // Next.js compiler dynamic import expression errors\n      let workflowHandler: WorkflowHandler | WorkflowJSON\n      if (\n        typeof workflowConfig.handler === 'function' ||\n        (typeof workflowConfig.handler === 'object' && Array.isArray(workflowConfig.handler))\n      ) {\n        workflowHandler = workflowConfig.handler\n      } else {\n        workflowHandler = await importHandlerPath<typeof workflowHandler>(workflowConfig.handler)\n\n        if (!workflowHandler) {\n          const jobLabel = job.workflowSlug || `Task: ${job.taskSlug}`\n          const errorMessage = `Can't find runner while importing with the path ${workflowConfig.handler} in job type ${jobLabel}.`\n          if (!silent || (typeof silent === 'object' && !silent.error)) {\n            payload.logger.error(errorMessage)\n          }\n\n          await updateJob({\n            error: {\n              error: errorMessage,\n            },\n            hasError: true,\n            processing: false,\n          })\n\n          return {\n            id: job.id,\n            result: {\n              status: 'error-reached-max-retries',\n            },\n          }\n        }\n      }\n\n      if (typeof workflowHandler === 'function') {\n        const result = await runJob({\n          job,\n          req: jobReq,\n          silent,\n          updateJob,\n          workflowConfig,\n          workflowHandler,\n        })\n\n        if (result.status === 'success') {\n          successfullyCompletedJobs.push(job.id)\n        }\n\n        return { id: job.id, result }\n      } else {\n        const result = await runJSONJob({\n          job,\n          req: jobReq,\n          silent,\n          updateJob,\n          workflowConfig,\n          workflowHandler,\n        })\n\n        if (result.status === 'success') {\n          successfullyCompletedJobs.push(job.id)\n        }\n\n        return { id: job.id, result }\n      }\n    } catch (error) {\n      if (error instanceof JobCancelledError) {\n        if (\n          !(job.error as Record<string, unknown> | undefined)?.cancelled ||\n          !job.hasError ||\n          job.processing ||\n          job.completedAt ||\n          job.waitUntil\n        ) {\n          // When using the local API to cancel jobs, the local API will update the job data for us to ensure the job is cancelled.\n          // But when throwing a JobCancelledError within a task or workflow handler, we are responsible for updating the job data ourselves.\n          await updateJob({\n            id: job.id,\n            data: {\n              completedAt: null,\n              error: {\n                cancelled: true,\n                message: error.message,\n              },\n              hasError: true,\n              processing: false,\n              waitUntil: null,\n            },\n            depth: 0,\n            disableTransaction: true,\n            req,\n            returning: false,\n          })\n        }\n\n        return {\n          id: job.id,\n          result: {\n            status: 'error-reached-max-retries',\n          },\n        }\n      }\n      throw error\n    }\n  }\n\n  let resultsArray: { id: number | string; result: RunJobResult }[] = []\n  if (sequential) {\n    for (const job of jobs) {\n      const result = await runSingleJob(job)\n      if (result) {\n        resultsArray.push(result)\n      }\n    }\n  } else {\n    const jobPromises = jobs.map(runSingleJob)\n    resultsArray = (await Promise.all(jobPromises)) as {\n      id: number | string\n      result: RunJobResult\n    }[]\n  }\n\n  if (jobsConfig.deleteJobOnComplete && successfullyCompletedJobs.length) {\n    try {\n      if (jobsConfig.runHooks) {\n        await payload.delete({\n          collection: jobsCollectionSlug,\n          depth: 0, // can be 0 since we're not returning anything\n          disableTransaction: true,\n          where: { id: { in: successfullyCompletedJobs } },\n        })\n      } else {\n        await payload.db.deleteMany({\n          collection: jobsCollectionSlug,\n          where: { id: { in: successfullyCompletedJobs } },\n        })\n      }\n    } catch (err) {\n      if (!silent || (typeof silent === 'object' && !silent.error)) {\n        payload.logger.error({\n          err,\n          msg: `Failed to delete jobs ${successfullyCompletedJobs.join(', ')} on complete`,\n        })\n      }\n    }\n  }\n\n  const resultsObject: RunJobsResult['jobStatus'] = resultsArray.reduce(\n    (acc, cur) => {\n      if (cur !== null) {\n        // Check if there's a valid result to include\n        acc[cur.id] = cur.result\n      }\n      return acc\n    },\n    {} as Record<string, RunJobResult>,\n  )\n\n  let remainingJobsFromQueried = 0\n  for (const jobID in resultsObject) {\n    const jobResult = resultsObject[jobID]\n    if (jobResult?.status === 'error') {\n      remainingJobsFromQueried++ // Can be retried\n    }\n  }\n\n  return {\n    jobStatus: resultsObject,\n    remainingJobsFromQueried,\n  }\n}\n"],"names":["Forbidden","isolateObjectProperty","jobsCollectionSlug","JobCancelledError","getCurrentDate","updateJob","updateJobs","getUpdateJobFunction","importHandlerPath","runJob","runJSONJob","runJobs","args","id","allQueues","limit","overrideAccess","processingOrder","queue","req","payload","config","jobs","jobsConfig","sequential","silent","where","whereFromProps","accessFn","access","run","hasAccess","t","and","completedAt","exists","hasError","not_equals","processing","equals","or","waitUntil","less_than","toISOString","push","enableConcurrencyControl","runningJobsWithConcurrency","db","find","collection","pagination","transactionID","undefined","select","concurrencyKey","runningConcurrencyKeys","Set","docs","doc","add","size","not_in","job","data","depth","disableTransaction","returning","defaultProcessingOrder","collections","defaultSort","processingOrderConfig","Array","isArray","queues","default","updatedDocs","sort","length","noJobsRemaining","remainingJobsFromQueried","seenConcurrencyKeys","jobsToRun","jobsToRelease","has","releaseIds","map","in","existingJobs","newJobs","reduce","acc","totalTried","info","logger","msg","new","retrying","successfullyCompletedJobs","runSingleJob","workflowSlug","taskSlug","Error","jobReq","workflowConfig","workflows","slug","handler","tasks","input","result","status","workflowHandler","jobLabel","errorMessage","error","cancelled","message","resultsArray","jobPromises","Promise","all","deleteJobOnComplete","runHooks","delete","deleteMany","err","join","resultsObject","cur","jobID","jobResult","jobStatus"],"mappings":"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"}},
    {"offset": {"line": 5285, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/queues/endpoints/run.ts"],"sourcesContent":["import type { Endpoint } from '../../config/types.js'\nimport type { SanitizedJobsConfig } from '../config/types/index.js'\n\nimport { runJobs, type RunJobsArgs } from '../operations/runJobs/index.js'\n\n/**\n * /api/payload-jobs/run endpoint\n *\n * This endpoint is GET instead of POST to allow it to be used in a Vercel Cron.\n */\nexport const runJobsEndpoint: Endpoint = {\n  handler: async (req) => {\n    const jobsConfig = req.payload.config.jobs\n\n    if (!configHasJobs(jobsConfig)) {\n      return Response.json(\n        {\n          message: 'No jobs to run.',\n        },\n        { status: 200 },\n      )\n    }\n\n    const accessFn = jobsConfig.access?.run ?? (() => true)\n\n    const hasAccess = await accessFn({ req })\n\n    if (!hasAccess) {\n      return Response.json(\n        {\n          message: req.i18n.t('error:unauthorized'),\n        },\n        { status: 401 },\n      )\n    }\n\n    const {\n      allQueues,\n      disableScheduling: disableSchedulingParam,\n      limit,\n      queue,\n      silent: silentParam,\n    } = req.query as {\n      allQueues?: 'false' | 'true'\n      disableScheduling?: 'false' | 'true'\n      limit?: number\n      queue?: string\n      silent?: string\n    }\n\n    const silent = silentParam === 'true'\n\n    const shouldHandleSchedules = disableSchedulingParam !== 'true'\n\n    const runAllQueues = allQueues && !(typeof allQueues === 'string' && allQueues === 'false')\n\n    if (shouldHandleSchedules && jobsConfig.scheduling) {\n      // If should handle schedules and schedules are defined\n      await req.payload.jobs.handleSchedules({ allQueues: runAllQueues, queue, req })\n    }\n\n    const runJobsArgs: RunJobsArgs = {\n      queue,\n      req,\n      // Access is validated above, so it's safe to override here\n      allQueues: runAllQueues,\n      overrideAccess: true,\n      silent,\n    }\n\n    if (typeof queue === 'string') {\n      runJobsArgs.queue = queue\n    }\n\n    const parsedLimit = Number(limit)\n    if (!isNaN(parsedLimit)) {\n      runJobsArgs.limit = parsedLimit\n    }\n\n    let noJobsRemaining = false\n    let remainingJobsFromQueried = 0\n    try {\n      const result = await runJobs(runJobsArgs)\n      noJobsRemaining = !!result.noJobsRemaining\n      remainingJobsFromQueried = result.remainingJobsFromQueried\n    } catch (err) {\n      req.payload.logger.error({\n        err,\n        msg: 'There was an error running jobs:',\n        queue: runJobsArgs.queue,\n      })\n\n      return Response.json(\n        {\n          message: req.i18n.t('error:unknown'),\n          noJobsRemaining: true,\n          remainingJobsFromQueried,\n        },\n        { status: 500 },\n      )\n    }\n\n    return Response.json(\n      {\n        message: req.i18n.t('general:success'),\n        noJobsRemaining,\n        remainingJobsFromQueried,\n      },\n      { status: 200 },\n    )\n  },\n  method: 'get',\n  path: '/run',\n}\n\nexport const configHasJobs = (jobsConfig: SanitizedJobsConfig): boolean => {\n  return Boolean(jobsConfig.tasks?.length || jobsConfig.workflows?.length)\n}\n"],"names":["runJobs","runJobsEndpoint","handler","req","jobsConfig","payload","config","jobs","configHasJobs","Response","json","message","status","accessFn","access","run","hasAccess","i18n","t","allQueues","disableScheduling","disableSchedulingParam","limit","queue","silent","silentParam","query","shouldHandleSchedules","runAllQueues","scheduling","handleSchedules","runJobsArgs","overrideAccess","parsedLimit","Number","isNaN","noJobsRemaining","remainingJobsFromQueried","result","err","logger","error","msg","method","path","Boolean","tasks","length","workflows"],"mappings":";;;;;;AAGA,SAASA,OAAO,QAA0B,iCAAgC;;AAOnE,MAAMC,kBAA4B;IACvCC,SAAS,OAAOC;QACd,MAAMC,aAAaD,IAAIE,OAAO,CAACC,MAAM,CAACC,IAAI;QAE1C,IAAI,CAACC,cAAcJ,aAAa;YAC9B,OAAOK,SAASC,IAAI,CAClB;gBACEC,SAAS;YACX,GACA;gBAAEC,QAAQ;YAAI;QAElB;QAEA,MAAMC,WAAWT,WAAWU,MAAM,EAAEC,OAAQ,CAAA,IAAM,IAAG;QAErD,MAAMC,YAAY,MAAMH,SAAS;YAAEV;QAAI;QAEvC,IAAI,CAACa,WAAW;YACd,OAAOP,SAASC,IAAI,CAClB;gBACEC,SAASR,IAAIc,IAAI,CAACC,CAAC,CAAC;YACtB,GACA;gBAAEN,QAAQ;YAAI;QAElB;QAEA,MAAM,EACJO,SAAS,EACTC,mBAAmBC,sBAAsB,EACzCC,KAAK,EACLC,KAAK,EACLC,QAAQC,WAAW,EACpB,GAAGtB,IAAIuB,KAAK;QAQb,MAAMF,SAASC,gBAAgB;QAE/B,MAAME,wBAAwBN,2BAA2B;QAEzD,MAAMO,eAAeT,aAAa,CAAE,CAAA,OAAOA,cAAc,YAAYA,cAAc,OAAM;QAEzF,IAAIQ,yBAAyBvB,WAAWyB,UAAU,EAAE;YAClD,uDAAuD;YACvD,MAAM1B,IAAIE,OAAO,CAACE,IAAI,CAACuB,eAAe,CAAC;gBAAEX,WAAWS;gBAAcL;gBAAOpB;YAAI;QAC/E;QAEA,MAAM4B,cAA2B;YAC/BR;YACApB;YACA,2DAA2D;YAC3DgB,WAAWS;YACXI,gBAAgB;YAChBR;QACF;QAEA,IAAI,OAAOD,UAAU,UAAU;YAC7BQ,YAAYR,KAAK,GAAGA;QACtB;QAEA,MAAMU,cAAcC,OAAOZ;QAC3B,IAAI,CAACa,MAAMF,cAAc;YACvBF,YAAYT,KAAK,GAAGW;QACtB;QAEA,IAAIG,kBAAkB;QACtB,IAAIC,2BAA2B;QAC/B,IAAI;YACF,MAAMC,SAAS,UAAMtC,wLAAAA,EAAQ+B;YAC7BK,kBAAkB,CAAC,CAACE,OAAOF,eAAe;YAC1CC,2BAA2BC,OAAOD,wBAAwB;QAC5D,EAAE,OAAOE,KAAK;YACZpC,IAAIE,OAAO,CAACmC,MAAM,CAACC,KAAK,CAAC;gBACvBF;gBACAG,KAAK;gBACLnB,OAAOQ,YAAYR,KAAK;YAC1B;YAEA,OAAOd,SAASC,IAAI,CAClB;gBACEC,SAASR,IAAIc,IAAI,CAACC,CAAC,CAAC;gBACpBkB,iBAAiB;gBACjBC;YACF,GACA;gBAAEzB,QAAQ;YAAI;QAElB;QAEA,OAAOH,SAASC,IAAI,CAClB;YACEC,SAASR,IAAIc,IAAI,CAACC,CAAC,CAAC;YACpBkB;YACAC;QACF,GACA;YAAEzB,QAAQ;QAAI;IAElB;IACA+B,QAAQ;IACRC,MAAM;AACR,EAAC;AAEM,MAAMpC,gBAAgB,CAACJ;IAC5B,OAAOyC,QAAQzC,WAAW0C,KAAK,EAAEC,UAAU3C,WAAW4C,SAAS,EAAED;AACnE,EAAC"}},
    {"offset": {"line": 5379, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/queues/endpoints/handleSchedules.ts"],"sourcesContent":["import type { Endpoint } from '../../config/types.js'\n\nimport { handleSchedules } from '../operations/handleSchedules/index.js'\nimport { configHasJobs } from './run.js'\n\n/**\n * GET /api/payload-jobs/handle-schedules endpoint\n *\n * This endpoint is GET instead of POST to allow it to be used in a Vercel Cron.\n */\nexport const handleSchedulesJobsEndpoint: Endpoint = {\n  handler: async (req) => {\n    const jobsConfig = req.payload.config.jobs\n\n    if (!configHasJobs(jobsConfig)) {\n      return Response.json(\n        {\n          message: 'No jobs to schedule.',\n        },\n        { status: 200 },\n      )\n    }\n\n    const accessFn = jobsConfig.access?.run ?? (() => true)\n\n    const hasAccess = await accessFn({ req })\n\n    if (!hasAccess) {\n      return Response.json(\n        {\n          message: req.i18n.t('error:unauthorized'),\n        },\n        { status: 401 },\n      )\n    }\n\n    if (!jobsConfig.scheduling) {\n      // There is no reason to call the handleSchedules endpoint if the stats global is not enabled (= no schedules defined)\n      return Response.json(\n        {\n          message:\n            'Cannot handle schedules because no tasks or workflows with schedules are defined.',\n        },\n        { status: 500 },\n      )\n    }\n\n    const { allQueues, queue } = req.query as {\n      allQueues?: 'false' | 'true'\n      queue?: string\n    }\n\n    const runAllQueues = allQueues && !(typeof allQueues === 'string' && allQueues === 'false')\n\n    const { errored, queued, skipped } = await handleSchedules({\n      allQueues: runAllQueues,\n      queue,\n      req,\n    })\n\n    return Response.json(\n      {\n        errored,\n        message: req.i18n.t('general:success'),\n        queued,\n        skipped,\n      },\n      { status: 200 },\n    )\n  },\n  method: 'get',\n  path: '/handle-schedules',\n}\n"],"names":["handleSchedules","configHasJobs","handleSchedulesJobsEndpoint","handler","req","jobsConfig","payload","config","jobs","Response","json","message","status","accessFn","access","run","hasAccess","i18n","t","scheduling","allQueues","queue","query","runAllQueues","errored","queued","skipped","method","path"],"mappings":";;;;AAEA,SAASA,eAAe,QAAQ,yCAAwC;AACxE,SAASC,aAAa,QAAQ,WAAU;;;AAOjC,MAAMC,8BAAwC;IACnDC,SAAS,OAAOC;QACd,MAAMC,aAAaD,IAAIE,OAAO,CAACC,MAAM,CAACC,IAAI;QAE1C,IAAI,KAACP,gLAAAA,EAAcI,aAAa;YAC9B,OAAOI,SAASC,IAAI,CAClB;gBACEC,SAAS;YACX,GACA;gBAAEC,QAAQ;YAAI;QAElB;QAEA,MAAMC,WAAWR,WAAWS,MAAM,EAAEC,OAAQ,CAAA,IAAM,IAAG;QAErD,MAAMC,YAAY,MAAMH,SAAS;YAAET;QAAI;QAEvC,IAAI,CAACY,WAAW;YACd,OAAOP,SAASC,IAAI,CAClB;gBACEC,SAASP,IAAIa,IAAI,CAACC,CAAC,CAAC;YACtB,GACA;gBAAEN,QAAQ;YAAI;QAElB;QAEA,IAAI,CAACP,WAAWc,UAAU,EAAE;YAC1B,sHAAsH;YACtH,OAAOV,SAASC,IAAI,CAClB;gBACEC,SACE;YACJ,GACA;gBAAEC,QAAQ;YAAI;QAElB;QAEA,MAAM,EAAEQ,SAAS,EAAEC,KAAK,EAAE,GAAGjB,IAAIkB,KAAK;QAKtC,MAAMC,eAAeH,aAAa,CAAE,CAAA,OAAOA,cAAc,YAAYA,cAAc,OAAM;QAEzF,MAAM,EAAEI,OAAO,EAAEC,MAAM,EAAEC,OAAO,EAAE,GAAG,UAAM1B,wMAAAA,EAAgB;YACzDoB,WAAWG;YACXF;YACAjB;QACF;QAEA,OAAOK,SAASC,IAAI,CAClB;YACEc;YACAb,SAASP,IAAIa,IAAI,CAACC,CAAC,CAAC;YACpBO;YACAC;QACF,GACA;YAAEd,QAAQ;QAAI;IAElB;IACAe,QAAQ;IACRC,MAAM;AACR,EAAC"}},
    {"offset": {"line": 5439, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/queues/utilities/getJobTaskStatus.ts"],"sourcesContent":["import type { Job } from '../../index.js'\nimport type { JobTaskStatus } from '../config/types/workflowTypes.js'\n\ntype Args = {\n  jobLog: Job['log']\n}\n\nexport const getJobTaskStatus = ({ jobLog }: Args): JobTaskStatus => {\n  const taskStatus: JobTaskStatus = {}\n\n  if (!jobLog || !Array.isArray(jobLog)) {\n    return taskStatus\n  }\n\n  // First, add (in order) the steps from the config to\n  // our status map\n  for (const loggedJob of jobLog) {\n    if (!taskStatus[loggedJob.taskSlug]) {\n      taskStatus[loggedJob.taskSlug] = {}\n    }\n    if (!taskStatus[loggedJob.taskSlug]?.[loggedJob.taskID]) {\n      taskStatus[loggedJob.taskSlug]![loggedJob.taskID] = {\n        complete: loggedJob.state === 'succeeded',\n        input: loggedJob.input,\n        output: loggedJob.output,\n        taskSlug: loggedJob.taskSlug,\n        totalTried: 1,\n      }\n    } else {\n      const newTaskStatus = taskStatus[loggedJob.taskSlug]![loggedJob.taskID]!\n      newTaskStatus.totalTried += 1\n\n      if (loggedJob.state === 'succeeded') {\n        newTaskStatus.complete = true\n        // As the task currently saved in taskStatus has likely failed and thus has no\n        // Output data, we need to update it with the new data from the successful task\n        newTaskStatus.output = loggedJob.output\n        newTaskStatus.input = loggedJob.input\n        newTaskStatus.taskSlug = loggedJob.taskSlug\n      }\n      taskStatus[loggedJob.taskSlug]![loggedJob.taskID] = newTaskStatus\n    }\n  }\n\n  return taskStatus\n}\n"],"names":["getJobTaskStatus","jobLog","taskStatus","Array","isArray","loggedJob","taskSlug","taskID","complete","state","input","output","totalTried","newTaskStatus"],"mappings":";;;;AAOO,MAAMA,mBAAmB,CAAC,EAAEC,MAAM,EAAQ;IAC/C,MAAMC,aAA4B,CAAC;IAEnC,IAAI,CAACD,UAAU,CAACE,MAAMC,OAAO,CAACH,SAAS;QACrC,OAAOC;IACT;IAEA,qDAAqD;IACrD,iBAAiB;IACjB,KAAK,MAAMG,aAAaJ,OAAQ;QAC9B,IAAI,CAACC,UAAU,CAACG,UAAUC,QAAQ,CAAC,EAAE;YACnCJ,UAAU,CAACG,UAAUC,QAAQ,CAAC,GAAG,CAAC;QACpC;QACA,IAAI,CAACJ,UAAU,CAACG,UAAUC,QAAQ,CAAC,EAAE,CAACD,UAAUE,MAAM,CAAC,EAAE;YACvDL,UAAU,CAACG,UAAUC,QAAQ,CAAE,CAACD,UAAUE,MAAM,CAAC,GAAG;gBAClDC,UAAUH,UAAUI,KAAK,KAAK;gBAC9BC,OAAOL,UAAUK,KAAK;gBACtBC,QAAQN,UAAUM,MAAM;gBACxBL,UAAUD,UAAUC,QAAQ;gBAC5BM,YAAY;YACd;QACF,OAAO;YACL,MAAMC,gBAAgBX,UAAU,CAACG,UAAUC,QAAQ,CAAE,CAACD,UAAUE,MAAM,CAAC;YACvEM,cAAcD,UAAU,IAAI;YAE5B,IAAIP,UAAUI,KAAK,KAAK,aAAa;gBACnCI,cAAcL,QAAQ,GAAG;gBACzB,8EAA8E;gBAC9E,+EAA+E;gBAC/EK,cAAcF,MAAM,GAAGN,UAAUM,MAAM;gBACvCE,cAAcH,KAAK,GAAGL,UAAUK,KAAK;gBACrCG,cAAcP,QAAQ,GAAGD,UAAUC,QAAQ;YAC7C;YACAJ,UAAU,CAACG,UAAUC,QAAQ,CAAE,CAACD,UAAUE,MAAM,CAAC,GAAGM;QACtD;IACF;IAEA,OAAOX;AACT,EAAC"}},
    {"offset": {"line": 5482, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/queues/config/collection.ts"],"sourcesContent":["import type { CollectionConfig } from '../../collections/config/types.js'\nimport type { SanitizedConfig } from '../../config/types.js'\nimport type { Field } from '../../fields/config/types.js'\nimport type { Job } from '../../index.js'\n\nimport { handleSchedulesJobsEndpoint } from '../endpoints/handleSchedules.js'\nimport { runJobsEndpoint } from '../endpoints/run.js'\nimport { getJobTaskStatus } from '../utilities/getJobTaskStatus.js'\n\nexport const jobsCollectionSlug = 'payload-jobs'\n\nexport const getDefaultJobsCollection: (jobsConfig: SanitizedConfig['jobs']) => CollectionConfig = (\n  jobsConfig,\n) => {\n  const workflowSlugs: Set<string> = new Set()\n  const taskSlugs: Set<string> = new Set(['inline'])\n\n  if (jobsConfig.workflows?.length) {\n    jobsConfig.workflows.forEach((workflow) => {\n      workflowSlugs.add(workflow.slug)\n\n      // Validate concurrency config requires enableConcurrencyControl flag\n      if (workflow.concurrency && !jobsConfig.enableConcurrencyControl) {\n        throw new Error(\n          `Workflow \"${workflow.slug}\" uses concurrency controls but \"jobs.enableConcurrencyControl\" is not enabled. ` +\n            `Set \"jobs.enableConcurrencyControl: true\" in your Payload config to use concurrency controls. ` +\n            `Note: This adds a new indexed field to the jobs collection schema and may require a database migration.`,\n        )\n      }\n    })\n  }\n\n  if (jobsConfig.tasks?.length) {\n    jobsConfig.tasks.forEach((task) => {\n      if (workflowSlugs.has(task.slug)) {\n        throw new Error(\n          `Task slug \"${task.slug}\" is already used by a workflow. No tasks are allowed to have the same slug as a workflow.`,\n        )\n      }\n\n      // Validate concurrency config requires enableConcurrencyControl flag\n      if (task.concurrency && !jobsConfig.enableConcurrencyControl) {\n        throw new Error(\n          `Task \"${task.slug}\" uses concurrency controls but \"jobs.enableConcurrencyControl\" is not enabled. ` +\n            `Set \"jobs.enableConcurrencyControl: true\" in your Payload config to use concurrency controls. ` +\n            `Note: This adds a new indexed field to the jobs collection schema and may require a database migration.`,\n        )\n      }\n\n      taskSlugs.add(task.slug)\n    })\n  }\n\n  const logFields: Field[] = [\n    {\n      name: 'executedAt',\n      type: 'date',\n      required: true,\n    },\n    {\n      name: 'completedAt',\n      type: 'date',\n      required: true,\n    },\n    {\n      name: 'taskSlug',\n      type: 'select',\n      options: [...taskSlugs],\n      required: true,\n    },\n    {\n      name: 'taskID',\n      type: 'text',\n      required: true,\n    },\n    /**\n     * @todo make required in 4.0\n     */\n    {\n      name: 'input',\n      type: 'json',\n    },\n    {\n      name: 'output',\n      type: 'json',\n    },\n    {\n      name: 'state',\n      type: 'radio',\n      options: ['failed', 'succeeded'],\n      required: true,\n    },\n    {\n      name: 'error',\n      type: 'json',\n      admin: {\n        condition: (_, data) => data.state === 'failed',\n      },\n      required: true,\n    },\n  ]\n\n  if (jobsConfig.addParentToTaskLog) {\n    logFields.push({\n      name: 'parent',\n      type: 'group',\n      fields: [\n        {\n          name: 'taskSlug',\n          type: 'select',\n          options: [...taskSlugs],\n        },\n        {\n          name: 'taskID',\n          type: 'text',\n        },\n      ],\n    })\n  }\n\n  const jobsCollection: CollectionConfig = {\n    slug: jobsCollectionSlug,\n    admin: {\n      group: 'System',\n      hidden: true,\n    },\n    endpoints: [runJobsEndpoint, handleSchedulesJobsEndpoint],\n    fields: [\n      {\n        name: 'input',\n        type: 'json',\n        admin: {\n          description: 'Input data provided to the job',\n        },\n      },\n      {\n        name: 'taskStatus',\n        type: 'json',\n        virtual: true,\n      },\n      {\n        type: 'tabs',\n        tabs: [\n          {\n            fields: [\n              {\n                name: 'completedAt',\n                type: 'date',\n                index: true,\n              },\n              {\n                name: 'totalTried',\n                type: 'number',\n                defaultValue: 0,\n                index: true,\n              },\n              {\n                name: 'hasError',\n                type: 'checkbox',\n                admin: {\n                  description: 'If hasError is true this job will not be retried',\n                },\n                defaultValue: false,\n                index: true,\n              },\n              {\n                name: 'error',\n                type: 'json',\n                admin: {\n                  condition: (data) => data.hasError,\n                  description: 'If hasError is true, this is the error that caused it',\n                },\n              },\n              {\n                name: 'log',\n                type: 'array',\n                admin: {\n                  description: 'Task execution log',\n                },\n                fields: logFields,\n              },\n            ],\n            label: 'Status',\n          },\n        ],\n      },\n      // only include the workflowSlugs field if workflows exist\n      ...((workflowSlugs.size > 0\n        ? [\n            {\n              name: 'workflowSlug',\n              type: 'select',\n              admin: {\n                position: 'sidebar',\n              },\n              index: true,\n              options: [...workflowSlugs],\n            },\n          ]\n        : []) as Field[]),\n      {\n        name: 'taskSlug',\n        type: 'select',\n        admin: {\n          position: 'sidebar',\n        },\n        index: true,\n        options: [...taskSlugs],\n        required: false,\n      },\n      {\n        name: 'queue',\n        type: 'text',\n        admin: {\n          position: 'sidebar',\n        },\n        defaultValue: 'default',\n        index: true,\n      },\n      {\n        name: 'waitUntil',\n        type: 'date',\n        admin: {\n          date: { pickerAppearance: 'dayAndTime' },\n        },\n        index: true,\n      },\n      {\n        name: 'processing',\n        type: 'checkbox',\n        admin: {\n          position: 'sidebar',\n        },\n        defaultValue: false,\n        index: true,\n      },\n      // Only add concurrencyKey field if concurrency control is enabled\n      ...(jobsConfig.enableConcurrencyControl\n        ? [\n            {\n              name: 'concurrencyKey',\n              type: 'text',\n              admin: {\n                description:\n                  'Used for concurrency control. Jobs with the same key are subject to exclusive/supersedes rules.',\n                position: 'sidebar',\n                readOnly: true,\n              },\n              index: true,\n            } as Field,\n          ]\n        : []),\n    ],\n    hooks: {\n      afterRead: [\n        ({ doc, req }) => {\n          // This hook is used to add the virtual `tasks` field to the document, that is computed from the `log` field\n\n          return jobAfterRead({ config: req.payload.config, doc })\n        },\n      ],\n      /**\n       * If another update comes in after a job as already been cancelled, we need to make sure that update doesn't\n       * change the state of the job.\n       */\n      beforeChange: [\n        ({ data, originalDoc }) => {\n          if (originalDoc?.error?.cancelled) {\n            data.processing = false\n            data.hasError = true\n            delete data.completedAt\n            delete data.waitUntil\n          }\n          return data\n        },\n      ],\n    },\n    lockDocuments: false,\n  }\n\n  if (jobsConfig.stats) {\n    // TODO: In 4.0, this should be added by default.\n    // The meta field can be used to store arbitrary data about the job. The scheduling system uses this to store\n    // `scheduled: true` to indicate that the job was queued by the scheduling system.\n    jobsCollection.fields.push({\n      name: 'meta',\n      type: 'json',\n    })\n  }\n  return jobsCollection\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport function jobAfterRead({ config, doc }: { config: SanitizedConfig; doc: Job }): Job {\n  doc.taskStatus = getJobTaskStatus({\n    jobLog: doc.log || [],\n  })\n  doc.input = doc.input || {}\n  doc.taskStatus = doc.taskStatus || {}\n  return doc\n}\n"],"names":["handleSchedulesJobsEndpoint","runJobsEndpoint","getJobTaskStatus","jobsCollectionSlug","getDefaultJobsCollection","jobsConfig","workflowSlugs","Set","taskSlugs","workflows","length","forEach","workflow","add","slug","concurrency","enableConcurrencyControl","Error","tasks","task","has","logFields","name","type","required","options","admin","condition","_","data","state","addParentToTaskLog","push","fields","jobsCollection","group","hidden","endpoints","description","virtual","tabs","index","defaultValue","hasError","label","size","position","date","pickerAppearance","readOnly","hooks","afterRead","doc","req","jobAfterRead","config","payload","beforeChange","originalDoc","error","cancelled","processing","completedAt","waitUntil","lockDocuments","stats","taskStatus","jobLog","log","input"],"mappings":"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"}},
    {"offset": {"line": 5781, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/folders/buildFolderField.ts"],"sourcesContent":["import type { SingleRelationshipField } from '../fields/config/types.js'\nimport type { Document } from '../types/index.js'\n\nimport { extractID } from '../utilities/extractID.js'\n\nexport const buildFolderField = ({\n  collectionSpecific,\n  folderFieldName,\n  folderSlug,\n  overrides = {},\n}: {\n  collectionSpecific: boolean\n  folderFieldName: string\n  folderSlug: string\n  overrides?: Partial<SingleRelationshipField>\n}): SingleRelationshipField => {\n  const field: SingleRelationshipField = {\n    name: folderFieldName,\n    type: 'relationship',\n    admin: {},\n    hasMany: false,\n    index: true,\n    label: 'Folder',\n    relationTo: folderSlug,\n    validate: async (value, { collectionSlug, data, overrideAccess, previousValue, req }) => {\n      if (!collectionSpecific) {\n        // if collection scoping is not enabled, no validation required since folders can contain any type of document\n        return true\n      }\n\n      if (!value) {\n        // no folder, no validation required\n        return true\n      }\n\n      const newID = extractID<Document>(value)\n      if (previousValue && extractID<Document>(previousValue) === newID) {\n        // value did not change, no validation required\n        return true\n      } else {\n        // need to validat the folder value allows this collection type\n        let parentFolder: Document = null\n        if (typeof value === 'string' || typeof value === 'number') {\n          // need to populate the value with the document\n          parentFolder = await req.payload.findByID({\n            id: newID,\n            collection: folderSlug,\n            depth: 0, // no need to populate nested folders\n            overrideAccess,\n            req,\n            select: {\n              folderType: true, // only need to check folderType\n            },\n            user: req.user,\n          })\n        }\n\n        if (parentFolder && collectionSlug) {\n          const parentFolderTypes: string[] = (parentFolder.folderType as string[]) || []\n\n          // if the parent folder has no folder types, it accepts all collections\n          if (parentFolderTypes.length === 0) {\n            return true\n          }\n\n          // validation for a folder document\n          if (collectionSlug === folderSlug) {\n            // ensure the parent accepts ALL folder types\n            const folderTypes: string[] = 'folderType' in data ? (data.folderType as string[]) : []\n            const invalidSlugs = folderTypes.filter((validCollectionSlug: string) => {\n              return !parentFolderTypes.includes(validCollectionSlug)\n            })\n            if (invalidSlugs.length === 0) {\n              return true\n            } else {\n              return `Folder with ID ${newID} does not allow documents of type ${invalidSlugs.join(', ')}`\n            }\n          }\n\n          // validation for a non-folder document\n          if (parentFolderTypes.includes(collectionSlug)) {\n            return true\n          } else {\n            return `Folder with ID ${newID} does not allow documents of type ${collectionSlug}`\n          }\n        } else {\n          return `Folder with ID ${newID} not found in collection ${folderSlug}`\n        }\n      }\n    },\n  }\n\n  if (overrides?.admin) {\n    field.admin = {\n      ...field.admin,\n      ...(overrides.admin || {}),\n    }\n\n    if (overrides.admin.components) {\n      field.admin.components = {\n        ...field.admin.components,\n        ...(overrides.admin.components || {}),\n      }\n    }\n  }\n\n  return field\n}\n"],"names":["extractID","buildFolderField","collectionSpecific","folderFieldName","folderSlug","overrides","field","name","type","admin","hasMany","index","label","relationTo","validate","value","collectionSlug","data","overrideAccess","previousValue","req","newID","parentFolder","payload","findByID","id","collection","depth","select","folderType","user","parentFolderTypes","length","folderTypes","invalidSlugs","filter","validCollectionSlug","includes","join","components"],"mappings":";;;;AAGA,SAASA,SAAS,QAAQ,4BAA2B;;AAE9C,MAAMC,mBAAmB,CAAC,EAC/BC,kBAAkB,EAClBC,eAAe,EACfC,UAAU,EACVC,YAAY,CAAC,CAAC,EAMf;IACC,MAAMC,QAAiC;QACrCC,MAAMJ;QACNK,MAAM;QACNC,OAAO,CAAC;QACRC,SAAS;QACTC,OAAO;QACPC,OAAO;QACPC,YAAYT;QACZU,UAAU,OAAOC,OAAO,EAAEC,cAAc,EAAEC,IAAI,EAAEC,cAAc,EAAEC,aAAa,EAAEC,GAAG,EAAE;YAClF,IAAI,CAAClB,oBAAoB;gBACvB,8GAA8G;gBAC9G,OAAO;YACT;YAEA,IAAI,CAACa,OAAO;gBACV,oCAAoC;gBACpC,OAAO;YACT;YAEA,MAAMM,YAAQrB,wKAAAA,EAAoBe;YAClC,IAAII,qBAAiBnB,wKAAAA,EAAoBmB,mBAAmBE,OAAO;gBACjE,+CAA+C;gBAC/C,OAAO;YACT,OAAO;gBACL,+DAA+D;gBAC/D,IAAIC,eAAyB;gBAC7B,IAAI,OAAOP,UAAU,YAAY,OAAOA,UAAU,UAAU;oBAC1D,+CAA+C;oBAC/CO,eAAe,MAAMF,IAAIG,OAAO,CAACC,QAAQ,CAAC;wBACxCC,IAAIJ;wBACJK,YAAYtB;wBACZuB,OAAO;wBACPT;wBACAE;wBACAQ,QAAQ;4BACNC,YAAY;wBACd;wBACAC,MAAMV,IAAIU,IAAI;oBAChB;gBACF;gBAEA,IAAIR,gBAAgBN,gBAAgB;oBAClC,MAAMe,oBAA+BT,aAAaO,UAAU,IAAiB,EAAE;oBAE/E,uEAAuE;oBACvE,IAAIE,kBAAkBC,MAAM,KAAK,GAAG;wBAClC,OAAO;oBACT;oBAEA,mCAAmC;oBACnC,IAAIhB,mBAAmBZ,YAAY;wBACjC,6CAA6C;wBAC7C,MAAM6B,cAAwB,gBAAgBhB,OAAQA,KAAKY,UAAU,GAAgB,EAAE;wBACvF,MAAMK,eAAeD,YAAYE,MAAM,CAAC,CAACC;4BACvC,OAAO,CAACL,kBAAkBM,QAAQ,CAACD;wBACrC;wBACA,IAAIF,aAAaF,MAAM,KAAK,GAAG;4BAC7B,OAAO;wBACT,OAAO;4BACL,OAAO,CAAC,eAAe,EAAEX,MAAM,kCAAkC,EAAEa,aAAaI,IAAI,CAAC,OAAO;wBAC9F;oBACF;oBAEA,uCAAuC;oBACvC,IAAIP,kBAAkBM,QAAQ,CAACrB,iBAAiB;wBAC9C,OAAO;oBACT,OAAO;wBACL,OAAO,CAAC,eAAe,EAAEK,MAAM,kCAAkC,EAAEL,gBAAgB;oBACrF;gBACF,OAAO;oBACL,OAAO,CAAC,eAAe,EAAEK,MAAM,yBAAyB,EAAEjB,YAAY;gBACxE;YACF;QACF;IACF;IAEA,IAAIC,WAAWI,OAAO;QACpBH,MAAMG,KAAK,GAAG;YACZ,GAAGH,MAAMG,KAAK;YACd,GAAIJ,UAAUI,KAAK,IAAI,CAAC,CAAC;QAC3B;QAEA,IAAIJ,UAAUI,KAAK,CAAC8B,UAAU,EAAE;YAC9BjC,MAAMG,KAAK,CAAC8B,UAAU,GAAG;gBACvB,GAAGjC,MAAMG,KAAK,CAAC8B,UAAU;gBACzB,GAAIlC,UAAUI,KAAK,CAAC8B,UAAU,IAAI,CAAC,CAAC;YACtC;QACF;IACF;IAEA,OAAOjC;AACT,EAAC"}},
    {"offset": {"line": 5875, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/folders/hooks/deleteSubfoldersAfterDelete.ts"],"sourcesContent":["import type { CollectionBeforeDeleteHook } from '../../index.js'\n\ntype Args = {\n  folderFieldName: string\n  folderSlug: string\n}\nexport const deleteSubfoldersBeforeDelete = ({\n  folderFieldName,\n  folderSlug,\n}: Args): CollectionBeforeDeleteHook => {\n  return async ({ id, req }) => {\n    await req.payload.delete({\n      collection: folderSlug,\n      req,\n      where: {\n        [folderFieldName]: {\n          equals: id,\n        },\n      },\n    })\n  }\n}\n"],"names":["deleteSubfoldersBeforeDelete","folderFieldName","folderSlug","id","req","payload","delete","collection","where","equals"],"mappings":";;;;AAMO,MAAMA,+BAA+B,CAAC,EAC3CC,eAAe,EACfC,UAAU,EACL;IACL,OAAO,OAAO,EAAEC,EAAE,EAAEC,GAAG,EAAE;QACvB,MAAMA,IAAIC,OAAO,CAACC,MAAM,CAAC;YACvBC,YAAYL;YACZE;YACAI,OAAO;gBACL,CAACP,gBAAgB,EAAE;oBACjBQ,QAAQN;gBACV;YACF;QACF;IACF;AACF,EAAC"}},
    {"offset": {"line": 5896, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/folders/hooks/dissasociateAfterDelete.ts"],"sourcesContent":["import type { CollectionAfterDeleteHook } from '../../index.js'\n\ntype Args = {\n  collectionSlugs: string[]\n  folderFieldName: string\n}\nexport const dissasociateAfterDelete = ({\n  collectionSlugs,\n  folderFieldName,\n}: Args): CollectionAfterDeleteHook => {\n  return async ({ id, req }) => {\n    for (const collectionSlug of collectionSlugs) {\n      await req.payload.update({\n        collection: collectionSlug,\n        data: {\n          [folderFieldName]: null,\n        },\n        req,\n        where: {\n          [folderFieldName]: {\n            equals: id,\n          },\n        },\n      })\n    }\n  }\n}\n"],"names":["dissasociateAfterDelete","collectionSlugs","folderFieldName","id","req","collectionSlug","payload","update","collection","data","where","equals"],"mappings":";;;;AAMO,MAAMA,0BAA0B,CAAC,EACtCC,eAAe,EACfC,eAAe,EACV;IACL,OAAO,OAAO,EAAEC,EAAE,EAAEC,GAAG,EAAE;QACvB,KAAK,MAAMC,kBAAkBJ,gBAAiB;YAC5C,MAAMG,IAAIE,OAAO,CAACC,MAAM,CAAC;gBACvBC,YAAYH;gBACZI,MAAM;oBACJ,CAACP,gBAAgB,EAAE;gBACrB;gBACAE;gBACAM,OAAO;oBACL,CAACR,gBAAgB,EAAE;wBACjBS,QAAQR;oBACV;gBACF;YACF;QACF;IACF;AACF,EAAC"}},
    {"offset": {"line": 5922, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/folders/hooks/ensureSafeCollectionsChange.ts"],"sourcesContent":["import { APIError, type CollectionBeforeValidateHook, type CollectionSlug } from '../../index.js'\nimport { extractID } from '../../utilities/extractID.js'\nimport { getTranslatedLabel } from '../../utilities/getTranslatedLabel.js'\n\nexport const ensureSafeCollectionsChange =\n  ({ foldersSlug }: { foldersSlug: CollectionSlug }): CollectionBeforeValidateHook =>\n  async ({ data, originalDoc, req }) => {\n    const currentFolderID = extractID(originalDoc || {})\n    const parentFolderID = extractID(data?.folder || originalDoc?.folder || {})\n    if (Array.isArray(data?.folderType) && data.folderType.length > 0) {\n      const folderType = data.folderType as string[]\n      const currentlyAssignedCollections: string[] | undefined =\n        Array.isArray(originalDoc?.folderType) && originalDoc.folderType.length > 0\n          ? originalDoc.folderType\n          : undefined\n      /**\n       * Check if the assigned collections have changed.\n       * example:\n       * - originalAssignedCollections: ['posts', 'pages']\n       * - folderType: ['posts']\n       *\n       * The user is narrowing the types of documents that can be associated with this folder.\n       * If the user is only expanding the types of documents that can be associated with this folder,\n       * we do not need to do anything.\n       */\n      const newCollections = currentlyAssignedCollections\n        ? // user is narrowing the current scope of the folder\n          currentlyAssignedCollections.filter((c) => !folderType.includes(c))\n        : // user is adding a scope to the folder\n          folderType\n\n      if (newCollections && newCollections.length > 0) {\n        let hasDependentDocuments = false\n        if (typeof currentFolderID === 'string' || typeof currentFolderID === 'number') {\n          const childDocumentsResult = await req.payload.findByID({\n            id: currentFolderID,\n            collection: foldersSlug,\n            joins: {\n              documentsAndFolders: {\n                limit: 100_000_000,\n                where: {\n                  or: [\n                    {\n                      relationTo: {\n                        in: newCollections,\n                      },\n                    },\n                  ],\n                },\n              },\n            },\n            overrideAccess: true,\n            req,\n          })\n\n          hasDependentDocuments = childDocumentsResult.documentsAndFolders.docs.length > 0\n        }\n\n        // matches folders that are directly related to the removed collections\n        let hasDependentFolders = false\n        if (\n          !hasDependentDocuments &&\n          (typeof currentFolderID === 'string' || typeof currentFolderID === 'number')\n        ) {\n          const childFoldersResult = await req.payload.find({\n            collection: foldersSlug,\n            limit: 1,\n            req,\n            where: {\n              and: [\n                {\n                  folderType: {\n                    in: newCollections,\n                  },\n                },\n                {\n                  folder: {\n                    equals: currentFolderID,\n                  },\n                },\n              ],\n            },\n          })\n          hasDependentFolders = childFoldersResult.totalDocs > 0\n        }\n\n        if (hasDependentDocuments || hasDependentFolders) {\n          const translatedLabels = newCollections.map((collectionSlug) => {\n            if (req.payload.collections[collectionSlug]?.config.labels.singular) {\n              return getTranslatedLabel(\n                req.payload.collections[collectionSlug]?.config.labels.plural,\n                req.i18n,\n              )\n            }\n            return collectionSlug\n          })\n\n          throw new APIError(\n            `The folder \"${data.name || originalDoc.name}\" contains ${hasDependentDocuments ? 'documents' : 'folders'} that still belong to the following collections: ${translatedLabels.join(', ')}`,\n            400,\n          )\n        }\n        return data\n      }\n    } else if (\n      (data?.folderType === null ||\n        (Array.isArray(data?.folderType) && data?.folderType.length === 0)) &&\n      parentFolderID\n    ) {\n      // attempting to set the folderType to catch-all, so we need to ensure that the parent allows this\n      let parentFolder\n      if (typeof parentFolderID === 'string' || typeof parentFolderID === 'number') {\n        try {\n          parentFolder = await req.payload.findByID({\n            id: parentFolderID,\n            collection: foldersSlug,\n            overrideAccess: true,\n            req,\n            select: {\n              name: true,\n              folderType: true,\n            },\n            user: req.user,\n          })\n        } catch (_) {\n          // parent folder does not exist\n        }\n      }\n\n      if (\n        parentFolder &&\n        parentFolder?.folderType &&\n        Array.isArray(parentFolder.folderType) &&\n        parentFolder.folderType.length > 0\n      ) {\n        throw new APIError(\n          `The folder \"${data?.name || originalDoc.name}\" must have folder-type set since its parent folder ${parentFolder?.name ? `\"${parentFolder?.name}\" ` : ''}has a folder-type set.`,\n          400,\n        )\n      }\n    }\n\n    return data\n  }\n"],"names":["APIError","extractID","getTranslatedLabel","ensureSafeCollectionsChange","foldersSlug","data","originalDoc","req","currentFolderID","parentFolderID","folder","Array","isArray","folderType","length","currentlyAssignedCollections","undefined","newCollections","filter","c","includes","hasDependentDocuments","childDocumentsResult","payload","findByID","id","collection","joins","documentsAndFolders","limit","where","or","relationTo","in","overrideAccess","docs","hasDependentFolders","childFoldersResult","find","and","equals","totalDocs","translatedLabels","map","collectionSlug","collections","config","labels","singular","plural","i18n","name","join","parentFolder","select","user","_"],"mappings":"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"}},
    {"offset": {"line": 6038, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/folders/hooks/reparentChildFolder.ts"],"sourcesContent":["import type { CollectionAfterChangeHook, Payload } from '../../index.js'\n\nimport { extractID } from '../../utilities/extractID.js'\n\ntype Args = {\n  folderCollectionSlug: string\n  folderFieldName: string\n  folderID: number | string\n  parentIDToFind: number | string\n  payload: Payload\n}\n\n/**\n * Determines if a child folder belongs to a parent folder by\n * recursively checking upwards through the folder hierarchy.\n */\nasync function isChildOfFolder({\n  folderCollectionSlug,\n  folderFieldName,\n  folderID,\n  parentIDToFind,\n  payload,\n}: Args): Promise<boolean> {\n  const parentFolder = await payload.findByID({\n    id: folderID,\n    collection: folderCollectionSlug,\n  })\n\n  const parentFolderID = parentFolder[folderFieldName]\n    ? extractID(parentFolder[folderFieldName])\n    : undefined\n\n  if (!parentFolderID) {\n    // made it to the root\n    return false\n  }\n\n  if (parentFolderID === parentIDToFind) {\n    // found match, would be cyclic\n    return true\n  }\n\n  return isChildOfFolder({\n    folderCollectionSlug,\n    folderFieldName,\n    folderID: parentFolderID,\n    parentIDToFind,\n    payload,\n  })\n}\n\n/**\n * If a parent is moved into a child folder, we need to re-parent the child\n * \n * @example\n * \n * ```ts\n     F1\n       F2\n         F2A\n       F3\n\n  Moving F1  F2A becomes:\n\n     F2A\n       F1\n         F2\n         F3\n  ```\n */\nexport const reparentChildFolder = ({\n  folderFieldName,\n}: {\n  folderFieldName: string\n}): CollectionAfterChangeHook => {\n  return async ({ doc, previousDoc, req }) => {\n    if (\n      previousDoc[folderFieldName] !== doc[folderFieldName] &&\n      doc[folderFieldName] &&\n      req.payload.config.folders\n    ) {\n      const newParentFolderID = extractID(doc[folderFieldName])\n      const isMovingToChild = newParentFolderID\n        ? await isChildOfFolder({\n            folderCollectionSlug: req.payload.config.folders.slug,\n            folderFieldName,\n            folderID: newParentFolderID,\n            parentIDToFind: doc.id,\n            payload: req.payload,\n          })\n        : false\n\n      if (isMovingToChild) {\n        // if the folder was moved into a child folder, the child folder needs\n        // to be re-parented with the parent of the folder that was moved\n        await req.payload.update({\n          id: newParentFolderID,\n          collection: req.payload.config.folders.slug,\n          data: {\n            [folderFieldName]: previousDoc[folderFieldName]\n              ? extractID(previousDoc[folderFieldName])\n              : null,\n          },\n          req,\n        })\n      }\n    }\n  }\n}\n"],"names":["extractID","isChildOfFolder","folderCollectionSlug","folderFieldName","folderID","parentIDToFind","payload","parentFolder","findByID","id","collection","parentFolderID","undefined","reparentChildFolder","doc","previousDoc","req","config","folders","newParentFolderID","isMovingToChild","slug","update","data"],"mappings":";;;;AAEA,SAASA,SAAS,QAAQ,+BAA8B;;AAUxD;;;CAGC,GACD,eAAeC,gBAAgB,EAC7BC,oBAAoB,EACpBC,eAAe,EACfC,QAAQ,EACRC,cAAc,EACdC,OAAO,EACF;IACL,MAAMC,eAAe,MAAMD,QAAQE,QAAQ,CAAC;QAC1CC,IAAIL;QACJM,YAAYR;IACd;IAEA,MAAMS,iBAAiBJ,YAAY,CAACJ,gBAAgB,OAChDH,wKAAAA,EAAUO,YAAY,CAACJ,gBAAgB,IACvCS;IAEJ,IAAI,CAACD,gBAAgB;QACnB,sBAAsB;QACtB,OAAO;IACT;IAEA,IAAIA,mBAAmBN,gBAAgB;QACrC,+BAA+B;QAC/B,OAAO;IACT;IAEA,OAAOJ,gBAAgB;QACrBC;QACAC;QACAC,UAAUO;QACVN;QACAC;IACF;AACF;AAqBO,MAAMO,sBAAsB,CAAC,EAClCV,eAAe,EAGhB;IACC,OAAO,OAAO,EAAEW,GAAG,EAAEC,WAAW,EAAEC,GAAG,EAAE;QACrC,IACED,WAAW,CAACZ,gBAAgB,KAAKW,GAAG,CAACX,gBAAgB,IACrDW,GAAG,CAACX,gBAAgB,IACpBa,IAAIV,OAAO,CAACW,MAAM,CAACC,OAAO,EAC1B;YACA,MAAMC,wBAAoBnB,wKAAAA,EAAUc,GAAG,CAACX,gBAAgB;YACxD,MAAMiB,kBAAkBD,oBACpB,MAAMlB,gBAAgB;gBACpBC,sBAAsBc,IAAIV,OAAO,CAACW,MAAM,CAACC,OAAO,CAACG,IAAI;gBACrDlB;gBACAC,UAAUe;gBACVd,gBAAgBS,IAAIL,EAAE;gBACtBH,SAASU,IAAIV,OAAO;YACtB,KACA;YAEJ,IAAIc,iBAAiB;gBACnB,sEAAsE;gBACtE,iEAAiE;gBACjE,MAAMJ,IAAIV,OAAO,CAACgB,MAAM,CAAC;oBACvBb,IAAIU;oBACJT,YAAYM,IAAIV,OAAO,CAACW,MAAM,CAACC,OAAO,CAACG,IAAI;oBAC3CE,MAAM;wBACJ,CAACpB,gBAAgB,EAAEY,WAAW,CAACZ,gBAAgB,OAC3CH,wKAAAA,EAAUe,WAAW,CAACZ,gBAAgB,IACtC;oBACN;oBACAa;gBACF;YACF;QACF;IACF;AACF,EAAC"}},
    {"offset": {"line": 6099, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/folders/createFolderCollection.ts"],"sourcesContent":["import type { CollectionConfig } from '../collections/config/types.js'\nimport type { Field, Option, SelectField } from '../fields/config/types.js'\n\nimport { defaultAccess } from '../auth/defaultAccess.js'\nimport { buildFolderField } from './buildFolderField.js'\nimport { deleteSubfoldersBeforeDelete } from './hooks/deleteSubfoldersAfterDelete.js'\nimport { dissasociateAfterDelete } from './hooks/dissasociateAfterDelete.js'\nimport { ensureSafeCollectionsChange } from './hooks/ensureSafeCollectionsChange.js'\nimport { reparentChildFolder } from './hooks/reparentChildFolder.js'\n\ntype CreateFolderCollectionArgs = {\n  collectionSpecific: boolean\n  debug?: boolean\n  folderEnabledCollections: CollectionConfig[]\n  folderFieldName: string\n  slug: string\n}\nexport const createFolderCollection = ({\n  slug,\n  collectionSpecific,\n  debug,\n  folderEnabledCollections,\n  folderFieldName,\n}: CreateFolderCollectionArgs): CollectionConfig => {\n  const { collectionOptions, collectionSlugs } = folderEnabledCollections.reduce(\n    (acc, collection: CollectionConfig) => {\n      acc.collectionSlugs.push(collection.slug)\n      acc.collectionOptions.push({\n        label: collection.labels?.plural || collection.slug,\n        value: collection.slug,\n      })\n\n      return acc\n    },\n    {\n      collectionOptions: [] as Option[],\n      collectionSlugs: [] as string[],\n    },\n  )\n\n  return {\n    slug,\n    access: {\n      create: defaultAccess,\n      delete: defaultAccess,\n      read: defaultAccess,\n      readVersions: defaultAccess,\n      update: defaultAccess,\n    },\n    admin: {\n      hidden: !debug,\n      useAsTitle: 'name',\n    },\n    fields: [\n      {\n        name: 'name',\n        type: 'text',\n        index: true,\n        required: true,\n      },\n      buildFolderField({\n        collectionSpecific,\n        folderFieldName,\n        folderSlug: slug,\n        overrides: {\n          admin: {\n            hidden: !debug,\n          },\n        },\n      }),\n      {\n        name: 'documentsAndFolders',\n        type: 'join',\n        admin: {\n          hidden: !debug,\n        },\n        collection: [slug, ...collectionSlugs],\n        hasMany: true,\n        on: folderFieldName,\n      },\n      ...(collectionSpecific\n        ? [\n            {\n              name: 'folderType',\n              type: 'select',\n              admin: {\n                components: {\n                  Field: {\n                    path: '@payloadcms/next/client#FolderTypeField',\n                  },\n                },\n                position: 'sidebar',\n              },\n              hasMany: true,\n              options: collectionOptions,\n            } satisfies SelectField,\n          ]\n        : ([] as Field[])),\n    ],\n    hooks: {\n      afterChange: [\n        reparentChildFolder({\n          folderFieldName,\n        }),\n      ],\n      afterDelete: [\n        dissasociateAfterDelete({\n          collectionSlugs,\n          folderFieldName,\n        }),\n      ],\n      beforeDelete: [deleteSubfoldersBeforeDelete({ folderFieldName, folderSlug: slug })],\n      beforeValidate: [\n        ...(collectionSpecific ? [ensureSafeCollectionsChange({ foldersSlug: slug })] : []),\n      ],\n    },\n    labels: {\n      plural: 'Folders',\n      singular: 'Folder',\n    },\n    typescript: {\n      interface: 'FolderInterface',\n    },\n  }\n}\n"],"names":["defaultAccess","buildFolderField","deleteSubfoldersBeforeDelete","dissasociateAfterDelete","ensureSafeCollectionsChange","reparentChildFolder","createFolderCollection","slug","collectionSpecific","debug","folderEnabledCollections","folderFieldName","collectionOptions","collectionSlugs","reduce","acc","collection","push","label","labels","plural","value","access","create","delete","read","readVersions","update","admin","hidden","useAsTitle","fields","name","type","index","required","folderSlug","overrides","hasMany","on","components","Field","path","position","options","hooks","afterChange","afterDelete","beforeDelete","beforeValidate","foldersSlug","singular","typescript","interface"],"mappings":";;;;AAGA,SAASA,aAAa,QAAQ,2BAA0B;AACxD,SAASC,gBAAgB,QAAQ,wBAAuB;AACxD,SAASC,4BAA4B,QAAQ,yCAAwC;AACrF,SAASC,uBAAuB,QAAQ,qCAAoC;AAC5E,SAASC,2BAA2B,QAAQ,yCAAwC;AACpF,SAASC,mBAAmB,QAAQ,iCAAgC;;;;;;;AAS7D,MAAMC,yBAAyB,CAAC,EACrCC,IAAI,EACJC,kBAAkB,EAClBC,KAAK,EACLC,wBAAwB,EACxBC,eAAe,EACY;IAC3B,MAAM,EAAEC,iBAAiB,EAAEC,eAAe,EAAE,GAAGH,yBAAyBI,MAAM,CAC5E,CAACC,KAAKC;QACJD,IAAIF,eAAe,CAACI,IAAI,CAACD,WAAWT,IAAI;QACxCQ,IAAIH,iBAAiB,CAACK,IAAI,CAAC;YACzBC,OAAOF,WAAWG,MAAM,EAAEC,UAAUJ,WAAWT,IAAI;YACnDc,OAAOL,WAAWT,IAAI;QACxB;QAEA,OAAOQ;IACT,GACA;QACEH,mBAAmB,EAAE;QACrBC,iBAAiB,EAAE;IACrB;IAGF,OAAO;QACLN;QACAe,QAAQ;YACNC,QAAQvB,2KAAAA;YACRwB,QAAQxB,2KAAAA;YACRyB,MAAMzB,2KAAAA;YACN0B,cAAc1B,2KAAAA;YACd2B,QAAQ3B,2KAAAA;QACV;QACA4B,OAAO;YACLC,QAAQ,CAACpB;YACTqB,YAAY;QACd;QACAC,QAAQ;YACN;gBACEC,MAAM;gBACNC,MAAM;gBACNC,OAAO;gBACPC,UAAU;YACZ;gBACAlC,oLAAAA,EAAiB;gBACfO;gBACAG;gBACAyB,YAAY7B;gBACZ8B,WAAW;oBACTT,OAAO;wBACLC,QAAQ,CAACpB;oBACX;gBACF;YACF;YACA;gBACEuB,MAAM;gBACNC,MAAM;gBACNL,OAAO;oBACLC,QAAQ,CAACpB;gBACX;gBACAO,YAAY;oBAACT;uBAASM;iBAAgB;gBACtCyB,SAAS;gBACTC,IAAI5B;YACN;eACIH,qBACA;gBACE;oBACEwB,MAAM;oBACNC,MAAM;oBACNL,OAAO;wBACLY,YAAY;4BACVC,OAAO;gCACLC,MAAM;4BACR;wBACF;wBACAC,UAAU;oBACZ;oBACAL,SAAS;oBACTM,SAAShC;gBACX;aACD,GACA,EAAE;SACR;QACDiC,OAAO;YACLC,aAAa;oBACXzC,mMAAAA,EAAoB;oBAClBM;gBACF;aACD;YACDoC,aAAa;oBACX5C,2MAAAA,EAAwB;oBACtBU;oBACAF;gBACF;aACD;YACDqC,cAAc;oBAAC9C,oNAAAA,EAA6B;oBAAES;oBAAiByB,YAAY7B;gBAAK;aAAG;YACnF0C,gBAAgB;mBACVzC,qBAAqB;wBAACJ,mNAAAA,EAA4B;wBAAE8C,aAAa3C;oBAAK;iBAAG,GAAG,EAAE;aACnF;QACH;QACAY,QAAQ;YACNC,QAAQ;YACR+B,UAAU;QACZ;QACAC,YAAY;YACVC,WAAW;QACb;IACF;AACF,EAAC"}},
    {"offset": {"line": 6226, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/folders/addFolderCollection.ts"],"sourcesContent":["import type { Config, SanitizedConfig } from '../config/types.js'\nimport type { CollectionConfig } from '../index.js'\n\nimport { sanitizeCollection } from '../collections/config/sanitize.js'\nimport { createFolderCollection } from './createFolderCollection.js'\n\nexport async function addFolderCollection({\n  collectionSpecific,\n  config,\n  folderEnabledCollections,\n  richTextSanitizationPromises = [],\n  validRelationships = [],\n}: {\n  collectionSpecific: boolean\n  config: NonNullable<Config>\n  folderEnabledCollections: CollectionConfig[]\n  richTextSanitizationPromises?: Array<(config: SanitizedConfig) => Promise<void>>\n  validRelationships?: string[]\n}): Promise<void> {\n  if (config.folders === false) {\n    return\n  }\n\n  let folderCollectionConfig = createFolderCollection({\n    slug: config.folders!.slug as string,\n    collectionSpecific,\n    debug: config.folders!.debug,\n    folderEnabledCollections,\n    folderFieldName: config.folders!.fieldName as string,\n  })\n\n  const collectionIndex = config.collections!.push(folderCollectionConfig)\n\n  if (\n    Array.isArray(config.folders?.collectionOverrides) &&\n    config?.folders.collectionOverrides.length\n  ) {\n    for (const override of config.folders.collectionOverrides) {\n      folderCollectionConfig = await override({ collection: folderCollectionConfig })\n    }\n  }\n\n  const sanitizedCollectionWithOverrides = await sanitizeCollection(\n    config as unknown as Config,\n    folderCollectionConfig,\n    richTextSanitizationPromises,\n    validRelationships,\n  )\n\n  config.collections![collectionIndex - 1] = sanitizedCollectionWithOverrides\n}\n"],"names":["sanitizeCollection","createFolderCollection","addFolderCollection","collectionSpecific","config","folderEnabledCollections","richTextSanitizationPromises","validRelationships","folders","folderCollectionConfig","slug","debug","folderFieldName","fieldName","collectionIndex","collections","push","Array","isArray","collectionOverrides","length","override","collection","sanitizedCollectionWithOverrides"],"mappings":";;;;AAGA,SAASA,kBAAkB,QAAQ,oCAAmC;AACtE,SAASC,sBAAsB,QAAQ,8BAA6B;;;AAE7D,eAAeC,oBAAoB,EACxCC,kBAAkB,EAClBC,MAAM,EACNC,wBAAwB,EACxBC,+BAA+B,EAAE,EACjCC,qBAAqB,EAAE,EAOxB;IACC,IAAIH,OAAOI,OAAO,KAAK,OAAO;QAC5B;IACF;IAEA,IAAIC,6BAAyBR,gMAAAA,EAAuB;QAClDS,MAAMN,OAAOI,OAAO,CAAEE,IAAI;QAC1BP;QACAQ,OAAOP,OAAOI,OAAO,CAAEG,KAAK;QAC5BN;QACAO,iBAAiBR,OAAOI,OAAO,CAAEK,SAAS;IAC5C;IAEA,MAAMC,kBAAkBV,OAAOW,WAAW,CAAEC,IAAI,CAACP;IAEjD,IACEQ,MAAMC,OAAO,CAACd,OAAOI,OAAO,EAAEW,wBAC9Bf,QAAQI,QAAQW,oBAAoBC,QACpC;QACA,KAAK,MAAMC,YAAYjB,OAAOI,OAAO,CAACW,mBAAmB,CAAE;YACzDV,yBAAyB,MAAMY,SAAS;gBAAEC,YAAYb;YAAuB;QAC/E;IACF;IAEA,MAAMc,mCAAmC,UAAMvB,4LAAAA,EAC7CI,QACAK,wBACAH,8BACAC;IAGFH,OAAOW,WAAY,CAACD,kBAAkB,EAAE,GAAGS;AAC7C"}},
    {"offset": {"line": 6260, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/folders/addFolderFieldToCollection.ts"],"sourcesContent":["import type { SanitizedCollectionConfig } from '../index.js'\n\nimport { buildFolderField } from './buildFolderField.js'\n\nexport const addFolderFieldToCollection = ({\n  collection,\n  collectionSpecific,\n  folderFieldName,\n  folderSlug,\n}: {\n  collection: SanitizedCollectionConfig\n  collectionSpecific: boolean\n  folderFieldName: string\n  folderSlug: string\n}): void => {\n  collection.fields.push(\n    buildFolderField({\n      collectionSpecific,\n      folderFieldName,\n      folderSlug,\n      overrides: {\n        admin: {\n          allowCreate: false,\n          allowEdit: false,\n          components: {\n            Cell: '@payloadcms/next/rsc#FolderTableCell',\n            Field: '@payloadcms/next/rsc#FolderField',\n          },\n        },\n      },\n    }),\n  )\n}\n"],"names":["buildFolderField","addFolderFieldToCollection","collection","collectionSpecific","folderFieldName","folderSlug","fields","push","overrides","admin","allowCreate","allowEdit","components","Cell","Field"],"mappings":";;;;AAEA,SAASA,gBAAgB,QAAQ,wBAAuB;;AAEjD,MAAMC,6BAA6B,CAAC,EACzCC,UAAU,EACVC,kBAAkB,EAClBC,eAAe,EACfC,UAAU,EAMX;IACCH,WAAWI,MAAM,CAACC,IAAI,KACpBP,oLAAAA,EAAiB;QACfG;QACAC;QACAC;QACAG,WAAW;YACTC,OAAO;gBACLC,aAAa;gBACbC,WAAW;gBACXC,YAAY;oBACVC,MAAM;oBACNC,OAAO;gBACT;YACF;QACF;IACF;AAEJ,EAAC"}},
    {"offset": {"line": 6287, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/folders/constants.ts"],"sourcesContent":["export const foldersSlug = 'payload-folders'\nexport const parentFolderFieldName = 'folder'\n"],"names":["foldersSlug","parentFolderFieldName"],"mappings":";;;;;;AAAO,MAAMA,cAAc,kBAAiB;AACrC,MAAMC,wBAAwB,SAAQ"}},
    {"offset": {"line": 6299, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/globals/operations/docAccess.ts"],"sourcesContent":["import type { SanitizedGlobalPermission } from '../../auth/index.js'\nimport type { AllOperations, JsonObject, PayloadRequest } from '../../types/index.js'\nimport type { SanitizedGlobalConfig } from '../config/types.js'\n\nimport { commitTransaction } from '../../utilities/commitTransaction.js'\nimport { getEntityPermissions } from '../../utilities/getEntityPermissions/getEntityPermissions.js'\nimport { initTransaction } from '../../utilities/initTransaction.js'\nimport { killTransaction } from '../../utilities/killTransaction.js'\nimport { sanitizePermissions } from '../../utilities/sanitizePermissions.js'\n\ntype Arguments = {\n  /**\n   * If the document data is passed, it will be used to check access instead of fetching the document from the database.\n   */\n  data?: JsonObject\n  globalConfig: SanitizedGlobalConfig\n  req: PayloadRequest\n}\n\nexport const docAccessOperation = async (args: Arguments): Promise<SanitizedGlobalPermission> => {\n  const { data, globalConfig, req } = args\n\n  const globalOperations: AllOperations[] = ['read', 'update']\n\n  if (globalConfig.versions) {\n    globalOperations.push('readVersions')\n  }\n\n  try {\n    const result = await getEntityPermissions({\n      id: undefined,\n      blockReferencesPermissions: {},\n      data,\n      entity: globalConfig,\n      entityType: 'global',\n      fetchData: true,\n      operations: globalOperations,\n      req,\n    })\n\n    const sanitizedPermissions = sanitizePermissions({\n      globals: {\n        [globalConfig.slug]: result,\n      },\n    })\n\n    const globalPermissions = sanitizedPermissions?.globals?.[globalConfig.slug]\n    return globalPermissions ?? { fields: {} }\n  } catch (e: unknown) {\n    await killTransaction(req)\n    throw e\n  }\n}\n"],"names":["getEntityPermissions","killTransaction","sanitizePermissions","docAccessOperation","args","data","globalConfig","req","globalOperations","versions","push","result","id","undefined","blockReferencesPermissions","entity","entityType","fetchData","operations","sanitizedPermissions","globals","slug","globalPermissions","fields","e"],"mappings":";;;;AAKA,SAASA,oBAAoB,QAAQ,+DAA8D;AAEnG,SAASC,eAAe,QAAQ,qCAAoC;AACpE,SAASC,mBAAmB,QAAQ,yCAAwC;;;;AAWrE,MAAMC,qBAAqB,OAAOC;IACvC,MAAM,EAAEC,IAAI,EAAEC,YAAY,EAAEC,GAAG,EAAE,GAAGH;IAEpC,MAAMI,mBAAoC;QAAC;QAAQ;KAAS;IAE5D,IAAIF,aAAaG,QAAQ,EAAE;QACzBD,iBAAiBE,IAAI,CAAC;IACxB;IAEA,IAAI;QACF,MAAMC,SAAS,UAAMX,sNAAAA,EAAqB;YACxCY,IAAIC;YACJC,4BAA4B,CAAC;YAC7BT;YACAU,QAAQT;YACRU,YAAY;YACZC,WAAW;YACXC,YAAYV;YACZD;QACF;QAEA,MAAMY,2BAAuBjB,4LAAAA,EAAoB;YAC/CkB,SAAS;gBACP,CAACd,aAAae,IAAI,CAAC,EAAEV;YACvB;QACF;QAEA,MAAMW,oBAAoBH,sBAAsBC,SAAS,CAACd,aAAae,IAAI,CAAC;QAC5E,OAAOC,qBAAqB;YAAEC,QAAQ,CAAC;QAAE;IAC3C,EAAE,OAAOC,GAAY;QACnB,UAAMvB,oLAAAA,EAAgBM;QACtB,MAAMiB;IACR;AACF,EAAC"}},
    {"offset": {"line": 6347, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/globals/endpoints/docAccess.ts"],"sourcesContent":["import { status as httpStatus } from 'http-status'\n\nimport type { PayloadHandler } from '../../config/types.js'\n\nimport { getRequestGlobal } from '../../utilities/getRequestEntity.js'\nimport { headersWithCors } from '../../utilities/headersWithCors.js'\nimport { docAccessOperation } from '../operations/docAccess.js'\n\nexport const docAccessHandler: PayloadHandler = async (req) => {\n  const globalConfig = getRequestGlobal(req)\n  const result = await docAccessOperation({\n    data: req.data,\n    globalConfig,\n    req,\n  })\n\n  return Response.json(result, {\n    headers: headersWithCors({\n      headers: new Headers(),\n      req,\n    }),\n    status: httpStatus.OK,\n  })\n}\n"],"names":["status","httpStatus","getRequestGlobal","headersWithCors","docAccessOperation","docAccessHandler","req","globalConfig","result","data","Response","json","headers","Headers","OK"],"mappings":";;;;;AAAA,SAASA,UAAUC,UAAU,QAAQ,cAAa;AAIlD,SAASC,gBAAgB,QAAQ,sCAAqC;AACtE,SAASC,eAAe,QAAQ,qCAAoC;AACpE,SAASC,kBAAkB,QAAQ,6BAA4B;;;;;AAExD,MAAMC,mBAAmC,OAAOC;IACrD,MAAMC,mBAAeL,sLAAAA,EAAiBI;IACtC,MAAME,SAAS,UAAMJ,6LAAAA,EAAmB;QACtCK,MAAMH,IAAIG,IAAI;QACdF;QACAD;IACF;IAEA,OAAOI,SAASC,IAAI,CAACH,QAAQ;QAC3BI,aAAST,oLAAAA,EAAgB;YACvBS,SAAS,IAAIC;YACbP;QACF;QACAN,QAAQC,sMAAAA,CAAWa,EAAE;IACvB;AACF,EAAC"}},
    {"offset": {"line": 6379, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/globals/operations/findOne.ts"],"sourcesContent":["import { ar } from '@payloadcms/translations/languages/ar'\n\nimport type { FindOptions } from '../../collections/operations/local/find.js'\nimport type { AccessResult } from '../../config/types.js'\nimport type {\n  JsonObject,\n  PayloadRequest,\n  PopulateType,\n  SelectType,\n  Where,\n} from '../../types/index.js'\nimport type { SanitizedGlobalConfig } from '../config/types.js'\n\nimport { executeAccess } from '../../auth/executeAccess.js'\nimport { NotFound } from '../../errors/NotFound.js'\nimport { afterRead, type AfterReadArgs } from '../../fields/hooks/afterRead/index.js'\nimport { lockedDocumentsCollectionSlug } from '../../locked-documents/config.js'\nimport { getSelectMode } from '../../utilities/getSelectMode.js'\nimport { hasDraftsEnabled } from '../../utilities/getVersionsConfig.js'\nimport { killTransaction } from '../../utilities/killTransaction.js'\nimport { sanitizeSelect } from '../../utilities/sanitizeSelect.js'\nimport { replaceWithDraftIfAvailable } from '../../versions/drafts/replaceWithDraftIfAvailable.js'\n\nexport type GlobalFindOneArgs = {\n  /**\n   * You may pass the document data directly which will skip the `db.findOne` database query.\n   * This is useful if you want to use this endpoint solely for running hooks and populating data.\n   */\n  data?: Record<string, unknown>\n  depth?: number\n  draft?: boolean\n  globalConfig: SanitizedGlobalConfig\n  includeLockStatus?: boolean\n  overrideAccess?: boolean\n  populate?: PopulateType\n  req: PayloadRequest\n  showHiddenFields?: boolean\n  slug: string\n} & Pick<AfterReadArgs<JsonObject>, 'flattenLocales'> &\n  Pick<FindOptions<string, SelectType>, 'select'>\n\nexport const findOneOperation = async <T extends Record<string, unknown>>(\n  args: GlobalFindOneArgs,\n): Promise<T> => {\n  const {\n    slug,\n    depth,\n    draft: replaceWithVersion = false,\n    flattenLocales,\n    globalConfig,\n    includeLockStatus: includeLockStatusFromArgs,\n    overrideAccess = false,\n    populate,\n    req: { fallbackLocale, locale },\n    req,\n    select: incomingSelect,\n    showHiddenFields,\n  } = args\n\n  const includeLockStatus =\n    includeLockStatusFromArgs && req.payload.collections?.[lockedDocumentsCollectionSlug]\n\n  try {\n    // /////////////////////////////////////\n    // beforeOperation - Global\n    // /////////////////////////////////////\n\n    if (globalConfig.hooks?.beforeOperation?.length) {\n      for (const hook of globalConfig.hooks.beforeOperation) {\n        args =\n          (await hook({\n            args,\n            context: args.req.context,\n            global: globalConfig,\n            operation: 'read',\n            overrideAccess,\n            req: args.req,\n          })) || args\n      }\n    }\n\n    // /////////////////////////////////////\n    // Retrieve and execute access\n    // /////////////////////////////////////\n\n    let accessResult!: AccessResult\n\n    if (!overrideAccess) {\n      accessResult = await executeAccess({ req }, globalConfig.access.read)\n    }\n\n    if (accessResult === false) {\n      throw new NotFound(req.t)\n    }\n\n    const select = sanitizeSelect({\n      fields: globalConfig.flattenedFields,\n      forceSelect: globalConfig.forceSelect,\n      select: incomingSelect,\n    })\n\n    // /////////////////////////////////////\n    // Perform database operation\n    // /////////////////////////////////////\n\n    let dbSelect = select\n\n    if (\n      globalConfig.versions?.drafts &&\n      replaceWithVersion &&\n      select &&\n      getSelectMode(select) === 'include'\n    ) {\n      dbSelect = { ...select, createdAt: true, updatedAt: true }\n    }\n    const docFromDB = await req.payload.db.findGlobal({\n      slug,\n      locale: locale!,\n      req,\n      select: dbSelect,\n      where: overrideAccess ? undefined : (accessResult as Where),\n    })\n\n    // Check if no document was returned (Postgres returns {} instead of null)\n    const hasDoc = docFromDB && Object.keys(docFromDB).length > 0\n\n    if (!hasDoc && !args.data && !overrideAccess && accessResult !== true) {\n      return {} as any\n    }\n\n    let doc = (args.data as any) ?? (hasDoc ? docFromDB : null) ?? {}\n\n    // /////////////////////////////////////\n    // Include Lock Status if required\n    // /////////////////////////////////////\n    if (includeLockStatus && slug) {\n      let lockStatus: JsonObject | null = null\n\n      try {\n        const lockDocumentsProp = globalConfig?.lockDocuments\n\n        const lockDurationDefault = 300 // Default 5 minutes in seconds\n        const lockDuration =\n          typeof lockDocumentsProp === 'object' ? lockDocumentsProp.duration : lockDurationDefault\n        const lockDurationInMilliseconds = lockDuration * 1000\n\n        const lockedDocument = await req.payload.find({\n          collection: lockedDocumentsCollectionSlug,\n          depth: 1,\n          limit: 1,\n          overrideAccess: false,\n          pagination: false,\n          req,\n          where: {\n            and: [\n              {\n                globalSlug: {\n                  equals: slug,\n                },\n              },\n              {\n                updatedAt: {\n                  greater_than: new Date(new Date().getTime() - lockDurationInMilliseconds),\n                },\n              },\n            ],\n          },\n        })\n\n        if (lockedDocument && lockedDocument.docs.length > 0) {\n          lockStatus = lockedDocument.docs[0]!\n        }\n      } catch {\n        // swallow error\n      }\n\n      doc._isLocked = !!lockStatus\n      doc._userEditing = lockStatus?.user?.value ?? null\n    }\n\n    // /////////////////////////////////////\n    // Replace document with draft if available\n    // /////////////////////////////////////\n\n    if (replaceWithVersion && hasDraftsEnabled(globalConfig)) {\n      doc = await replaceWithDraftIfAvailable({\n        accessResult,\n        doc,\n        entity: globalConfig,\n        entityType: 'global',\n        overrideAccess,\n        req,\n        select,\n      })\n    }\n\n    // /////////////////////////////////////\n    // Execute before global hook\n    // /////////////////////////////////////\n\n    if (globalConfig.hooks?.beforeRead?.length) {\n      for (const hook of globalConfig.hooks.beforeRead) {\n        doc =\n          (await hook({\n            context: req.context,\n            doc,\n            global: globalConfig,\n            overrideAccess,\n            req,\n          })) || doc\n      }\n    }\n\n    // /////////////////////////////////////\n    // Execute globalType field if not selected\n    // /////////////////////////////////////\n    if (select && doc.globalType) {\n      const selectMode = getSelectMode(select)\n      if (\n        (selectMode === 'include' && !select['globalType']) ||\n        (selectMode === 'exclude' && select['globalType'] === false)\n      ) {\n        delete doc['globalType']\n      }\n    }\n\n    // /////////////////////////////////////\n    // Execute field-level hooks and access\n    // /////////////////////////////////////\n\n    doc = await afterRead({\n      collection: null,\n      context: req.context,\n      depth: depth!,\n      doc,\n      draft: replaceWithVersion,\n      fallbackLocale: fallbackLocale!,\n      flattenLocales,\n      global: globalConfig,\n      locale: locale!,\n      overrideAccess,\n      populate,\n      req,\n      select,\n      showHiddenFields: showHiddenFields!,\n    })\n\n    // /////////////////////////////////////\n    // Execute after global hook\n    // /////////////////////////////////////\n\n    if (globalConfig.hooks?.afterRead?.length) {\n      for (const hook of globalConfig.hooks.afterRead) {\n        doc =\n          (await hook({\n            context: req.context,\n            doc,\n            global: globalConfig,\n            overrideAccess,\n            req,\n          })) || doc\n      }\n    }\n\n    // /////////////////////////////////////\n    // Return results\n    // /////////////////////////////////////\n\n    return doc\n  } catch (error: unknown) {\n    await killTransaction(req)\n    throw error\n  }\n}\n"],"names":["executeAccess","NotFound","afterRead","lockedDocumentsCollectionSlug","getSelectMode","hasDraftsEnabled","killTransaction","sanitizeSelect","replaceWithDraftIfAvailable","findOneOperation","args","slug","depth","draft","replaceWithVersion","flattenLocales","globalConfig","includeLockStatus","includeLockStatusFromArgs","overrideAccess","populate","req","fallbackLocale","locale","select","incomingSelect","showHiddenFields","payload","collections","hooks","beforeOperation","length","hook","context","global","operation","accessResult","access","read","t","fields","flattenedFields","forceSelect","dbSelect","versions","drafts","createdAt","updatedAt","docFromDB","db","findGlobal","where","undefined","hasDoc","Object","keys","data","doc","lockStatus","lockDocumentsProp","lockDocuments","lockDurationDefault","lockDuration","duration","lockDurationInMilliseconds","lockedDocument","find","collection","limit","pagination","and","globalSlug","equals","greater_than","Date","getTime","docs","_isLocked","_userEditing","user","value","entity","entityType","beforeRead","globalType","selectMode","error"],"mappings":"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"}},
    {"offset": {"line": 6586, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/globals/endpoints/findOne.ts"],"sourcesContent":["import { status as httpStatus } from 'http-status'\n\nimport type { PayloadHandler } from '../../config/types.js'\n\nimport { getRequestGlobal } from '../../utilities/getRequestEntity.js'\nimport { headersWithCors } from '../../utilities/headersWithCors.js'\nimport { isNumber } from '../../utilities/isNumber.js'\nimport { sanitizePopulateParam } from '../../utilities/sanitizePopulateParam.js'\nimport { sanitizeSelectParam } from '../../utilities/sanitizeSelectParam.js'\nimport { findOneOperation } from '../operations/findOne.js'\n\nexport const findOneHandler: PayloadHandler = async (req) => {\n  const globalConfig = getRequestGlobal(req)\n  const { data, searchParams } = req\n  const depth = data ? data.depth : searchParams.get('depth')\n  const flattenLocales = data\n    ? data.flattenLocales\n    : searchParams.has('flattenLocales')\n      ? searchParams.get('flattenLocales') === 'true'\n      : // flattenLocales should be undfined if not provided, so that the default (true) is applied in the operation\n        undefined\n\n  const result = await findOneOperation({\n    slug: globalConfig.slug,\n    data: data\n      ? data?.data\n      : searchParams.get('data')\n        ? JSON.parse(searchParams.get('data') as string)\n        : undefined,\n    depth: isNumber(depth) ? Number(depth) : undefined,\n    draft: data ? data.draft : searchParams.get('draft') === 'true',\n    flattenLocales,\n    globalConfig,\n    populate: sanitizePopulateParam(req.query.populate),\n    req,\n    select: sanitizeSelectParam(req.query.select),\n  })\n\n  return Response.json(result, {\n    headers: headersWithCors({\n      headers: new Headers(),\n      req,\n    }),\n    status: httpStatus.OK,\n  })\n}\n"],"names":["status","httpStatus","getRequestGlobal","headersWithCors","isNumber","sanitizePopulateParam","sanitizeSelectParam","findOneOperation","findOneHandler","req","globalConfig","data","searchParams","depth","get","flattenLocales","has","undefined","result","slug","JSON","parse","Number","draft","populate","query","select","Response","json","headers","Headers","OK"],"mappings":";;;;;AAAA,SAASA,UAAUC,UAAU,QAAQ,cAAa;AAIlD,SAASC,gBAAgB,QAAQ,sCAAqC;AACtE,SAASC,eAAe,QAAQ,qCAAoC;AACpE,SAASC,QAAQ,QAAQ,8BAA6B;AACtD,SAASC,qBAAqB,QAAQ,2CAA0C;AAChF,SAASC,mBAAmB,QAAQ,yCAAwC;AAC5E,SAASC,gBAAgB,QAAQ,2BAA0B;;;;;;;;AAEpD,MAAMC,iBAAiC,OAAOC;IACnD,MAAMC,mBAAeR,sLAAAA,EAAiBO;IACtC,MAAM,EAAEE,IAAI,EAAEC,YAAY,EAAE,GAAGH;IAC/B,MAAMI,QAAQF,OAAOA,KAAKE,KAAK,GAAGD,aAAaE,GAAG,CAAC;IACnD,MAAMC,iBAAiBJ,OACnBA,KAAKI,cAAc,GACnBH,aAAaI,GAAG,CAAC,oBACfJ,aAAaE,GAAG,CAAC,sBAAsB,SAEvCG;IAEN,MAAMC,SAAS,UAAMX,yLAAAA,EAAiB;QACpCY,MAAMT,aAAaS,IAAI;QACvBR,MAAMA,OACFA,MAAMA,OACNC,aAAaE,GAAG,CAAC,UACfM,KAAKC,KAAK,CAACT,aAAaE,GAAG,CAAC,WAC5BG;QACNJ,WAAOT,sKAAAA,EAASS,SAASS,OAAOT,SAASI;QACzCM,OAAOZ,OAAOA,KAAKY,KAAK,GAAGX,aAAaE,GAAG,CAAC,aAAa;QACzDC;QACAL;QACAc,cAAUnB,gMAAAA,EAAsBI,IAAIgB,KAAK,CAACD,QAAQ;QAClDf;QACAiB,YAAQpB,4LAAAA,EAAoBG,IAAIgB,KAAK,CAACC,MAAM;IAC9C;IAEA,OAAOC,SAASC,IAAI,CAACV,QAAQ;QAC3BW,aAAS1B,oLAAAA,EAAgB;YACvB0B,SAAS,IAAIC;YACbrB;QACF;QACAT,QAAQC,sMAAAA,CAAW8B,EAAE;IACvB;AACF,EAAC"}},
    {"offset": {"line": 6633, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/globals/operations/findVersionByID.ts"],"sourcesContent":["import type { FindOptions } from '../../collections/operations/local/find.js'\nimport type { FindGlobalVersionsArgs } from '../../database/types.js'\nimport type { PayloadRequest, PopulateType, SelectType } from '../../types/index.js'\nimport type { TypeWithVersion } from '../../versions/types.js'\nimport type { SanitizedGlobalConfig } from '../config/types.js'\n\nimport { executeAccess } from '../../auth/executeAccess.js'\nimport { combineQueries } from '../../database/combineQueries.js'\nimport { Forbidden, NotFound } from '../../errors/index.js'\nimport { afterRead } from '../../fields/hooks/afterRead/index.js'\nimport { deepCopyObjectSimple } from '../../utilities/deepCopyObject.js'\nimport { killTransaction } from '../../utilities/killTransaction.js'\nimport { sanitizeSelect } from '../../utilities/sanitizeSelect.js'\nimport { buildVersionGlobalFields } from '../../versions/buildGlobalFields.js'\nimport { getQueryDraftsSelect } from '../../versions/drafts/getQueryDraftsSelect.js'\n\nexport type Arguments = {\n  currentDepth?: number\n  depth?: number\n  disableErrors?: boolean\n  globalConfig: SanitizedGlobalConfig\n  id: number | string\n  overrideAccess?: boolean\n  populate?: PopulateType\n  req: PayloadRequest\n  showHiddenFields?: boolean\n} & Pick<FindOptions<string, SelectType>, 'select'>\n\nexport const findVersionByIDOperation = async <T extends TypeWithVersion<T> = any>(\n  args: Arguments,\n): Promise<T> => {\n  const {\n    id,\n    currentDepth,\n    depth,\n    disableErrors,\n    globalConfig,\n    overrideAccess,\n    populate,\n    req: { fallbackLocale, locale, payload },\n    req,\n    select: incomingSelect,\n    showHiddenFields,\n  } = args\n\n  try {\n    // /////////////////////////////////////\n    // Access\n    // /////////////////////////////////////\n\n    const accessResults = !overrideAccess\n      ? await executeAccess({ id, disableErrors, req }, globalConfig.access.readVersions)\n      : true\n\n    // If errors are disabled, and access returns false, return null\n    if (accessResults === false) {\n      return null!\n    }\n\n    const hasWhereAccess = typeof accessResults === 'object'\n\n    const select = sanitizeSelect({\n      fields: buildVersionGlobalFields(payload.config, globalConfig, true),\n      forceSelect: getQueryDraftsSelect({ select: globalConfig.forceSelect }),\n      select: incomingSelect,\n      versions: true,\n    })\n\n    const findGlobalVersionsArgs: FindGlobalVersionsArgs = {\n      global: globalConfig.slug,\n      limit: 1,\n      locale: locale!,\n      req,\n      select,\n      where: combineQueries({ id: { equals: id } }, accessResults),\n    }\n\n    // /////////////////////////////////////\n    // Find by ID\n    // /////////////////////////////////////\n\n    if (!findGlobalVersionsArgs.where?.and?.[0]?.id) {\n      throw new NotFound(req.t)\n    }\n\n    const { docs: results } = await payload.db.findGlobalVersions(findGlobalVersionsArgs)\n    if (!results || results?.length === 0) {\n      if (!disableErrors) {\n        if (!hasWhereAccess) {\n          throw new NotFound(req.t)\n        }\n        if (hasWhereAccess) {\n          throw new Forbidden(req.t)\n        }\n      }\n\n      return null!\n    }\n\n    // Clone the result - it may have come back memoized\n    let result: any = deepCopyObjectSimple(results[0])\n\n    if (!result.version) {\n      result.version = {}\n    }\n\n    // Patch globalType onto version doc\n    result.version.globalType = globalConfig.slug\n\n    // /////////////////////////////////////\n    // beforeRead - Collection\n    // /////////////////////////////////////\n\n    if (globalConfig.hooks?.beforeRead?.length) {\n      for (const hook of globalConfig.hooks.beforeRead) {\n        result =\n          (await hook({\n            context: req.context,\n            doc: result.version,\n            global: globalConfig,\n            overrideAccess,\n            req,\n          })) || result.version\n      }\n    }\n\n    // /////////////////////////////////////\n    // afterRead - Fields\n    // /////////////////////////////////////\n\n    result.version = await afterRead({\n      collection: null,\n      context: req.context,\n      currentDepth,\n      depth: depth!,\n      doc: result.version,\n      draft: undefined!,\n      fallbackLocale: fallbackLocale!,\n      global: globalConfig,\n      locale: locale!,\n      overrideAccess: overrideAccess!,\n      populate,\n      req,\n      select: typeof select?.version === 'object' ? select.version : undefined,\n      showHiddenFields: showHiddenFields!,\n    })\n\n    // /////////////////////////////////////\n    // afterRead - Global\n    // /////////////////////////////////////\n\n    if (globalConfig.hooks?.afterRead?.length) {\n      for (const hook of globalConfig.hooks.afterRead) {\n        result.version =\n          (await hook({\n            context: req.context,\n            doc: result.version,\n            global: globalConfig,\n            overrideAccess,\n            query: findGlobalVersionsArgs.where,\n            req,\n          })) || result.version\n      }\n    }\n\n    return result\n  } catch (error: unknown) {\n    await killTransaction(req)\n    throw error\n  }\n}\n"],"names":["executeAccess","combineQueries","Forbidden","NotFound","afterRead","deepCopyObjectSimple","killTransaction","sanitizeSelect","buildVersionGlobalFields","getQueryDraftsSelect","findVersionByIDOperation","args","id","currentDepth","depth","disableErrors","globalConfig","overrideAccess","populate","req","fallbackLocale","locale","payload","select","incomingSelect","showHiddenFields","accessResults","access","readVersions","hasWhereAccess","fields","config","forceSelect","versions","findGlobalVersionsArgs","global","slug","limit","where","equals","and","t","docs","results","db","findGlobalVersions","length","result","version","globalType","hooks","beforeRead","hook","context","doc","collection","draft","undefined","query","error"],"mappings":"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"}},
    {"offset": {"line": 6775, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/globals/endpoints/findVersionByID.ts"],"sourcesContent":["import { status as httpStatus } from 'http-status'\n\nimport type { PayloadHandler } from '../../config/types.js'\n\nimport { getRequestGlobal } from '../../utilities/getRequestEntity.js'\nimport { headersWithCors } from '../../utilities/headersWithCors.js'\nimport { isNumber } from '../../utilities/isNumber.js'\nimport { sanitizePopulateParam } from '../../utilities/sanitizePopulateParam.js'\nimport { sanitizeSelectParam } from '../../utilities/sanitizeSelectParam.js'\nimport { findVersionByIDOperation } from '../operations/findVersionByID.js'\n\nexport const findVersionByIDHandler: PayloadHandler = async (req) => {\n  const globalConfig = getRequestGlobal(req)\n  const { searchParams } = req\n  const depth = searchParams.get('depth')\n\n  const result = await findVersionByIDOperation({\n    id: req.routeParams!.id as string,\n    depth: isNumber(depth) ? Number(depth) : undefined,\n    globalConfig,\n    populate: sanitizePopulateParam(req.query.populate),\n    req,\n    select: sanitizeSelectParam(req.query.select),\n  })\n\n  return Response.json(result, {\n    headers: headersWithCors({\n      headers: new Headers(),\n      req,\n    }),\n    status: httpStatus.OK,\n  })\n}\n"],"names":["status","httpStatus","getRequestGlobal","headersWithCors","isNumber","sanitizePopulateParam","sanitizeSelectParam","findVersionByIDOperation","findVersionByIDHandler","req","globalConfig","searchParams","depth","get","result","id","routeParams","Number","undefined","populate","query","select","Response","json","headers","Headers","OK"],"mappings":";;;;;AAAA,SAASA,UAAUC,UAAU,QAAQ,cAAa;AAIlD,SAASC,gBAAgB,QAAQ,sCAAqC;AACtE,SAASC,eAAe,QAAQ,qCAAoC;AACpE,SAASC,QAAQ,QAAQ,8BAA6B;AACtD,SAASC,qBAAqB,QAAQ,2CAA0C;AAChF,SAASC,mBAAmB,QAAQ,yCAAwC;AAC5E,SAASC,wBAAwB,QAAQ,mCAAkC;;;;;;;;AAEpE,MAAMC,yBAAyC,OAAOC;IAC3D,MAAMC,mBAAeR,sLAAAA,EAAiBO;IACtC,MAAM,EAAEE,YAAY,EAAE,GAAGF;IACzB,MAAMG,QAAQD,aAAaE,GAAG,CAAC;IAE/B,MAAMC,SAAS,UAAMP,yMAAAA,EAAyB;QAC5CQ,IAAIN,IAAIO,WAAW,CAAED,EAAE;QACvBH,WAAOR,sKAAAA,EAASQ,SAASK,OAAOL,SAASM;QACzCR;QACAS,cAAUd,gMAAAA,EAAsBI,IAAIW,KAAK,CAACD,QAAQ;QAClDV;QACAY,YAAQf,4LAAAA,EAAoBG,IAAIW,KAAK,CAACC,MAAM;IAC9C;IAEA,OAAOC,SAASC,IAAI,CAACT,QAAQ;QAC3BU,aAASrB,oLAAAA,EAAgB;YACvBqB,SAAS,IAAIC;YACbhB;QACF;QACAT,QAAQC,sMAAAA,CAAWyB,EAAE;IACvB;AACF,EAAC"}},
    {"offset": {"line": 6818, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/globals/operations/findVersions.ts"],"sourcesContent":["import type { FindOptions } from '../../collections/operations/local/find.js'\nimport type { PaginatedDocs } from '../../database/types.js'\nimport type { PayloadRequest, PopulateType, SelectType, Sort, Where } from '../../types/index.js'\nimport type { TypeWithVersion } from '../../versions/types.js'\nimport type { SanitizedGlobalConfig } from '../config/types.js'\n\nimport { executeAccess } from '../../auth/executeAccess.js'\nimport { combineQueries } from '../../database/combineQueries.js'\nimport { validateQueryPaths } from '../../database/queryValidation/validateQueryPaths.js'\nimport { afterRead } from '../../fields/hooks/afterRead/index.js'\nimport { killTransaction } from '../../utilities/killTransaction.js'\nimport { sanitizeInternalFields } from '../../utilities/sanitizeInternalFields.js'\nimport { sanitizeSelect } from '../../utilities/sanitizeSelect.js'\nimport { buildVersionGlobalFields } from '../../versions/buildGlobalFields.js'\nimport { getQueryDraftsSelect } from '../../versions/drafts/getQueryDraftsSelect.js'\n\nexport type Arguments = {\n  depth?: number\n  globalConfig: SanitizedGlobalConfig\n  limit?: number\n  overrideAccess?: boolean\n  page?: number\n  pagination?: boolean\n  populate?: PopulateType\n  req?: PayloadRequest\n  showHiddenFields?: boolean\n  sort?: Sort\n  where?: Where\n} & Pick<FindOptions<string, SelectType>, 'select'>\n\nexport const findVersionsOperation = async <T extends TypeWithVersion<T>>(\n  args: Arguments,\n): Promise<PaginatedDocs<T>> => {\n  const {\n    depth,\n    globalConfig,\n    limit,\n    overrideAccess,\n    page,\n    pagination = true,\n    populate,\n    select: incomingSelect,\n    showHiddenFields,\n    sort,\n    where,\n  } = args\n  const req = args.req!\n  const { fallbackLocale, locale, payload } = req\n\n  const versionFields = buildVersionGlobalFields(payload.config, globalConfig, true)\n\n  try {\n    // /////////////////////////////////////\n    // Access\n    // /////////////////////////////////////\n\n    const accessResults = !overrideAccess\n      ? await executeAccess({ req }, globalConfig.access.readVersions)\n      : true\n\n    await validateQueryPaths({\n      globalConfig,\n      overrideAccess: overrideAccess!,\n      req,\n      versionFields,\n      where: where!,\n    })\n\n    const fullWhere = combineQueries(where!, accessResults)\n\n    const select = sanitizeSelect({\n      fields: buildVersionGlobalFields(payload.config, globalConfig, true),\n      forceSelect: getQueryDraftsSelect({ select: globalConfig.forceSelect }),\n      select: incomingSelect,\n      versions: true,\n    })\n\n    // /////////////////////////////////////\n    // Find\n    // /////////////////////////////////////\n\n    const usePagination = pagination && limit !== 0\n    const sanitizedLimit = limit ?? (usePagination ? 10 : 0)\n    const sanitizedPage = page || 1\n\n    const paginatedDocs = await payload.db.findGlobalVersions<T>({\n      global: globalConfig.slug,\n      limit: sanitizedLimit,\n      locale: locale!,\n      page: sanitizedPage,\n      pagination,\n      req,\n      select,\n      sort,\n      where: fullWhere,\n    })\n\n    // /////////////////////////////////////\n    // afterRead - Fields\n    // /////////////////////////////////////\n\n    let result = {\n      ...paginatedDocs,\n      docs: await Promise.all(\n        paginatedDocs.docs.map(async (data) => {\n          if (!data.version) {\n            // Fallback if not selected\n            ;(data as any).version = {}\n          }\n          return {\n            ...data,\n            version: await afterRead<T>({\n              collection: null,\n              context: req.context,\n              depth: depth!,\n              doc: {\n                ...data.version,\n                // Patch globalType onto version doc\n                globalType: globalConfig.slug,\n              },\n              draft: undefined!,\n              fallbackLocale: fallbackLocale!,\n              findMany: true,\n              global: globalConfig,\n              locale: locale!,\n              overrideAccess: overrideAccess!,\n              populate,\n              req,\n              select,\n              showHiddenFields: showHiddenFields!,\n            }),\n          }\n        }),\n      ),\n    } as PaginatedDocs<T>\n\n    // /////////////////////////////////////\n    // afterRead - Global\n    // /////////////////////////////////////\n\n    if (globalConfig.hooks?.afterRead?.length) {\n      result.docs = await Promise.all(\n        result.docs.map(async (doc) => {\n          const docRef = doc\n\n          for (const hook of globalConfig.hooks.afterRead) {\n            docRef.version =\n              (await hook({\n                context: req.context,\n                doc: doc.version,\n                findMany: true,\n                global: globalConfig,\n                overrideAccess,\n                query: fullWhere,\n                req,\n              })) || doc.version\n          }\n\n          return docRef\n        }),\n      )\n    }\n\n    // /////////////////////////////////////\n    // Return results\n    // /////////////////////////////////////\n\n    result = {\n      ...result,\n      docs: result.docs.map((doc) => sanitizeInternalFields<T>(doc)),\n    }\n\n    return result\n  } catch (error: unknown) {\n    await killTransaction(req)\n    throw error\n  }\n}\n"],"names":["executeAccess","combineQueries","validateQueryPaths","afterRead","killTransaction","sanitizeInternalFields","sanitizeSelect","buildVersionGlobalFields","getQueryDraftsSelect","findVersionsOperation","args","depth","globalConfig","limit","overrideAccess","page","pagination","populate","select","incomingSelect","showHiddenFields","sort","where","req","fallbackLocale","locale","payload","versionFields","config","accessResults","access","readVersions","fullWhere","fields","forceSelect","versions","usePagination","sanitizedLimit","sanitizedPage","paginatedDocs","db","findGlobalVersions","global","slug","result","docs","Promise","all","map","data","version","collection","context","doc","globalType","draft","undefined","findMany","hooks","length","docRef","hook","query","error"],"mappings":"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"}},
    {"offset": {"line": 6958, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/globals/endpoints/findVersions.ts"],"sourcesContent":["import { status as httpStatus } from 'http-status'\n\nimport type { PayloadHandler } from '../../config/types.js'\nimport type { Where } from '../../types/index.js'\n\nimport { getRequestGlobal } from '../../utilities/getRequestEntity.js'\nimport { headersWithCors } from '../../utilities/headersWithCors.js'\nimport { isNumber } from '../../utilities/isNumber.js'\nimport { sanitizePopulateParam } from '../../utilities/sanitizePopulateParam.js'\nimport { sanitizeSelectParam } from '../../utilities/sanitizeSelectParam.js'\nimport { sanitizeSortParams } from '../../utilities/sanitizeSortParams.js'\nimport { findVersionsOperation } from '../operations/findVersions.js'\n\nexport const findVersionsHandler: PayloadHandler = async (req) => {\n  const globalConfig = getRequestGlobal(req)\n  const { depth, limit, page, pagination, populate, select, sort, where } = req.query as {\n    depth?: string\n    limit?: string\n    page?: string\n    pagination?: string\n    populate?: Record<string, unknown>\n    select?: Record<string, unknown>\n    sort?: string | string[]\n    where?: Where\n  }\n\n  const result = await findVersionsOperation({\n    depth: isNumber(depth) ? Number(depth) : undefined,\n    globalConfig,\n    limit: isNumber(limit) ? Number(limit) : undefined,\n    page: isNumber(page) ? Number(page) : undefined,\n    pagination: pagination === 'false' ? false : undefined,\n    populate: sanitizePopulateParam(populate),\n    req,\n    select: sanitizeSelectParam(select),\n    sort: sanitizeSortParams(sort),\n    where,\n  })\n\n  return Response.json(result, {\n    headers: headersWithCors({\n      headers: new Headers(),\n      req,\n    }),\n    status: httpStatus.OK,\n  })\n}\n"],"names":["status","httpStatus","getRequestGlobal","headersWithCors","isNumber","sanitizePopulateParam","sanitizeSelectParam","sanitizeSortParams","findVersionsOperation","findVersionsHandler","req","globalConfig","depth","limit","page","pagination","populate","select","sort","where","query","result","Number","undefined","Response","json","headers","Headers","OK"],"mappings":";;;;;AAAA,SAASA,UAAUC,UAAU,QAAQ,cAAa;AAKlD,SAASC,gBAAgB,QAAQ,sCAAqC;AACtE,SAASC,eAAe,QAAQ,qCAAoC;AACpE,SAASC,QAAQ,QAAQ,8BAA6B;AACtD,SAASC,qBAAqB,QAAQ,2CAA0C;AAChF,SAASC,mBAAmB,QAAQ,yCAAwC;AAC5E,SAASC,kBAAkB,QAAQ,wCAAuC;AAC1E,SAASC,qBAAqB,QAAQ,gCAA+B;;;;;;;;;AAE9D,MAAMC,sBAAsC,OAAOC;IACxD,MAAMC,mBAAeT,sLAAAA,EAAiBQ;IACtC,MAAM,EAAEE,KAAK,EAAEC,KAAK,EAAEC,IAAI,EAAEC,UAAU,EAAEC,QAAQ,EAAEC,MAAM,EAAEC,IAAI,EAAEC,KAAK,EAAE,GAAGT,IAAIU,KAAK;IAWnF,MAAMC,SAAS,UAAMb,mMAAAA,EAAsB;QACzCI,WAAOR,sKAAAA,EAASQ,SAASU,OAAOV,SAASW;QACzCZ;QACAE,WAAOT,sKAAAA,EAASS,SAASS,OAAOT,SAASU;QACzCT,UAAMV,sKAAAA,EAASU,QAAQQ,OAAOR,QAAQS;QACtCR,YAAYA,eAAe,UAAU,QAAQQ;QAC7CP,cAAUX,gMAAAA,EAAsBW;QAChCN;QACAO,YAAQX,4LAAAA,EAAoBW;QAC5BC,UAAMX,0LAAAA,EAAmBW;QACzBC;IACF;IAEA,OAAOK,SAASC,IAAI,CAACJ,QAAQ;QAC3BK,aAASvB,oLAAAA,EAAgB;YACvBuB,SAAS,IAAIC;YACbjB;QACF;QACAV,QAAQC,sMAAAA,CAAW2B,EAAE;IACvB;AACF,EAAC"}},
    {"offset": {"line": 7006, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/globals/operations/restoreVersion.ts"],"sourcesContent":["import type { PayloadRequest, PopulateType } from '../../types/index.js'\nimport type { TypeWithVersion } from '../../versions/types.js'\nimport type { SanitizedGlobalConfig } from '../config/types.js'\n\nimport { executeAccess } from '../../auth/executeAccess.js'\nimport { NotFound } from '../../errors/index.js'\nimport { afterChange } from '../../fields/hooks/afterChange/index.js'\nimport { afterRead } from '../../fields/hooks/afterRead/index.js'\nimport { commitTransaction } from '../../utilities/commitTransaction.js'\nimport { initTransaction } from '../../utilities/initTransaction.js'\nimport { killTransaction } from '../../utilities/killTransaction.js'\n\nexport type Arguments = {\n  depth?: number\n  draft?: boolean\n  globalConfig: SanitizedGlobalConfig\n  id: number | string\n  overrideAccess?: boolean\n  populate?: PopulateType\n  req?: PayloadRequest\n  showHiddenFields?: boolean\n}\n\nexport const restoreVersionOperation = async <T extends TypeWithVersion<T> = any>(\n  args: Arguments,\n): Promise<T> => {\n  const { id, depth, draft, globalConfig, overrideAccess, populate, showHiddenFields } = args\n  const req = args.req!\n  const { fallbackLocale, locale, payload } = req\n\n  try {\n    const shouldCommit = await initTransaction(req)\n\n    // /////////////////////////////////////\n    // beforeOperation - Global\n    // /////////////////////////////////////\n\n    if (globalConfig.hooks?.beforeOperation?.length) {\n      for (const hook of globalConfig.hooks.beforeOperation) {\n        args =\n          (await hook({\n            args,\n            context: req.context,\n            global: globalConfig,\n            operation: 'restoreVersion',\n            overrideAccess,\n            req,\n          })) || args\n      }\n    }\n\n    // /////////////////////////////////////\n    // Access\n    // /////////////////////////////////////\n\n    if (!overrideAccess) {\n      await executeAccess({ req }, globalConfig.access.update)\n    }\n\n    // /////////////////////////////////////\n    // Retrieve original raw version\n    // /////////////////////////////////////\n\n    const { docs: versionDocs } = await payload.db.findGlobalVersions<any>({\n      global: globalConfig.slug,\n      limit: 1,\n      req,\n      where: { id: { equals: id } },\n    })\n\n    if (!versionDocs || versionDocs.length === 0) {\n      throw new NotFound(req.t)\n    }\n\n    const rawVersion = versionDocs[0]!\n\n    // Patch globalType onto version doc\n    rawVersion.version.globalType = globalConfig.slug\n\n    // Overwrite draft status if draft is true\n\n    if (draft) {\n      rawVersion.version._status = 'draft'\n    }\n    // /////////////////////////////////////\n    // fetch previousDoc\n    // /////////////////////////////////////\n\n    const previousDoc = await payload.findGlobal({\n      slug: globalConfig.slug,\n      depth,\n      req,\n    })\n\n    // /////////////////////////////////////\n    // Update global\n    // /////////////////////////////////////\n\n    const global = await payload.db.findGlobal({\n      slug: globalConfig.slug,\n      req,\n    })\n\n    let result = rawVersion.version\n\n    if (global) {\n      // Ensure updatedAt date is always updated\n      result.updatedAt = new Date().toISOString()\n      result = await payload.db.updateGlobal({\n        slug: globalConfig.slug,\n        data: result,\n        req,\n      })\n\n      const now = new Date().toISOString()\n\n      result = await payload.db.createGlobalVersion({\n        autosave: false,\n        createdAt: result.createdAt ? new Date(result.createdAt).toISOString() : now,\n        globalSlug: globalConfig.slug,\n        req,\n        updatedAt: draft ? now : new Date(result.updatedAt).toISOString(),\n        versionData: result,\n      })\n    } else {\n      result = await payload.db.createGlobal({\n        slug: globalConfig.slug,\n        data: result,\n        req,\n      })\n    }\n\n    // /////////////////////////////////////\n    // afterRead - Fields\n    // /////////////////////////////////////\n\n    result = await afterRead({\n      collection: null,\n      context: req.context,\n      depth: depth!,\n      doc: result,\n      draft: undefined!,\n      fallbackLocale: fallbackLocale!,\n      global: globalConfig,\n      locale: locale!,\n      overrideAccess: overrideAccess!,\n      populate,\n      req,\n      showHiddenFields: showHiddenFields!,\n    })\n\n    // /////////////////////////////////////\n    // afterRead - Global\n    // /////////////////////////////////////\n\n    if (globalConfig.hooks?.afterRead?.length) {\n      for (const hook of globalConfig.hooks.afterRead) {\n        result =\n          (await hook({\n            context: req.context,\n            doc: result,\n            global: globalConfig,\n            overrideAccess,\n            req,\n          })) || result\n      }\n    }\n\n    // /////////////////////////////////////\n    // afterChange - Fields\n    // /////////////////////////////////////\n\n    result = await afterChange({\n      collection: null,\n      context: req.context,\n      data: result,\n      doc: result,\n      global: globalConfig,\n      operation: 'update',\n      previousDoc,\n      req,\n    })\n\n    // /////////////////////////////////////\n    // afterChange - Global\n    // /////////////////////////////////////\n\n    if (globalConfig.hooks?.afterChange?.length) {\n      for (const hook of globalConfig.hooks.afterChange) {\n        result =\n          (await hook({\n            context: req.context,\n            data: result,\n            doc: result,\n            global: globalConfig,\n            overrideAccess,\n            previousDoc,\n            req,\n          })) || result\n      }\n    }\n\n    if (shouldCommit) {\n      await commitTransaction(req)\n    }\n\n    return result\n  } catch (error: unknown) {\n    await killTransaction(req)\n    throw error\n  }\n}\n"],"names":["executeAccess","NotFound","afterChange","afterRead","commitTransaction","initTransaction","killTransaction","restoreVersionOperation","args","id","depth","draft","globalConfig","overrideAccess","populate","showHiddenFields","req","fallbackLocale","locale","payload","shouldCommit","hooks","beforeOperation","length","hook","context","global","operation","access","update","docs","versionDocs","db","findGlobalVersions","slug","limit","where","equals","t","rawVersion","version","globalType","_status","previousDoc","findGlobal","result","updatedAt","Date","toISOString","updateGlobal","data","now","createGlobalVersion","autosave","createdAt","globalSlug","versionData","createGlobal","collection","doc","undefined","error"],"mappings":";;;;AAIA,SAASA,aAAa,QAAQ,8BAA6B;AAC3D,SAASC,QAAQ,QAAQ,wBAAuB;AAChD,SAASC,WAAW,QAAQ,0CAAyC;AACrE,SAASC,SAAS,QAAQ,wCAAuC;AACjE,SAASC,iBAAiB,QAAQ,uCAAsC;AACxE,SAASC,eAAe,QAAQ,qCAAoC;AACpE,SAASC,eAAe,QAAQ,qCAAoC;;;;;;;;AAa7D,MAAMC,0BAA0B,OACrCC;IAEA,MAAM,EAAEC,EAAE,EAAEC,KAAK,EAAEC,KAAK,EAAEC,YAAY,EAAEC,cAAc,EAAEC,QAAQ,EAAEC,gBAAgB,EAAE,GAAGP;IACvF,MAAMQ,MAAMR,KAAKQ,GAAG;IACpB,MAAM,EAAEC,cAAc,EAAEC,MAAM,EAAEC,OAAO,EAAE,GAAGH;IAE5C,IAAI;QACF,MAAMI,eAAe,UAAMf,oLAAAA,EAAgBW;QAE3C,wCAAwC;QACxC,2BAA2B;QAC3B,wCAAwC;QAExC,IAAIJ,aAAaS,KAAK,EAAEC,iBAAiBC,QAAQ;YAC/C,KAAK,MAAMC,QAAQZ,aAAaS,KAAK,CAACC,eAAe,CAAE;gBACrDd,OACG,MAAMgB,KAAK;oBACVhB;oBACAiB,SAAST,IAAIS,OAAO;oBACpBC,QAAQd;oBACRe,WAAW;oBACXd;oBACAG;gBACF,MAAOR;YACX;QACF;QAEA,wCAAwC;QACxC,SAAS;QACT,wCAAwC;QAExC,IAAI,CAACK,gBAAgB;YACnB,UAAMb,2KAAAA,EAAc;gBAAEgB;YAAI,GAAGJ,aAAagB,MAAM,CAACC,MAAM;QACzD;QAEA,wCAAwC;QACxC,gCAAgC;QAChC,wCAAwC;QAExC,MAAM,EAAEC,MAAMC,WAAW,EAAE,GAAG,MAAMZ,QAAQa,EAAE,CAACC,kBAAkB,CAAM;YACrEP,QAAQd,aAAasB,IAAI;YACzBC,OAAO;YACPnB;YACAoB,OAAO;gBAAE3B,IAAI;oBAAE4B,QAAQ5B;gBAAG;YAAE;QAC9B;QAEA,IAAI,CAACsB,eAAeA,YAAYR,MAAM,KAAK,GAAG;YAC5C,MAAM,IAAItB,mKAAAA,CAASe,IAAIsB,CAAC;QAC1B;QAEA,MAAMC,aAAaR,WAAW,CAAC,EAAE;QAEjC,oCAAoC;QACpCQ,WAAWC,OAAO,CAACC,UAAU,GAAG7B,aAAasB,IAAI;QAEjD,0CAA0C;QAE1C,IAAIvB,OAAO;YACT4B,WAAWC,OAAO,CAACE,OAAO,GAAG;QAC/B;QACA,wCAAwC;QACxC,oBAAoB;QACpB,wCAAwC;QAExC,MAAMC,cAAc,MAAMxB,QAAQyB,UAAU,CAAC;YAC3CV,MAAMtB,aAAasB,IAAI;YACvBxB;YACAM;QACF;QAEA,wCAAwC;QACxC,gBAAgB;QAChB,wCAAwC;QAExC,MAAMU,SAAS,MAAMP,QAAQa,EAAE,CAACY,UAAU,CAAC;YACzCV,MAAMtB,aAAasB,IAAI;YACvBlB;QACF;QAEA,IAAI6B,SAASN,WAAWC,OAAO;QAE/B,IAAId,QAAQ;YACV,0CAA0C;YAC1CmB,OAAOC,SAAS,GAAG,IAAIC,OAAOC,WAAW;YACzCH,SAAS,MAAM1B,QAAQa,EAAE,CAACiB,YAAY,CAAC;gBACrCf,MAAMtB,aAAasB,IAAI;gBACvBgB,MAAML;gBACN7B;YACF;YAEA,MAAMmC,MAAM,IAAIJ,OAAOC,WAAW;YAElCH,SAAS,MAAM1B,QAAQa,EAAE,CAACoB,mBAAmB,CAAC;gBAC5CC,UAAU;gBACVC,WAAWT,OAAOS,SAAS,GAAG,IAAIP,KAAKF,OAAOS,SAAS,EAAEN,WAAW,KAAKG;gBACzEI,YAAY3C,aAAasB,IAAI;gBAC7BlB;gBACA8B,WAAWnC,QAAQwC,MAAM,IAAIJ,KAAKF,OAAOC,SAAS,EAAEE,WAAW;gBAC/DQ,aAAaX;YACf;QACF,OAAO;YACLA,SAAS,MAAM1B,QAAQa,EAAE,CAACyB,YAAY,CAAC;gBACrCvB,MAAMtB,aAAasB,IAAI;gBACvBgB,MAAML;gBACN7B;YACF;QACF;QAEA,wCAAwC;QACxC,qBAAqB;QACrB,wCAAwC;QAExC6B,SAAS,UAAM1C,uLAAAA,EAAU;YACvBuD,YAAY;YACZjC,SAAST,IAAIS,OAAO;YACpBf,OAAOA;YACPiD,KAAKd;YACLlC,OAAOiD;YACP3C,gBAAgBA;YAChBS,QAAQd;YACRM,QAAQA;YACRL,gBAAgBA;YAChBC;YACAE;YACAD,kBAAkBA;QACpB;QAEA,wCAAwC;QACxC,qBAAqB;QACrB,wCAAwC;QAExC,IAAIH,aAAaS,KAAK,EAAElB,WAAWoB,QAAQ;YACzC,KAAK,MAAMC,QAAQZ,aAAaS,KAAK,CAAClB,SAAS,CAAE;gBAC/C0C,SACG,MAAMrB,KAAK;oBACVC,SAAST,IAAIS,OAAO;oBACpBkC,KAAKd;oBACLnB,QAAQd;oBACRC;oBACAG;gBACF,MAAO6B;YACX;QACF;QAEA,wCAAwC;QACxC,uBAAuB;QACvB,wCAAwC;QAExCA,SAAS,UAAM3C,2LAAAA,EAAY;YACzBwD,YAAY;YACZjC,SAAST,IAAIS,OAAO;YACpByB,MAAML;YACNc,KAAKd;YACLnB,QAAQd;YACRe,WAAW;YACXgB;YACA3B;QACF;QAEA,wCAAwC;QACxC,uBAAuB;QACvB,wCAAwC;QAExC,IAAIJ,aAAaS,KAAK,EAAEnB,aAAaqB,QAAQ;YAC3C,KAAK,MAAMC,QAAQZ,aAAaS,KAAK,CAACnB,WAAW,CAAE;gBACjD2C,SACG,MAAMrB,KAAK;oBACVC,SAAST,IAAIS,OAAO;oBACpByB,MAAML;oBACNc,KAAKd;oBACLnB,QAAQd;oBACRC;oBACA8B;oBACA3B;gBACF,MAAO6B;YACX;QACF;QAEA,IAAIzB,cAAc;YAChB,UAAMhB,wLAAAA,EAAkBY;QAC1B;QAEA,OAAO6B;IACT,EAAE,OAAOgB,OAAgB;QACvB,UAAMvD,oLAAAA,EAAgBU;QACtB,MAAM6C;IACR;AACF,EAAC"}},
    {"offset": {"line": 7198, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/globals/endpoints/restoreVersion.ts"],"sourcesContent":["import { status as httpStatus } from 'http-status'\n\nimport type { PayloadHandler } from '../../config/types.js'\n\nimport { restoreVersionOperationGlobal, sanitizePopulateParam } from '../../index.js'\nimport { getRequestGlobal } from '../../utilities/getRequestEntity.js'\nimport { headersWithCors } from '../../utilities/headersWithCors.js'\nimport { isNumber } from '../../utilities/isNumber.js'\n\nexport const restoreVersionHandler: PayloadHandler = async (req) => {\n  const globalConfig = getRequestGlobal(req)\n  const { searchParams } = req\n  const depth = searchParams.get('depth')\n  const draft = searchParams.get('draft')\n\n  const doc = await restoreVersionOperationGlobal({\n    id: req.routeParams!.id as string,\n    depth: isNumber(depth) ? Number(depth) : undefined,\n    draft: draft === 'true' ? true : undefined,\n    globalConfig,\n    populate: sanitizePopulateParam(req.query.populate),\n    req,\n  })\n\n  return Response.json(\n    {\n      doc,\n      message: req.t('version:restoredSuccessfully'),\n    },\n    {\n      headers: headersWithCors({\n        headers: new Headers(),\n        req,\n      }),\n      status: httpStatus.OK,\n    },\n  )\n}\n"],"names":["status","httpStatus","restoreVersionOperationGlobal","sanitizePopulateParam","getRequestGlobal","headersWithCors","isNumber","restoreVersionHandler","req","globalConfig","searchParams","depth","get","draft","doc","id","routeParams","Number","undefined","populate","query","Response","json","message","t","headers","Headers","OK"],"mappings":";;;;;AAAA,SAASA,UAAUC,UAAU,QAAQ,cAAa;;AAIlD,SAASC,6BAA6B,EAAEC,qBAAqB,QAAQ,iBAAgB;AACrF,SAASC,gBAAgB,QAAQ,sCAAqC;AACtE,SAASC,eAAe,QAAQ,qCAAoC;AACpE,SAASC,QAAQ,QAAQ,8BAA6B;;;;;;AAE/C,MAAMC,wBAAwC,OAAOC;IAC1D,MAAMC,mBAAeL,sLAAAA,EAAiBI;IACtC,MAAM,EAAEE,YAAY,EAAE,GAAGF;IACzB,MAAMG,QAAQD,aAAaE,GAAG,CAAC;IAC/B,MAAMC,QAAQH,aAAaE,GAAG,CAAC;IAE/B,MAAME,MAAM,UAAMZ,yRAAAA,EAA8B;QAC9Ca,IAAIP,IAAIQ,WAAW,CAAED,EAAE;QACvBJ,WAAOL,sKAAAA,EAASK,SAASM,OAAON,SAASO;QACzCL,OAAOA,UAAU,SAAS,OAAOK;QACjCT;QACAU,cAAUhB,gMAAAA,EAAsBK,IAAIY,KAAK,CAACD,QAAQ;QAClDX;IACF;IAEA,OAAOa,SAASC,IAAI,CAClB;QACER;QACAS,SAASf,IAAIgB,CAAC,CAAC;IACjB,GACA;QACEC,aAASpB,oLAAAA,EAAgB;YACvBoB,SAAS,IAAIC;YACblB;QACF;QACAR,QAAQC,sMAAAA,CAAW0B,EAAE;IACvB;AAEJ,EAAC"}},
    {"offset": {"line": 7242, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/globals/operations/update.ts"],"sourcesContent":["import type { DeepPartial } from 'ts-essentials'\n\nimport type { FindOptions } from '../../collections/operations/local/find.js'\nimport type { GlobalSlug, JsonObject } from '../../index.js'\nimport type {\n  Operation,\n  PayloadRequest,\n  PopulateType,\n  SelectType,\n  TransformGlobalWithSelect,\n  Where,\n} from '../../types/index.js'\nimport type {\n  DataFromGlobalSlug,\n  SanitizedGlobalConfig,\n  SelectFromGlobalSlug,\n} from '../config/types.js'\n\nimport { executeAccess } from '../../auth/executeAccess.js'\nimport { afterChange } from '../../fields/hooks/afterChange/index.js'\nimport { afterRead } from '../../fields/hooks/afterRead/index.js'\nimport { beforeChange } from '../../fields/hooks/beforeChange/index.js'\nimport { beforeValidate } from '../../fields/hooks/beforeValidate/index.js'\nimport { deepCopyObjectSimple } from '../../index.js'\nimport { checkDocumentLockStatus } from '../../utilities/checkDocumentLockStatus.js'\nimport { commitTransaction } from '../../utilities/commitTransaction.js'\nimport { getSelectMode } from '../../utilities/getSelectMode.js'\nimport {\n  hasDraftsEnabled,\n  hasDraftValidationEnabled,\n  hasLocalizeStatusEnabled,\n} from '../../utilities/getVersionsConfig.js'\nimport { initTransaction } from '../../utilities/initTransaction.js'\nimport { killTransaction } from '../../utilities/killTransaction.js'\nimport { mergeLocalizedData } from '../../utilities/mergeLocalizedData.js'\nimport { sanitizeSelect } from '../../utilities/sanitizeSelect.js'\nimport { getLatestGlobalVersion } from '../../versions/getLatestGlobalVersion.js'\nimport { saveVersion } from '../../versions/saveVersion.js'\ntype Args<TSlug extends GlobalSlug> = {\n  autosave?: boolean\n  data: DeepPartial<Omit<DataFromGlobalSlug<TSlug>, 'id'>>\n  depth?: number\n  disableTransaction?: boolean\n  draft?: boolean\n  globalConfig: SanitizedGlobalConfig\n  overrideAccess?: boolean\n  overrideLock?: boolean\n  populate?: PopulateType\n  publishAllLocales?: boolean\n  publishSpecificLocale?: string\n  req: PayloadRequest\n  showHiddenFields?: boolean\n  slug: string\n  unpublishAllLocales?: boolean\n} & Pick<FindOptions<string, SelectType>, 'select'>\n\nexport const updateOperation = async <\n  TSlug extends GlobalSlug,\n  TSelect extends SelectFromGlobalSlug<TSlug>,\n>(\n  args: Args<TSlug>,\n): Promise<TransformGlobalWithSelect<TSlug, TSelect>> => {\n  if (args.publishSpecificLocale) {\n    args.req.locale = args.publishSpecificLocale\n  }\n\n  const {\n    slug,\n    autosave,\n    depth,\n    disableTransaction,\n    draft: draftArg,\n    globalConfig,\n    overrideAccess,\n    overrideLock,\n    populate,\n    publishAllLocales: publishAllLocalesArg,\n    publishSpecificLocale,\n    req: { fallbackLocale, locale, payload, payload: { config } = {} },\n    req,\n    select: incomingSelect,\n    showHiddenFields,\n    unpublishAllLocales: unpublishAllLocalesArg,\n  } = args\n\n  try {\n    const shouldCommit = !disableTransaction && (await initTransaction(req))\n\n    // /////////////////////////////////////\n    // beforeOperation - Global\n    // /////////////////////////////////////\n\n    if (globalConfig.hooks?.beforeOperation?.length) {\n      for (const hook of globalConfig.hooks.beforeOperation) {\n        args =\n          (await hook({\n            args,\n            context: args.req.context,\n            global: globalConfig,\n            operation: 'update',\n            overrideAccess,\n            req: args.req,\n          })) || args\n      }\n    }\n\n    let { data } = args\n\n    const publishAllLocales =\n      !draftArg && (publishAllLocalesArg ?? (hasLocalizeStatusEnabled(globalConfig) ? false : true))\n    const unpublishAllLocales =\n      typeof unpublishAllLocalesArg === 'string'\n        ? unpublishAllLocalesArg === 'true'\n        : !!unpublishAllLocalesArg\n    const isSavingDraft =\n      Boolean(draftArg && hasDraftsEnabled(globalConfig)) &&\n      data._status !== 'published' &&\n      !publishAllLocales\n\n    if (isSavingDraft) {\n      data._status = 'draft'\n    }\n\n    // /////////////////////////////////////\n    // 1. Retrieve and execute access\n    // /////////////////////////////////////\n\n    const accessResults = !overrideAccess\n      ? await executeAccess(\n          {\n            data,\n            req,\n          },\n          globalConfig.access.update,\n        )\n      : true\n\n    // /////////////////////////////////////\n    // Retrieve document\n    // /////////////////////////////////////\n\n    const query: Where = overrideAccess ? undefined! : (accessResults as Where)\n\n    // /////////////////////////////////////\n    // 2. Retrieve document\n    // /////////////////////////////////////\n    const globalVersionResult = await getLatestGlobalVersion({\n      slug,\n      config: globalConfig,\n      locale: locale!,\n      payload,\n      req,\n      where: query,\n    })\n    const { global, globalExists } = globalVersionResult || {}\n\n    let globalJSON: JsonObject = {}\n\n    if (globalVersionResult && globalVersionResult.global) {\n      globalJSON = deepCopyObjectSimple(global)\n\n      if (globalJSON._id) {\n        delete globalJSON._id\n      }\n    }\n\n    const originalDoc = await afterRead({\n      collection: null,\n      context: req.context,\n      depth: 0,\n      doc: deepCopyObjectSimple(globalJSON),\n      draft: draftArg!,\n      fallbackLocale: fallbackLocale!,\n      global: globalConfig,\n      locale: locale!,\n      overrideAccess: true,\n      req,\n      showHiddenFields: showHiddenFields!,\n    })\n\n    // ///////////////////////////////////////////\n    // Handle potentially locked global documents\n    // ///////////////////////////////////////////\n\n    await checkDocumentLockStatus({\n      globalSlug: slug,\n      lockErrorMessage: `Global with slug \"${slug}\" is currently locked by another user and cannot be updated.`,\n      overrideLock,\n      req,\n    })\n\n    // /////////////////////////////////////\n    // beforeValidate - Fields\n    // /////////////////////////////////////\n\n    data = await beforeValidate({\n      collection: null,\n      context: req.context,\n      data,\n      doc: originalDoc,\n      global: globalConfig,\n      operation: 'update',\n      overrideAccess: overrideAccess!,\n      req,\n    })\n\n    // /////////////////////////////////////\n    // beforeValidate - Global\n    // /////////////////////////////////////\n\n    if (globalConfig.hooks?.beforeValidate?.length) {\n      for (const hook of globalConfig.hooks.beforeValidate) {\n        data =\n          (await hook({\n            context: req.context,\n            data,\n            global: globalConfig,\n            originalDoc,\n            overrideAccess,\n            req,\n          })) || data\n      }\n    }\n\n    // /////////////////////////////////////\n    // beforeChange - Global\n    // /////////////////////////////////////\n\n    if (globalConfig.hooks?.beforeChange?.length) {\n      for (const hook of globalConfig.hooks.beforeChange) {\n        data =\n          (await hook({\n            context: req.context,\n            data,\n            global: globalConfig,\n            originalDoc,\n            overrideAccess,\n            req,\n          })) || data\n      }\n    }\n\n    // /////////////////////////////////////\n    // beforeChange - Fields\n    // /////////////////////////////////////\n\n    const beforeChangeArgs = {\n      collection: null,\n      context: req.context,\n      data,\n      doc: originalDoc,\n      docWithLocales: globalJSON,\n      global: globalConfig,\n      operation: 'update' as Operation,\n      req,\n      skipValidation: isSavingDraft && !hasDraftValidationEnabled(globalConfig),\n    }\n\n    let result: JsonObject = await beforeChange(beforeChangeArgs)\n    let snapshotToSave: JsonObject | undefined\n\n    // /////////////////////////////////////\n    // Handle Localized Data Merging\n    // /////////////////////////////////////\n\n    if (config && config.localization && globalConfig.versions) {\n      let currentGlobal: JsonObject | null = null\n      let snapshotData: JsonObject | undefined\n\n      if (globalConfig.versions.drafts && globalConfig.versions.drafts.localizeStatus) {\n        if (publishAllLocales || unpublishAllLocales) {\n          let accessibleLocaleCodes = config.localization.localeCodes\n\n          if (config.localization.filterAvailableLocales) {\n            const filteredLocales = await config.localization.filterAvailableLocales({\n              locales: config.localization.locales,\n              req,\n            })\n            accessibleLocaleCodes = filteredLocales.map((locale) =>\n              typeof locale === 'string' ? locale : locale.code,\n            )\n          }\n\n          if (typeof result._status !== 'object' || result._status === null) {\n            result._status = {}\n          }\n\n          for (const localeCode of accessibleLocaleCodes) {\n            result._status[localeCode] = unpublishAllLocales ? 'draft' : 'published'\n          }\n        } else if (!isSavingDraft) {\n          // publishing a single locale\n          currentGlobal = await payload.db.findGlobal({\n            slug: globalConfig.slug,\n            req,\n            where: query,\n          })\n          snapshotData = result\n        }\n      } else if (publishSpecificLocale) {\n        // previous way of publishing a single locale\n        currentGlobal = (\n          await getLatestGlobalVersion({\n            slug,\n            config: globalConfig,\n            payload,\n            published: true,\n            req,\n            where: query,\n          })\n        ).global\n        snapshotData = {\n          ...result,\n          _status: 'draft',\n        }\n      }\n\n      if (snapshotData) {\n        snapshotToSave = deepCopyObjectSimple(snapshotData)\n\n        result = mergeLocalizedData({\n          configBlockReferences: config.blocks,\n          dataWithLocales: result || {},\n          docWithLocales: currentGlobal || {},\n          fields: globalConfig.fields,\n          selectedLocales: [locale!],\n        })\n      }\n    }\n    // /////////////////////////////////////\n    // Update\n    // /////////////////////////////////////\n\n    const select = sanitizeSelect({\n      fields: globalConfig.flattenedFields,\n      forceSelect: globalConfig.forceSelect,\n      select: incomingSelect,\n    })\n\n    if (!isSavingDraft) {\n      const now = new Date().toISOString()\n      // Ensure global has createdAt\n      if (!result.createdAt) {\n        result.createdAt = now\n      }\n\n      // Ensure updatedAt date is always updated\n      result.updatedAt = now\n\n      if (globalExists) {\n        result = await payload.db.updateGlobal({\n          slug,\n          data: result,\n          req,\n          select,\n        })\n      } else {\n        result = await payload.db.createGlobal({\n          slug,\n          data: result,\n          req,\n        })\n      }\n    }\n\n    // /////////////////////////////////////\n    // Create version\n    // /////////////////////////////////////\n    if (globalConfig.versions) {\n      const { globalType } = result\n      result = await saveVersion({\n        autosave,\n        docWithLocales: result,\n        draft: isSavingDraft,\n        global: globalConfig,\n        operation: 'update',\n        payload,\n        publishSpecificLocale,\n        req,\n        select,\n        snapshot: snapshotToSave,\n      })\n\n      result = {\n        ...result,\n        globalType,\n      }\n    }\n\n    // /////////////////////////////////////\n    // Execute globalType field if not selected\n    // /////////////////////////////////////\n    if (select && result.globalType) {\n      const selectMode = getSelectMode(select)\n      if (\n        (selectMode === 'include' && !select['globalType']) ||\n        (selectMode === 'exclude' && select['globalType'] === false)\n      ) {\n        delete result['globalType']\n      }\n    }\n\n    // /////////////////////////////////////\n    // afterRead - Fields\n    // /////////////////////////////////////\n\n    result = await afterRead({\n      collection: null,\n      context: req.context,\n      depth: depth!,\n      doc: result,\n      draft: draftArg!,\n      fallbackLocale: null,\n      global: globalConfig,\n      locale: locale!,\n      overrideAccess: overrideAccess!,\n      populate,\n      req,\n      select,\n      showHiddenFields: showHiddenFields!,\n    })\n\n    // /////////////////////////////////////\n    // afterRead - Global\n    // /////////////////////////////////////\n\n    if (globalConfig.hooks?.afterRead?.length) {\n      for (const hook of globalConfig.hooks.afterRead) {\n        result =\n          (await hook({\n            context: req.context,\n            doc: result,\n            global: globalConfig,\n            overrideAccess,\n            req,\n          })) || result\n      }\n    }\n\n    // /////////////////////////////////////\n    // afterChange - Fields\n    // /////////////////////////////////////\n\n    result = await afterChange({\n      collection: null,\n      context: req.context,\n      data,\n      doc: result,\n      global: globalConfig,\n      operation: 'update',\n      previousDoc: originalDoc,\n      req,\n    })\n\n    // /////////////////////////////////////\n    // afterChange - Global\n    // /////////////////////////////////////\n\n    if (globalConfig.hooks?.afterChange?.length) {\n      for (const hook of globalConfig.hooks.afterChange) {\n        result =\n          (await hook({\n            context: req.context,\n            data,\n            doc: result,\n            global: globalConfig,\n            overrideAccess,\n            previousDoc: originalDoc,\n            req,\n          })) || result\n      }\n    }\n\n    // /////////////////////////////////////\n    // Return results\n    // /////////////////////////////////////\n\n    if (shouldCommit) {\n      await commitTransaction(req)\n    }\n\n    return result as TransformGlobalWithSelect<TSlug, TSelect>\n  } catch (error: unknown) {\n    await killTransaction(req)\n    throw error\n  }\n}\n"],"names":["executeAccess","afterChange","afterRead","beforeChange","beforeValidate","deepCopyObjectSimple","checkDocumentLockStatus","commitTransaction","getSelectMode","hasDraftsEnabled","hasDraftValidationEnabled","hasLocalizeStatusEnabled","initTransaction","killTransaction","mergeLocalizedData","sanitizeSelect","getLatestGlobalVersion","saveVersion","updateOperation","args","publishSpecificLocale","req","locale","slug","autosave","depth","disableTransaction","draft","draftArg","globalConfig","overrideAccess","overrideLock","populate","publishAllLocales","publishAllLocalesArg","fallbackLocale","payload","config","select","incomingSelect","showHiddenFields","unpublishAllLocales","unpublishAllLocalesArg","shouldCommit","hooks","beforeOperation","length","hook","context","global","operation","data","isSavingDraft","Boolean","_status","accessResults","access","update","query","undefined","globalVersionResult","where","globalExists","globalJSON","_id","originalDoc","collection","doc","globalSlug","lockErrorMessage","beforeChangeArgs","docWithLocales","skipValidation","result","snapshotToSave","localization","versions","currentGlobal","snapshotData","drafts","localizeStatus","accessibleLocaleCodes","localeCodes","filterAvailableLocales","filteredLocales","locales","map","code","localeCode","db","findGlobal","published","configBlockReferences","blocks","dataWithLocales","fields","selectedLocales","flattenedFields","forceSelect","now","Date","toISOString","createdAt","updatedAt","updateGlobal","createGlobal","globalType","snapshot","selectMode","previousDoc","error"],"mappings":"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"}},
    {"offset": {"line": 7616, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/globals/endpoints/update.ts"],"sourcesContent":["import { status as httpStatus } from 'http-status'\n\nimport type { PayloadHandler } from '../../config/types.js'\n\nimport { getRequestGlobal } from '../../utilities/getRequestEntity.js'\nimport { headersWithCors } from '../../utilities/headersWithCors.js'\nimport { isNumber } from '../../utilities/isNumber.js'\nimport { sanitizePopulateParam } from '../../utilities/sanitizePopulateParam.js'\nimport { sanitizeSelectParam } from '../../utilities/sanitizeSelectParam.js'\nimport { updateOperation } from '../operations/update.js'\n\nexport const updateHandler: PayloadHandler = async (req) => {\n  const globalConfig = getRequestGlobal(req)\n  const { searchParams } = req\n  const depth = searchParams.get('depth')\n  const draft = searchParams.get('draft') === 'true'\n  const autosave = searchParams.get('autosave') === 'true'\n  const publishSpecificLocale = req.query.publishSpecificLocale as string | undefined\n  const publishAllLocales = searchParams.get('publishAllLocales') === 'true'\n  const unpublishAllLocales = searchParams.get('unpublishAllLocales') === 'true'\n\n  const result = await updateOperation({\n    slug: globalConfig.slug,\n    autosave,\n    data: req.data!,\n    depth: isNumber(depth) ? Number(depth) : undefined,\n    draft,\n    globalConfig,\n    populate: sanitizePopulateParam(req.query.populate),\n    publishAllLocales,\n    publishSpecificLocale,\n    req,\n    select: sanitizeSelectParam(req.query.select),\n    unpublishAllLocales,\n  })\n\n  let message = req.t('general:updatedSuccessfully')\n\n  if (draft) {\n    message = req.t('version:draftSavedSuccessfully')\n  }\n  if (autosave) {\n    message = req.t('version:autosavedSuccessfully')\n  }\n\n  return Response.json(\n    {\n      message,\n      result,\n    },\n    {\n      headers: headersWithCors({\n        headers: new Headers(),\n        req,\n      }),\n      status: httpStatus.OK,\n    },\n  )\n}\n"],"names":["status","httpStatus","getRequestGlobal","headersWithCors","isNumber","sanitizePopulateParam","sanitizeSelectParam","updateOperation","updateHandler","req","globalConfig","searchParams","depth","get","draft","autosave","publishSpecificLocale","query","publishAllLocales","unpublishAllLocales","result","slug","data","Number","undefined","populate","select","message","t","Response","json","headers","Headers","OK"],"mappings":";;;;;AAAA,SAASA,UAAUC,UAAU,QAAQ,cAAa;AAIlD,SAASC,gBAAgB,QAAQ,sCAAqC;AACtE,SAASC,eAAe,QAAQ,qCAAoC;AACpE,SAASC,QAAQ,QAAQ,8BAA6B;AACtD,SAASC,qBAAqB,QAAQ,2CAA0C;AAChF,SAASC,mBAAmB,QAAQ,yCAAwC;AAC5E,SAASC,eAAe,QAAQ,0BAAyB;;;;;;;;AAElD,MAAMC,gBAAgC,OAAOC;IAClD,MAAMC,mBAAeR,sLAAAA,EAAiBO;IACtC,MAAM,EAAEE,YAAY,EAAE,GAAGF;IACzB,MAAMG,QAAQD,aAAaE,GAAG,CAAC;IAC/B,MAAMC,QAAQH,aAAaE,GAAG,CAAC,aAAa;IAC5C,MAAME,WAAWJ,aAAaE,GAAG,CAAC,gBAAgB;IAClD,MAAMG,wBAAwBP,IAAIQ,KAAK,CAACD,qBAAqB;IAC7D,MAAME,oBAAoBP,aAAaE,GAAG,CAAC,yBAAyB;IACpE,MAAMM,sBAAsBR,aAAaE,GAAG,CAAC,2BAA2B;IAExE,MAAMO,SAAS,UAAMb,uLAAAA,EAAgB;QACnCc,MAAMX,aAAaW,IAAI;QACvBN;QACAO,MAAMb,IAAIa,IAAI;QACdV,WAAOR,sKAAAA,EAASQ,SAASW,OAAOX,SAASY;QACzCV;QACAJ;QACAe,cAAUpB,gMAAAA,EAAsBI,IAAIQ,KAAK,CAACQ,QAAQ;QAClDP;QACAF;QACAP;QACAiB,YAAQpB,4LAAAA,EAAoBG,IAAIQ,KAAK,CAACS,MAAM;QAC5CP;IACF;IAEA,IAAIQ,UAAUlB,IAAImB,CAAC,CAAC;IAEpB,IAAId,OAAO;QACTa,UAAUlB,IAAImB,CAAC,CAAC;IAClB;IACA,IAAIb,UAAU;QACZY,UAAUlB,IAAImB,CAAC,CAAC;IAClB;IAEA,OAAOC,SAASC,IAAI,CAClB;QACEH;QACAP;IACF,GACA;QACEW,aAAS5B,oLAAAA,EAAgB;YACvB4B,SAAS,IAAIC;YACbvB;QACF;QACAT,QAAQC,sMAAAA,CAAWgC,EAAE;IACvB;AAEJ,EAAC"}},
    {"offset": {"line": 7680, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/globals/endpoints/index.ts"],"sourcesContent":["import type { Endpoint } from '../../config/types.js'\n\nimport { wrapInternalEndpoints } from '../../utilities/wrapInternalEndpoints.js'\nimport { docAccessHandler } from './docAccess.js'\nimport { findOneHandler } from './findOne.js'\nimport { findVersionByIDHandler } from './findVersionByID.js'\nimport { findVersionsHandler } from './findVersions.js'\nimport { restoreVersionHandler } from './restoreVersion.js'\nimport { updateHandler } from './update.js'\n\nexport const defaultGlobalEndpoints: Endpoint[] = wrapInternalEndpoints([\n  {\n    handler: docAccessHandler,\n    method: 'post',\n    path: '/access',\n  },\n  {\n    handler: findOneHandler,\n    method: 'get',\n    path: '/',\n  },\n  {\n    handler: findVersionByIDHandler,\n    method: 'get',\n    path: '/versions/:id',\n  },\n  {\n    handler: findVersionsHandler,\n    method: 'get',\n    path: '/versions',\n  },\n  {\n    handler: restoreVersionHandler,\n    method: 'post',\n    path: '/versions/:id',\n  },\n  {\n    handler: updateHandler,\n    method: 'post',\n    path: '/',\n  },\n])\n"],"names":["wrapInternalEndpoints","docAccessHandler","findOneHandler","findVersionByIDHandler","findVersionsHandler","restoreVersionHandler","updateHandler","defaultGlobalEndpoints","handler","method","path"],"mappings":";;;;AAEA,SAASA,qBAAqB,QAAQ,2CAA0C;AAChF,SAASC,gBAAgB,QAAQ,iBAAgB;AACjD,SAASC,cAAc,QAAQ,eAAc;AAC7C,SAASC,sBAAsB,QAAQ,uBAAsB;AAC7D,SAASC,mBAAmB,QAAQ,oBAAmB;AACvD,SAASC,qBAAqB,QAAQ,sBAAqB;AAC3D,SAASC,aAAa,QAAQ,cAAa;;;;;;;;AAEpC,MAAMC,6BAAqCP,gMAAAA,EAAsB;IACtE;QACEQ,SAASP,0LAAAA;QACTQ,QAAQ;QACRC,MAAM;IACR;IACA;QACEF,SAASN,sLAAAA;QACTO,QAAQ;QACRC,MAAM;IACR;IACA;QACEF,SAASL,sMAAAA;QACTM,QAAQ;QACRC,MAAM;IACR;IACA;QACEF,SAASJ,gMAAAA;QACTK,QAAQ;QACRC,MAAM;IACR;IACA;QACEF,SAASH,oMAAAA;QACTI,QAAQ;QACRC,MAAM;IACR;IACA;QACEF,SAASF,oLAAAA;QACTG,QAAQ;QACRC,MAAM;IACR;CACD,EAAC"}},
    {"offset": {"line": 7734, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/globals/config/sanitize.ts"],"sourcesContent":["import type { Config, SanitizedConfig } from '../../config/types.js'\nimport type { GlobalConfig, SanitizedGlobalConfig } from './types.js'\n\nimport { defaultAccess } from '../../auth/defaultAccess.js'\nimport { sanitizeFields } from '../../fields/config/sanitize.js'\nimport { fieldAffectsData } from '../../fields/config/types.js'\nimport { mergeBaseFields } from '../../fields/mergeBaseFields.js'\nimport { flattenAllFields } from '../../utilities/flattenAllFields.js'\nimport { toWords } from '../../utilities/formatLabels.js'\nimport { traverseForLocalizedFields } from '../../utilities/traverseForLocalizedFields.js'\nimport { baseVersionFields } from '../../versions/baseFields.js'\nimport { versionDefaults } from '../../versions/defaults.js'\nimport { defaultGlobalEndpoints } from '../endpoints/index.js'\nexport const sanitizeGlobal = async (\n  config: Config,\n  global: GlobalConfig,\n  /**\n   * If this property is set, RichText fields won't be sanitized immediately. Instead, they will be added to this array as promises\n   * so that you can sanitize them together, after the config has been sanitized.\n   */\n  richTextSanitizationPromises?: Array<(config: SanitizedConfig) => Promise<void>>,\n  _validRelationships?: string[],\n): Promise<SanitizedGlobalConfig> => {\n  if (global._sanitized) {\n    return global as SanitizedGlobalConfig\n  }\n\n  global._sanitized = true\n\n  global.label = global.label || toWords(global.slug)\n\n  // /////////////////////////////////\n  // Ensure that collection has required object structure\n  // /////////////////////////////////\n\n  global.endpoints = global.endpoints ?? []\n\n  if (!global.hooks) {\n    global.hooks = {}\n  }\n\n  if (!global.access) {\n    global.access = {}\n  }\n\n  if (!global.admin) {\n    global.admin = {}\n  }\n\n  if (!global.access.read) {\n    global.access.read = defaultAccess\n  }\n\n  if (!global.access.update) {\n    global.access.update = defaultAccess\n  }\n\n  if (!global.hooks.beforeValidate) {\n    global.hooks.beforeValidate = []\n  }\n\n  if (!global.hooks.beforeChange) {\n    global.hooks.beforeChange = []\n  }\n\n  if (!global.hooks.afterChange) {\n    global.hooks.afterChange = []\n  }\n\n  if (!global.hooks.beforeRead) {\n    global.hooks.beforeRead = []\n  }\n\n  if (!global.hooks.afterRead) {\n    global.hooks.afterRead = []\n  }\n\n  // Sanitize fields\n  const validRelationships = _validRelationships ?? config.collections?.map((c) => c.slug) ?? []\n\n  global.fields = await sanitizeFields({\n    config,\n    fields: global.fields,\n    globalConfig: global,\n    parentIsLocalized: false,\n    richTextSanitizationPromises,\n    validRelationships,\n  })\n\n  if (global.endpoints !== false) {\n    if (!global.endpoints) {\n      global.endpoints = []\n    }\n\n    for (const endpoint of defaultGlobalEndpoints) {\n      global.endpoints.push(endpoint)\n    }\n  }\n\n  if (global.versions) {\n    if (global.versions === true) {\n      global.versions = {\n        drafts: false,\n        max: 100,\n      }\n    }\n\n    global.versions.max = typeof global.versions.max === 'number' ? global.versions.max : 100\n\n    if (global.versions.drafts) {\n      if (global.versions.drafts === true) {\n        global.versions.drafts = {\n          autosave: false,\n          validate: false,\n        }\n      }\n\n      const hasLocalizedFields = traverseForLocalizedFields(global.fields)\n\n      if (config.localization && hasLocalizedFields) {\n        if (global.versions.drafts.localizeStatus === undefined) {\n          global.versions.drafts.localizeStatus = false\n        }\n      }\n\n      global.versions.drafts.localizeStatus = config.experimental?.localizeStatus\n        ? global.versions.drafts.localizeStatus\n        : false\n\n      if (global.versions.drafts.autosave === true) {\n        global.versions.drafts.autosave = {\n          interval: versionDefaults.autosaveInterval,\n        }\n      }\n\n      if (global.versions.drafts.validate === undefined) {\n        global.versions.drafts.validate = false\n      }\n\n      global.fields = mergeBaseFields(\n        global.fields,\n        baseVersionFields({\n          localized: global.versions.drafts.localizeStatus ?? false,\n        }),\n      )\n    }\n  }\n\n  if (!global.custom) {\n    global.custom = {}\n  }\n\n  // /////////////////////////////////\n  // Sanitize fields\n  // /////////////////////////////////\n  let hasUpdatedAt: boolean | null = null\n  let hasCreatedAt: boolean | null = null\n  global.fields.some((field) => {\n    if (fieldAffectsData(field)) {\n      if (field.name === 'updatedAt') {\n        hasUpdatedAt = true\n      }\n      if (field.name === 'createdAt') {\n        hasCreatedAt = true\n      }\n    }\n    return hasCreatedAt && hasUpdatedAt\n  })\n  if (!hasUpdatedAt) {\n    global.fields.push({\n      name: 'updatedAt',\n      type: 'date',\n      admin: {\n        disableBulkEdit: true,\n        hidden: true,\n      },\n      label: ({ t }) => t('general:updatedAt'),\n    })\n  }\n  if (!hasCreatedAt) {\n    global.fields.push({\n      name: 'createdAt',\n      type: 'date',\n      admin: {\n        disableBulkEdit: true,\n        hidden: true,\n      },\n      label: ({ t }) => t('general:createdAt'),\n    })\n  }\n\n  ;(global as SanitizedGlobalConfig).flattenedFields = flattenAllFields({ fields: global.fields })\n\n  return global as SanitizedGlobalConfig\n}\n"],"names":["defaultAccess","sanitizeFields","fieldAffectsData","mergeBaseFields","flattenAllFields","toWords","traverseForLocalizedFields","baseVersionFields","versionDefaults","defaultGlobalEndpoints","sanitizeGlobal","config","global","richTextSanitizationPromises","_validRelationships","_sanitized","label","slug","endpoints","hooks","access","admin","read","update","beforeValidate","beforeChange","afterChange","beforeRead","afterRead","validRelationships","collections","map","c","fields","globalConfig","parentIsLocalized","endpoint","push","versions","drafts","max","autosave","validate","hasLocalizedFields","localization","localizeStatus","undefined","experimental","interval","autosaveInterval","localized","custom","hasUpdatedAt","hasCreatedAt","some","field","name","type","disableBulkEdit","hidden","t","flattenedFields"],"mappings":"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"}},
    {"offset": {"line": 7905, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/query-presets/access.ts"],"sourcesContent":["import type { Access, Config } from '../config/types.js'\nimport type { Operation } from '../types/index.js'\n\nimport { defaultAccess } from '../auth/defaultAccess.js'\n\nconst operations: Operation[] = ['delete', 'read', 'update', 'create'] as const\n\nconst defaultCollectionAccess = {\n  create: defaultAccess,\n  delete: defaultAccess,\n  read: defaultAccess,\n  unlock: defaultAccess,\n  update: defaultAccess,\n}\n\nexport const getAccess = (config: Config): Record<Operation, Access> =>\n  operations.reduce(\n    (acc, operation) => {\n      acc[operation] = async (args) => {\n        const { req } = args\n\n        const collectionAccess = config?.queryPresets?.access?.[operation]\n          ? await config.queryPresets.access[operation](args)\n          : defaultCollectionAccess?.[operation]\n            ? defaultCollectionAccess[operation](args)\n            : true\n\n        // If collection-level access control is `false`, no need to continue to document-level access\n        if (collectionAccess === false) {\n          return false\n        }\n\n        // The `create` operation does not affect the document-level access control\n        if (operation === 'create') {\n          return collectionAccess\n        }\n\n        return {\n          and: [\n            {\n              or: [\n                // Default access control ensures a user exists, but custom access control may not\n                ...(req?.user\n                  ? [\n                      {\n                        and: [\n                          {\n                            [`access.${operation}.users`]: {\n                              in: [req.user.id],\n                            },\n                          },\n                          {\n                            [`access.${operation}.constraint`]: {\n                              in: ['onlyMe', 'specificUsers'],\n                            },\n                          },\n                        ],\n                      },\n                    ]\n                  : []),\n                {\n                  [`access.${operation}.constraint`]: {\n                    equals: 'everyone',\n                  },\n                },\n                ...(await Promise.all(\n                  (config?.queryPresets?.constraints?.[operation] || []).map(async (constraint) => {\n                    const constraintAccess = constraint.access\n                      ? await constraint.access(args)\n                      : undefined\n\n                    return {\n                      and: [\n                        ...(typeof constraintAccess === 'object'\n                          ? [constraintAccess]\n                          : constraintAccess === false\n                            ? [\n                                {\n                                  id: {\n                                    equals: null,\n                                  },\n                                },\n                              ]\n                            : []),\n                        {\n                          [`access.${operation}.constraint`]: {\n                            equals: constraint.value,\n                          },\n                        },\n                      ],\n                    }\n                  }),\n                )),\n              ],\n            },\n            ...(typeof collectionAccess === 'object' ? [collectionAccess] : []),\n          ],\n        }\n      }\n\n      return acc\n    },\n    {} as Record<Operation, Access>,\n  )\n"],"names":["defaultAccess","operations","defaultCollectionAccess","create","delete","read","unlock","update","getAccess","config","reduce","acc","operation","args","req","collectionAccess","queryPresets","access","and","or","user","in","id","equals","Promise","all","constraints","map","constraint","constraintAccess","undefined","value"],"mappings":";;;;AAGA,SAASA,aAAa,QAAQ,2BAA0B;;AAExD,MAAMC,aAA0B;IAAC;IAAU;IAAQ;IAAU;CAAS;AAEtE,MAAMC,0BAA0B;IAC9BC,QAAQH,2KAAAA;IACRI,QAAQJ,2KAAAA;IACRK,MAAML,2KAAAA;IACNM,QAAQN,2KAAAA;IACRO,QAAQP,2KAAAA;AACV;AAEO,MAAMQ,YAAY,CAACC,SACxBR,WAAWS,MAAM,CACf,CAACC,KAAKC;QACJD,GAAG,CAACC,UAAU,GAAG,OAAOC;YACtB,MAAM,EAAEC,GAAG,EAAE,GAAGD;YAEhB,MAAME,mBAAmBN,QAAQO,cAAcC,QAAQ,CAACL,UAAU,GAC9D,MAAMH,OAAOO,YAAY,CAACC,MAAM,CAACL,UAAU,CAACC,QAC5CX,yBAAyB,CAACU,UAAU,GAClCV,uBAAuB,CAACU,UAAU,CAACC,QACnC;YAEN,8FAA8F;YAC9F,IAAIE,qBAAqB,OAAO;gBAC9B,OAAO;YACT;YAEA,2EAA2E;YAC3E,IAAIH,cAAc,UAAU;gBAC1B,OAAOG;YACT;YAEA,OAAO;gBACLG,KAAK;oBACH;wBACEC,IAAI;4BACF,kFAAkF;+BAC9EL,KAAKM,OACL;gCACE;oCACEF,KAAK;wCACH;4CACE,CAAC,CAAC,OAAO,EAAEN,UAAU,MAAM,CAAC,CAAC,EAAE;gDAC7BS,IAAI;oDAACP,IAAIM,IAAI,CAACE,EAAE;iDAAC;4CACnB;wCACF;wCACA;4CACE,CAAC,CAAC,OAAO,EAAEV,UAAU,WAAW,CAAC,CAAC,EAAE;gDAClCS,IAAI;oDAAC;oDAAU;iDAAgB;4CACjC;wCACF;qCACD;gCACH;6BACD,GACD,EAAE;4BACN;gCACE,CAAC,CAAC,OAAO,EAAET,UAAU,WAAW,CAAC,CAAC,EAAE;oCAClCW,QAAQ;gCACV;4BACF;+BACI,MAAMC,QAAQC,GAAG,CAClBhB,CAAAA,QAAQO,cAAcU,aAAa,CAACd,UAAU,IAAI,EAAC,EAAGe,GAAG,CAAC,OAAOC;gCAChE,MAAMC,mBAAmBD,WAAWX,MAAM,GACtC,MAAMW,WAAWX,MAAM,CAACJ,QACxBiB;gCAEJ,OAAO;oCACLZ,KAAK;2CACC,OAAOW,qBAAqB,WAC5B;4CAACA;yCAAiB,GAClBA,qBAAqB,QACnB;4CACE;gDACEP,IAAI;oDACFC,QAAQ;gDACV;4CACF;yCACD,GACD,EAAE;wCACR;4CACE,CAAC,CAAC,OAAO,EAAEX,UAAU,WAAW,CAAC,CAAC,EAAE;gDAClCW,QAAQK,WAAWG,KAAK;4CAC1B;wCACF;qCACD;gCACH;4BACF;yBAEH;oBACH;uBACI,OAAOhB,qBAAqB,WAAW;wBAACA;qBAAiB,GAAG,EAAE;iBACnE;YACH;QACF;QAEA,OAAOJ;IACT,GACA,CAAC,GACF"}},
    {"offset": {"line": 8002, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/query-presets/preventLockout.ts"],"sourcesContent":["import type { Validate } from '../fields/config/types.js'\n\nimport { APIError } from '../errors/APIError.js'\nimport { createLocalReq } from '../utilities/createLocalReq.js'\nimport { initTransaction } from '../utilities/initTransaction.js'\nimport { killTransaction } from '../utilities/killTransaction.js'\nimport { queryPresetsCollectionSlug } from './config.js'\n\n/**\n * Prevents \"accidental lockouts\" where a user makes an update that removes their own access to the preset.\n * This is effectively an access control function proxied through a `validate` function.\n * How it works:\n *   1. Creates a temporary record with the incoming data\n *   2. Attempts to read and update that record with the incoming user\n *   3. If either of those fail, throws an error to the user\n *   4. Once finished, prevents the temp record from persisting to the database\n */\nexport const preventLockout: Validate = async (\n  value,\n  { data, overrideAccess, req: incomingReq },\n) => {\n  // Use context to ensure an infinite loop doesn't occur\n  if (!incomingReq.context._preventLockout && !overrideAccess) {\n    const req = await createLocalReq(\n      {\n        context: {\n          _preventLockout: true,\n        },\n        req: {\n          user: incomingReq.user,\n        },\n      },\n      incomingReq.payload,\n    )\n\n    // Might be `null` if no transactions are enabled\n    const transaction = await initTransaction(req)\n\n    // create a temp record to validate the constraints, using the req\n    const tempPreset = await req.payload.create({\n      collection: queryPresetsCollectionSlug,\n      data: {\n        ...data,\n        isTemp: true,\n      },\n      req,\n    })\n\n    let canUpdate = false\n    let canRead = false\n\n    try {\n      await req.payload.findByID({\n        id: tempPreset.id,\n        collection: queryPresetsCollectionSlug,\n        overrideAccess: false,\n        req,\n        user: req.user,\n      })\n\n      canRead = true\n\n      await req.payload.update({\n        id: tempPreset.id,\n        collection: queryPresetsCollectionSlug,\n        data: tempPreset,\n        overrideAccess: false,\n        req,\n        user: req.user,\n      })\n\n      canUpdate = true\n    } catch (_err) {\n      if (!canRead || !canUpdate) {\n        throw new APIError('This action will lock you out of this preset.', 403, {}, true)\n      }\n    } finally {\n      if (transaction) {\n        await killTransaction(req)\n      } else {\n        // delete the temp record\n        await req.payload.delete({\n          id: tempPreset.id,\n          collection: queryPresetsCollectionSlug,\n          req,\n        })\n      }\n    }\n  }\n\n  return true as unknown as true\n}\n"],"names":["APIError","createLocalReq","initTransaction","killTransaction","queryPresetsCollectionSlug","preventLockout","value","data","overrideAccess","req","incomingReq","context","_preventLockout","user","payload","transaction","tempPreset","create","collection","isTemp","canUpdate","canRead","findByID","id","update","_err","delete"],"mappings":";;;;AAEA,SAASA,QAAQ,QAAQ,wBAAuB;AAChD,SAASC,cAAc,QAAQ,iCAAgC;AAC/D,SAASC,eAAe,QAAQ,kCAAiC;AACjE,SAASC,eAAe,QAAQ,kCAAiC;AACjE,SAASC,0BAA0B,QAAQ,cAAa;;;;;;AAWjD,MAAMC,iBAA2B,OACtCC,OACA,EAAEC,IAAI,EAAEC,cAAc,EAAEC,KAAKC,WAAW,EAAE;IAE1C,uDAAuD;IACvD,IAAI,CAACA,YAAYC,OAAO,CAACC,eAAe,IAAI,CAACJ,gBAAgB;QAC3D,MAAMC,MAAM,UAAMR,kLAAAA,EAChB;YACEU,SAAS;gBACPC,iBAAiB;YACnB;YACAH,KAAK;gBACHI,MAAMH,YAAYG,IAAI;YACxB;QACF,GACAH,YAAYI,OAAO;QAGrB,iDAAiD;QACjD,MAAMC,cAAc,UAAMb,oLAAAA,EAAgBO;QAE1C,kEAAkE;QAClE,MAAMO,aAAa,MAAMP,IAAIK,OAAO,CAACG,MAAM,CAAC;YAC1CC,YAAYd,6LAAAA;YACZG,MAAM;gBACJ,GAAGA,IAAI;gBACPY,QAAQ;YACV;YACAV;QACF;QAEA,IAAIW,YAAY;QAChB,IAAIC,UAAU;QAEd,IAAI;YACF,MAAMZ,IAAIK,OAAO,CAACQ,QAAQ,CAAC;gBACzBC,IAAIP,WAAWO,EAAE;gBACjBL,YAAYd,6LAAAA;gBACZI,gBAAgB;gBAChBC;gBACAI,MAAMJ,IAAII,IAAI;YAChB;YAEAQ,UAAU;YAEV,MAAMZ,IAAIK,OAAO,CAACU,MAAM,CAAC;gBACvBD,IAAIP,WAAWO,EAAE;gBACjBL,YAAYd,6LAAAA;gBACZG,MAAMS;gBACNR,gBAAgB;gBAChBC;gBACAI,MAAMJ,IAAII,IAAI;YAChB;YAEAO,YAAY;QACd,EAAE,OAAOK,MAAM;YACb,IAAI,CAACJ,WAAW,CAACD,WAAW;gBAC1B,MAAM,IAAIpB,mKAAAA,CAAS,iDAAiD,KAAK,CAAC,GAAG;YAC/E;QACF,SAAU;YACR,IAAIe,aAAa;gBACf,UAAMZ,oLAAAA,EAAgBM;YACxB,OAAO;gBACL,yBAAyB;gBACzB,MAAMA,IAAIK,OAAO,CAACY,MAAM,CAAC;oBACvBH,IAAIP,WAAWO,EAAE;oBACjBL,YAAYd,6LAAAA;oBACZK;gBACF;YACF;QACF;IACF;IAEA,OAAO;AACT,EAAC"}},
    {"offset": {"line": 8081, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/query-presets/types.ts"],"sourcesContent":["import type { Field } from '../fields/config/types.js'\nimport type { Access, CollectionSlug } from '../index.js'\nimport type { CollectionPreferences } from '../preferences/types.js'\nimport type { Where } from '../types/index.js'\n\n// Note: order matters here as it will change the rendered order in the UI\nexport const operations = ['read', 'update', 'delete'] as const\n\nexport type ConstraintOperation = (typeof operations)[number]\n\nexport type DefaultConstraint = 'everyone' | 'onlyMe' | 'specificUsers'\n\nexport type Constraint = DefaultConstraint | string // TODO: type `string` as the custom constraints provided by the config\n\nexport type QueryPreset = {\n  access: {\n    [operation in ConstraintOperation]: {\n      constraint: DefaultConstraint\n      users?: string[]\n    }\n  }\n  columns: CollectionPreferences['columns']\n  groupBy?: string\n  id: number | string\n  isShared: boolean\n  relatedCollection: CollectionSlug\n  title: string\n  where: Where\n}\n\nexport type QueryPresetConstraint = {\n  /**\n   * A function that determines the access control rules for this constraint.\n   */\n  access: Access<QueryPreset>\n  /**\n   * An array of fields to render when this constraint is selected.\n   */\n  fields?: Field[]\n  /**\n   * The label displayed in the dropdown\n   */\n  label: string\n  /**\n   * The value to store in the database when this constraint is selected.\n   */\n  value: string\n}\n\nexport type QueryPresetConstraints = QueryPresetConstraint[]\n"],"names":["operations"],"mappings":"AAKA,0EAA0E;;;;;AACnE,MAAMA,aAAa;IAAC;IAAQ;IAAU;CAAS,CAAS"}},
    {"offset": {"line": 8095, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/query-presets/constraints.ts"],"sourcesContent":["import { getTranslation } from '@payloadcms/translations'\n\nimport type { Config } from '../config/types.js'\nimport type { Field, Option } from '../fields/config/types.js'\nimport type { QueryPresetConstraint } from './types.js'\n\nimport { fieldAffectsData } from '../fields/config/types.js'\nimport { toWords } from '../utilities/formatLabels.js'\nimport { preventLockout } from './preventLockout.js'\nimport { operations } from './types.js'\n\nconst defaultConstraintOptions: Option[] = [\n  {\n    label: 'Everyone',\n    value: 'everyone',\n  },\n  {\n    label: 'Only Me',\n    value: 'onlyMe',\n  },\n  {\n    label: 'Specific Users',\n    value: 'specificUsers',\n  },\n]\n\nexport const getConstraints = (config: Config): Field => ({\n  name: 'access',\n  type: 'group',\n  admin: {\n    components: {\n      Cell: '@payloadcms/next/client#QueryPresetsAccessCell',\n    },\n    condition: (data) => Boolean(data?.isShared),\n  },\n  fields: operations.map((constraintOperation) => ({\n    type: 'collapsible',\n    fields: [\n      {\n        name: constraintOperation,\n        type: 'group',\n        admin: {\n          hideGutter: true,\n        },\n        fields: [\n          {\n            name: 'constraint',\n            type: 'select',\n            defaultValue: 'onlyMe',\n            filterOptions: (args) =>\n              typeof config?.queryPresets?.filterConstraints === 'function'\n                ? config.queryPresets.filterConstraints(args)\n                : args.options,\n            label: ({ i18n }) =>\n              `Specify who can ${constraintOperation} this ${getTranslation(config.queryPresets?.labels?.singular || 'Preset', i18n)}`,\n            options: [\n              ...defaultConstraintOptions,\n              ...(config?.queryPresets?.constraints?.[constraintOperation]?.map(\n                (option: QueryPresetConstraint) => ({\n                  label: option.label,\n                  value: option.value,\n                }),\n              ) || []),\n            ],\n          },\n          {\n            name: 'users',\n            type: 'relationship',\n            admin: {\n              condition: (data) =>\n                Boolean(data?.access?.[constraintOperation]?.constraint === 'specificUsers'),\n            },\n            hasMany: true,\n            hooks: {\n              beforeChange: [\n                ({ data, req }) => {\n                  if (data?.access?.[constraintOperation]?.constraint === 'onlyMe' && req.user) {\n                    return [req.user.id]\n                  }\n\n                  if (\n                    data?.access?.[constraintOperation]?.constraint === 'specificUsers' &&\n                    req.user\n                  ) {\n                    return [...(data?.access?.[constraintOperation]?.users || []), req.user.id]\n                  }\n                },\n              ],\n            },\n            relationTo: config.admin?.user ?? 'users', // TODO: remove this fallback when the args are properly typed as `SanitizedConfig`\n          },\n          ...(config?.queryPresets?.constraints?.[constraintOperation]?.reduce(\n            (acc: Field[], option: QueryPresetConstraint) => {\n              option.fields?.forEach((field, index) => {\n                acc.push({ ...field })\n\n                if (fieldAffectsData(field)) {\n                  acc[index]!.admin = {\n                    ...(acc[index]?.admin || {}),\n                    condition: (data) =>\n                      Boolean(data?.access?.[constraintOperation]?.constraint === option.value),\n                  }\n                }\n              })\n\n              return acc\n            },\n            [] as Field[],\n          ) || []),\n        ],\n        label: false,\n      },\n    ],\n    label: () => toWords(constraintOperation),\n  })),\n  label: 'Sharing settings',\n  validate: preventLockout,\n})\n"],"names":["getTranslation","fieldAffectsData","toWords","preventLockout","operations","defaultConstraintOptions","label","value","getConstraints","config","name","type","admin","components","Cell","condition","data","Boolean","isShared","fields","map","constraintOperation","hideGutter","defaultValue","filterOptions","args","queryPresets","filterConstraints","options","i18n","labels","singular","constraints","option","access","constraint","hasMany","hooks","beforeChange","req","user","id","users","relationTo","reduce","acc","forEach","field","index","push","validate"],"mappings":"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"}},
    {"offset": {"line": 8209, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/query-presets/config.ts"],"sourcesContent":["import type { CollectionConfig } from '../collections/config/types.js'\nimport type { Config } from '../config/types.js'\nimport type { Option } from '../fields/config/types.js'\n\nimport { transformWhereQuery } from '../utilities/transformWhereQuery.js'\nimport { validateWhereQuery } from '../utilities/validateWhereQuery.js'\nimport { getAccess } from './access.js'\nimport { getConstraints } from './constraints.js'\nimport { operations, type QueryPreset } from './types.js'\n\nexport const queryPresetsCollectionSlug = 'payload-query-presets'\n\nexport const getQueryPresetsConfig = (config: Config): CollectionConfig => ({\n  slug: queryPresetsCollectionSlug,\n  access: getAccess(config),\n  admin: {\n    defaultColumns: ['title', 'isShared', 'access', 'where', 'columns', 'groupBy'],\n    hidden: true,\n    useAsTitle: 'title',\n  },\n  fields: [\n    {\n      name: 'title',\n      type: 'text',\n      required: true,\n    },\n    {\n      name: 'isShared',\n      type: 'checkbox',\n      defaultValue: false,\n      validate: (isShared, { data }) => {\n        const typedData = data as QueryPreset\n\n        // ensure the `isShared` is only true if all constraints are 'onlyMe'\n        if (typedData?.access) {\n          const someOperationsAreShared = Object.values(typedData.access).some(\n            (operation) => operation.constraint !== 'onlyMe',\n          )\n\n          if (!isShared && someOperationsAreShared) {\n            return 'If any constraint is not \"onlyMe\", the preset must be shared'\n          }\n        }\n\n        return true\n      },\n    },\n    getConstraints(config),\n    {\n      name: 'where',\n      type: 'json',\n      admin: {\n        components: {\n          Cell: '@payloadcms/next/client#QueryPresetsWhereCell',\n          Field: '@payloadcms/next/client#QueryPresetsWhereField',\n        },\n      },\n      hooks: {\n        beforeValidate: [\n          ({ data }) => {\n            // transform the \"where\" query here so that the client-side doesn't have to\n            if (data?.where) {\n              if (validateWhereQuery(data.where)) {\n                return data.where\n              } else {\n                return transformWhereQuery(data.where)\n              }\n            }\n\n            return data?.where\n          },\n        ],\n      },\n      label: 'Filters',\n    },\n    {\n      name: 'columns',\n      type: 'json',\n      admin: {\n        components: {\n          Cell: '@payloadcms/next/client#QueryPresetsColumnsCell',\n          Field: '@payloadcms/next/client#QueryPresetsColumnField',\n        },\n      },\n      validate: (value) => {\n        if (value) {\n          try {\n            JSON.parse(JSON.stringify(value))\n          } catch {\n            return 'Invalid JSON'\n          }\n        }\n\n        return true\n      },\n    },\n    {\n      name: 'groupBy',\n      type: 'text',\n      admin: {\n        components: {\n          Cell: '@payloadcms/next/client#QueryPresetsGroupByCell',\n          Field: '@payloadcms/next/client#QueryPresetsGroupByField',\n        },\n      },\n      label: 'Group By',\n    },\n    {\n      name: 'relatedCollection',\n      type: 'select',\n      admin: {\n        hidden: true,\n      },\n      options: config.collections\n        ? config.collections.reduce((acc, collection) => {\n            if (collection.enableQueryPresets) {\n              acc.push({\n                label: collection.labels?.plural || collection.slug,\n                value: collection.slug,\n              })\n            }\n            return acc\n          }, [] as Option[])\n        : [],\n      required: true,\n    },\n    {\n      name: 'isTemp',\n      type: 'checkbox',\n      admin: {\n        description:\n          \"This is a temporary field used to determine if updating the preset would remove the user's access to it. When `true`, this record will be deleted after running the preset's `validate` function.\",\n        disabled: true,\n        hidden: true,\n      },\n    },\n  ],\n  hooks: {\n    beforeValidate: [\n      ({ data, operation }) => {\n        // TODO: type this\n        const typedData = data as any\n\n        if (operation === 'create' || operation === 'update') {\n          // Ensure all operations have a constraint\n          operations.forEach((operation) => {\n            if (!typedData.access) {\n              typedData.access = {}\n            }\n\n            if (!typedData.access?.[operation]) {\n              typedData[operation] = {}\n            }\n\n            // Ensure all operations have a constraint\n            if (!typedData.access[operation]?.constraint) {\n              typedData.access[operation] = {\n                ...typedData.access[operation],\n                constraint: 'onlyMe',\n              }\n            }\n          })\n\n          // If at least one constraint is not `onlyMe` then `isShared` must be true\n          if (typedData?.access) {\n            const someOperationsAreShared = Object.values(typedData.access).some(\n              // TODO: remove the `any` here\n              (operation: any) => operation.constraint !== 'onlyMe',\n            )\n\n            typedData.isShared = someOperationsAreShared\n          }\n        }\n\n        return typedData\n      },\n    ],\n  },\n  labels: {\n    plural: 'Presets',\n    singular: 'Preset',\n    ...(config.queryPresets?.labels || {}),\n  },\n  lockDocuments: false,\n})\n"],"names":["transformWhereQuery","validateWhereQuery","getAccess","getConstraints","operations","queryPresetsCollectionSlug","getQueryPresetsConfig","config","slug","access","admin","defaultColumns","hidden","useAsTitle","fields","name","type","required","defaultValue","validate","isShared","data","typedData","someOperationsAreShared","Object","values","some","operation","constraint","components","Cell","Field","hooks","beforeValidate","where","label","value","JSON","parse","stringify","options","collections","reduce","acc","collection","enableQueryPresets","push","labels","plural","description","disabled","forEach","singular","queryPresets","lockDocuments"],"mappings":"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"}},
    {"offset": {"line": 8391, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/translations/getLocalI18n.ts"],"sourcesContent":["import type { AcceptedLanguages } from '@payloadcms/translations'\n\nimport { initI18n } from '@payloadcms/translations'\n\nimport type { SanitizedConfig } from '../config/types.js'\n\nexport const getLocalI18n = async ({\n  config,\n  language,\n}: {\n  config: SanitizedConfig\n  language: AcceptedLanguages\n}) =>\n  initI18n({\n    config: config.i18n,\n    context: 'api',\n    language,\n  })\n"],"names":["initI18n","getLocalI18n","config","language","i18n","context"],"mappings":";;;;AAEA,SAASA,QAAQ,QAAQ,2BAA0B;;AAI5C,MAAMC,eAAe,OAAO,EACjCC,MAAM,EACNC,QAAQ,EAIT,OACCH,uLAAAA,EAAS;QACPE,QAAQA,OAAOE,IAAI;QACnBC,SAAS;QACTF;IACF,GAAE"}},
    {"offset": {"line": 8406, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/kv/adapters/DatabaseKVAdapter.ts"],"sourcesContent":["import type { CollectionConfig } from '../../index.js'\nimport type { Payload, PayloadRequest } from '../../types/index.js'\nimport type { KVAdapter, KVAdapterResult, KVStoreValue } from '../index.js'\n\n/** Mocked `req`, we don't need to use transactions, neither we want `createLocalReq` overhead. */\nconst req = {} as PayloadRequest\n\nexport class DatabaseKVAdapter implements KVAdapter {\n  constructor(\n    readonly payload: Payload,\n    readonly collectionSlug: string,\n  ) {}\n\n  async clear(): Promise<void> {\n    await this.payload.db.deleteMany({\n      collection: this.collectionSlug,\n      req,\n      where: {},\n    })\n  }\n\n  async delete(key: string): Promise<void> {\n    await this.payload.db.deleteOne({\n      collection: this.collectionSlug,\n      req,\n      where: { key: { equals: key } },\n    })\n  }\n\n  async get<T extends KVStoreValue>(key: string): Promise<null | T> {\n    const doc = await this.payload.db.findOne<{\n      data: T\n      id: number | string\n    }>({\n      collection: this.collectionSlug,\n      joins: false,\n      req,\n      select: {\n        data: true,\n        key: true,\n      },\n      where: { key: { equals: key } },\n    })\n\n    if (doc === null) {\n      return null\n    }\n\n    return doc.data\n  }\n\n  async has(key: string): Promise<boolean> {\n    const { totalDocs } = await this.payload.db.count({\n      collection: this.collectionSlug,\n      req,\n      where: { key: { equals: key } },\n    })\n\n    return totalDocs > 0\n  }\n\n  async keys(): Promise<string[]> {\n    const result = await this.payload.db.find<{ key: string }>({\n      collection: this.collectionSlug,\n      limit: 0,\n      pagination: false,\n      req,\n      select: {\n        key: true,\n      },\n    })\n\n    return result.docs.map((each) => each.key)\n  }\n\n  async set(key: string, data: KVStoreValue): Promise<void> {\n    await this.payload.db.upsert({\n      collection: this.collectionSlug,\n      data: {\n        data,\n        key,\n      },\n      joins: false,\n      req,\n      select: {},\n      where: { key: { equals: key } },\n    })\n  }\n}\n\nexport type DatabaseKVAdapterOptions = {\n  /** Override options for the generated collection */\n  kvCollectionOverrides?: Partial<CollectionConfig>\n}\n\nexport const databaseKVAdapter = (options: DatabaseKVAdapterOptions = {}): KVAdapterResult => {\n  const collectionSlug = options.kvCollectionOverrides?.slug ?? 'payload-kv'\n  return {\n    init: ({ payload }) => new DatabaseKVAdapter(payload, collectionSlug),\n    kvCollection: {\n      slug: collectionSlug,\n      access: {\n        create: () => false,\n        delete: () => false,\n        read: () => false,\n        update: () => false,\n      },\n      admin: {\n        hidden: true,\n      },\n      fields: [\n        {\n          name: 'key',\n          type: 'text',\n          index: true,\n          required: true,\n          unique: true,\n        },\n        {\n          name: 'data',\n          type: 'json',\n          required: true,\n        },\n      ],\n      lockDocuments: false,\n      timestamps: false,\n      ...options.kvCollectionOverrides,\n    },\n  }\n}\n"],"names":["req","DatabaseKVAdapter","payload","collectionSlug","clear","db","deleteMany","collection","where","delete","key","deleteOne","equals","get","doc","findOne","joins","select","data","has","totalDocs","count","keys","result","find","limit","pagination","docs","map","each","set","upsert","databaseKVAdapter","options","kvCollectionOverrides","slug","init","kvCollection","access","create","read","update","admin","hidden","fields","name","type","index","required","unique","lockDocuments","timestamps"],"mappings":";;;;;;AAIA,gGAAgG,GAChG,MAAMA,MAAM,CAAC;AAEN,MAAMC;;;IACX,YACWC,OAAgB,EAChBC,cAAsB,CAC/B;aAFSD,OAAAA,GAAAA;aACAC,cAAAA,GAAAA;IACR;IAEH,MAAMC,QAAuB;QAC3B,MAAM,IAAI,CAACF,OAAO,CAACG,EAAE,CAACC,UAAU,CAAC;YAC/BC,YAAY,IAAI,CAACJ,cAAc;YAC/BH;YACAQ,OAAO,CAAC;QACV;IACF;IAEA,MAAMC,OAAOC,GAAW,EAAiB;QACvC,MAAM,IAAI,CAACR,OAAO,CAACG,EAAE,CAACM,SAAS,CAAC;YAC9BJ,YAAY,IAAI,CAACJ,cAAc;YAC/BH;YACAQ,OAAO;gBAAEE,KAAK;oBAAEE,QAAQF;gBAAI;YAAE;QAChC;IACF;IAEA,MAAMG,IAA4BH,GAAW,EAAqB;QAChE,MAAMI,MAAM,MAAM,IAAI,CAACZ,OAAO,CAACG,EAAE,CAACU,OAAO,CAGtC;YACDR,YAAY,IAAI,CAACJ,cAAc;YAC/Ba,OAAO;YACPhB;YACAiB,QAAQ;gBACNC,MAAM;gBACNR,KAAK;YACP;YACAF,OAAO;gBAAEE,KAAK;oBAAEE,QAAQF;gBAAI;YAAE;QAChC;QAEA,IAAII,QAAQ,MAAM;YAChB,OAAO;QACT;QAEA,OAAOA,IAAII,IAAI;IACjB;IAEA,MAAMC,IAAIT,GAAW,EAAoB;QACvC,MAAM,EAAEU,SAAS,EAAE,GAAG,MAAM,IAAI,CAAClB,OAAO,CAACG,EAAE,CAACgB,KAAK,CAAC;YAChDd,YAAY,IAAI,CAACJ,cAAc;YAC/BH;YACAQ,OAAO;gBAAEE,KAAK;oBAAEE,QAAQF;gBAAI;YAAE;QAChC;QAEA,OAAOU,YAAY;IACrB;IAEA,MAAME,OAA0B;QAC9B,MAAMC,SAAS,MAAM,IAAI,CAACrB,OAAO,CAACG,EAAE,CAACmB,IAAI,CAAkB;YACzDjB,YAAY,IAAI,CAACJ,cAAc;YAC/BsB,OAAO;YACPC,YAAY;YACZ1B;YACAiB,QAAQ;gBACNP,KAAK;YACP;QACF;QAEA,OAAOa,OAAOI,IAAI,CAACC,GAAG,CAAC,CAACC,OAASA,KAAKnB,GAAG;IAC3C;IAEA,MAAMoB,IAAIpB,GAAW,EAAEQ,IAAkB,EAAiB;QACxD,MAAM,IAAI,CAAChB,OAAO,CAACG,EAAE,CAAC0B,MAAM,CAAC;YAC3BxB,YAAY,IAAI,CAACJ,cAAc;YAC/Be,MAAM;gBACJA;gBACAR;YACF;YACAM,OAAO;YACPhB;YACAiB,QAAQ,CAAC;YACTT,OAAO;gBAAEE,KAAK;oBAAEE,QAAQF;gBAAI;YAAE;QAChC;IACF;AACF;AAOO,MAAMsB,oBAAoB,CAACC,UAAoC,CAAC,CAAC;IACtE,MAAM9B,iBAAiB8B,QAAQC,qBAAqB,EAAEC,QAAQ;IAC9D,OAAO;QACLC,MAAM,CAAC,EAAElC,OAAO,EAAE,GAAK,IAAID,kBAAkBC,SAASC;QACtDkC,cAAc;YACZF,MAAMhC;YACNmC,QAAQ;gBACNC,QAAQ,IAAM;gBACd9B,QAAQ,IAAM;gBACd+B,MAAM,IAAM;gBACZC,QAAQ,IAAM;YAChB;YACAC,OAAO;gBACLC,QAAQ;YACV;YACAC,QAAQ;gBACN;oBACEC,MAAM;oBACNC,MAAM;oBACNC,OAAO;oBACPC,UAAU;oBACVC,QAAQ;gBACV;gBACA;oBACEJ,MAAM;oBACNC,MAAM;oBACNE,UAAU;gBACZ;aACD;YACDE,eAAe;YACfC,YAAY;YACZ,GAAGlB,QAAQC,qBAAqB;QAClC;IACF;AACF,EAAC"}},
    {"offset": {"line": 8539, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/config/defaults.ts"],"sourcesContent":["import type { JobsConfig } from '../queues/config/types/index.js'\nimport type { Config } from './types.js'\n\nimport { defaultAccess } from '../auth/defaultAccess.js'\nimport { foldersSlug, parentFolderFieldName } from '../folders/constants.js'\nimport { databaseKVAdapter } from '../kv/adapters/DatabaseKVAdapter.js'\n\n/**\n * @deprecated - remove in 4.0. This is error-prone, as mutating this object will affect any objects that use the defaults as a base.\n */\nexport const defaults: Omit<Config, 'db' | 'editor' | 'secret'> = {\n  admin: {\n    avatar: 'gravatar',\n    components: {},\n    custom: {},\n    dateFormat: 'MMMM do yyyy, h:mm a',\n    dependencies: {},\n    importMap: {\n      baseDir: `${typeof process?.cwd === 'function' ? process.cwd() : ''}`,\n    },\n    meta: {\n      defaultOGImageType: 'dynamic',\n      robots: 'noindex, nofollow',\n      titleSuffix: '- Payload',\n    },\n    routes: {\n      account: '/account',\n      browseByFolder: '/browse-by-folder',\n      createFirstUser: '/create-first-user',\n      forgot: '/forgot',\n      inactivity: '/logout-inactivity',\n      login: '/login',\n      logout: '/logout',\n      reset: '/reset',\n      unauthorized: '/unauthorized',\n    },\n    theme: 'all',\n  },\n  auth: {\n    jwtOrder: ['JWT', 'Bearer', 'cookie'],\n  },\n  bin: [],\n  collections: [],\n  cookiePrefix: 'payload',\n  cors: [],\n  csrf: [],\n  custom: {},\n  defaultDepth: 2,\n  defaultMaxTextLength: 40000,\n  endpoints: [],\n  globals: [],\n  graphQL: {\n    disablePlaygroundInProduction: true,\n    maxComplexity: 1000,\n    schemaOutputFile: `${typeof process?.cwd === 'function' ? process.cwd() : ''}/schema.graphql`,\n  },\n  hooks: {},\n  i18n: {},\n  jobs: {\n    access: {\n      cancel: defaultAccess,\n      queue: defaultAccess,\n      run: defaultAccess,\n    },\n    deleteJobOnComplete: true,\n    depth: 0,\n  } as JobsConfig,\n\n  localization: false,\n  maxDepth: 10,\n  routes: {\n    admin: '/admin',\n    api: '/api',\n    graphQL: '/graphql',\n    graphQLPlayground: '/graphql-playground',\n  },\n  serverURL: '',\n  telemetry: true,\n  typescript: {\n    autoGenerate: true,\n    outputFile: `${typeof process?.cwd === 'function' ? process.cwd() : ''}/payload-types.ts`,\n  },\n  upload: {},\n}\n\nexport const addDefaultsToConfig = (config: Config): Config => {\n  config.admin = {\n    avatar: 'gravatar',\n    components: {},\n    custom: {},\n    dateFormat: 'MMMM do yyyy, h:mm a',\n    dependencies: {},\n    theme: 'all',\n    ...(config.admin || {}),\n    importMap: {\n      baseDir: `${typeof process?.cwd === 'function' ? process.cwd() : ''}`,\n      ...(config?.admin?.importMap || {}),\n    },\n    meta: {\n      defaultOGImageType: 'dynamic',\n      robots: 'noindex, nofollow',\n      titleSuffix: '- Payload',\n      ...(config?.admin?.meta || {}),\n    },\n    routes: {\n      account: '/account',\n      browseByFolder: '/browse-by-folder',\n      createFirstUser: '/create-first-user',\n      forgot: '/forgot',\n      inactivity: '/logout-inactivity',\n      login: '/login',\n      logout: '/logout',\n      reset: '/reset',\n      unauthorized: '/unauthorized',\n      ...(config?.admin?.routes || {}),\n    },\n  }\n\n  config.bin = config.bin ?? []\n  config.collections = config.collections ?? []\n  config.cookiePrefix = config.cookiePrefix ?? 'payload'\n  config.cors = config.cors ?? []\n  config.csrf = config.csrf ?? []\n  config.custom = config.custom ?? {}\n  config.defaultDepth = config.defaultDepth ?? 2\n  config.defaultMaxTextLength = config.defaultMaxTextLength ?? 40000\n  config.endpoints = config.endpoints ?? []\n  config.globals = config.globals ?? []\n  config.graphQL = {\n    disableIntrospectionInProduction: true,\n    disablePlaygroundInProduction: true,\n    maxComplexity: 1000,\n    schemaOutputFile: `${typeof process?.cwd === 'function' ? process.cwd() : ''}/schema.graphql`,\n    ...(config.graphQL || {}),\n  }\n  config.hooks = config.hooks ?? {}\n  config.i18n = config.i18n ?? {}\n  config.jobs = {\n    deleteJobOnComplete: true,\n    depth: 0,\n    ...(config.jobs || {}),\n    access: {\n      cancel: defaultAccess,\n      queue: defaultAccess,\n      run: defaultAccess,\n      ...(config.jobs?.access || {}),\n    },\n  } as JobsConfig\n  config.localization = config.localization ?? false\n  config.maxDepth = config.maxDepth ?? 10\n  config.routes = {\n    admin: '/admin',\n    api: '/api',\n    graphQL: '/graphql',\n    graphQLPlayground: '/graphql-playground',\n    ...(config.routes || {}),\n  }\n  config.serverURL = config.serverURL ?? ''\n  config.telemetry = config.telemetry ?? true\n  config.typescript = {\n    autoGenerate: true,\n    outputFile: `${typeof process?.cwd === 'function' ? process.cwd() : ''}/payload-types.ts`,\n    ...(config.typescript || {}),\n  }\n  config.upload = config.upload ?? {}\n\n  config.auth = {\n    jwtOrder: ['JWT', 'Bearer', 'cookie'],\n    ...(config.auth || {}),\n  }\n\n  config.kv = config.kv ?? databaseKVAdapter()\n\n  if (config.kv?.kvCollection) {\n    config.collections.push(config.kv.kvCollection)\n  }\n\n  if (\n    config.folders !== false &&\n    config.collections.some((collection) => Boolean(collection.folders))\n  ) {\n    config.folders = {\n      slug: config.folders?.slug ?? foldersSlug,\n      browseByFolder: config.folders?.browseByFolder ?? true,\n      collectionOverrides: config.folders?.collectionOverrides || undefined,\n      collectionSpecific: config.folders?.collectionSpecific ?? true,\n      debug: config.folders?.debug ?? false,\n      fieldName: config.folders?.fieldName ?? parentFolderFieldName,\n    }\n  } else {\n    config.folders = false\n  }\n\n  return config\n}\n"],"names":["defaultAccess","foldersSlug","parentFolderFieldName","databaseKVAdapter","defaults","admin","avatar","components","custom","dateFormat","dependencies","importMap","baseDir","process","cwd","meta","defaultOGImageType","robots","titleSuffix","routes","account","browseByFolder","createFirstUser","forgot","inactivity","login","logout","reset","unauthorized","theme","auth","jwtOrder","bin","collections","cookiePrefix","cors","csrf","defaultDepth","defaultMaxTextLength","endpoints","globals","graphQL","disablePlaygroundInProduction","maxComplexity","schemaOutputFile","hooks","i18n","jobs","access","cancel","queue","run","deleteJobOnComplete","depth","localization","maxDepth","api","graphQLPlayground","serverURL","telemetry","typescript","autoGenerate","outputFile","upload","addDefaultsToConfig","config","disableIntrospectionInProduction","kv","kvCollection","push","folders","some","collection","Boolean","slug","collectionOverrides","undefined","collectionSpecific","debug","fieldName"],"mappings":"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"}},
    {"offset": {"line": 8737, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/config/orderable/fractional-indexing.js"],"sourcesContent":["// @ts-no-check\n\n/**\n * THIS FILE IS BASED ON:\n * https://github.com/rocicorp/fractional-indexing/blob/main/src/index.js\n *\n * MODIFIED FOR PAYLOAD CMS:\n * - Changed the integer part encoding to use only digits for \"small\" keys and\n *   only lowercase letters for \"large\" keys, ensuring consistent ordering\n *   across databases with different collations.\n *\n * - Original algorithm used A-Z (uppercase) for \"smaller\" integers and a-z (lowercase)\n *   for \"larger\" integers, relying on ASCII ordering where 'Z' < 'a'.\n *\n * - Some databases (e.g., PostgreSQL with default collation) use case-insensitive\n *   comparison, treating 'Z' as 'z', which breaks the ordering.\n *\n * - New encoding:\n *   - Uses digits '0'-'9' for \"small\" integers (10 values, lengths 11 down to 2)\n *   - Uses lowercase 'a'-'z' for \"large\" integers (26 values, lengths 2 up to 27)\n *   - Digits ALWAYS sort before letters in both ASCII and case-insensitive orderings.\n *\n * - Ordering: '0...' < '1...' < ... < '9..' < 'a.' < 'b..' < ... < 'z...'\n *\n * BACKWARD COMPATIBILITY:\n * - Existing keys starting with lowercase 'a'-'z' remain valid and work correctly.\n * - Keys starting with uppercase 'A'-'Z' (from the old algorithm) will still be\n *   parsed for backward compatibility, but they may sort incorrectly in\n *   case-insensitive databases. Consider running a migration to convert them.\n */\n\n// License: CC0 (no rights reserved).\n\n// This is based on https://observablehq.com/@dgreensp/implementing-fractional-indexing\n\nexport const BASE_36_DIGITS = '0123456789abcdefghijklmnopqrstuvwxyz'\n\n// `a` may be empty string, `b` is null or non-empty string.\n// `a < b` lexicographically if `b` is non-null.\n// no trailing zeros allowed.\n// digits is a string such as '0123456789' for base 10.  Digits must be in\n// ascending character code order!\n/**\n * @param {string} a\n * @param {string | null | undefined} b\n * @param {string} digits\n * @returns {string}\n */\nfunction midpoint(a, b, digits) {\n  const zero = digits[0]\n  if (b != null && a >= b) {\n    throw new Error(a + ' >= ' + b)\n  }\n  if (a.slice(-1) === zero || (b && b.slice(-1) === zero)) {\n    throw new Error('trailing zero')\n  }\n  if (b) {\n    // remove longest common prefix.  pad `a` with 0s as we\n    // go.  note that we don't need to pad `b`, because it can't\n    // end before `a` while traversing the common prefix.\n    let n = 0\n    while ((a[n] || zero) === b[n]) {\n      n++\n    }\n    if (n > 0) {\n      return b.slice(0, n) + midpoint(a.slice(n), b.slice(n), digits)\n    }\n  }\n  // first digits (or lack of digit) are different\n  const digitA = a ? digits.indexOf(a[0]) : 0\n  const digitB = b != null ? digits.indexOf(b[0]) : digits.length\n  if (digitB - digitA > 1) {\n    const midDigit = Math.round(0.5 * (digitA + digitB))\n    return digits[midDigit]\n  } else {\n    // first digits are consecutive\n    if (b && b.length > 1) {\n      return b.slice(0, 1)\n    } else {\n      // `b` is null or has length 1 (a single digit).\n      // the first digit of `a` is the previous digit to `b`,\n      // or 9 if `b` is null.\n      // given, for example, midpoint('49', '5'), return\n      // '4' + midpoint('9', null), which will become\n      // '4' + '9' + midpoint('', null), which is '495'\n      return digits[digitA] + midpoint(a.slice(1), null, digits)\n    }\n  }\n}\n\n/**\n * @param {string} int\n * @return {void}\n */\n\nfunction validateInteger(int) {\n  if (int.length !== getIntegerLength(int[0])) {\n    throw new Error('invalid integer part of order key: ' + int)\n  }\n}\n\n/**\n * Returns the length of the integer part based on the head character.\n *\n * New encoding (case-insensitive safe):\n * - SMALL range (digits): '0' = 11 chars, '1' = 10 chars, ..., '9' = 2 chars\n * - LARGE range (lowercase): 'a' = 2 chars, 'b' = 3 chars, ..., 'z' = 27 chars\n *\n * Legacy encoding (for backward compatibility with existing keys):\n * - 'A'-'Z' uppercase: 'A' = 27 chars, 'B' = 26 chars, ..., 'Z' = 2 chars\n *\n * @param {string} head\n * @return {number}\n */\nfunction getIntegerLength(head) {\n  if (head >= '0' && head <= '9') {\n    return 11 - (head.charCodeAt(0) - '0'.charCodeAt(0))\n  } else if (head >= 'a' && head <= 'z') {\n    return head.charCodeAt(0) - 'a'.charCodeAt(0) + 2\n  } else if (head >= 'A' && head <= 'Z') {\n    // Legacy encoding\n    return 'Z'.charCodeAt(0) - head.charCodeAt(0) + 2\n  } else {\n    throw new Error('invalid order key head: ' + head)\n  }\n}\n\n/**\n * @param {string} key\n * @return {string}\n */\n\nfunction getIntegerPart(key) {\n  const integerPartLength = getIntegerLength(key[0])\n  if (integerPartLength > key.length) {\n    throw new Error('invalid order key: ' + key)\n  }\n  return key.slice(0, integerPartLength)\n}\n\n/**\n * Smallest possible key (for validation)\n * '0' + 10 zeros = smallest valid key in new format\n */\nconst SMALLEST_KEY = '0' + BASE_36_DIGITS[0].repeat(10)\n\n/**\n * @param {string} key\n * @param {string} digits\n * @return {void}\n */\n\nfunction validateOrderKey(key, digits) {\n  if (key === SMALLEST_KEY) {\n    throw new Error('invalid order key: ' + key)\n  }\n  // Legacy check for old format\n  if (key === 'A' + digits[0].repeat(26)) {\n    throw new Error('invalid order key: ' + key)\n  }\n  // getIntegerPart will throw if the first character is bad,\n  // or the key is too short.  we'd call it to check these things\n  // even if we didn't need the result\n  const i = getIntegerPart(key)\n  const f = key.slice(i.length)\n  if (f.slice(-1) === digits[0]) {\n    throw new Error('invalid order key: ' + key)\n  }\n}\n\n// note that this may return null, as there is a largest integer\n/**\n * @param {string} x\n * @param {string} digits\n * @return {string | null}\n */\nfunction incrementInteger(x, digits) {\n  validateInteger(x)\n  const [head, ...digs] = x.split('')\n  let carry = true\n  for (let i = digs.length - 1; carry && i >= 0; i--) {\n    const d = digits.indexOf(digs[i]) + 1\n    if (d === digits.length) {\n      digs[i] = digits[0]\n    } else {\n      digs[i] = digits[d]\n      carry = false\n    }\n  }\n  if (carry) {\n    if (head === '9') {\n      return 'a' + digits[0]\n    }\n    // Handle legacy uppercase transition\n    if (head === 'Z') {\n      return 'a' + digits[0]\n    }\n    if (head === 'z') {\n      return null\n    }\n\n    let h\n    if (head >= '0' && head <= '8') {\n      h = String.fromCharCode(head.charCodeAt(0) + 1)\n      digs.pop()\n    } else if (head >= 'a' && head <= 'y') {\n      h = String.fromCharCode(head.charCodeAt(0) + 1)\n      digs.push(digits[0])\n    } else if (head >= 'A' && head <= 'Y') {\n      // Legacy uppercase\n      h = String.fromCharCode(head.charCodeAt(0) + 1)\n      digs.pop()\n    } else {\n      throw new Error('invalid head: ' + head)\n    }\n    return h + digs.join('')\n  } else {\n    return head + digs.join('')\n  }\n}\n\n// note that this may return null, as there is a smallest integer\n/**\n * @param {string} x\n * @param {string} digits\n * @return {string | null}\n */\n\nfunction decrementInteger(x, digits) {\n  validateInteger(x)\n  const [head, ...digs] = x.split('')\n  let borrow = true\n  for (let i = digs.length - 1; borrow && i >= 0; i--) {\n    const d = digits.indexOf(digs[i]) - 1\n    if (d === -1) {\n      digs[i] = digits.slice(-1)\n    } else {\n      digs[i] = digits[d]\n      borrow = false\n    }\n  }\n  if (borrow) {\n    if (head === 'a') {\n      return '9' + digits.slice(-1)\n    }\n    if (head === '0') {\n      return null\n    }\n\n    let h\n    if (head >= '1' && head <= '9') {\n      h = String.fromCharCode(head.charCodeAt(0) - 1)\n      digs.push(digits.slice(-1))\n    } else if (head >= 'b' && head <= 'z') {\n      h = String.fromCharCode(head.charCodeAt(0) - 1)\n      digs.pop()\n    } else if (head >= 'B' && head <= 'Z') {\n      // Legacy uppercase\n      h = String.fromCharCode(head.charCodeAt(0) - 1)\n      digs.push(digits.slice(-1))\n    } else if (head === 'A') {\n      // Legacy uppercase\n      return null\n    } else {\n      throw new Error('invalid head: ' + head)\n    }\n    return h + digs.join('')\n  } else {\n    return head + digs.join('')\n  }\n}\n\n// `a` is an order key or null (START).\n// `b` is an order key or null (END).\n// `a < b` lexicographically if both are non-null.\n// digits is a string such as '0123456789' for base 10.  Digits must be in\n// ascending character code order!\n/**\n * @param {string | null | undefined} a\n * @param {string | null | undefined} b\n * @param {string=} digits\n * @return {string}\n */\nexport function generateKeyBetween(a, b, digits = BASE_36_DIGITS) {\n  if (a != null) {\n    validateOrderKey(a, digits)\n  }\n  if (b != null) {\n    validateOrderKey(b, digits)\n  }\n  if (a != null && b != null && a >= b) {\n    throw new Error(a + ' >= ' + b)\n  }\n  if (a == null) {\n    if (b == null) {\n      return 'a' + digits[0]\n    }\n\n    const ib = getIntegerPart(b)\n    const fb = b.slice(ib.length)\n    if (ib === SMALLEST_KEY) {\n      return ib + midpoint('', fb, digits)\n    }\n    // Legacy check\n    if (ib === 'A' + digits[0].repeat(26)) {\n      return ib + midpoint('', fb, digits)\n    }\n    if (ib < b) {\n      return ib\n    }\n    const res = decrementInteger(ib, digits)\n    if (res == null) {\n      throw new Error('cannot decrement any more')\n    }\n    return res\n  }\n\n  if (b == null) {\n    const ia = getIntegerPart(a)\n    const fa = a.slice(ia.length)\n    const i = incrementInteger(ia, digits)\n    return i == null ? ia + midpoint(fa, null, digits) : i\n  }\n\n  const ia = getIntegerPart(a)\n  const fa = a.slice(ia.length)\n  const ib = getIntegerPart(b)\n  const fb = b.slice(ib.length)\n  if (ia === ib) {\n    return ia + midpoint(fa, fb, digits)\n  }\n  const i = incrementInteger(ia, digits)\n  if (i == null) {\n    throw new Error('cannot increment any more')\n  }\n  if (i < b) {\n    return i\n  }\n  return ia + midpoint(fa, null, digits)\n}\n\n/**\n * same preconditions as generateKeysBetween.\n * n >= 0.\n * Returns an array of n distinct keys in sorted order.\n * If a and b are both null, returns [a0, a1, ...]\n * If one or the other is null, returns consecutive \"integer\"\n * keys.  Otherwise, returns relatively short keys between\n * a and b.\n * @param {string | null | undefined} a\n * @param {string | null | undefined} b\n * @param {number} n\n * @param {string} digits\n * @return {string[]}\n */\nexport function generateNKeysBetween(a, b, n, digits = BASE_36_DIGITS) {\n  if (n === 0) {\n    return []\n  }\n  if (n === 1) {\n    return [generateKeyBetween(a, b, digits)]\n  }\n  if (b == null) {\n    let c = generateKeyBetween(a, b, digits)\n    const result = [c]\n    for (let i = 0; i < n - 1; i++) {\n      c = generateKeyBetween(c, b, digits)\n      result.push(c)\n    }\n    return result\n  }\n  if (a == null) {\n    let c = generateKeyBetween(a, b, digits)\n    const result = [c]\n    for (let i = 0; i < n - 1; i++) {\n      c = generateKeyBetween(a, c, digits)\n      result.push(c)\n    }\n    result.reverse()\n    return result\n  }\n  const mid = Math.floor(n / 2)\n  const c = generateKeyBetween(a, b, digits)\n  return [\n    ...generateNKeysBetween(a, c, mid, digits),\n    c,\n    ...generateNKeysBetween(c, b, n - mid - 1, digits),\n  ]\n}\n"],"names":["BASE_36_DIGITS","midpoint","a","b","digits","zero","Error","slice","n","digitA","indexOf","digitB","length","midDigit","Math","round","validateInteger","int","getIntegerLength","head","charCodeAt","getIntegerPart","key","integerPartLength","SMALLEST_KEY","repeat","validateOrderKey","i","f","incrementInteger","x","digs","split","carry","d","h","String","fromCharCode","pop","push","join","decrementInteger","borrow","generateKeyBetween","ib","fb","res","ia","fa","generateNKeysBetween","c","result","reverse","mid","floor"],"mappings":"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"}},
    {"offset": {"line": 9087, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/config/orderable/index.ts"],"sourcesContent":["import { status as httpStatus } from 'http-status'\n\nimport type { BeforeChangeHook, CollectionConfig } from '../../collections/config/types.js'\nimport type { Field } from '../../fields/config/types.js'\nimport type { Endpoint, PayloadHandler, SanitizedConfig } from '../types.js'\n\nimport { executeAccess } from '../../auth/executeAccess.js'\nimport { APIError } from '../../errors/index.js'\nimport { commitTransaction } from '../../utilities/commitTransaction.js'\nimport { initTransaction } from '../../utilities/initTransaction.js'\nimport { killTransaction } from '../../utilities/killTransaction.js'\nimport { traverseFields } from '../../utilities/traverseFields.js'\nimport { generateKeyBetween, generateNKeysBetween } from './fractional-indexing.js'\n\n/**\n * This function creates:\n * - N fields per collection, named `_order` or `_<collection>_<joinField>_order`\n * - 1 hook per collection\n * - 1 endpoint per app\n *\n * Also, if collection.defaultSort or joinField.defaultSort is not set, it will be set to the orderable field.\n */\nexport const setupOrderable = (config: SanitizedConfig) => {\n  const fieldsToAdd = new Map<CollectionConfig, string[]>()\n\n  config.collections.forEach((collection) => {\n    if (collection.orderable) {\n      const currentFields = fieldsToAdd.get(collection) || []\n      fieldsToAdd.set(collection, [...currentFields, '_order'])\n      collection.defaultSort = collection.defaultSort ?? '_order'\n    }\n\n    traverseFields({\n      callback: ({ field, parentRef, ref }) => {\n        if (field.type === 'array' || field.type === 'blocks') {\n          return false\n        }\n        if (field.type === 'group' || field.type === 'tab') {\n          // @ts-expect-error ref is untyped\n          const parentPrefix = parentRef?.prefix ? `${parentRef.prefix}_` : ''\n          // @ts-expect-error ref is untyped\n          ref.prefix = `${parentPrefix}${field.name}`\n        }\n        if (field.type === 'join' && field.orderable === true) {\n          if (Array.isArray(field.collection)) {\n            throw new APIError(\n              'Orderable joins must target a single collection',\n              httpStatus.BAD_REQUEST,\n              {},\n              true,\n            )\n          }\n          const relationshipCollection = config.collections.find((c) => c.slug === field.collection)\n          if (!relationshipCollection) {\n            return false\n          }\n          field.defaultSort = field.defaultSort ?? `_${field.collection}_${field.name}_order`\n          const currentFields = fieldsToAdd.get(relationshipCollection) || []\n          // @ts-expect-error ref is untyped\n          const prefix = parentRef?.prefix ? `${parentRef.prefix}_` : ''\n          fieldsToAdd.set(relationshipCollection, [\n            ...currentFields,\n            `_${field.collection}_${prefix}${field.name}_order`,\n          ])\n        }\n      },\n      fields: collection.fields,\n    })\n  })\n\n  Array.from(fieldsToAdd.entries()).forEach(([collection, orderableFields]) => {\n    addOrderableFieldsAndHook(collection, orderableFields)\n  })\n\n  if (fieldsToAdd.size > 0) {\n    addOrderableEndpoint(config)\n  }\n}\n\nexport const addOrderableFieldsAndHook = (\n  collection: CollectionConfig,\n  orderableFieldNames: string[],\n) => {\n  // 1. Add field\n  orderableFieldNames.forEach((orderableFieldName) => {\n    const orderField: Field = {\n      name: orderableFieldName,\n      type: 'text',\n      admin: {\n        disableBulkEdit: true,\n        disabled: true,\n        disableGroupBy: true,\n        disableListColumn: true,\n        disableListFilter: true,\n        hidden: true,\n        readOnly: true,\n      },\n      hooks: {\n        beforeDuplicate: [\n          ({ siblingData }) => {\n            delete siblingData[orderableFieldName]\n          },\n        ],\n      },\n      index: true,\n    }\n\n    collection.fields.unshift(orderField)\n  })\n\n  // 2. Add hook\n  if (!collection.hooks) {\n    collection.hooks = {}\n  }\n  if (!collection.hooks.beforeChange) {\n    collection.hooks.beforeChange = []\n  }\n\n  const orderBeforeChangeHook: BeforeChangeHook = async ({ data, originalDoc, req }) => {\n    for (const orderableFieldName of orderableFieldNames) {\n      if (!data[orderableFieldName] && !originalDoc?.[orderableFieldName]) {\n        const lastDoc = await req.payload.find({\n          collection: collection.slug,\n          depth: 0,\n          limit: 1,\n          pagination: false,\n          req,\n          select: { [orderableFieldName]: true },\n          sort: `-${orderableFieldName}`,\n          where: {\n            [orderableFieldName]: {\n              exists: true,\n            },\n          },\n        })\n\n        const lastOrderValue = lastDoc.docs[0]?.[orderableFieldName] || null\n        data[orderableFieldName] = generateKeyBetween(lastOrderValue, null)\n      }\n    }\n\n    return data\n  }\n\n  collection.hooks.beforeChange.push(orderBeforeChangeHook)\n}\n\n/**\n * The body of the reorder endpoint.\n * @internal\n */\nexport type OrderableEndpointBody = {\n  collectionSlug: string\n  docsToMove: string[]\n  newKeyWillBe: 'greater' | 'less'\n  orderableFieldName: string\n  target: {\n    id: string\n    key: string\n  }\n}\n\nexport const addOrderableEndpoint = (config: SanitizedConfig) => {\n  // 3. Add endpoint\n  const reorderHandler: PayloadHandler = async (req) => {\n    const body = (await req.json?.()) as OrderableEndpointBody\n\n    const { collectionSlug, docsToMove, newKeyWillBe, orderableFieldName, target } = body\n\n    if (!Array.isArray(docsToMove) || docsToMove.length === 0) {\n      return new Response(JSON.stringify({ error: 'docsToMove must be a non-empty array' }), {\n        headers: { 'Content-Type': 'application/json' },\n        status: 400,\n      })\n    }\n    if (newKeyWillBe !== 'greater' && newKeyWillBe !== 'less') {\n      return new Response(JSON.stringify({ error: 'newKeyWillBe must be \"greater\" or \"less\"' }), {\n        headers: { 'Content-Type': 'application/json' },\n        status: 400,\n      })\n    }\n    const collection = config.collections.find((c) => c.slug === collectionSlug)\n    if (!collection) {\n      return new Response(JSON.stringify({ error: `Collection ${collectionSlug} not found` }), {\n        headers: { 'Content-Type': 'application/json' },\n        status: 400,\n      })\n    }\n    if (typeof orderableFieldName !== 'string') {\n      return new Response(JSON.stringify({ error: 'orderableFieldName must be a string' }), {\n        headers: { 'Content-Type': 'application/json' },\n        status: 400,\n      })\n    }\n\n    // Prevent reordering if user doesn't have editing permissions\n    if (collection.access?.update) {\n      await executeAccess(\n        {\n          // Currently only one doc can be moved at a time. We should review this if we want to allow\n          // multiple docs to be moved at once in the future.\n          id: docsToMove[0],\n          data: {},\n          req,\n        },\n        collection.access.update,\n      )\n    }\n    /**\n     * If there is no target.key, we can assume the user enabled `orderable`\n     * on a collection with existing documents, and that this is the first\n     * time they tried to reorder them. Therefore, we perform a one-time\n     * migration by setting the key value for all documents. We do this\n     * instead of enforcing `required` and `unique` at the database schema\n     * level, so that users don't have to run a migration when they enable\n     * `orderable` on a collection with existing documents.\n     */\n    if (!target.key) {\n      const { docs } = await req.payload.find({\n        collection: collection.slug,\n        depth: 0,\n        limit: 0,\n        req,\n        select: { [orderableFieldName]: true },\n        where: {\n          [orderableFieldName]: {\n            exists: false,\n          },\n        },\n      })\n      await initTransaction(req)\n      // We cannot update all documents in a single operation with `payload.update`,\n      // because they would all end up with the same order key (`a0`).\n      try {\n        for (const doc of docs) {\n          await req.payload.update({\n            id: doc.id,\n            collection: collection.slug,\n            data: {\n              // no data needed since the order hooks will handle this\n            },\n            depth: 0,\n            req,\n          })\n          await commitTransaction(req)\n        }\n      } catch (e) {\n        await killTransaction(req)\n        if (e instanceof Error) {\n          throw new APIError(e.message, httpStatus.INTERNAL_SERVER_ERROR)\n        }\n      }\n\n      return new Response(JSON.stringify({ message: 'initial migration', success: true }), {\n        headers: { 'Content-Type': 'application/json' },\n        status: 200,\n      })\n    }\n\n    if (\n      typeof target !== 'object' ||\n      typeof target.id === 'undefined' ||\n      typeof target.key !== 'string'\n    ) {\n      return new Response(JSON.stringify({ error: 'target must be an object with id' }), {\n        headers: { 'Content-Type': 'application/json' },\n        status: 400,\n      })\n    }\n\n    const targetId = target.id\n    let targetKey = target.key\n\n    // If targetKey = pending, we need to find its current key.\n    // This can only happen if the user reorders rows quickly with a slow connection.\n    if (targetKey === 'pending') {\n      const beforeDoc = await req.payload.findByID({\n        id: targetId,\n        collection: collection.slug,\n        depth: 0,\n        select: { [orderableFieldName]: true },\n      })\n      targetKey = beforeDoc?.[orderableFieldName] || null\n    }\n\n    // The reason the endpoint does not receive this docId as an argument is that there\n    // are situations where the user may not see or know what the next or previous one is. For\n    // example, access control restrictions, if docBefore is the last one on the page, etc.\n    const adjacentDoc = await req.payload.find({\n      collection: collection.slug,\n      depth: 0,\n      limit: 1,\n      pagination: false,\n      select: { [orderableFieldName]: true },\n      sort: newKeyWillBe === 'greater' ? orderableFieldName : `-${orderableFieldName}`,\n      where: {\n        [orderableFieldName]: {\n          [newKeyWillBe === 'greater' ? 'greater_than' : 'less_than']: targetKey,\n        },\n      },\n    })\n    const adjacentDocKey = adjacentDoc.docs?.[0]?.[orderableFieldName] || null\n\n    // Currently N (= docsToMove.length) is always 1. Maybe in the future we will\n    // allow dragging and reordering multiple documents at once via the UI.\n    const orderValues =\n      newKeyWillBe === 'greater'\n        ? generateNKeysBetween(targetKey, adjacentDocKey, docsToMove.length)\n        : generateNKeysBetween(adjacentDocKey, targetKey, docsToMove.length)\n\n    // Update each document with its new order value\n    for (const [index, id] of docsToMove.entries()) {\n      await req.payload.update({\n        id,\n        collection: collection.slug,\n        data: {\n          [orderableFieldName]: orderValues[index],\n        },\n        depth: 0,\n        req,\n      })\n    }\n\n    return new Response(JSON.stringify({ orderValues, success: true }), {\n      headers: { 'Content-Type': 'application/json' },\n      status: 200,\n    })\n  }\n\n  const reorderEndpoint: Endpoint = {\n    handler: reorderHandler,\n    method: 'post',\n    path: '/reorder',\n  }\n\n  if (!config.endpoints) {\n    config.endpoints = []\n  }\n\n  config.endpoints.push(reorderEndpoint)\n}\n"],"names":["status","httpStatus","executeAccess","APIError","commitTransaction","initTransaction","killTransaction","traverseFields","generateKeyBetween","generateNKeysBetween","setupOrderable","config","fieldsToAdd","Map","collections","forEach","collection","orderable","currentFields","get","set","defaultSort","callback","field","parentRef","ref","type","parentPrefix","prefix","name","Array","isArray","BAD_REQUEST","relationshipCollection","find","c","slug","fields","from","entries","orderableFields","addOrderableFieldsAndHook","size","addOrderableEndpoint","orderableFieldNames","orderableFieldName","orderField","admin","disableBulkEdit","disabled","disableGroupBy","disableListColumn","disableListFilter","hidden","readOnly","hooks","beforeDuplicate","siblingData","index","unshift","beforeChange","orderBeforeChangeHook","data","originalDoc","req","lastDoc","payload","depth","limit","pagination","select","sort","where","exists","lastOrderValue","docs","push","reorderHandler","body","json","collectionSlug","docsToMove","newKeyWillBe","target","length","Response","JSON","stringify","error","headers","access","update","id","key","doc","e","Error","message","INTERNAL_SERVER_ERROR","success","targetId","targetKey","beforeDoc","findByID","adjacentDoc","adjacentDocKey","orderValues","reorderEndpoint","handler","method","path","endpoints"],"mappings":"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"}},
    {"offset": {"line": 9414, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/config/sanitize.ts"],"sourcesContent":["import type { AcceptedLanguages } from '@payloadcms/translations'\n\nimport { en } from '@payloadcms/translations/languages/en'\nimport { deepMergeSimple } from '@payloadcms/translations/utilities'\n\nimport type { CollectionSlug, GlobalSlug, SanitizedCollectionConfig } from '../index.js'\nimport type { SanitizedJobsConfig } from '../queues/config/types/index.js'\nimport type {\n  Config,\n  LocalizationConfigWithLabels,\n  LocalizationConfigWithNoLabels,\n  SanitizedConfig,\n  Timezone,\n  WidgetInstance,\n} from './types.js'\n\nimport { defaultUserCollection } from '../auth/defaultUser.js'\nimport { authRootEndpoints } from '../auth/endpoints/index.js'\nimport { sanitizeCollection } from '../collections/config/sanitize.js'\nimport { migrationsCollection } from '../database/migrations/migrationsCollection.js'\nimport { DuplicateCollection, InvalidConfiguration } from '../errors/index.js'\nimport { defaultTimezones } from '../fields/baseFields/timezone/defaultTimezones.js'\nimport { addFolderCollection } from '../folders/addFolderCollection.js'\nimport { addFolderFieldToCollection } from '../folders/addFolderFieldToCollection.js'\nimport { sanitizeGlobal } from '../globals/config/sanitize.js'\nimport { baseBlockFields, formatLabels, sanitizeFields } from '../index.js'\nimport {\n  getLockedDocumentsCollection,\n  lockedDocumentsCollectionSlug,\n} from '../locked-documents/config.js'\nimport { getPreferencesCollection, preferencesCollectionSlug } from '../preferences/config.js'\nimport { getQueryPresetsConfig, queryPresetsCollectionSlug } from '../query-presets/config.js'\nimport { getDefaultJobsCollection, jobsCollectionSlug } from '../queues/config/collection.js'\nimport { getJobStatsGlobal } from '../queues/config/global.js'\nimport { flattenBlock } from '../utilities/flattenAllFields.js'\nimport { hasScheduledPublishEnabled } from '../utilities/getVersionsConfig.js'\nimport { validateTimezones } from '../utilities/validateTimezones.js'\nimport { getSchedulePublishTask } from '../versions/schedule/job.js'\nimport { addDefaultsToConfig } from './defaults.js'\nimport { setupOrderable } from './orderable/index.js'\n\nconst sanitizeAdminConfig = (configToSanitize: Config): Partial<SanitizedConfig> => {\n  const sanitizedConfig = { ...configToSanitize }\n\n  if (configToSanitize?.compatibility?.allowLocalizedWithinLocalized) {\n    process.env.NEXT_PUBLIC_PAYLOAD_COMPATIBILITY_allowLocalizedWithinLocalized = 'true'\n  }\n\n  // default logging level will be 'error' if not provided\n  sanitizedConfig.loggingLevels = {\n    Forbidden: 'info',\n    Locked: 'info',\n    MissingFile: 'info',\n    NotFound: 'info',\n    ValidationError: 'info',\n    ...(sanitizedConfig.loggingLevels || {}),\n  }\n  ;(sanitizedConfig.admin!.dashboard ??= { widgets: [] }).widgets.push({\n    slug: 'collections',\n    ComponentPath: '@payloadcms/next/rsc#CollectionCards',\n    minWidth: 'full',\n  })\n  sanitizedConfig.admin!.dashboard.defaultLayout ??= [\n    {\n      widgetSlug: 'collections',\n      width: 'full',\n    } satisfies WidgetInstance,\n  ]\n\n  // add default user collection if none provided\n  if (!sanitizedConfig?.admin?.user) {\n    const firstCollectionWithAuth = sanitizedConfig.collections!.find(({ auth }) => Boolean(auth))\n\n    if (firstCollectionWithAuth) {\n      sanitizedConfig.admin!.user = firstCollectionWithAuth.slug\n    } else {\n      sanitizedConfig.admin!.user = defaultUserCollection.slug\n      sanitizedConfig.collections!.push(defaultUserCollection)\n    }\n  }\n\n  const userCollection = sanitizedConfig.collections!.find(\n    ({ slug }) => slug === sanitizedConfig.admin!.user,\n  )\n\n  if (!userCollection || !userCollection.auth) {\n    throw new InvalidConfiguration(\n      `${sanitizedConfig.admin!.user} is not a valid admin user collection`,\n    )\n  }\n\n  if (sanitizedConfig?.admin?.timezones) {\n    if (typeof configToSanitize?.admin?.timezones?.supportedTimezones === 'function') {\n      sanitizedConfig.admin.timezones.supportedTimezones =\n        configToSanitize.admin.timezones.supportedTimezones({ defaultTimezones })\n    }\n\n    if (!sanitizedConfig?.admin?.timezones?.supportedTimezones) {\n      sanitizedConfig.admin.timezones.supportedTimezones = defaultTimezones\n    }\n  } else {\n    sanitizedConfig.admin!.timezones = {\n      supportedTimezones: defaultTimezones,\n    }\n  }\n\n  validateTimezones({\n    source: 'admin.timezones.supportedTimezones',\n    timezones: sanitizedConfig.admin!.timezones.supportedTimezones as Timezone[],\n  })\n\n  return sanitizedConfig as unknown as Partial<SanitizedConfig>\n}\n\nexport const sanitizeConfig = async (incomingConfig: Config): Promise<SanitizedConfig> => {\n  const configWithDefaults = addDefaultsToConfig(incomingConfig)\n\n  const config: Partial<SanitizedConfig> = sanitizeAdminConfig(configWithDefaults)\n\n  // Add orderable fields\n  setupOrderable(config as SanitizedConfig)\n\n  if (!config.endpoints) {\n    config.endpoints = []\n  }\n\n  for (const endpoint of authRootEndpoints) {\n    config.endpoints.push(endpoint)\n  }\n\n  if (config.localization && config.localization.locales?.length > 0) {\n    // clone localization config so to not break everything\n    const firstLocale = config.localization.locales[0]\n    if (typeof firstLocale === 'string') {\n      config.localization.localeCodes = [\n        ...(config.localization as unknown as LocalizationConfigWithNoLabels).locales,\n      ]\n\n      // is string[], so convert to Locale[]\n      config.localization.locales = (\n        config.localization as unknown as LocalizationConfigWithNoLabels\n      ).locales.map((locale) => ({\n        code: locale,\n        label: locale,\n        rtl: false,\n        toString: () => locale,\n      }))\n    } else {\n      // is Locale[], so convert to string[] for localeCodes\n      config.localization.localeCodes = config.localization.locales.map((locale) => locale.code)\n\n      config.localization.locales = (\n        config.localization as LocalizationConfigWithLabels\n      ).locales.map((locale) => ({\n        ...locale,\n        toString: () => locale.code,\n      }))\n    }\n\n    // Default fallback to true if not provided\n    config.localization.fallback = config.localization?.fallback ?? true\n  }\n\n  const i18nConfig: SanitizedConfig['i18n'] = {\n    fallbackLanguage: 'en',\n    supportedLanguages: {\n      en,\n    },\n    translations: {},\n  }\n\n  if (incomingConfig?.i18n) {\n    i18nConfig.supportedLanguages =\n      incomingConfig.i18n?.supportedLanguages || i18nConfig.supportedLanguages\n\n    const supportedLangKeys = <AcceptedLanguages[]>Object.keys(i18nConfig.supportedLanguages)\n    const fallbackLang = incomingConfig.i18n?.fallbackLanguage || i18nConfig.fallbackLanguage\n\n    i18nConfig.fallbackLanguage = supportedLangKeys.includes(fallbackLang)\n      ? fallbackLang\n      : supportedLangKeys[0]!\n    i18nConfig.translations =\n      (incomingConfig.i18n?.translations as SanitizedConfig['i18n']['translations']) ||\n      i18nConfig.translations\n  }\n\n  config.i18n = i18nConfig\n\n  const richTextSanitizationPromises: Array<(config: SanitizedConfig) => Promise<void>> = []\n\n  const schedulePublishCollections: CollectionSlug[] = []\n\n  const queryPresetsCollections: CollectionSlug[] = []\n\n  const schedulePublishGlobals: GlobalSlug[] = []\n\n  const collectionSlugs = new Set<CollectionSlug>()\n\n  const validRelationships = [\n    ...(config.collections?.map((c) => c.slug) ?? []),\n    jobsCollectionSlug,\n    lockedDocumentsCollectionSlug,\n    preferencesCollectionSlug,\n  ]\n\n  if (config.folders !== false) {\n    validRelationships.push(config.folders!.slug)\n  }\n\n  /**\n   * Blocks sanitization needs to happen before collections, as collection/global join field sanitization needs config.blocks\n   * to be populated with the sanitized blocks\n   */\n  config.blocks = []\n\n  if (incomingConfig.blocks?.length) {\n    for (const block of incomingConfig.blocks) {\n      const sanitizedBlock = block\n\n      if (sanitizedBlock._sanitized === true) {\n        continue\n      }\n      sanitizedBlock._sanitized = true\n\n      sanitizedBlock.fields = sanitizedBlock.fields.concat(baseBlockFields)\n\n      sanitizedBlock.labels = !sanitizedBlock.labels\n        ? formatLabels(sanitizedBlock.slug)\n        : sanitizedBlock.labels\n\n      sanitizedBlock.fields = await sanitizeFields({\n        config: config as unknown as Config,\n        existingFieldNames: new Set(),\n        fields: sanitizedBlock.fields,\n        parentIsLocalized: false,\n        richTextSanitizationPromises,\n        validRelationships,\n      })\n\n      const flattenedSanitizedBlock = flattenBlock({ block })\n\n      config.blocks.push(flattenedSanitizedBlock)\n    }\n  }\n\n  const folderEnabledCollections: SanitizedCollectionConfig[] = []\n\n  for (let i = 0; i < config.collections!.length; i++) {\n    if (collectionSlugs.has(config.collections![i]!.slug)) {\n      throw new DuplicateCollection('slug', config.collections![i]!.slug)\n    }\n\n    collectionSlugs.add(config.collections![i]!.slug)\n\n    const draftsConfig = config.collections![i]?.versions?.drafts\n\n    if (typeof draftsConfig === 'object' && draftsConfig.schedulePublish) {\n      schedulePublishCollections.push(config.collections![i]!.slug)\n    }\n\n    if (config.collections![i]!.enableQueryPresets) {\n      queryPresetsCollections.push(config.collections![i]!.slug)\n\n      if (!validRelationships.includes(queryPresetsCollectionSlug)) {\n        validRelationships.push(queryPresetsCollectionSlug)\n      }\n    }\n\n    if (config.folders !== false && config.collections![i]!.folders) {\n      addFolderFieldToCollection({\n        collection: config.collections![i]!,\n        collectionSpecific: config.folders!.collectionSpecific,\n        folderFieldName: config.folders!.fieldName,\n        folderSlug: config.folders!.slug,\n      })\n    }\n\n    config.collections![i] = await sanitizeCollection(\n      config as unknown as Config,\n      config.collections![i]!,\n      richTextSanitizationPromises,\n      validRelationships,\n    )\n\n    if (config.folders !== false && config.collections![i]!.folders) {\n      folderEnabledCollections.push(config.collections![i]!)\n    }\n  }\n\n  if (config.globals!.length > 0) {\n    for (let i = 0; i < config.globals!.length; i++) {\n      if (hasScheduledPublishEnabled(config.globals![i]!)) {\n        schedulePublishGlobals.push(config.globals![i]!.slug)\n      }\n\n      config.globals![i] = await sanitizeGlobal(\n        config as unknown as Config,\n        config.globals![i]!,\n        richTextSanitizationPromises,\n        validRelationships,\n      )\n    }\n  }\n\n  if (schedulePublishCollections.length || schedulePublishGlobals.length) {\n    ;((config.jobs ??= {} as SanitizedJobsConfig).tasks ??= []).push(\n      getSchedulePublishTask({\n        adminUserSlug: config.admin!.user,\n        collections: schedulePublishCollections,\n        globals: schedulePublishGlobals,\n      }),\n    )\n  }\n\n  ;(config.jobs ??= {} as SanitizedJobsConfig).enabled = Boolean(\n    (Array.isArray(configWithDefaults.jobs?.tasks) && configWithDefaults.jobs?.tasks?.length) ||\n      (Array.isArray(configWithDefaults.jobs?.workflows) &&\n        configWithDefaults.jobs?.workflows?.length),\n  )\n\n  // Need to add default jobs collection before locked documents collections\n  if (config.jobs.enabled) {\n    // Check for schedule property in both tasks and workflows\n    const hasScheduleProperty =\n      (config?.jobs?.tasks?.length && config.jobs.tasks.some((task) => task.schedule)) ||\n      (config?.jobs?.workflows?.length &&\n        config.jobs.workflows.some((workflow) => workflow.schedule))\n\n    if (hasScheduleProperty) {\n      config.jobs.scheduling = true\n      // Add payload-jobs-stats global for tracking when a job of a specific slug was last run\n      ;(config.globals ??= []).push(\n        await sanitizeGlobal(\n          config as unknown as Config,\n          getJobStatsGlobal(config as unknown as Config),\n          richTextSanitizationPromises,\n          validRelationships,\n        ),\n      )\n\n      config.jobs.stats = true\n    }\n\n    let defaultJobsCollection = getDefaultJobsCollection(config.jobs)\n\n    if (typeof config.jobs.jobsCollectionOverrides === 'function') {\n      defaultJobsCollection = config.jobs.jobsCollectionOverrides({\n        defaultJobsCollection,\n      })\n\n      const hooks = defaultJobsCollection?.hooks\n      // @todo - delete this check in 4.0\n      if (hooks && config?.jobs?.runHooks !== true) {\n        for (const [hookKey, hook] of Object.entries(hooks)) {\n          const defaultAmount = hookKey === 'afterRead' || hookKey === 'beforeChange' ? 1 : 0\n          if (hook.length > defaultAmount) {\n            // eslint-disable-next-line no-console\n            console.warn(\n              `The jobsCollectionOverrides function is returning a collection with an additional ${hookKey} hook defined. These hooks will not run unless the jobs.runHooks option is set to true. Setting this option to true will negatively impact performance.`,\n            )\n            break\n          }\n        }\n      }\n    }\n    const sanitizedJobsCollection = await sanitizeCollection(\n      config as unknown as Config,\n      defaultJobsCollection,\n      richTextSanitizationPromises,\n      validRelationships,\n    )\n\n    ;(config.collections ??= []).push(sanitizedJobsCollection)\n  }\n\n  if (config.folders !== false && folderEnabledCollections.length) {\n    await addFolderCollection({\n      collectionSpecific: config.folders!.collectionSpecific,\n      config: config as unknown as Config,\n      folderEnabledCollections,\n      richTextSanitizationPromises,\n      validRelationships,\n    })\n  }\n\n  const lockedDocumentsCollection = getLockedDocumentsCollection(config as unknown as Config)\n\n  if (lockedDocumentsCollection) {\n    configWithDefaults.collections!.push(\n      await sanitizeCollection(\n        config as unknown as Config,\n        lockedDocumentsCollection,\n        richTextSanitizationPromises,\n        validRelationships,\n      ),\n    )\n  }\n\n  configWithDefaults.collections!.push(\n    await sanitizeCollection(\n      config as unknown as Config,\n      getPreferencesCollection(config as unknown as Config),\n      richTextSanitizationPromises,\n      validRelationships,\n    ),\n  )\n\n  const migrations = await sanitizeCollection(\n    config as unknown as Config,\n    migrationsCollection,\n    richTextSanitizationPromises,\n    validRelationships,\n  )\n\n  // @ts-expect-error indexSortableFields is only valid for @payloadcms/db-mongodb\n  if (config?.db?.indexSortableFields) {\n    migrations.indexes = [\n      {\n        fields: ['batch', 'name'],\n        unique: false,\n      },\n    ]\n  }\n  configWithDefaults.collections!.push(migrations)\n\n  if (queryPresetsCollections.length > 0) {\n    configWithDefaults.collections!.push(\n      await sanitizeCollection(\n        config as unknown as Config,\n        getQueryPresetsConfig(config as unknown as Config),\n        richTextSanitizationPromises,\n        validRelationships,\n      ),\n    )\n  }\n\n  if (config.serverURL !== '') {\n    config.csrf!.push(config.serverURL!)\n  }\n\n  const uploadAdapters = new Set<string>()\n  // interact with all collections\n  for (const collection of config.collections!) {\n    // deduped upload adapters\n    if (collection.upload?.adapter) {\n      uploadAdapters.add(collection.upload.adapter)\n    }\n  }\n\n  if (!config.upload) {\n    config.upload = { adapters: [] }\n  }\n\n  config.upload.adapters = Array.from(\n    new Set(config.collections!.map((c) => c.upload?.adapter).filter(Boolean) as string[]),\n  )\n\n  // Pass through the email config as is so adapters don't break\n  if (incomingConfig.email) {\n    config.email = incomingConfig.email\n  }\n\n  /*\n    Execute richText sanitization\n   */\n  if (typeof incomingConfig.editor === 'function') {\n    config.editor = await incomingConfig.editor({\n      config: config as SanitizedConfig,\n      isRoot: true,\n      parentIsLocalized: false,\n    })\n    if (config.editor.i18n && Object.keys(config.editor.i18n).length >= 0) {\n      config.i18n.translations = deepMergeSimple(config.i18n.translations, config.editor.i18n)\n    }\n  }\n\n  const promises: Promise<void>[] = []\n\n  for (const sanitizeFunction of richTextSanitizationPromises) {\n    promises.push(sanitizeFunction(config as SanitizedConfig))\n  }\n\n  await Promise.all(promises)\n\n  return config as SanitizedConfig\n}\n"],"names":["en","deepMergeSimple","defaultUserCollection","authRootEndpoints","sanitizeCollection","migrationsCollection","DuplicateCollection","InvalidConfiguration","defaultTimezones","addFolderCollection","addFolderFieldToCollection","sanitizeGlobal","baseBlockFields","formatLabels","sanitizeFields","getLockedDocumentsCollection","lockedDocumentsCollectionSlug","getPreferencesCollection","preferencesCollectionSlug","getQueryPresetsConfig","queryPresetsCollectionSlug","getDefaultJobsCollection","jobsCollectionSlug","getJobStatsGlobal","flattenBlock","hasScheduledPublishEnabled","validateTimezones","getSchedulePublishTask","addDefaultsToConfig","setupOrderable","sanitizeAdminConfig","configToSanitize","sanitizedConfig","compatibility","allowLocalizedWithinLocalized","process","env","NEXT_PUBLIC_PAYLOAD_COMPATIBILITY_allowLocalizedWithinLocalized","loggingLevels","Forbidden","Locked","MissingFile","NotFound","ValidationError","admin","dashboard","widgets","push","slug","ComponentPath","minWidth","defaultLayout","widgetSlug","width","user","firstCollectionWithAuth","collections","find","auth","Boolean","userCollection","timezones","supportedTimezones","source","sanitizeConfig","incomingConfig","configWithDefaults","config","endpoints","endpoint","localization","locales","length","firstLocale","localeCodes","map","locale","code","label","rtl","toString","fallback","i18nConfig","fallbackLanguage","supportedLanguages","translations","i18n","supportedLangKeys","Object","keys","fallbackLang","includes","richTextSanitizationPromises","schedulePublishCollections","queryPresetsCollections","schedulePublishGlobals","collectionSlugs","Set","validRelationships","c","folders","blocks","block","sanitizedBlock","_sanitized","fields","concat","labels","existingFieldNames","parentIsLocalized","flattenedSanitizedBlock","folderEnabledCollections","i","has","add","draftsConfig","versions","drafts","schedulePublish","enableQueryPresets","collection","collectionSpecific","folderFieldName","fieldName","folderSlug","globals","jobs","tasks","adminUserSlug","enabled","Array","isArray","workflows","hasScheduleProperty","some","task","schedule","workflow","scheduling","stats","defaultJobsCollection","jobsCollectionOverrides","hooks","runHooks","hookKey","hook","entries","defaultAmount","console","warn","sanitizedJobsCollection","lockedDocumentsCollection","migrations","db","indexSortableFields","indexes","unique","serverURL","csrf","uploadAdapters","upload","adapter","adapters","from","filter","email","editor","isRoot","promises","sanitizeFunction","Promise","all"],"mappings":"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"}},
    {"offset": {"line": 9774, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/config/build.ts"],"sourcesContent":["import type { Config, SanitizedConfig } from './types.js'\n\nimport { sanitizeConfig } from './sanitize.js'\n\n/**\n * @description Builds and validates Payload configuration\n * @param config Payload Config\n * @returns Built and sanitized Payload Config\n */\nexport async function buildConfig(config: Config): Promise<SanitizedConfig> {\n  if (Array.isArray(config.plugins)) {\n    let configAfterPlugins = config\n    for (const plugin of config.plugins) {\n      configAfterPlugins = await plugin(configAfterPlugins)\n    }\n    return await sanitizeConfig(configAfterPlugins)\n  }\n\n  return await sanitizeConfig(config)\n}\n"],"names":["sanitizeConfig","buildConfig","config","Array","isArray","plugins","configAfterPlugins","plugin"],"mappings":";;;;AAEA,SAASA,cAAc,QAAQ,gBAAe;;AAOvC,eAAeC,YAAYC,MAAc;IAC9C,IAAIC,MAAMC,OAAO,CAACF,OAAOG,OAAO,GAAG;QACjC,IAAIC,qBAAqBJ;QACzB,KAAK,MAAMK,UAAUL,OAAOG,OAAO,CAAE;YACnCC,qBAAqB,MAAMC,OAAOD;QACpC;QACA,OAAO,UAAMN,yKAAAA,EAAeM;IAC9B;IAEA,OAAO,UAAMN,yKAAAA,EAAeE;AAC9B"}},
    {"offset": {"line": 9794, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/config/find.ts"],"sourcesContent":["import { getTsconfig } from 'get-tsconfig'\nimport path from 'path'\n\nimport { findUpSync } from '../utilities/findUp.js'\n\n/**\n * List of all filenames to detect as a Payload configuration file.\n */\nexport const payloadConfigFileNames = ['payload.config.js', 'payload.config.ts']\n\n/**\n * Returns the source and output paths from the nearest tsconfig.json file.\n * If no tsconfig.json file is found, returns the current working directory.\n * @returns An object containing the source and output paths.\n */\nconst getTSConfigPaths = (): {\n  configPath?: string\n  outPath?: string\n  rootPath?: string\n  srcPath?: string\n  tsConfigPath?: string\n} => {\n  const tsConfigResult = getTsconfig()!\n  const tsConfig = tsConfigResult.config\n  const tsConfigDir = path.dirname(tsConfigResult.path)\n\n  try {\n    const rootConfigDir = path.resolve(tsConfigDir, tsConfig.compilerOptions!.baseUrl || '')\n    const srcPath = tsConfig.compilerOptions?.rootDir || path.resolve(process.cwd(), 'src')\n    const outPath = tsConfig.compilerOptions?.outDir || path.resolve(process.cwd(), 'dist')\n    let configPath = tsConfig.compilerOptions?.paths?.['@payload-config']?.[0]\n\n    if (configPath) {\n      configPath = path.resolve(rootConfigDir, configPath)\n    }\n    return {\n      configPath,\n      outPath,\n      rootPath: rootConfigDir,\n      srcPath,\n      tsConfigPath: tsConfigResult.path,\n    }\n  } catch (error) {\n    console.error(`Error parsing tsconfig.json: ${error}`) // Do not throw the error, as we can still continue with the other config path finding methods\n    return {\n      rootPath: process.cwd(),\n    }\n  }\n}\n\n/**\n * Searches for a Payload configuration file.\n * @returns The absolute path to the Payload configuration file.\n * @throws An error if no configuration file is found.\n */\nexport const findConfig = (): string => {\n  // If the developer has specified a config path,\n  // format it if relative and use it directly if absolute\n  if (process.env.PAYLOAD_CONFIG_PATH) {\n    if (path.isAbsolute(process.env.PAYLOAD_CONFIG_PATH)) {\n      return process.env.PAYLOAD_CONFIG_PATH\n    }\n\n    return path.resolve(process.cwd(), process.env.PAYLOAD_CONFIG_PATH)\n  }\n\n  const { configPath, outPath, rootPath, srcPath } = getTSConfigPaths()\n\n  // if configPath is absolute file, not folder, return it\n  if (configPath && (path.extname(configPath) === '.js' || path.extname(configPath) === '.ts')) {\n    return configPath\n  }\n\n  const searchPaths =\n    process.env.NODE_ENV === 'production'\n      ? [configPath, outPath, srcPath, rootPath]\n      : [configPath, srcPath, rootPath]\n\n  for (const searchPath of searchPaths) {\n    if (!searchPath) {\n      continue\n    }\n\n    const configPath = findUpSync({\n      dir: searchPath,\n      fileNames: payloadConfigFileNames,\n    })\n\n    if (configPath) {\n      return configPath\n    }\n  }\n\n  // If no config file is found in the directories defined by tsconfig.json,\n  // try searching in the 'src' and 'dist' directory as a last resort, as they are most commonly used\n  if (process.env.NODE_ENV === 'production') {\n    const distConfigPath = findUpSync({\n      dir: path.resolve(process.cwd(), 'dist'),\n      fileNames: ['payload.config.js'],\n    })\n\n    if (distConfigPath) {\n      return distConfigPath\n    }\n  } else {\n    const srcConfigPath = findUpSync({\n      dir: path.resolve(process.cwd(), 'src'),\n      fileNames: payloadConfigFileNames,\n    })\n\n    if (srcConfigPath) {\n      return srcConfigPath\n    }\n  }\n\n  throw new Error(\n    'Error: cannot find Payload config. Please create a configuration file located at the root of your current working directory called \"payload.config.js\" or \"payload.config.ts\".',\n  )\n}\n"],"names":["getTsconfig","path","findUpSync","payloadConfigFileNames","getTSConfigPaths","tsConfigResult","tsConfig","config","tsConfigDir","dirname","rootConfigDir","resolve","compilerOptions","baseUrl","srcPath","rootDir","process","cwd","outPath","outDir","configPath","paths","rootPath","tsConfigPath","error","console","findConfig","env","PAYLOAD_CONFIG_PATH","isAbsolute","extname","searchPaths","NODE_ENV","searchPath","dir","fileNames","distConfigPath","srcConfigPath","Error"],"mappings":";;;;;;AAAA,SAASA,WAAW,QAAQ,eAAc;AAC1C,OAAOC,UAAU,OAAM;AAEvB,SAASC,UAAU,QAAQ,yBAAwB;;;;AAK5C,MAAMC,yBAAyB;IAAC;IAAqB;CAAoB,CAAA;AAEhF;;;;CAIC,GACD,MAAMC,mBAAmB;IAOvB,MAAMC,qBAAiBL,6LAAAA;IACvB,MAAMM,WAAWD,eAAeE,MAAM;IACtC,MAAMC,cAAcP,4GAAAA,CAAKQ,OAAO,CAACJ,eAAeJ,IAAI;IAEpD,IAAI;QACF,MAAMS,gBAAgBT,4GAAAA,CAAKU,OAAO,CAACH,aAAaF,SAASM,eAAe,CAAEC,OAAO,IAAI;QACrF,MAAMC,UAAUR,SAASM,eAAe,EAAEG,WAAWd,4GAAAA,CAAKU,OAAO,CAACK,QAAQC,GAAG,IAAI;QACjF,MAAMC,UAAUZ,SAASM,eAAe,EAAEO,UAAUlB,4GAAAA,CAAKU,OAAO,CAACK,QAAQC,GAAG,IAAI;QAChF,IAAIG,aAAad,SAASM,eAAe,EAAES,OAAO,CAAC,kBAAkB,EAAE,CAAC,EAAE;QAE1E,IAAID,YAAY;YACdA,aAAanB,4GAAAA,CAAKU,OAAO,CAACD,eAAeU;QAC3C;QACA,OAAO;YACLA;YACAF;YACAI,UAAUZ;YACVI;YACAS,cAAclB,eAAeJ,IAAI;QACnC;IACF,EAAE,OAAOuB,OAAO;QACdC,QAAQD,KAAK,CAAC,CAAC,6BAA6B,EAAEA,OAAO,GAAE,8FAA8F;QACrJ,OAAO;YACLF,UAAUN,QAAQC,GAAG;QACvB;IACF;AACF;AAOO,MAAMS,aAAa;IACxB,gDAAgD;IAChD,wDAAwD;IACxD,IAAIV,QAAQW,GAAG,CAACC,mBAAmB,EAAE;QACnC,IAAI3B,4GAAAA,CAAK4B,UAAU,CAACb,QAAQW,GAAG,CAACC,mBAAmB,GAAG;YACpD,OAAOZ,QAAQW,GAAG,CAACC,mBAAmB;QACxC;QAEA,OAAO3B,4GAAAA,CAAKU,OAAO,CAACK,QAAQC,GAAG,IAAID,QAAQW,GAAG,CAACC,mBAAmB;IACpE;IAEA,MAAM,EAAER,UAAU,EAAEF,OAAO,EAAEI,QAAQ,EAAER,OAAO,EAAE,GAAGV;IAEnD,wDAAwD;IACxD,IAAIgB,cAAenB,CAAAA,4GAAAA,CAAK6B,OAAO,CAACV,gBAAgB,SAASnB,4GAAAA,CAAK6B,OAAO,CAACV,gBAAgB,KAAI,GAAI;QAC5F,OAAOA;IACT;IAEA,MAAMW,cACJf,QAAQW,GAAG,CAACK,QAAQ,KAAK,aACrB,0BACA;QAACZ;QAAYN;QAASQ;KAAS;IAErC,KAAK,MAAMW,cAAcF,YAAa;QACpC,IAAI,CAACE,YAAY;YACf;QACF;QAEA,MAAMb,iBAAalB,sKAAAA,EAAW;YAC5BgC,KAAKD;YACLE,WAAWhC;QACb;QAEA,IAAIiB,YAAY;YACd,OAAOA;QACT;IACF;IAEA,0EAA0E;IAC1E,mGAAmG;IACnG,IAAIJ,QAAQW,GAAG,CAACK,QAAQ,KAAK,cAAc;;SASpC;QACL,MAAMK,oBAAgBnC,sKAAAA,EAAW;YAC/BgC,KAAKjC,4GAAAA,CAAKU,OAAO,CAACK,QAAQC,GAAG,IAAI;YACjCkB,WAAWhC;QACb;QAEA,IAAIkC,eAAe;YACjB,OAAOA;QACT;IACF;IAEA,MAAM,IAAIC,MACR;AAEJ,EAAC"}}]
}