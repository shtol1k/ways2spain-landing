{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/auth/defaultUser.ts"],"sourcesContent":["import type { CollectionConfig } from '../collections/config/types.js'\n\nexport const defaultUserCollection: CollectionConfig = {\n  slug: 'users',\n  admin: {\n    useAsTitle: 'email',\n  },\n  auth: {\n    tokenExpiration: 7200,\n  },\n  fields: [],\n  labels: {\n    plural: ({ t }) => t('general:users'),\n    singular: ({ t }) => t('general:user'),\n  },\n}\n"],"names":["defaultUserCollection","slug","admin","useAsTitle","auth","tokenExpiration","fields","labels","plural","t","singular"],"mappings":";;;;AAEO,MAAMA,wBAA0C;IACrDC,MAAM;IACNC,OAAO;QACLC,YAAY;IACd;IACAC,MAAM;QACJC,iBAAiB;IACnB;IACAC,QAAQ,EAAE;IACVC,QAAQ;QACNC,QAAQ,CAAC,EAAEC,CAAC,EAAE,GAAKA,EAAE;QACrBC,UAAU,CAAC,EAAED,CAAC,EAAE,GAAKA,EAAE;IACzB;AACF,EAAC"}},
    {"offset": {"line": 26, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/auth/types.ts"],"sourcesContent":["import type { DeepRequired } from 'ts-essentials'\n\nimport type { CollectionSlug, GlobalSlug, Payload, TypedUser } from '../index.js'\nimport type { PayloadRequest, Where } from '../types/index.js'\n\n/**\n * A permission object that can be used to determine if a user has access to a specific operation.\n */\nexport type Permission = {\n  permission: boolean\n  where?: Where\n}\n\nexport type FieldsPermissions = {\n  [fieldName: string]: FieldPermissions\n}\n\nexport type BlockPermissions = {\n  create: Permission\n  fields: FieldsPermissions\n  read: Permission\n  update: Permission\n}\n\nexport type SanitizedBlockPermissions =\n  | {\n      fields: SanitizedFieldsPermissions\n    }\n  | true\n\nexport type BlocksPermissions = {\n  [blockSlug: string]: BlockPermissions\n}\n\nexport type SanitizedBlocksPermissions =\n  | {\n      [blockSlug: string]: SanitizedBlockPermissions\n    }\n  | true\n\nexport type FieldPermissions = {\n  blocks?: BlocksPermissions\n  create?: Permission\n  fields?: FieldsPermissions\n  read?: Permission\n  update?: Permission\n}\n\nexport type SanitizedFieldPermissions =\n  | {\n      blocks?: SanitizedBlocksPermissions\n      create: true\n      fields?: SanitizedFieldsPermissions\n      read: true\n      update: true\n    }\n  | true\n\nexport type SanitizedFieldsPermissions =\n  | {\n      [fieldName: string]: SanitizedFieldPermissions\n    }\n  | true\n\nexport type CollectionPermission = {\n  create?: Permission\n  delete?: Permission\n  fields: FieldsPermissions\n  read?: Permission\n  readVersions?: Permission\n  // Auth-enabled Collections only\n  unlock?: Permission\n  update?: Permission\n}\n\nexport type SanitizedCollectionPermission = {\n  create?: true\n  delete?: true\n  fields: SanitizedFieldsPermissions\n  read?: true\n  readVersions?: true\n  // Auth-enabled Collections only\n  unlock?: true\n  update?: true\n}\n\nexport type GlobalPermission = {\n  fields: FieldsPermissions\n  read?: Permission\n  readVersions?: Permission\n  update?: Permission\n}\n\nexport type SanitizedGlobalPermission = {\n  fields: SanitizedFieldsPermissions\n  read?: true\n  readVersions?: true\n  update?: true\n}\n\nexport type DocumentPermissions = CollectionPermission | GlobalPermission\n\nexport type SanitizedDocumentPermissions = SanitizedCollectionPermission | SanitizedGlobalPermission\n\nexport type Permissions = {\n  canAccessAdmin: boolean\n  collections?: Record<CollectionSlug, CollectionPermission>\n  globals?: Record<GlobalSlug, GlobalPermission>\n}\n\nexport type SanitizedPermissions = {\n  canAccessAdmin?: boolean\n  collections?: {\n    [collectionSlug: string]: SanitizedCollectionPermission\n  }\n  globals?: {\n    [globalSlug: string]: SanitizedGlobalPermission\n  }\n}\n\ntype BaseUser = {\n  collection: string\n  email?: string\n  id: number | string\n  sessions?: Array<UserSession>\n  username?: string\n}\n\n/**\n * @deprecated Use `TypedUser` instead. This will be removed in 4.0.\n */\nexport type UntypedUser = {\n  [key: string]: any\n} & BaseUser\n\n/**\n * `collection` is not available one the client. It's only available on the server (req.user)\n * On the client, you can access the collection via config.admin.user. Config can be accessed using the useConfig() hook\n */\nexport type ClientUser = {\n  [key: string]: any\n} & BaseUser\n\nexport type UserSession = { createdAt: Date | string; expiresAt: Date | string; id: string }\ntype GenerateVerifyEmailHTML<TUser = any> = (args: {\n  req: PayloadRequest\n  token: string\n  user: TUser\n}) => Promise<string> | string\n\ntype GenerateVerifyEmailSubject<TUser = any> = (args: {\n  req: PayloadRequest\n  token: string\n  user: TUser\n}) => Promise<string> | string\n\ntype GenerateForgotPasswordEmailHTML<TUser = any> = (args?: {\n  req?: PayloadRequest\n  token?: string\n  user?: TUser\n}) => Promise<string> | string\n\ntype GenerateForgotPasswordEmailSubject<TUser = any> = (args?: {\n  req?: PayloadRequest\n  token?: string\n  user?: TUser\n}) => Promise<string> | string\n\nexport type AuthStrategyFunctionArgs = {\n  /**\n   * Specifies whether or not response headers can be set from this strategy.\n   */\n  canSetHeaders?: boolean\n  headers: Request['headers']\n  isGraphQL?: boolean\n  payload: Payload\n  /**\n   * The AuthStrategy name property from the payload config.\n   */\n  strategyName?: string\n}\n\nexport type AuthStrategyResult = {\n  responseHeaders?: Headers\n  user:\n    | ({\n        _strategy?: string\n        collection?: string\n      } & TypedUser)\n    | null\n}\n\nexport type AuthStrategyFunction = (\n  args: AuthStrategyFunctionArgs,\n) => AuthStrategyResult | Promise<AuthStrategyResult>\nexport type AuthStrategy = {\n  authenticate: AuthStrategyFunction\n  name: string\n}\n\nexport type LoginWithUsernameOptions =\n  | {\n      allowEmailLogin?: false\n      requireEmail?: boolean\n      // If `allowEmailLogin` is false, `requireUsername` must be true (default: true)\n      requireUsername?: true\n    }\n  | {\n      allowEmailLogin?: true\n      requireEmail?: boolean\n      requireUsername?: boolean\n    }\n\nexport interface IncomingAuthType {\n  /**\n   * Set cookie options, including secure, sameSite, and domain. For advanced users.\n   */\n  cookies?: {\n    domain?: string\n    sameSite?: 'Lax' | 'None' | 'Strict' | boolean\n    secure?: boolean\n  }\n  /**\n   * How many levels deep a user document should be populated when creating the JWT and binding the user to the req. Defaults to 0 and should only be modified if absolutely necessary, as this will affect performance.\n   * @default 0\n   */\n  depth?: number\n  /**\n   * Advanced - disable Payload's built-in local auth strategy. Only use this property if you have replaced Payload's auth mechanisms with your own.\n   */\n  disableLocalStrategy?:\n    | {\n        /**\n         * Include auth fields on the collection even though the local strategy is disabled.\n         * Useful when you do not want the database or types to vary depending on the auth configuration.\n         */\n        enableFields?: true\n        optionalPassword?: true\n      }\n    | true\n  /**\n   * Customize the way that the forgotPassword operation functions.\n   * @link https://payloadcms.com/docs/authentication/email#forgot-password\n   */\n  forgotPassword?: {\n    /**\n     * The number of milliseconds that the forgot password token should be valid for.\n     * @default 3600000 // 1 hour\n     */\n    expiration?: number\n    generateEmailHTML?: GenerateForgotPasswordEmailHTML\n    generateEmailSubject?: GenerateForgotPasswordEmailSubject\n  }\n  /**\n   * Set the time (in milliseconds) that a user should be locked out if they fail authentication more times than maxLoginAttempts allows for.\n   */\n  lockTime?: number\n  /**\n   * Ability to allow users to login with username/password.\n   *\n   * @link https://payloadcms.com/docs/authentication/overview#login-with-username\n   */\n  loginWithUsername?: boolean | LoginWithUsernameOptions\n  /**\n   * Only allow a user to attempt logging in X amount of times. Automatically locks out a user from authenticating if this limit is passed. Set to 0 to disable.\n   */\n  maxLoginAttempts?: number\n  /***\n   * Set to true if you want to remove the token from the returned authentication API responses such as login or refresh.\n   */\n  removeTokenFromResponses?: true\n  /**\n   * Advanced - an array of custom authentification strategies to extend this collection's authentication with.\n   * @link https://payloadcms.com/docs/authentication/custom-strategies\n   */\n  strategies?: AuthStrategy[]\n  /**\n   * Controls how many seconds the token will be valid for. Default is 2 hours.\n   * @default 7200\n   * @link https://payloadcms.com/docs/authentication/overview#config-options\n   */\n  tokenExpiration?: number\n  /**\n   * Payload Authentication provides for API keys to be set on each user within an Authentication-enabled Collection.\n   * @default false\n   * @link https://payloadcms.com/docs/authentication/api-keys\n   */\n  useAPIKey?: boolean\n\n  /**\n   * Use sessions for authentication. Enabled by default.\n   * @default true\n   */\n  useSessions?: boolean\n\n  /**\n   * Set to true or pass an object with verification options to require users to verify by email before they are allowed to log into your app.\n   * @link https://payloadcms.com/docs/authentication/email#email-verification\n   */\n  verify?:\n    | {\n        generateEmailHTML?: GenerateVerifyEmailHTML\n        generateEmailSubject?: GenerateVerifyEmailSubject\n      }\n    | boolean\n}\n\nexport type VerifyConfig = {\n  generateEmailHTML?: GenerateVerifyEmailHTML\n  generateEmailSubject?: GenerateVerifyEmailSubject\n}\n\nexport interface Auth\n  extends Omit<DeepRequired<IncomingAuthType>, 'forgotPassword' | 'loginWithUsername' | 'verify'> {\n  forgotPassword?: {\n    expiration?: number\n    generateEmailHTML?: GenerateForgotPasswordEmailHTML\n    generateEmailSubject?: GenerateForgotPasswordEmailSubject\n  }\n  loginWithUsername: false | LoginWithUsernameOptions\n  verify?: boolean | VerifyConfig\n}\n\nexport function hasWhereAccessResult(result: boolean | Where): result is Where {\n  return result && typeof result === 'object'\n}\n"],"names":["hasWhereAccessResult","result"],"mappings":";;;;AAmUO,SAASA,qBAAqBC,MAAuB;IAC1D,OAAOA,UAAU,OAAOA,WAAW;AACrC"}},
    {"offset": {"line": 37, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/auth/getAccessResults.ts"],"sourcesContent":["import type { AllOperations, PayloadRequest } from '../types/index.js'\nimport type { Permissions, SanitizedPermissions } from './types.js'\n\nimport { getEntityPermissions } from '../utilities/getEntityPermissions/getEntityPermissions.js'\nimport { sanitizePermissions } from '../utilities/sanitizePermissions.js'\n\ntype GetAccessResultsArgs = {\n  req: PayloadRequest\n}\nexport async function getAccessResults({\n  req,\n}: GetAccessResultsArgs): Promise<SanitizedPermissions> {\n  const results = {\n    collections: {},\n    globals: {},\n  } as Permissions\n  const { payload, user } = req\n\n  const isLoggedIn = !!user\n  const userCollectionConfig =\n    user && user.collection ? payload?.collections?.[user.collection]?.config : null\n\n  if (userCollectionConfig && payload.config.admin.user === user?.collection) {\n    results.canAccessAdmin = userCollectionConfig.access.admin\n      ? await userCollectionConfig.access.admin({ req })\n      : isLoggedIn\n  } else {\n    results.canAccessAdmin = false\n  }\n  const blockReferencesPermissions = {}\n\n  await Promise.all(\n    payload.config.collections.map(async (collection) => {\n      const collectionOperations: AllOperations[] = ['create', 'read', 'update', 'delete']\n\n      if (\n        collection.auth &&\n        typeof collection.auth.maxLoginAttempts !== 'undefined' &&\n        collection.auth.maxLoginAttempts !== 0\n      ) {\n        collectionOperations.push('unlock')\n      }\n\n      if (collection.versions) {\n        collectionOperations.push('readVersions')\n      }\n\n      const collectionPermissions = await getEntityPermissions({\n        blockReferencesPermissions,\n        entity: collection,\n        entityType: 'collection',\n        fetchData: false,\n        operations: collectionOperations,\n        req,\n      })\n      results.collections![collection.slug] = collectionPermissions\n    }),\n  )\n\n  await Promise.all(\n    payload.config.globals.map(async (global) => {\n      const globalOperations: AllOperations[] = ['read', 'update']\n\n      if (global.versions) {\n        globalOperations.push('readVersions')\n      }\n\n      const globalPermissions = await getEntityPermissions({\n        blockReferencesPermissions,\n        entity: global,\n        entityType: 'global',\n        fetchData: false,\n        operations: globalOperations,\n        req,\n      })\n      results.globals![global.slug] = globalPermissions\n    }),\n  )\n\n  return sanitizePermissions(results)\n}\n"],"names":["getEntityPermissions","sanitizePermissions","getAccessResults","req","results","collections","globals","payload","user","isLoggedIn","userCollectionConfig","collection","config","admin","canAccessAdmin","access","blockReferencesPermissions","Promise","all","map","collectionOperations","auth","maxLoginAttempts","push","versions","collectionPermissions","entity","entityType","fetchData","operations","slug","global","globalOperations","globalPermissions"],"mappings":";;;;AAGA,SAASA,oBAAoB,QAAQ,4DAA2D;AAChG,SAASC,mBAAmB,QAAQ,sCAAqC;;;AAKlE,eAAeC,iBAAiB,EACrCC,GAAG,EACkB;IACrB,MAAMC,UAAU;QACdC,aAAa,CAAC;QACdC,SAAS,CAAC;IACZ;IACA,MAAM,EAAEC,OAAO,EAAEC,IAAI,EAAE,GAAGL;IAE1B,MAAMM,aAAa,CAAC,CAACD;IACrB,MAAME,uBACJF,QAAQA,KAAKG,UAAU,GAAGJ,SAASF,aAAa,CAACG,KAAKG,UAAU,CAAC,EAAEC,SAAS;IAE9E,IAAIF,wBAAwBH,QAAQK,MAAM,CAACC,KAAK,CAACL,IAAI,KAAKA,MAAMG,YAAY;QAC1EP,QAAQU,cAAc,GAAGJ,qBAAqBK,MAAM,CAACF,KAAK,GACtD,MAAMH,qBAAqBK,MAAM,CAACF,KAAK,CAAC;YAAEV;QAAI,KAC9CM;IACN,OAAO;QACLL,QAAQU,cAAc,GAAG;IAC3B;IACA,MAAME,6BAA6B,CAAC;IAEpC,MAAMC,QAAQC,GAAG,CACfX,QAAQK,MAAM,CAACP,WAAW,CAACc,GAAG,CAAC,OAAOR;QACpC,MAAMS,uBAAwC;YAAC;YAAU;YAAQ;YAAU;SAAS;QAEpF,IACET,WAAWU,IAAI,IACf,OAAOV,WAAWU,IAAI,CAACC,gBAAgB,KAAK,eAC5CX,WAAWU,IAAI,CAACC,gBAAgB,KAAK,GACrC;YACAF,qBAAqBG,IAAI,CAAC;QAC5B;QAEA,IAAIZ,WAAWa,QAAQ,EAAE;YACvBJ,qBAAqBG,IAAI,CAAC;QAC5B;QAEA,MAAME,wBAAwB,UAAMzB,sNAAAA,EAAqB;YACvDgB;YACAU,QAAQf;YACRgB,YAAY;YACZC,WAAW;YACXC,YAAYT;YACZjB;QACF;QACAC,QAAQC,WAAY,CAACM,WAAWmB,IAAI,CAAC,GAAGL;IAC1C;IAGF,MAAMR,QAAQC,GAAG,CACfX,QAAQK,MAAM,CAACN,OAAO,CAACa,GAAG,CAAC,OAAOY;QAChC,MAAMC,mBAAoC;YAAC;YAAQ;SAAS;QAE5D,IAAID,OAAOP,QAAQ,EAAE;YACnBQ,iBAAiBT,IAAI,CAAC;QACxB;QAEA,MAAMU,oBAAoB,UAAMjC,sNAAAA,EAAqB;YACnDgB;YACAU,QAAQK;YACRJ,YAAY;YACZC,WAAW;YACXC,YAAYG;YACZ7B;QACF;QACAC,QAAQE,OAAQ,CAACyB,OAAOD,IAAI,CAAC,GAAGG;IAClC;IAGF,WAAOhC,4LAAAA,EAAoBG;AAC7B"}},
    {"offset": {"line": 108, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/auth/operations/access.ts"],"sourcesContent":["import type { PayloadRequest } from '../../types/index.js'\nimport type { SanitizedPermissions } from '../types.js'\n\nimport { killTransaction } from '../../utilities/killTransaction.js'\nimport { adminInit as adminInitTelemetry } from '../../utilities/telemetry/events/adminInit.js'\nimport { getAccessResults } from '../getAccessResults.js'\n\ntype Arguments = {\n  req: PayloadRequest\n}\n\nexport const accessOperation = async (args: Arguments): Promise<SanitizedPermissions> => {\n  const { req } = args\n\n  adminInitTelemetry(req)\n\n  try {\n    return getAccessResults({ req })\n  } catch (e: unknown) {\n    await killTransaction(req)\n    throw e\n  }\n}\n"],"names":["killTransaction","adminInit","adminInitTelemetry","getAccessResults","accessOperation","args","req","e"],"mappings":";;;;AAGA,SAASA,eAAe,QAAQ,qCAAoC;AACpE,SAASC,aAAaC,kBAAkB,QAAQ,gDAA+C;AAC/F,SAASC,gBAAgB,QAAQ,yBAAwB;;;;AAMlD,MAAMC,kBAAkB,OAAOC;IACpC,MAAM,EAAEC,GAAG,EAAE,GAAGD;QAEhBH,+LAAAA,EAAmBI;IAEnB,IAAI;QACF,WAAOH,iLAAAA,EAAiB;YAAEG;QAAI;IAChC,EAAE,OAAOC,GAAY;QACnB,UAAMP,oLAAAA,EAAgBM;QACtB,MAAMC;IACR;AACF,EAAC"}},
    {"offset": {"line": 134, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/auth/endpoints/access.ts"],"sourcesContent":["import { status as httpStatus } from 'http-status'\n\nimport type { PayloadHandler } from '../../config/types.js'\n\nimport { headersWithCors } from '../../utilities/headersWithCors.js'\nimport { accessOperation } from '../operations/access.js'\n\nexport const accessHandler: PayloadHandler = async (req) => {\n  const headers = headersWithCors({\n    headers: new Headers(),\n    req,\n  })\n\n  try {\n    const results = await accessOperation({\n      req,\n    })\n\n    return Response.json(results, {\n      headers,\n      status: httpStatus.OK,\n    })\n  } catch (e: unknown) {\n    return Response.json(\n      {\n        error: e,\n      },\n      {\n        headers,\n        status: httpStatus.INTERNAL_SERVER_ERROR,\n      },\n    )\n  }\n}\n"],"names":["status","httpStatus","headersWithCors","accessOperation","accessHandler","req","headers","Headers","results","Response","json","OK","e","error","INTERNAL_SERVER_ERROR"],"mappings":";;;;;AAAA,SAASA,UAAUC,UAAU,QAAQ,cAAa;AAIlD,SAASC,eAAe,QAAQ,qCAAoC;AACpE,SAASC,eAAe,QAAQ,0BAAyB;;;;AAElD,MAAMC,gBAAgC,OAAOC;IAClD,MAAMC,cAAUJ,oLAAAA,EAAgB;QAC9BI,SAAS,IAAIC;QACbF;IACF;IAEA,IAAI;QACF,MAAMG,UAAU,UAAML,oLAAAA,EAAgB;YACpCE;QACF;QAEA,OAAOI,SAASC,IAAI,CAACF,SAAS;YAC5BF;YACAN,QAAQC,sMAAAA,CAAWU,EAAE;QACvB;IACF,EAAE,OAAOC,GAAY;QACnB,OAAOH,SAASC,IAAI,CAClB;YACEG,OAAOD;QACT,GACA;YACEN;YACAN,QAAQC,sMAAAA,CAAWa,qBAAqB;QAC1C;IAEJ;AACF,EAAC"}},
    {"offset": {"line": 171, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/auth/getLoginOptions.ts"],"sourcesContent":["import type { Auth } from './types.js'\n\nexport const getLoginOptions = (\n  loginWithUsername: Auth['loginWithUsername'],\n): {\n  canLoginWithEmail: boolean\n  canLoginWithUsername: boolean\n} => {\n  return {\n    canLoginWithEmail: !loginWithUsername || loginWithUsername.allowEmailLogin!,\n    canLoginWithUsername: Boolean(loginWithUsername),\n  }\n}\n"],"names":["getLoginOptions","loginWithUsername","canLoginWithEmail","allowEmailLogin","canLoginWithUsername","Boolean"],"mappings":";;;;AAEO,MAAMA,kBAAkB,CAC7BC;IAKA,OAAO;QACLC,mBAAmB,CAACD,qBAAqBA,kBAAkBE,eAAe;QAC1EC,sBAAsBC,QAAQJ;IAChC;AACF,EAAC"}},
    {"offset": {"line": 185, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/auth/operations/forgotPassword.ts"],"sourcesContent":["import crypto from 'crypto'\nimport { status as httpStatus } from 'http-status'\nimport { URL } from 'url'\n\nimport type {\n  AuthOperationsFromCollectionSlug,\n  Collection,\n} from '../../collections/config/types.js'\nimport type { CollectionSlug } from '../../index.js'\nimport type { PayloadRequest, Where } from '../../types/index.js'\n\nimport { buildAfterOperation } from '../../collections/operations/utilities/buildAfterOperation.js'\nimport { buildBeforeOperation } from '../../collections/operations/utilities/buildBeforeOperation.js'\nimport { APIError } from '../../errors/index.js'\nimport { Forbidden } from '../../index.js'\nimport { appendNonTrashedFilter } from '../../utilities/appendNonTrashedFilter.js'\nimport { commitTransaction } from '../../utilities/commitTransaction.js'\nimport { formatAdminURL } from '../../utilities/formatAdminURL.js'\nimport { initTransaction } from '../../utilities/initTransaction.js'\nimport { killTransaction } from '../../utilities/killTransaction.js'\nimport { getLoginOptions } from '../getLoginOptions.js'\n\nexport type Arguments<TSlug extends CollectionSlug> = {\n  collection: Collection\n  data: {\n    [key: string]: unknown\n  } & AuthOperationsFromCollectionSlug<TSlug>['forgotPassword']\n  disableEmail?: boolean\n  expiration?: number\n  overrideAccess?: boolean\n  req: PayloadRequest\n}\n\nexport type Result = string\n\nexport const forgotPasswordOperation = async <TSlug extends CollectionSlug>(\n  incomingArgs: Arguments<TSlug>,\n): Promise<null | string> => {\n  const loginWithUsername = incomingArgs.collection.config.auth.loginWithUsername\n  const { data, overrideAccess } = incomingArgs\n\n  const { canLoginWithEmail, canLoginWithUsername } = getLoginOptions(loginWithUsername)\n\n  const sanitizedEmail =\n    (canLoginWithEmail && (incomingArgs.data.email || '').toLowerCase().trim()) || null\n  const sanitizedUsername =\n    'username' in data && typeof data?.username === 'string'\n      ? data.username.toLowerCase().trim()\n      : null\n\n  let args = incomingArgs\n\n  if (incomingArgs.collection.config.auth.disableLocalStrategy) {\n    throw new Forbidden(incomingArgs.req.t)\n  }\n  if (!sanitizedEmail && !sanitizedUsername) {\n    throw new APIError(\n      `Missing ${loginWithUsername ? 'username' : 'email'}.`,\n      httpStatus.BAD_REQUEST,\n    )\n  }\n\n  try {\n    const shouldCommit = await initTransaction(args.req)\n\n    // /////////////////////////////////////\n    // beforeOperation - Collection\n    // /////////////////////////////////////\n    args = await buildBeforeOperation({\n      args,\n      collection: args.collection.config,\n      operation: 'forgotPassword',\n      overrideAccess,\n    })\n\n    const {\n      collection: { config: collectionConfig },\n      disableEmail,\n      expiration,\n      req: {\n        payload: { config, email },\n        payload,\n      },\n      req,\n    } = args\n\n    // /////////////////////////////////////\n    // Forget password\n    // /////////////////////////////////////\n\n    let token: string = crypto.randomBytes(20).toString('hex')\n    type UserDoc = {\n      email?: string\n      id: number | string\n      resetPasswordExpiration?: string\n      resetPasswordToken?: string\n    }\n\n    if (!sanitizedEmail && !sanitizedUsername) {\n      throw new APIError(\n        `Missing ${loginWithUsername ? 'username' : 'email'}.`,\n        httpStatus.BAD_REQUEST,\n      )\n    }\n\n    let whereConstraint: Where = {}\n\n    if (canLoginWithEmail && sanitizedEmail) {\n      whereConstraint = {\n        email: {\n          equals: sanitizedEmail,\n        },\n      }\n    } else if (canLoginWithUsername && sanitizedUsername) {\n      whereConstraint = {\n        username: {\n          equals: sanitizedUsername,\n        },\n      }\n    }\n\n    // Exclude trashed users unless `trash: true`\n    whereConstraint = appendNonTrashedFilter({\n      enableTrash: collectionConfig.trash,\n      trash: false,\n      where: whereConstraint,\n    })\n\n    let user = await payload.db.findOne<UserDoc>({\n      collection: collectionConfig.slug,\n      req,\n      where: whereConstraint,\n    })\n\n    // We don't want to indicate specifically that an email was not found,\n    // as doing so could lead to the exposure of registered emails.\n    // Therefore, we prefer to fail silently.\n    if (!user) {\n      await commitTransaction(args.req)\n      return null\n    }\n\n    const resetPasswordExpiration = new Date(\n      Date.now() + (collectionConfig.auth?.forgotPassword?.expiration ?? expiration ?? 3600000),\n    ).toISOString()\n\n    user = await payload.update({\n      id: user.id,\n      collection: collectionConfig.slug,\n      data: {\n        resetPasswordExpiration,\n        resetPasswordToken: token,\n      },\n      req,\n    })\n\n    if (!disableEmail && user.email) {\n      const protocol = new URL(req.url!).protocol // includes the final :\n      const serverURL =\n        config.serverURL !== null && config.serverURL !== ''\n          ? config.serverURL\n          : `${protocol}//${req.headers.get('host')}`\n      const forgotURL = formatAdminURL({\n        adminRoute: config.routes.admin,\n        path: `${config.admin.routes.reset}/${token}`,\n        serverURL,\n      })\n      let html = `${req.t('authentication:youAreReceivingResetPassword')}\n    <a href=\"${forgotURL}\">${forgotURL}</a>\n    ${req.t('authentication:youDidNotRequestPassword')}`\n\n      if (typeof collectionConfig.auth.forgotPassword?.generateEmailHTML === 'function') {\n        html = await collectionConfig.auth.forgotPassword.generateEmailHTML({\n          req,\n          token,\n          user,\n        })\n      }\n\n      let subject = req.t('authentication:resetYourPassword')\n\n      if (typeof collectionConfig.auth.forgotPassword?.generateEmailSubject === 'function') {\n        subject = await collectionConfig.auth.forgotPassword.generateEmailSubject({\n          req,\n          token,\n          user,\n        })\n      }\n\n      await email.sendEmail({\n        from: `\"${email.defaultFromName}\" <${email.defaultFromAddress}>`,\n        html,\n        subject,\n        to: user.email,\n      })\n    }\n\n    // /////////////////////////////////////\n    // afterForgotPassword - Collection\n    // /////////////////////////////////////\n\n    if (collectionConfig.hooks?.afterForgotPassword?.length) {\n      for (const hook of collectionConfig.hooks.afterForgotPassword) {\n        await hook({ args, collection: args.collection?.config, context: req.context })\n      }\n    }\n\n    // /////////////////////////////////////\n    // afterOperation - Collection\n    // /////////////////////////////////////\n\n    token = await buildAfterOperation({\n      args,\n      collection: args.collection?.config,\n      operation: 'forgotPassword',\n      overrideAccess,\n      result: token,\n    })\n\n    if (shouldCommit) {\n      await commitTransaction(req)\n    }\n\n    return token\n  } catch (error: unknown) {\n    await killTransaction(args.req)\n    throw error\n  }\n}\n"],"names":["crypto","status","httpStatus","URL","buildAfterOperation","buildBeforeOperation","APIError","Forbidden","appendNonTrashedFilter","commitTransaction","formatAdminURL","initTransaction","killTransaction","getLoginOptions","forgotPasswordOperation","incomingArgs","loginWithUsername","collection","config","auth","data","overrideAccess","canLoginWithEmail","canLoginWithUsername","sanitizedEmail","email","toLowerCase","trim","sanitizedUsername","username","args","disableLocalStrategy","req","t","BAD_REQUEST","shouldCommit","operation","collectionConfig","disableEmail","expiration","payload","token","randomBytes","toString","whereConstraint","equals","enableTrash","trash","where","user","db","findOne","slug","resetPasswordExpiration","Date","now","forgotPassword","toISOString","update","id","resetPasswordToken","protocol","url","serverURL","headers","get","forgotURL","adminRoute","routes","admin","path","reset","html","generateEmailHTML","subject","generateEmailSubject","sendEmail","from","defaultFromName","defaultFromAddress","to","hooks","afterForgotPassword","length","hook","context","result","error"],"mappings":"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"}},
    {"offset": {"line": 359, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/auth/endpoints/forgotPassword.ts"],"sourcesContent":["import { status as httpStatus } from 'http-status'\n\nimport type { PayloadHandler } from '../../config/types.js'\n\nimport { getRequestCollection } from '../../utilities/getRequestEntity.js'\nimport { headersWithCors } from '../../utilities/headersWithCors.js'\nimport { forgotPasswordOperation } from '../operations/forgotPassword.js'\n\nexport const forgotPasswordHandler: PayloadHandler = async (req) => {\n  const { t } = req\n\n  const collection = getRequestCollection(req)\n\n  const authData = collection.config.auth?.loginWithUsername\n    ? {\n        email: typeof req.data?.email === 'string' ? req.data.email : '',\n        username: typeof req.data?.username === 'string' ? req.data.username : '',\n      }\n    : {\n        email: typeof req.data?.email === 'string' ? req.data.email : '',\n      }\n\n  await forgotPasswordOperation({\n    collection,\n    data: authData,\n    disableEmail: Boolean(req.data?.disableEmail),\n    expiration: typeof req.data?.expiration === 'number' ? req.data.expiration : undefined,\n    req,\n  })\n\n  return Response.json(\n    {\n      message: t('general:success'),\n    },\n    {\n      headers: headersWithCors({\n        headers: new Headers(),\n        req,\n      }),\n      status: httpStatus.OK,\n    },\n  )\n}\n"],"names":["status","httpStatus","getRequestCollection","headersWithCors","forgotPasswordOperation","forgotPasswordHandler","req","t","collection","authData","config","auth","loginWithUsername","email","data","username","disableEmail","Boolean","expiration","undefined","Response","json","message","headers","Headers","OK"],"mappings":";;;;;AAAA,SAASA,UAAUC,UAAU,QAAQ,cAAa;AAIlD,SAASC,oBAAoB,QAAQ,sCAAqC;AAC1E,SAASC,eAAe,QAAQ,qCAAoC;AACpE,SAASC,uBAAuB,QAAQ,kCAAiC;;;;;AAElE,MAAMC,wBAAwC,OAAOC;IAC1D,MAAM,EAAEC,CAAC,EAAE,GAAGD;IAEd,MAAME,iBAAaN,0LAAAA,EAAqBI;IAExC,MAAMG,WAAWD,WAAWE,MAAM,CAACC,IAAI,EAAEC,oBACrC;QACEC,OAAO,OAAOP,IAAIQ,IAAI,EAAED,UAAU,WAAWP,IAAIQ,IAAI,CAACD,KAAK,GAAG;QAC9DE,UAAU,OAAOT,IAAIQ,IAAI,EAAEC,aAAa,WAAWT,IAAIQ,IAAI,CAACC,QAAQ,GAAG;IACzE,IACA;QACEF,OAAO,OAAOP,IAAIQ,IAAI,EAAED,UAAU,WAAWP,IAAIQ,IAAI,CAACD,KAAK,GAAG;IAChE;IAEJ,UAAMT,oMAAAA,EAAwB;QAC5BI;QACAM,MAAML;QACNO,cAAcC,QAAQX,IAAIQ,IAAI,EAAEE;QAChCE,YAAY,OAAOZ,IAAIQ,IAAI,EAAEI,eAAe,WAAWZ,IAAIQ,IAAI,CAACI,UAAU,GAAGC;QAC7Eb;IACF;IAEA,OAAOc,SAASC,IAAI,CAClB;QACEC,SAASf,EAAE;IACb,GACA;QACEgB,aAASpB,oLAAAA,EAAgB;YACvBoB,SAAS,IAAIC;YACblB;QACF;QACAN,QAAQC,sMAAAA,CAAWwB,EAAE;IACvB;AAEJ,EAAC"}},
    {"offset": {"line": 402, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/auth/operations/init.ts"],"sourcesContent":["import type { PayloadRequest, Where } from '../../types/index.js'\n\nimport { appendNonTrashedFilter } from '../../utilities/appendNonTrashedFilter.js'\n\nexport const initOperation = async (args: {\n  collection: string\n  req: PayloadRequest\n}): Promise<boolean> => {\n  const { collection: slug, req } = args\n\n  const collectionConfig = req.payload.config.collections?.find((c) => c.slug === slug)\n\n  // Exclude trashed documents unless `trash: true`\n  const where: Where = appendNonTrashedFilter({\n    enableTrash: Boolean(collectionConfig?.trash),\n    trash: false,\n    where: {},\n  })\n\n  const doc = await req.payload.db.findOne({\n    collection: slug,\n    req,\n    where,\n  })\n\n  return !!doc\n}\n"],"names":["appendNonTrashedFilter","initOperation","args","collection","slug","req","collectionConfig","payload","config","collections","find","c","where","enableTrash","Boolean","trash","doc","db","findOne"],"mappings":";;;;AAEA,SAASA,sBAAsB,QAAQ,4CAA2C;;AAE3E,MAAMC,gBAAgB,OAAOC;IAIlC,MAAM,EAAEC,YAAYC,IAAI,EAAEC,GAAG,EAAE,GAAGH;IAElC,MAAMI,mBAAmBD,IAAIE,OAAO,CAACC,MAAM,CAACC,WAAW,EAAEC,KAAK,CAACC,IAAMA,EAAEP,IAAI,KAAKA;IAEhF,iDAAiD;IACjD,MAAMQ,YAAeZ,kMAAAA,EAAuB;QAC1Ca,aAAaC,QAAQR,kBAAkBS;QACvCA,OAAO;QACPH,OAAO,CAAC;IACV;IAEA,MAAMI,MAAM,MAAMX,IAAIE,OAAO,CAACU,EAAE,CAACC,OAAO,CAAC;QACvCf,YAAYC;QACZC;QACAO;IACF;IAEA,OAAO,CAAC,CAACI;AACX,EAAC"}},
    {"offset": {"line": 428, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/auth/endpoints/init.ts"],"sourcesContent":["import type { PayloadHandler } from '../../config/types.js'\n\nimport { getRequestCollection } from '../../utilities/getRequestEntity.js'\nimport { headersWithCors } from '../../utilities/headersWithCors.js'\nimport { initOperation } from '../operations/init.js'\n\nexport const initHandler: PayloadHandler = async (req) => {\n  const initialized = await initOperation({\n    collection: getRequestCollection(req).config.slug,\n    req,\n  })\n\n  return Response.json(\n    { initialized },\n    {\n      headers: headersWithCors({\n        headers: new Headers(),\n        req,\n      }),\n    },\n  )\n}\n"],"names":["getRequestCollection","headersWithCors","initOperation","initHandler","req","initialized","collection","config","slug","Response","json","headers","Headers"],"mappings":";;;;AAEA,SAASA,oBAAoB,QAAQ,sCAAqC;AAC1E,SAASC,eAAe,QAAQ,qCAAoC;AACpE,SAASC,aAAa,QAAQ,wBAAuB;;;;AAE9C,MAAMC,cAA8B,OAAOC;IAChD,MAAMC,cAAc,UAAMH,gLAAAA,EAAc;QACtCI,gBAAYN,0LAAAA,EAAqBI,KAAKG,MAAM,CAACC,IAAI;QACjDJ;IACF;IAEA,OAAOK,SAASC,IAAI,CAClB;QAAEL;IAAY,GACd;QACEM,aAASV,oLAAAA,EAAgB;YACvBU,SAAS,IAAIC;YACbR;QACF;IACF;AAEJ,EAAC"}},
    {"offset": {"line": 456, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/auth/cookies.ts"],"sourcesContent":["import type { SanitizedCollectionConfig } from './../collections/config/types.js'\n\ntype CookieOptions = {\n  domain?: string\n  expires?: Date\n  httpOnly?: boolean\n  maxAge?: number\n  name: string\n  path?: string\n  returnCookieAsObject: boolean\n  sameSite?: 'Lax' | 'None' | 'Strict'\n  secure?: boolean\n  value?: string\n}\n\ntype CookieObject = {\n  domain?: string\n  expires?: string\n  httpOnly?: boolean\n  maxAge?: number\n  name: string\n  path?: string\n  sameSite?: 'Lax' | 'None' | 'Strict'\n  secure?: boolean\n  value: string | undefined\n}\n\nexport const generateCookie = <ReturnCookieAsObject = boolean>(\n  args: CookieOptions,\n): ReturnCookieAsObject extends true ? CookieObject : string => {\n  const {\n    name,\n    domain,\n    expires,\n    httpOnly,\n    maxAge,\n    path,\n    returnCookieAsObject,\n    sameSite,\n    secure: secureArg,\n    value,\n  } = args\n\n  let cookieString = `${name}=${value || ''}`\n  const cookieObject: CookieObject = {\n    name,\n    value,\n  }\n\n  const secure = secureArg || sameSite === 'None'\n\n  if (expires) {\n    if (returnCookieAsObject) {\n      cookieObject.expires = expires.toUTCString()\n    } else {\n      cookieString += `; Expires=${expires.toUTCString()}`\n    }\n  }\n\n  if (maxAge) {\n    if (returnCookieAsObject) {\n      cookieObject.maxAge = maxAge\n    } else {\n      cookieString += `; Max-Age=${maxAge.toString()}`\n    }\n  }\n\n  if (domain) {\n    if (returnCookieAsObject) {\n      cookieObject.domain = domain\n    } else {\n      cookieString += `; Domain=${domain}`\n    }\n  }\n\n  if (path) {\n    if (returnCookieAsObject) {\n      cookieObject.path = path\n    } else {\n      cookieString += `; Path=${path}`\n    }\n  }\n\n  if (secure) {\n    if (returnCookieAsObject) {\n      cookieObject.secure = secure\n    } else {\n      cookieString += `; Secure=${secure}`\n    }\n  }\n\n  if (httpOnly) {\n    if (returnCookieAsObject) {\n      cookieObject.httpOnly = httpOnly\n    } else {\n      cookieString += `; HttpOnly=${httpOnly}`\n    }\n  }\n\n  if (sameSite) {\n    if (returnCookieAsObject) {\n      cookieObject.sameSite = sameSite\n    } else {\n      cookieString += `; SameSite=${sameSite}`\n    }\n  }\n\n  return (returnCookieAsObject ? cookieObject : cookieString) as ReturnCookieAsObject extends true\n    ? CookieObject\n    : string\n}\ntype GetCookieExpirationArgs = {\n  /*\n    The number of seconds until the cookie expires\n    @default 7200 seconds (2 hours)\n  */\n  seconds: number\n}\nexport const getCookieExpiration = ({ seconds = 7200 }: GetCookieExpirationArgs) => {\n  const currentTime = new Date()\n  currentTime.setSeconds(currentTime.getSeconds() + seconds)\n  return currentTime\n}\n\ntype GeneratePayloadCookieArgs = {\n  /* The auth collection config */\n  collectionAuthConfig: SanitizedCollectionConfig['auth']\n  /* Prefix to scope the cookie */\n  cookiePrefix: string\n  /* The returnAs value */\n  returnCookieAsObject?: boolean\n  /* The token to be stored in the cookie */\n  token: string\n}\nexport const generatePayloadCookie = <T extends GeneratePayloadCookieArgs>({\n  collectionAuthConfig,\n  cookiePrefix,\n  returnCookieAsObject = false,\n  token,\n}: T): T['returnCookieAsObject'] extends true ? CookieObject : string => {\n  const sameSite =\n    typeof collectionAuthConfig.cookies.sameSite === 'string'\n      ? collectionAuthConfig.cookies.sameSite\n      : collectionAuthConfig.cookies.sameSite\n        ? 'Strict'\n        : undefined\n\n  return generateCookie<T['returnCookieAsObject']>({\n    name: `${cookiePrefix}-token`,\n    domain: collectionAuthConfig.cookies.domain ?? undefined,\n    expires: getCookieExpiration({ seconds: collectionAuthConfig.tokenExpiration }),\n    httpOnly: true,\n    path: '/',\n    returnCookieAsObject,\n    sameSite,\n    secure: collectionAuthConfig.cookies.secure,\n    value: token,\n  })\n}\n\nexport const generateExpiredPayloadCookie = <T extends Omit<GeneratePayloadCookieArgs, 'token'>>({\n  collectionAuthConfig,\n  cookiePrefix,\n  returnCookieAsObject = false,\n}: T): T['returnCookieAsObject'] extends true ? CookieObject : string => {\n  const sameSite =\n    typeof collectionAuthConfig.cookies.sameSite === 'string'\n      ? collectionAuthConfig.cookies.sameSite\n      : collectionAuthConfig.cookies.sameSite\n        ? 'Strict'\n        : undefined\n\n  const expires = new Date(Date.now() - 1000)\n\n  return generateCookie<T['returnCookieAsObject']>({\n    name: `${cookiePrefix}-token`,\n    domain: collectionAuthConfig.cookies.domain ?? undefined,\n    expires,\n    httpOnly: true,\n    path: '/',\n    returnCookieAsObject,\n    sameSite,\n    secure: collectionAuthConfig.cookies.secure,\n  })\n}\n\nexport function parseCookies(headers: Request['headers']) {\n  // Taken from https://github.com/vercel/edge-runtime/blob/main/packages/cookies/src/serialize.ts\n\n  /*\n  The MIT License (MIT)\n\n  Copyright (c) 2024 Vercel, Inc.\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n  */\n  const map = new Map<string, string>()\n\n  const cookie = headers.get('Cookie')\n\n  if (!cookie) {\n    return map\n  }\n\n  for (const pair of cookie.split(/; */)) {\n    if (!pair) {\n      continue\n    }\n\n    const splitAt = pair.indexOf('=')\n\n    // If the attribute doesn't have a value, set it to 'true'.\n    if (splitAt === -1) {\n      map.set(pair, 'true')\n      continue\n    }\n\n    // Otherwise split it into key and value and trim the whitespace on the\n    // value.\n    const [key, value] = [pair.slice(0, splitAt), pair.slice(splitAt + 1)]\n    try {\n      map.set(key, decodeURIComponent(value ?? 'true'))\n    } catch {\n      // ignore invalid encoded values\n    }\n  }\n\n  return map\n}\n"],"names":["generateCookie","args","name","domain","expires","httpOnly","maxAge","path","returnCookieAsObject","sameSite","secure","secureArg","value","cookieString","cookieObject","toUTCString","toString","getCookieExpiration","seconds","currentTime","Date","setSeconds","getSeconds","generatePayloadCookie","collectionAuthConfig","cookiePrefix","token","cookies","undefined","tokenExpiration","generateExpiredPayloadCookie","now","parseCookies","headers","map","Map","cookie","get","pair","split","splitAt","indexOf","set","key","slice","decodeURIComponent"],"mappings":"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"}},
    {"offset": {"line": 607, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/auth/getFieldsToSign.ts"],"sourcesContent":["import type { CollectionConfig } from '../collections/config/types.js'\nimport type { Field, TabAsField } from '../fields/config/types.js'\nimport type { PayloadRequest } from '../types/index.js'\n\nimport { fieldAffectsData, tabHasName } from '../fields/config/types.js'\n\ntype TraverseFieldsArgs = {\n  data: Record<string, unknown>\n  fields: (Field | TabAsField)[]\n  result: Record<string, unknown>\n}\nconst traverseFields = ({\n  data,\n  // parent,\n  fields,\n  result,\n}: TraverseFieldsArgs) => {\n  fields.forEach((field) => {\n    switch (field.type) {\n      case 'collapsible':\n      case 'row': {\n        traverseFields({\n          data,\n          fields: field.fields,\n          result,\n        })\n        break\n      }\n      case 'group': {\n        if (fieldAffectsData(field)) {\n          let targetResult\n          if (typeof field.saveToJWT === 'string') {\n            targetResult = field.saveToJWT\n            result[field.saveToJWT] = data[field.name]\n          } else if (field.saveToJWT) {\n            targetResult = field.name\n            result[field.name] = data[field.name]\n          }\n          const groupData: Record<string, unknown> = data[field.name] as Record<string, unknown>\n          const groupResult = (targetResult ? result[targetResult] : result) as Record<\n            string,\n            unknown\n          >\n          traverseFields({\n            data: groupData,\n            fields: field.fields,\n            result: groupResult,\n          })\n          break\n        } else {\n          traverseFields({\n            data,\n            fields: field.fields,\n            result,\n          })\n\n          break\n        }\n      }\n      case 'tab': {\n        if (tabHasName(field)) {\n          let targetResult\n          if (typeof field.saveToJWT === 'string') {\n            targetResult = field.saveToJWT\n            result[field.saveToJWT] = data[field.name]\n          } else if (field.saveToJWT) {\n            targetResult = field.name\n            result[field.name] = data[field.name]\n          }\n          const tabData: Record<string, unknown> = data[field.name] as Record<string, unknown>\n          const tabResult = (targetResult ? result[targetResult] : result) as Record<\n            string,\n            unknown\n          >\n          traverseFields({\n            data: tabData,\n            fields: field.fields,\n            result: tabResult,\n          })\n        } else {\n          traverseFields({\n            data,\n            fields: field.fields,\n            result,\n          })\n        }\n        break\n      }\n      case 'tabs': {\n        traverseFields({\n          data,\n          fields: field.tabs.map((tab) => ({ ...tab, type: 'tab' })),\n          result,\n        })\n        break\n      }\n      default:\n        if (fieldAffectsData(field)) {\n          if (field.saveToJWT) {\n            if (typeof field.saveToJWT === 'string') {\n              result[field.saveToJWT] = data[field.name]\n              delete result[field.name]\n            } else {\n              result[field.name] = data[field.name] as Record<string, unknown>\n            }\n          } else if (field.saveToJWT === false) {\n            delete result[field.name]\n          }\n        }\n    }\n  })\n  return result\n}\nexport const getFieldsToSign = (args: {\n  collectionConfig: CollectionConfig\n  email: string\n  sid?: string\n  user: PayloadRequest['user']\n}): Record<string, unknown> => {\n  const { collectionConfig, email, sid, user } = args\n\n  const result: Record<string, unknown> = {\n    id: user?.id,\n    collection: collectionConfig.slug,\n    email,\n  }\n\n  if (sid) {\n    result.sid = sid\n  }\n\n  traverseFields({\n    data: user!,\n    fields: collectionConfig.fields,\n    result,\n  })\n\n  return result\n}\n"],"names":["fieldAffectsData","tabHasName","traverseFields","data","fields","result","forEach","field","type","targetResult","saveToJWT","name","groupData","groupResult","tabData","tabResult","tabs","map","tab","getFieldsToSign","args","collectionConfig","email","sid","user","id","collection","slug"],"mappings":"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"}},
    {"offset": {"line": 731, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/auth/isUserLocked.ts"],"sourcesContent":["export const isUserLocked = (date: Date): boolean => {\n  if (!date) {\n    return false\n  }\n  return date.getTime() > Date.now()\n}\n"],"names":["isUserLocked","date","getTime","Date","now"],"mappings":";;;;AAAO,MAAMA,eAAe,CAACC;IAC3B,IAAI,CAACA,MAAM;QACT,OAAO;IACT;IACA,OAAOA,KAAKC,OAAO,KAAKC,KAAKC,GAAG;AAClC,EAAC"}},
    {"offset": {"line": 745, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/auth/jwt.ts"],"sourcesContent":["import { SignJWT } from 'jose'\n\nexport const jwtSign = async ({\n  fieldsToSign,\n  secret,\n  tokenExpiration,\n}: {\n  fieldsToSign: Record<string, unknown>\n  secret: string\n  tokenExpiration: number\n}) => {\n  const secretKey = new TextEncoder().encode(secret)\n  const issuedAt = Math.floor(Date.now() / 1000)\n  const exp = issuedAt + tokenExpiration\n  const token = await new SignJWT(fieldsToSign)\n    .setProtectedHeader({ alg: 'HS256', typ: 'JWT' })\n    .setIssuedAt(issuedAt)\n    .setExpirationTime(exp)\n    .sign(secretKey)\n  return { exp, token }\n}\n"],"names":["SignJWT","jwtSign","fieldsToSign","secret","tokenExpiration","secretKey","TextEncoder","encode","issuedAt","Math","floor","Date","now","exp","token","setProtectedHeader","alg","typ","setIssuedAt","setExpirationTime","sign"],"mappings":";;;;AAAA,SAASA,OAAO,QAAQ,OAAM;;AAEvB,MAAMC,UAAU,OAAO,EAC5BC,YAAY,EACZC,MAAM,EACNC,eAAe,EAKhB;IACC,MAAMC,YAAY,IAAIC,cAAcC,MAAM,CAACJ;IAC3C,MAAMK,WAAWC,KAAKC,KAAK,CAACC,KAAKC,GAAG,KAAK;IACzC,MAAMC,MAAML,WAAWJ;IACvB,MAAMU,QAAQ,MAAM,IAAId,uKAAAA,CAAQE,cAC7Ba,kBAAkB,CAAC;QAAEC,KAAK;QAASC,KAAK;IAAM,GAC9CC,WAAW,CAACV,UACZW,iBAAiB,CAACN,KAClBO,IAAI,CAACf;IACR,OAAO;QAAEQ;QAAKC;IAAM;AACtB,EAAC"}},
    {"offset": {"line": 768, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/auth/sessions.ts"],"sourcesContent":["import { v4 as uuid } from 'uuid'\n\nimport type { SanitizedCollectionConfig, TypeWithID } from '../collections/config/types.js'\nimport type { TypedUser } from '../index.js'\nimport type { Payload, PayloadRequest } from '../types/index.js'\nimport type { UntypedUser, UserSession } from './types.js'\n\n/**\n * Removes expired sessions from an array of sessions\n */\nexport const removeExpiredSessions = (sessions: UserSession[]) => {\n  const now = new Date()\n\n  return sessions.filter(({ expiresAt }) => {\n    const expiry = expiresAt instanceof Date ? expiresAt : new Date(expiresAt)\n    return expiry > now\n  })\n}\n\n/**\n * Adds a session to the user and removes expired sessions\n * @returns The session ID (sid) if sessions are used\n */\nexport const addSessionToUser = async ({\n  collectionConfig,\n  payload,\n  req,\n  user,\n}: {\n  collectionConfig: SanitizedCollectionConfig\n  payload: Payload\n  req: PayloadRequest\n  user: TypedUser\n}): Promise<{ sid?: string }> => {\n  let sid: string | undefined\n  if (collectionConfig.auth.useSessions) {\n    // Add session to user\n    sid = uuid()\n    const now = new Date()\n    const tokenExpInMs = collectionConfig.auth.tokenExpiration * 1000\n    const expiresAt = new Date(now.getTime() + tokenExpInMs)\n\n    const session = { id: sid, createdAt: now, expiresAt }\n\n    if (!user.sessions?.length) {\n      user.sessions = [session]\n    } else {\n      user.sessions = removeExpiredSessions(user.sessions)\n      user.sessions.push(session)\n    }\n\n    // Prevent updatedAt from being updated when only adding a session\n    user.updatedAt = null\n\n    await payload.db.updateOne({\n      id: user.id,\n      collection: collectionConfig.slug,\n      data: user,\n      req,\n      returning: false,\n    })\n\n    user.collection = collectionConfig.slug\n    user._strategy = 'local-jwt'\n  }\n\n  return {\n    sid,\n  }\n}\n\nexport const revokeSession = async ({\n  collectionConfig,\n  payload,\n  req,\n  sid,\n  user,\n}: {\n  collectionConfig: SanitizedCollectionConfig\n  payload: Payload\n  req: PayloadRequest\n  sid: string\n  user: null | (TypeWithID & UntypedUser)\n}): Promise<void> => {\n  if (collectionConfig.auth.useSessions && user && user.sessions?.length) {\n    user.sessions = user.sessions.filter((session) => session.id !== sid)\n    await payload.db.updateOne({\n      id: user.id,\n      collection: collectionConfig.slug,\n      data: user,\n      req,\n      returning: false,\n    })\n  }\n}\n"],"names":["v4","uuid","removeExpiredSessions","sessions","now","Date","filter","expiresAt","expiry","addSessionToUser","collectionConfig","payload","req","user","sid","auth","useSessions","tokenExpInMs","tokenExpiration","getTime","session","id","createdAt","length","push","updatedAt","db","updateOne","collection","slug","data","returning","_strategy","revokeSession"],"mappings":";;;;;;;;AAAA,SAASA,MAAMC,IAAI,QAAQ,OAAM;;AAU1B,MAAMC,wBAAwB,CAACC;IACpC,MAAMC,MAAM,IAAIC;IAEhB,OAAOF,SAASG,MAAM,CAAC,CAAC,EAAEC,SAAS,EAAE;QACnC,MAAMC,SAASD,qBAAqBF,OAAOE,YAAY,IAAIF,KAAKE;QAChE,OAAOC,SAASJ;IAClB;AACF,EAAC;AAMM,MAAMK,mBAAmB,OAAO,EACrCC,gBAAgB,EAChBC,OAAO,EACPC,GAAG,EACHC,IAAI,EAML;IACC,IAAIC;IACJ,IAAIJ,iBAAiBK,IAAI,CAACC,WAAW,EAAE;QACrC,sBAAsB;QACtBF,UAAMb,0LAAAA;QACN,MAAMG,MAAM,IAAIC;QAChB,MAAMY,eAAeP,iBAAiBK,IAAI,CAACG,eAAe,GAAG;QAC7D,MAAMX,YAAY,IAAIF,KAAKD,IAAIe,OAAO,KAAKF;QAE3C,MAAMG,UAAU;YAAEC,IAAIP;YAAKQ,WAAWlB;YAAKG;QAAU;QAErD,IAAI,CAACM,KAAKV,QAAQ,EAAEoB,QAAQ;YAC1BV,KAAKV,QAAQ,GAAG;gBAACiB;aAAQ;QAC3B,OAAO;YACLP,KAAKV,QAAQ,GAAGD,sBAAsBW,KAAKV,QAAQ;YACnDU,KAAKV,QAAQ,CAACqB,IAAI,CAACJ;QACrB;QAEA,kEAAkE;QAClEP,KAAKY,SAAS,GAAG;QAEjB,MAAMd,QAAQe,EAAE,CAACC,SAAS,CAAC;YACzBN,IAAIR,KAAKQ,EAAE;YACXO,YAAYlB,iBAAiBmB,IAAI;YACjCC,MAAMjB;YACND;YACAmB,WAAW;QACb;QAEAlB,KAAKe,UAAU,GAAGlB,iBAAiBmB,IAAI;QACvChB,KAAKmB,SAAS,GAAG;IACnB;IAEA,OAAO;QACLlB;IACF;AACF,EAAC;AAEM,MAAMmB,gBAAgB,OAAO,EAClCvB,gBAAgB,EAChBC,OAAO,EACPC,GAAG,EACHE,GAAG,EACHD,IAAI,EAOL;IACC,IAAIH,iBAAiBK,IAAI,CAACC,WAAW,IAAIH,QAAQA,KAAKV,QAAQ,EAAEoB,QAAQ;QACtEV,KAAKV,QAAQ,GAAGU,KAAKV,QAAQ,CAACG,MAAM,CAAC,CAACc,UAAYA,QAAQC,EAAE,KAAKP;QACjE,MAAMH,QAAQe,EAAE,CAACC,SAAS,CAAC;YACzBN,IAAIR,KAAKQ,EAAE;YACXO,YAAYlB,iBAAiBmB,IAAI;YACjCC,MAAMjB;YACND;YACAmB,WAAW;QACb;IACF;AACF,EAAC"}},
    {"offset": {"line": 838, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/auth/strategies/local/authenticate.ts"],"sourcesContent":["// @ts-strict-ignore\nimport crypto from 'crypto'\n\nimport type { TypeWithID } from '../../../collections/config/types.js'\n\ntype Doc = Record<string, unknown> & TypeWithID\n\ntype Args = {\n  doc: Doc\n  password: string\n}\n\nexport const authenticateLocalStrategy = async ({ doc, password }: Args): Promise<Doc | null> => {\n  try {\n    const { hash, salt } = doc\n\n    if (typeof salt === 'string' && typeof hash === 'string') {\n      const res = await new Promise<Doc | null>((resolve, reject) => {\n        crypto.pbkdf2(password, salt, 25000, 512, 'sha256', (e, hashBuffer) => {\n          if (e) {\n            reject(e)\n          }\n\n          const storedHashBuffer = Buffer.from(hash, 'hex')\n\n          if (\n            hashBuffer.length === storedHashBuffer.length &&\n            crypto.timingSafeEqual(hashBuffer, storedHashBuffer)\n          ) {\n            resolve(doc)\n          } else {\n            reject(new Error('Invalid password'))\n          }\n        })\n      })\n\n      return res\n    }\n\n    return null\n  } catch (ignore) {\n    return null\n  }\n}\n"],"names":["crypto","authenticateLocalStrategy","doc","password","hash","salt","res","Promise","resolve","reject","pbkdf2","e","hashBuffer","storedHashBuffer","Buffer","from","length","timingSafeEqual","Error","ignore"],"mappings":";;;;AAAA,oBAAoB;AACpB,OAAOA,YAAY,SAAQ;;AAWpB,MAAMC,4BAA4B,OAAO,EAAEC,GAAG,EAAEC,QAAQ,EAAQ;IACrE,IAAI;QACF,MAAM,EAAEC,IAAI,EAAEC,IAAI,EAAE,GAAGH;QAEvB,IAAI,OAAOG,SAAS,YAAY,OAAOD,SAAS,UAAU;YACxD,MAAME,MAAM,MAAM,IAAIC,QAAoB,CAACC,SAASC;gBAClDT,gHAAAA,CAAOU,MAAM,CAACP,UAAUE,MAAM,OAAO,KAAK,UAAU,CAACM,GAAGC;oBACtD,IAAID,GAAG;wBACLF,OAAOE;oBACT;oBAEA,MAAME,mBAAmBC,OAAOC,IAAI,CAACX,MAAM;oBAE3C,IACEQ,WAAWI,MAAM,KAAKH,iBAAiBG,MAAM,IAC7ChB,gHAAAA,CAAOiB,eAAe,CAACL,YAAYC,mBACnC;wBACAL,QAAQN;oBACV,OAAO;wBACLO,OAAO,IAAIS,MAAM;oBACnB;gBACF;YACF;YAEA,OAAOZ;QACT;QAEA,OAAO;IACT,EAAE,OAAOa,QAAQ;QACf,OAAO;IACT;AACF,EAAC"}},
    {"offset": {"line": 873, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/auth/strategies/local/incrementLoginAttempts.ts"],"sourcesContent":["import type { SanitizedCollectionConfig } from '../../../collections/config/types.js'\n\nimport { type JsonObject, type Payload, type TypedUser } from '../../../index.js'\nimport { isUserLocked } from '../../isUserLocked.js'\n\ntype Args = {\n  collection: SanitizedCollectionConfig\n  payload: Payload\n  user: TypedUser\n}\n\n// Note: this function does not use req in its updates, as we want those to be visible in parallel requests that are on a different\n// transaction. At the same time, we want updates from parallel requests to be visible here.\nexport const incrementLoginAttempts = async ({\n  collection,\n  payload,\n  user,\n}: Args): Promise<void> => {\n  const {\n    auth: { lockTime, maxLoginAttempts },\n  } = collection\n\n  const currentTime = Date.now()\n\n  let updatedLockUntil: null | string = null\n  let updatedLoginAttempts: null | number = null\n\n  if (user.lockUntil && !isUserLocked(new Date(user.lockUntil))) {\n    // Expired lock, restart count at 1\n    const updatedUser = await payload.db.updateOne({\n      id: user.id,\n      collection: collection.slug,\n      data: {\n        lockUntil: null,\n        loginAttempts: 1,\n      },\n      select: {\n        lockUntil: true,\n        loginAttempts: true,\n      },\n    })\n    updatedLockUntil = updatedUser.lockUntil\n    updatedLoginAttempts = updatedUser.loginAttempts\n    user.lockUntil = updatedLockUntil\n  } else {\n    const data: JsonObject = {\n      loginAttempts: {\n        $inc: 1,\n      },\n    }\n\n    const willReachMaxAttempts =\n      typeof user.loginAttempts === 'number' && user.loginAttempts + 1 >= maxLoginAttempts\n    // Lock the account if at max attempts and not already locked\n    if (willReachMaxAttempts) {\n      const lockUntil = new Date(currentTime + lockTime).toISOString()\n      data.lockUntil = lockUntil\n    }\n\n    const updatedUser = await payload.db.updateOne({\n      id: user.id,\n      collection: collection.slug,\n      data,\n      select: {\n        lockUntil: true,\n        loginAttempts: true,\n      },\n    })\n\n    updatedLockUntil = updatedUser.lockUntil\n    updatedLoginAttempts = updatedUser.loginAttempts\n  }\n\n  if (updatedLoginAttempts === null) {\n    throw new Error('Failed to update login attempts or lockUntil for user')\n  }\n\n  // Check updated latest lockUntil and loginAttempts in case there were parallel updates\n  const reachedMaxAttemptsForCurrentUser =\n    typeof updatedLoginAttempts === 'number' && updatedLoginAttempts - 1 >= maxLoginAttempts\n\n  const reachedMaxAttemptsForNextUser =\n    typeof updatedLoginAttempts === 'number' && updatedLoginAttempts >= maxLoginAttempts\n\n  if (reachedMaxAttemptsForCurrentUser) {\n    user.lockUntil = updatedLockUntil\n  }\n  user.loginAttempts = updatedLoginAttempts - 1 // -1, as the updated increment is applied for the *next* login attempt, not the current one\n\n  if (\n    reachedMaxAttemptsForNextUser &&\n    (!updatedLockUntil || !isUserLocked(new Date(updatedLockUntil)))\n  ) {\n    // If lockUntil reached max login attempts due to multiple parallel attempts but user was not locked yet,\n    const newLockUntil = new Date(currentTime + lockTime).toISOString()\n\n    await payload.db.updateOne({\n      id: user.id,\n      collection: collection.slug,\n      data: {\n        lockUntil: newLockUntil,\n      },\n      returning: false,\n    })\n\n    if (reachedMaxAttemptsForCurrentUser) {\n      user.lockUntil = newLockUntil\n    }\n\n    if (collection.auth.useSessions) {\n      // Remove all active sessions that have been created in a 20 second window. This protects\n      // against brute force attacks - example: 99 incorrect, 1 correct parallel login attempts.\n      // The correct login attempt will be finished first, as it's faster due to not having to perform\n      // an additional db update here.\n      // However, this request (the incorrect login attempt request) can kill the successful login attempt here.\n\n      // Fetch user sessions separately (do not do this in the updateOne select in order to preserve the returning: true db call optimization)\n      const currentUser = await payload.db.findOne<TypedUser>({\n        collection: collection.slug,\n        select: {\n          sessions: true,\n        },\n        where: {\n          id: {\n            equals: user.id,\n          },\n        },\n      })\n      if (currentUser?.sessions?.length) {\n        // Does not hurt also removing expired sessions\n        currentUser.sessions = currentUser.sessions.filter((session) => {\n          const sessionCreatedAt = new Date(session.createdAt)\n          const twentySecondsAgo = new Date(currentTime - 20000)\n\n          // Remove sessions created within the last 20 seconds\n          return sessionCreatedAt <= twentySecondsAgo\n        })\n\n        user.sessions = currentUser.sessions\n\n        // Ensure updatedAt date is always updated\n        user.updatedAt = new Date().toISOString()\n\n        await payload.db.updateOne({\n          id: user.id,\n          collection: collection.slug,\n          data: user,\n          returning: false,\n        })\n      }\n    }\n  }\n}\n"],"names":["isUserLocked","incrementLoginAttempts","collection","payload","user","auth","lockTime","maxLoginAttempts","currentTime","Date","now","updatedLockUntil","updatedLoginAttempts","lockUntil","updatedUser","db","updateOne","id","slug","data","loginAttempts","select","$inc","willReachMaxAttempts","toISOString","Error","reachedMaxAttemptsForCurrentUser","reachedMaxAttemptsForNextUser","newLockUntil","returning","useSessions","currentUser","findOne","sessions","where","equals","length","filter","session","sessionCreatedAt","createdAt","twentySecondsAgo","updatedAt"],"mappings":"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"}},
    {"offset": {"line": 992, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/auth/strategies/local/resetLoginAttempts.ts"],"sourcesContent":["import type { SanitizedCollectionConfig, TypeWithID } from '../../../collections/config/types.js'\nimport type { Payload } from '../../../index.js'\nimport type { PayloadRequest } from '../../../types/index.js'\n\ntype Args = {\n  collection: SanitizedCollectionConfig\n  doc: Record<string, unknown> & TypeWithID\n  payload: Payload\n  req: PayloadRequest\n}\n\nexport const resetLoginAttempts = async ({\n  collection,\n  doc,\n  payload,\n  req,\n}: Args): Promise<void> => {\n  if (\n    !('lockUntil' in doc && typeof doc.lockUntil === 'string') &&\n    (!('loginAttempts' in doc) || doc.loginAttempts === 0)\n  ) {\n    return\n  }\n  await payload.db.updateOne({\n    id: doc.id,\n    collection: collection.slug,\n    data: {\n      lockUntil: null,\n      loginAttempts: 0,\n    },\n    req,\n    returning: false,\n  })\n}\n"],"names":["resetLoginAttempts","collection","doc","payload","req","lockUntil","loginAttempts","db","updateOne","id","slug","data","returning"],"mappings":";;;;AAWO,MAAMA,qBAAqB,OAAO,EACvCC,UAAU,EACVC,GAAG,EACHC,OAAO,EACPC,GAAG,EACE;IACL,IACE,CAAE,CAAA,eAAeF,OAAO,OAAOA,IAAIG,SAAS,KAAK,QAAO,KACvD,CAAA,CAAE,CAAA,mBAAmBH,GAAE,KAAMA,IAAII,aAAa,KAAK,CAAA,GACpD;QACA;IACF;IACA,MAAMH,QAAQI,EAAE,CAACC,SAAS,CAAC;QACzBC,IAAIP,IAAIO,EAAE;QACVR,YAAYA,WAAWS,IAAI;QAC3BC,MAAM;YACJN,WAAW;YACXC,eAAe;QACjB;QACAF;QACAQ,WAAW;IACb;AACF,EAAC"}},
    {"offset": {"line": 1015, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/auth/operations/login.ts"],"sourcesContent":["import type {\n  AuthOperationsFromCollectionSlug,\n  Collection,\n  DataFromCollectionSlug,\n} from '../../collections/config/types.js'\nimport type { CollectionSlug, TypedUser } from '../../index.js'\nimport type { PayloadRequest, Where } from '../../types/index.js'\n\nimport { buildAfterOperation } from '../../collections/operations/utilities/buildAfterOperation.js'\nimport { buildBeforeOperation } from '../../collections/operations/utilities/buildBeforeOperation.js'\nimport {\n  AuthenticationError,\n  LockedAuth,\n  UnverifiedEmail,\n  ValidationError,\n} from '../../errors/index.js'\nimport { afterRead } from '../../fields/hooks/afterRead/index.js'\nimport { commitTransaction, Forbidden, initTransaction } from '../../index.js'\nimport { appendNonTrashedFilter } from '../../utilities/appendNonTrashedFilter.js'\nimport { killTransaction } from '../../utilities/killTransaction.js'\nimport { sanitizeInternalFields } from '../../utilities/sanitizeInternalFields.js'\nimport { getFieldsToSign } from '../getFieldsToSign.js'\nimport { getLoginOptions } from '../getLoginOptions.js'\nimport { isUserLocked } from '../isUserLocked.js'\nimport { jwtSign } from '../jwt.js'\nimport { addSessionToUser, revokeSession } from '../sessions.js'\nimport { authenticateLocalStrategy } from '../strategies/local/authenticate.js'\nimport { incrementLoginAttempts } from '../strategies/local/incrementLoginAttempts.js'\nimport { resetLoginAttempts } from '../strategies/local/resetLoginAttempts.js'\n\nexport type Result = {\n  exp?: number\n  token?: string\n  user?: TypedUser\n}\n\nexport type Arguments<TSlug extends CollectionSlug> = {\n  collection: Collection\n  data: AuthOperationsFromCollectionSlug<TSlug>['login']\n  depth?: number\n  overrideAccess?: boolean\n  req: PayloadRequest\n  showHiddenFields?: boolean\n}\n\ntype CheckLoginPermissionArgs = {\n  loggingInWithUsername?: boolean\n  req: PayloadRequest\n  user: any\n}\n\n/**\n * Throws an error if the user is locked or does not exist.\n * This does not check the login attempts, only the lock status. Whoever increments login attempts\n * is responsible for locking the user properly, not whoever checks the login permission.\n */\nexport const checkLoginPermission = ({\n  loggingInWithUsername,\n  req,\n  user,\n}: CheckLoginPermissionArgs) => {\n  if (!user) {\n    throw new AuthenticationError(req.t, Boolean(loggingInWithUsername))\n  }\n\n  if (isUserLocked(new Date(user.lockUntil))) {\n    throw new LockedAuth(req.t)\n  }\n}\n\nexport const loginOperation = async <TSlug extends CollectionSlug>(\n  incomingArgs: Arguments<TSlug>,\n): Promise<{ user: DataFromCollectionSlug<TSlug> } & Result> => {\n  let args = incomingArgs\n\n  if (args.collection.config.auth.disableLocalStrategy) {\n    throw new Forbidden(args.req.t)\n  }\n\n  // /////////////////////////////////////\n  // beforeOperation - Collection\n  // /////////////////////////////////////\n\n  args = await buildBeforeOperation({\n    args,\n    collection: args.collection.config,\n    operation: 'login',\n    overrideAccess: args.overrideAccess!,\n  })\n\n  const {\n    collection: { config: collectionConfig },\n    data,\n    depth,\n    overrideAccess = false,\n    req,\n    req: {\n      fallbackLocale,\n      locale,\n      payload,\n      payload: { secret },\n    },\n    showHiddenFields,\n  } = args\n\n  // /////////////////////////////////////\n  // Login\n  // /////////////////////////////////////\n\n  const { email: unsanitizedEmail, password } = data\n  const loginWithUsername = collectionConfig.auth.loginWithUsername\n\n  const sanitizedEmail =\n    typeof unsanitizedEmail === 'string' ? unsanitizedEmail.toLowerCase().trim() : null\n  const sanitizedUsername =\n    'username' in data && typeof data?.username === 'string'\n      ? data.username.toLowerCase().trim()\n      : null\n\n  const { canLoginWithEmail, canLoginWithUsername } = getLoginOptions(loginWithUsername)\n\n  // cannot login with email, did not provide username\n  if (!canLoginWithEmail && !sanitizedUsername) {\n    throw new ValidationError({\n      collection: collectionConfig.slug,\n      errors: [{ message: req.i18n.t('validation:required'), path: 'username' }],\n    })\n  }\n\n  // cannot login with username, did not provide email\n  if (!canLoginWithUsername && !sanitizedEmail) {\n    throw new ValidationError({\n      collection: collectionConfig.slug,\n      errors: [{ message: req.i18n.t('validation:required'), path: 'email' }],\n    })\n  }\n\n  // can login with either email or username, did not provide either\n  if (!sanitizedUsername && !sanitizedEmail) {\n    throw new ValidationError({\n      collection: collectionConfig.slug,\n      errors: [\n        { message: req.i18n.t('validation:required'), path: 'email' },\n        { message: req.i18n.t('validation:required'), path: 'username' },\n      ],\n    })\n  }\n\n  // did not provide password for login\n  if (typeof password !== 'string' || password.trim() === '') {\n    throw new ValidationError({\n      collection: collectionConfig.slug,\n      errors: [{ message: req.i18n.t('validation:required'), path: 'password' }],\n    })\n  }\n\n  let whereConstraint: Where = {}\n  const emailConstraint: Where = {\n    email: {\n      equals: sanitizedEmail,\n    },\n  }\n  const usernameConstraint: Where = {\n    username: {\n      equals: sanitizedUsername,\n    },\n  }\n\n  if (canLoginWithEmail && canLoginWithUsername && (sanitizedUsername || sanitizedEmail)) {\n    if (sanitizedUsername) {\n      whereConstraint = {\n        or: [\n          usernameConstraint,\n          {\n            email: {\n              equals: sanitizedUsername,\n            },\n          },\n        ],\n      }\n    } else {\n      whereConstraint = {\n        or: [\n          emailConstraint,\n          {\n            username: {\n              equals: sanitizedEmail,\n            },\n          },\n        ],\n      }\n    }\n  } else if (canLoginWithEmail && sanitizedEmail) {\n    whereConstraint = emailConstraint\n  } else if (canLoginWithUsername && sanitizedUsername) {\n    whereConstraint = usernameConstraint\n  }\n\n  // Exclude trashed users\n  whereConstraint = appendNonTrashedFilter({\n    enableTrash: collectionConfig.trash,\n    trash: false,\n    where: whereConstraint,\n  })\n\n  let user = (await payload.db.findOne<TypedUser>({\n    collection: collectionConfig.slug,\n    req,\n    where: whereConstraint,\n  })) as TypedUser\n\n  checkLoginPermission({\n    loggingInWithUsername: Boolean(canLoginWithUsername && sanitizedUsername),\n    req,\n    user,\n  })\n\n  user.collection = collectionConfig.slug\n  user._strategy = 'local-jwt'\n\n  const authResult = await authenticateLocalStrategy({ doc: user, password })\n  user = sanitizeInternalFields(user)\n\n  const maxLoginAttemptsEnabled = args.collection.config.auth.maxLoginAttempts > 0\n\n  if (!authResult) {\n    if (maxLoginAttemptsEnabled) {\n      await incrementLoginAttempts({\n        collection: collectionConfig,\n        payload: req.payload,\n        user,\n      })\n\n      // Re-check login permissions and max attempts after incrementing attempts, in case parallel updates occurred\n      checkLoginPermission({\n        loggingInWithUsername: Boolean(canLoginWithUsername && sanitizedUsername),\n        req,\n        user,\n      })\n    }\n\n    throw new AuthenticationError(req.t)\n  }\n\n  if (collectionConfig.auth.verify && user._verified === false) {\n    throw new UnverifiedEmail({ t: req.t })\n  }\n\n  // Authentication successful - start transaction for remaining operations\n  const shouldCommit = await initTransaction(args.req)\n  let sid: string | undefined\n\n  try {\n    /*\n     * Correct password accepted - recheck that the account didn't\n     * get locked by parallel bad attempts in the meantime.\n     */\n    if (maxLoginAttemptsEnabled) {\n      const { lockUntil, loginAttempts } = (await payload.db.findOne<TypedUser>({\n        collection: collectionConfig.slug,\n        req,\n        select: {\n          lockUntil: true,\n          loginAttempts: true,\n        },\n        where: { id: { equals: user.id } },\n      }))!\n\n      user.lockUntil = lockUntil\n      user.loginAttempts = loginAttempts\n\n      checkLoginPermission({\n        req,\n        user,\n      })\n    }\n\n    const fieldsToSignArgs: Parameters<typeof getFieldsToSign>[0] = {\n      collectionConfig,\n      email: sanitizedEmail!,\n      user,\n    }\n\n    const session = await addSessionToUser({\n      collectionConfig,\n      payload,\n      req,\n      user,\n    })\n    sid = session.sid\n\n    if (sid) {\n      fieldsToSignArgs.sid = sid\n    }\n\n    const fieldsToSign = getFieldsToSign(fieldsToSignArgs)\n\n    if (maxLoginAttemptsEnabled) {\n      await resetLoginAttempts({\n        collection: collectionConfig,\n        doc: user,\n        payload: req.payload,\n        req,\n      })\n    }\n\n    // /////////////////////////////////////\n    // beforeLogin - Collection\n    // /////////////////////////////////////\n\n    if (collectionConfig.hooks?.beforeLogin?.length) {\n      for (const hook of collectionConfig.hooks.beforeLogin) {\n        user =\n          (await hook({\n            collection: args.collection?.config,\n            context: args.req.context,\n            req: args.req,\n            user,\n          })) || user\n      }\n    }\n\n    const { exp, token } = await jwtSign({\n      fieldsToSign,\n      secret,\n      tokenExpiration: collectionConfig.auth.tokenExpiration,\n    })\n\n    req.user = user\n\n    // /////////////////////////////////////\n    // afterLogin - Collection\n    // /////////////////////////////////////\n\n    if (collectionConfig.hooks?.afterLogin?.length) {\n      for (const hook of collectionConfig.hooks.afterLogin) {\n        user =\n          (await hook({\n            collection: args.collection?.config,\n            context: args.req.context,\n            req: args.req,\n            token,\n            user,\n          })) || user\n      }\n    }\n\n    // /////////////////////////////////////\n    // afterRead - Fields\n    // /////////////////////////////////////\n\n    user = await afterRead({\n      collection: collectionConfig,\n      context: req.context,\n      depth: depth!,\n      doc: user,\n      // @ts-expect-error - vestiges of when tsconfig was not strict. Feel free to improve\n      draft: undefined,\n      fallbackLocale: fallbackLocale!,\n      global: null,\n      locale: locale!,\n      overrideAccess,\n      req,\n      showHiddenFields: showHiddenFields!,\n    })\n\n    // /////////////////////////////////////\n    // afterRead - Collection\n    // /////////////////////////////////////\n\n    if (collectionConfig.hooks?.afterRead?.length) {\n      for (const hook of collectionConfig.hooks.afterRead) {\n        user =\n          (await hook({\n            collection: args.collection?.config,\n            context: req.context,\n            doc: user,\n            overrideAccess,\n            req,\n          })) || user\n      }\n    }\n\n    let result: { user: DataFromCollectionSlug<TSlug> } & Result = {\n      exp,\n      token,\n      user,\n    }\n\n    // /////////////////////////////////////\n    // afterOperation - Collection\n    // /////////////////////////////////////\n\n    result = await buildAfterOperation({\n      args,\n      collection: args.collection?.config,\n      operation: 'login',\n      overrideAccess: args.overrideAccess!,\n      result,\n    })\n\n    if (shouldCommit) {\n      await commitTransaction(req)\n    }\n\n    // /////////////////////////////////////\n    // Return results\n    // /////////////////////////////////////\n\n    return result\n  } catch (error: unknown) {\n    if (sid) {\n      await revokeSession({\n        collectionConfig,\n        payload,\n        req,\n        sid,\n        user,\n      })\n    }\n    await killTransaction(args.req)\n    throw error\n  }\n}\n"],"names":["buildAfterOperation","buildBeforeOperation","AuthenticationError","LockedAuth","UnverifiedEmail","ValidationError","afterRead","commitTransaction","Forbidden","initTransaction","appendNonTrashedFilter","killTransaction","sanitizeInternalFields","getFieldsToSign","getLoginOptions","isUserLocked","jwtSign","addSessionToUser","revokeSession","authenticateLocalStrategy","incrementLoginAttempts","resetLoginAttempts","checkLoginPermission","loggingInWithUsername","req","user","t","Boolean","Date","lockUntil","loginOperation","incomingArgs","args","collection","config","auth","disableLocalStrategy","operation","overrideAccess","collectionConfig","data","depth","fallbackLocale","locale","payload","secret","showHiddenFields","email","unsanitizedEmail","password","loginWithUsername","sanitizedEmail","toLowerCase","trim","sanitizedUsername","username","canLoginWithEmail","canLoginWithUsername","slug","errors","message","i18n","path","whereConstraint","emailConstraint","equals","usernameConstraint","or","enableTrash","trash","where","db","findOne","_strategy","authResult","doc","maxLoginAttemptsEnabled","maxLoginAttempts","verify","_verified","shouldCommit","sid","loginAttempts","select","id","fieldsToSignArgs","session","fieldsToSign","hooks","beforeLogin","length","hook","context","exp","token","tokenExpiration","afterLogin","draft","undefined","global","result","error"],"mappings":"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"}},
    {"offset": {"line": 1382, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/auth/endpoints/login.ts"],"sourcesContent":["import { status as httpStatus } from 'http-status'\n\nimport type { PayloadHandler } from '../../config/types.js'\n\nimport { getRequestCollection } from '../../utilities/getRequestEntity.js'\nimport { headersWithCors } from '../../utilities/headersWithCors.js'\nimport { isNumber } from '../../utilities/isNumber.js'\nimport { generatePayloadCookie } from '../cookies.js'\nimport { loginOperation } from '../operations/login.js'\n\nexport const loginHandler: PayloadHandler = async (req) => {\n  const collection = getRequestCollection(req)\n  const { searchParams, t } = req\n  const depth = searchParams.get('depth')\n  const authData =\n    collection.config.auth?.loginWithUsername !== false\n      ? {\n          email: typeof req.data?.email === 'string' ? req.data.email : '',\n          password: typeof req.data?.password === 'string' ? req.data.password : '',\n          username: typeof req.data?.username === 'string' ? req.data.username : '',\n        }\n      : {\n          email: typeof req.data?.email === 'string' ? req.data.email : '',\n          password: typeof req.data?.password === 'string' ? req.data.password : '',\n        }\n\n  const result = await loginOperation({\n    collection,\n    data: authData,\n    depth: isNumber(depth) ? Number(depth) : undefined,\n    req,\n  })\n\n  const cookie = generatePayloadCookie({\n    collectionAuthConfig: collection.config.auth,\n    cookiePrefix: req.payload.config.cookiePrefix,\n    token: result.token!,\n  })\n\n  if (collection.config.auth.removeTokenFromResponses) {\n    delete result.token\n  }\n\n  return Response.json(\n    {\n      message: t('authentication:passed'),\n      ...result,\n    },\n    {\n      headers: headersWithCors({\n        headers: new Headers({\n          'Set-Cookie': cookie,\n        }),\n        req,\n      }),\n      status: httpStatus.OK,\n    },\n  )\n}\n"],"names":["status","httpStatus","getRequestCollection","headersWithCors","isNumber","generatePayloadCookie","loginOperation","loginHandler","req","collection","searchParams","t","depth","get","authData","config","auth","loginWithUsername","email","data","password","username","result","Number","undefined","cookie","collectionAuthConfig","cookiePrefix","payload","token","removeTokenFromResponses","Response","json","message","headers","Headers","OK"],"mappings":";;;;;AAAA,SAASA,UAAUC,UAAU,QAAQ,cAAa;AAIlD,SAASC,oBAAoB,QAAQ,sCAAqC;AAC1E,SAASC,eAAe,QAAQ,qCAAoC;AACpE,SAASC,QAAQ,QAAQ,8BAA6B;AACtD,SAASC,qBAAqB,QAAQ,gBAAe;AACrD,SAASC,cAAc,QAAQ,yBAAwB;;;;;;;AAEhD,MAAMC,eAA+B,OAAOC;IACjD,MAAMC,iBAAaP,0LAAAA,EAAqBM;IACxC,MAAM,EAAEE,YAAY,EAAEC,CAAC,EAAE,GAAGH;IAC5B,MAAMI,QAAQF,aAAaG,GAAG,CAAC;IAC/B,MAAMC,WACJL,WAAWM,MAAM,CAACC,IAAI,EAAEC,sBAAsB,QAC1C;QACEC,OAAO,OAAOV,IAAIW,IAAI,EAAED,UAAU,WAAWV,IAAIW,IAAI,CAACD,KAAK,GAAG;QAC9DE,UAAU,OAAOZ,IAAIW,IAAI,EAAEC,aAAa,WAAWZ,IAAIW,IAAI,CAACC,QAAQ,GAAG;QACvEC,UAAU,OAAOb,IAAIW,IAAI,EAAEE,aAAa,WAAWb,IAAIW,IAAI,CAACE,QAAQ,GAAG;IACzE,IACA;QACEH,OAAO,OAAOV,IAAIW,IAAI,EAAED,UAAU,WAAWV,IAAIW,IAAI,CAACD,KAAK,GAAG;QAC9DE,UAAU,OAAOZ,IAAIW,IAAI,EAAEC,aAAa,WAAWZ,IAAIW,IAAI,CAACC,QAAQ,GAAG;IACzE;IAEN,MAAME,SAAS,UAAMhB,kLAAAA,EAAe;QAClCG;QACAU,MAAML;QACNF,WAAOR,sKAAAA,EAASQ,SAASW,OAAOX,SAASY;QACzChB;IACF;IAEA,MAAMiB,aAASpB,6KAAAA,EAAsB;QACnCqB,sBAAsBjB,WAAWM,MAAM,CAACC,IAAI;QAC5CW,cAAcnB,IAAIoB,OAAO,CAACb,MAAM,CAACY,YAAY;QAC7CE,OAAOP,OAAOO,KAAK;IACrB;IAEA,IAAIpB,WAAWM,MAAM,CAACC,IAAI,CAACc,wBAAwB,EAAE;QACnD,OAAOR,OAAOO,KAAK;IACrB;IAEA,OAAOE,SAASC,IAAI,CAClB;QACEC,SAAStB,EAAE;QACX,GAAGW,MAAM;IACX,GACA;QACEY,aAAS/B,oLAAAA,EAAgB;YACvB+B,SAAS,IAAIC,QAAQ;gBACnB,cAAcV;YAChB;YACAjB;QACF;QACAR,QAAQC,sMAAAA,CAAWmC,EAAE;IACvB;AAEJ,EAAC"}},
    {"offset": {"line": 1442, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/auth/operations/logout.ts"],"sourcesContent":["import { status as httpStatus } from 'http-status'\n\nimport type { Collection } from '../../collections/config/types.js'\nimport type { PayloadRequest } from '../../types/index.js'\n\nimport { APIError } from '../../errors/index.js'\nimport { appendNonTrashedFilter } from '../../utilities/appendNonTrashedFilter.js'\nimport { commitTransaction } from '../../utilities/commitTransaction.js'\nimport { initTransaction } from '../../utilities/initTransaction.js'\nimport { killTransaction } from '../../utilities/killTransaction.js'\n\nexport type Arguments = {\n  allSessions?: boolean\n  collection: Collection\n  req: PayloadRequest\n}\n\nexport const logoutOperation = async (incomingArgs: Arguments): Promise<boolean> => {\n  let args = incomingArgs\n  const {\n    allSessions,\n    collection: { config: collectionConfig },\n    req: { user },\n    req,\n  } = incomingArgs\n\n  if (!user) {\n    throw new APIError('No User', httpStatus.BAD_REQUEST)\n  }\n  if (user.collection !== collectionConfig.slug) {\n    throw new APIError('Incorrect collection', httpStatus.FORBIDDEN)\n  }\n\n  const shouldCommit = await initTransaction(req)\n\n  try {\n    if (collectionConfig.hooks?.afterLogout?.length) {\n      for (const hook of collectionConfig.hooks.afterLogout) {\n        args =\n          (await hook({\n            collection: args.collection?.config,\n            context: req.context,\n            req,\n          })) || args\n      }\n    }\n\n    if (collectionConfig.auth.disableLocalStrategy !== true && collectionConfig.auth.useSessions) {\n      const where = appendNonTrashedFilter({\n        enableTrash: Boolean(collectionConfig.trash),\n        trash: false,\n        where: {\n          id: {\n            equals: user.id,\n          },\n        },\n      })\n\n      const userWithSessions = await req.payload.db.findOne<{\n        id: number | string\n        sessions: { id: string }[]\n      }>({\n        collection: collectionConfig.slug,\n        req,\n        where,\n      })\n\n      if (!userWithSessions) {\n        throw new APIError('No User', httpStatus.BAD_REQUEST)\n      }\n\n      if (allSessions) {\n        userWithSessions.sessions = []\n      } else {\n        const sessionsAfterLogout = (userWithSessions?.sessions || []).filter(\n          (s) => s.id !== req?.user?._sid,\n        )\n\n        userWithSessions.sessions = sessionsAfterLogout\n      }\n\n      // Prevent updatedAt from being updated when only removing a session\n      ;(userWithSessions as any).updatedAt = null\n\n      await req.payload.db.updateOne({\n        id: user.id,\n        collection: collectionConfig.slug,\n        data: userWithSessions,\n        req,\n        returning: false,\n      })\n    }\n\n    if (shouldCommit) {\n      await commitTransaction(req)\n    }\n\n    return true\n  } catch (error: unknown) {\n    await killTransaction(req)\n    throw error\n  }\n}\n"],"names":["status","httpStatus","APIError","appendNonTrashedFilter","commitTransaction","initTransaction","killTransaction","logoutOperation","incomingArgs","args","allSessions","collection","config","collectionConfig","req","user","BAD_REQUEST","slug","FORBIDDEN","shouldCommit","hooks","afterLogout","length","hook","context","auth","disableLocalStrategy","useSessions","where","enableTrash","Boolean","trash","id","equals","userWithSessions","payload","db","findOne","sessions","sessionsAfterLogout","filter","s","_sid","updatedAt","updateOne","data","returning","error"],"mappings":";;;;;AAAA,SAASA,UAAUC,UAAU,QAAQ,cAAa;AAKlD,SAASC,QAAQ,QAAQ,wBAAuB;AAChD,SAASC,sBAAsB,QAAQ,4CAA2C;AAClF,SAASC,iBAAiB,QAAQ,uCAAsC;AACxE,SAASC,eAAe,QAAQ,qCAAoC;AACpE,SAASC,eAAe,QAAQ,qCAAoC;;;;;;;AAQ7D,MAAMC,kBAAkB,OAAOC;IACpC,IAAIC,OAAOD;IACX,MAAM,EACJE,WAAW,EACXC,YAAY,EAAEC,QAAQC,gBAAgB,EAAE,EACxCC,KAAK,EAAEC,IAAI,EAAE,EACbD,GAAG,EACJ,GAAGN;IAEJ,IAAI,CAACO,MAAM;QACT,MAAM,IAAIb,mKAAAA,CAAS,WAAWD,sMAAAA,CAAWe,WAAW;IACtD;IACA,IAAID,KAAKJ,UAAU,KAAKE,iBAAiBI,IAAI,EAAE;QAC7C,MAAM,IAAIf,mKAAAA,CAAS,wBAAwBD,sMAAAA,CAAWiB,SAAS;IACjE;IAEA,MAAMC,eAAe,UAAMd,oLAAAA,EAAgBS;IAE3C,IAAI;QACF,IAAID,iBAAiBO,KAAK,EAAEC,aAAaC,QAAQ;YAC/C,KAAK,MAAMC,QAAQV,iBAAiBO,KAAK,CAACC,WAAW,CAAE;gBACrDZ,OACG,MAAMc,KAAK;oBACVZ,YAAYF,KAAKE,UAAU,EAAEC;oBAC7BY,SAASV,IAAIU,OAAO;oBACpBV;gBACF,MAAOL;YACX;QACF;QAEA,IAAII,iBAAiBY,IAAI,CAACC,oBAAoB,KAAK,QAAQb,iBAAiBY,IAAI,CAACE,WAAW,EAAE;YAC5F,MAAMC,YAAQzB,kMAAAA,EAAuB;gBACnC0B,aAAaC,QAAQjB,iBAAiBkB,KAAK;gBAC3CA,OAAO;gBACPH,OAAO;oBACLI,IAAI;wBACFC,QAAQlB,KAAKiB,EAAE;oBACjB;gBACF;YACF;YAEA,MAAME,mBAAmB,MAAMpB,IAAIqB,OAAO,CAACC,EAAE,CAACC,OAAO,CAGlD;gBACD1B,YAAYE,iBAAiBI,IAAI;gBACjCH;gBACAc;YACF;YAEA,IAAI,CAACM,kBAAkB;gBACrB,MAAM,IAAIhC,mKAAAA,CAAS,WAAWD,sMAAAA,CAAWe,WAAW;YACtD;YAEA,IAAIN,aAAa;gBACfwB,iBAAiBI,QAAQ,GAAG,EAAE;YAChC,OAAO;gBACL,MAAMC,sBAAuBL,CAAAA,kBAAkBI,YAAY,EAAC,EAAGE,MAAM,CACnE,CAACC,IAAMA,EAAET,EAAE,KAAKlB,KAAKC,MAAM2B;gBAG7BR,iBAAiBI,QAAQ,GAAGC;YAC9B;YAEA,oEAAoE;;YAClEL,iBAAyBS,SAAS,GAAG;YAEvC,MAAM7B,IAAIqB,OAAO,CAACC,EAAE,CAACQ,SAAS,CAAC;gBAC7BZ,IAAIjB,KAAKiB,EAAE;gBACXrB,YAAYE,iBAAiBI,IAAI;gBACjC4B,MAAMX;gBACNpB;gBACAgC,WAAW;YACb;QACF;QAEA,IAAI3B,cAAc;YAChB,UAAMf,wLAAAA,EAAkBU;QAC1B;QAEA,OAAO;IACT,EAAE,OAAOiC,OAAgB;QACvB,UAAMzC,oLAAAA,EAAgBQ;QACtB,MAAMiC;IACR;AACF,EAAC"}},
    {"offset": {"line": 1527, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/auth/endpoints/logout.ts"],"sourcesContent":["import { status as httpStatus } from 'http-status'\n\nimport type { PayloadHandler } from '../../config/types.js'\n\nimport { getRequestCollection } from '../../utilities/getRequestEntity.js'\nimport { headersWithCors } from '../../utilities/headersWithCors.js'\nimport { generateExpiredPayloadCookie } from '../cookies.js'\nimport { logoutOperation } from '../operations/logout.js'\n\nexport const logoutHandler: PayloadHandler = async (req) => {\n  const collection = getRequestCollection(req)\n  const { searchParams, t } = req\n\n  const result = await logoutOperation({\n    allSessions: searchParams.get('allSessions') === 'true',\n    collection,\n    req,\n  })\n\n  const headers = headersWithCors({\n    headers: new Headers(),\n    req,\n  })\n\n  if (!result) {\n    return Response.json(\n      {\n        message: t('error:logoutFailed'),\n      },\n      {\n        headers,\n        status: httpStatus.BAD_REQUEST,\n      },\n    )\n  }\n\n  const expiredCookie = generateExpiredPayloadCookie({\n    collectionAuthConfig: collection.config.auth,\n    config: req.payload.config,\n    cookiePrefix: req.payload.config.cookiePrefix,\n  })\n\n  headers.set('Set-Cookie', expiredCookie)\n\n  return Response.json(\n    {\n      message: t('authentication:logoutSuccessful'),\n    },\n    {\n      headers,\n      status: httpStatus.OK,\n    },\n  )\n}\n"],"names":["status","httpStatus","getRequestCollection","headersWithCors","generateExpiredPayloadCookie","logoutOperation","logoutHandler","req","collection","searchParams","t","result","allSessions","get","headers","Headers","Response","json","message","BAD_REQUEST","expiredCookie","collectionAuthConfig","config","auth","payload","cookiePrefix","set","OK"],"mappings":";;;;;AAAA,SAASA,UAAUC,UAAU,QAAQ,cAAa;AAIlD,SAASC,oBAAoB,QAAQ,sCAAqC;AAC1E,SAASC,eAAe,QAAQ,qCAAoC;AACpE,SAASC,4BAA4B,QAAQ,gBAAe;AAC5D,SAASC,eAAe,QAAQ,0BAAyB;;;;;;AAElD,MAAMC,gBAAgC,OAAOC;IAClD,MAAMC,iBAAaN,0LAAAA,EAAqBK;IACxC,MAAM,EAAEE,YAAY,EAAEC,CAAC,EAAE,GAAGH;IAE5B,MAAMI,SAAS,UAAMN,oLAAAA,EAAgB;QACnCO,aAAaH,aAAaI,GAAG,CAAC,mBAAmB;QACjDL;QACAD;IACF;IAEA,MAAMO,cAAUX,oLAAAA,EAAgB;QAC9BW,SAAS,IAAIC;QACbR;IACF;IAEA,IAAI,CAACI,QAAQ;QACX,OAAOK,SAASC,IAAI,CAClB;YACEC,SAASR,EAAE;QACb,GACA;YACEI;YACAd,QAAQC,sMAAAA,CAAWkB,WAAW;QAChC;IAEJ;IAEA,MAAMC,oBAAgBhB,oLAAAA,EAA6B;QACjDiB,sBAAsBb,WAAWc,MAAM,CAACC,IAAI;QAC5CD,QAAQf,IAAIiB,OAAO,CAACF,MAAM;QAC1BG,cAAclB,IAAIiB,OAAO,CAACF,MAAM,CAACG,YAAY;IAC/C;IAEAX,QAAQY,GAAG,CAAC,cAAcN;IAE1B,OAAOJ,SAASC,IAAI,CAClB;QACEC,SAASR,EAAE;IACb,GACA;QACEI;QACAd,QAAQC,sMAAAA,CAAW0B,EAAE;IACvB;AAEJ,EAAC"}},
    {"offset": {"line": 1579, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/auth/extractJWT.ts"],"sourcesContent":["import type { BasePayload } from '../index.js'\nimport type { AuthStrategyFunctionArgs } from './index.js'\n\nimport { parseCookies } from '../utilities/parseCookies.js'\n\ntype ExtractionMethod = (args: { headers: Headers; payload: BasePayload }) => null | string\n\nconst extractionMethods: Record<string, ExtractionMethod> = {\n  Bearer: ({ headers }) => {\n    const jwtFromHeader = headers.get('Authorization')\n\n    // allow RFC6750 OAuth 2.0 compliant Bearer tokens\n    // in addition to the payload default JWT format\n    if (jwtFromHeader?.startsWith('Bearer ')) {\n      return jwtFromHeader.replace('Bearer ', '')\n    }\n\n    return null\n  },\n  cookie: ({ headers, payload }) => {\n    const origin = headers.get('Origin')\n    const cookies = parseCookies(headers)\n    const tokenCookieName = `${payload.config.cookiePrefix}-token`\n    const cookieToken = cookies.get(tokenCookieName)\n\n    if (!cookieToken) {\n      return null\n    }\n\n    if (!origin || payload.config.csrf.length === 0 || payload.config.csrf.indexOf(origin) > -1) {\n      return cookieToken\n    }\n\n    return null\n  },\n  JWT: ({ headers }) => {\n    const jwtFromHeader = headers.get('Authorization')\n\n    if (jwtFromHeader?.startsWith('JWT ')) {\n      return jwtFromHeader.replace('JWT ', '')\n    }\n\n    return null\n  },\n}\n\nexport const extractJWT = (args: Omit<AuthStrategyFunctionArgs, 'strategyName'>): null | string => {\n  const { headers, payload } = args\n\n  const extractionOrder = payload.config.auth.jwtOrder\n\n  for (const extractionStrategy of extractionOrder) {\n    const result = extractionMethods[extractionStrategy]!({ headers, payload })\n\n    if (result) {\n      return result\n    }\n  }\n\n  return null\n}\n"],"names":["parseCookies","extractionMethods","Bearer","headers","jwtFromHeader","get","startsWith","replace","cookie","payload","origin","cookies","tokenCookieName","config","cookiePrefix","cookieToken","csrf","length","indexOf","JWT","extractJWT","args","extractionOrder","auth","jwtOrder","extractionStrategy","result"],"mappings":";;;;AAGA,SAASA,YAAY,QAAQ,+BAA8B;;AAI3D,MAAMC,oBAAsD;IAC1DC,QAAQ,CAAC,EAAEC,OAAO,EAAE;QAClB,MAAMC,gBAAgBD,QAAQE,GAAG,CAAC;QAElC,kDAAkD;QAClD,gDAAgD;QAChD,IAAID,eAAeE,WAAW,YAAY;YACxC,OAAOF,cAAcG,OAAO,CAAC,WAAW;QAC1C;QAEA,OAAO;IACT;IACAC,QAAQ,CAAC,EAAEL,OAAO,EAAEM,OAAO,EAAE;QAC3B,MAAMC,SAASP,QAAQE,GAAG,CAAC;QAC3B,MAAMM,cAAUX,8KAAAA,EAAaG;QAC7B,MAAMS,kBAAkB,GAAGH,QAAQI,MAAM,CAACC,YAAY,CAAC,MAAM,CAAC;QAC9D,MAAMC,cAAcJ,QAAQN,GAAG,CAACO;QAEhC,IAAI,CAACG,aAAa;YAChB,OAAO;QACT;QAEA,IAAI,CAACL,UAAUD,QAAQI,MAAM,CAACG,IAAI,CAACC,MAAM,KAAK,KAAKR,QAAQI,MAAM,CAACG,IAAI,CAACE,OAAO,CAACR,UAAU,CAAC,GAAG;YAC3F,OAAOK;QACT;QAEA,OAAO;IACT;IACAI,KAAK,CAAC,EAAEhB,OAAO,EAAE;QACf,MAAMC,gBAAgBD,QAAQE,GAAG,CAAC;QAElC,IAAID,eAAeE,WAAW,SAAS;YACrC,OAAOF,cAAcG,OAAO,CAAC,QAAQ;QACvC;QAEA,OAAO;IACT;AACF;AAEO,MAAMa,aAAa,CAACC;IACzB,MAAM,EAAElB,OAAO,EAAEM,OAAO,EAAE,GAAGY;IAE7B,MAAMC,kBAAkBb,QAAQI,MAAM,CAACU,IAAI,CAACC,QAAQ;IAEpD,KAAK,MAAMC,sBAAsBH,gBAAiB;QAChD,MAAMI,SAASzB,iBAAiB,CAACwB,mBAAmB,CAAE;YAAEtB;YAASM;QAAQ;QAEzE,IAAIiB,QAAQ;YACV,OAAOA;QACT;IACF;IAEA,OAAO;AACT,EAAC"}},
    {"offset": {"line": 1634, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/auth/operations/me.ts"],"sourcesContent":["import { decodeJwt } from 'jose'\n\nimport type { Collection } from '../../collections/config/types.js'\nimport type { TypedUser } from '../../index.js'\nimport type { JoinQuery, PayloadRequest, PopulateType, SelectType } from '../../types/index.js'\nimport type { ClientUser } from '../types.js'\n\nexport type MeOperationResult = {\n  collection?: string\n  exp?: number\n  /** @deprecated\n   * use:\n   * ```ts\n   * user._strategy\n   * ```\n   */\n  strategy?: string\n  token?: string\n  user?: ClientUser\n}\n\nexport type Arguments = {\n  collection: Collection\n  currentToken?: string\n  depth?: number\n  draft?: boolean\n  joins?: JoinQuery\n  populate?: PopulateType\n  req: PayloadRequest\n  select?: SelectType\n}\n\nexport const meOperation = async (args: Arguments): Promise<MeOperationResult> => {\n  const { collection, currentToken, depth, draft, joins, populate, req, select } = args\n\n  let result: MeOperationResult = {\n    user: null!,\n  }\n\n  if (req.user) {\n    const { pathname } = req\n    const isGraphQL = pathname === `/api${req.payload.config.routes.graphQL}`\n\n    const user = (await req.payload.findByID({\n      id: req.user.id,\n      collection: collection.config.slug,\n      depth: isGraphQL ? 0 : (depth ?? collection.config.auth.depth),\n      draft,\n      joins,\n      overrideAccess: false,\n      populate,\n      req,\n      select,\n      showHiddenFields: false,\n    })) as TypedUser\n\n    if (user) {\n      user.collection = collection.config.slug\n      user._strategy = req.user._strategy\n    }\n\n    if (req.user.collection !== collection.config.slug) {\n      return {\n        user: null!,\n      }\n    }\n\n    // /////////////////////////////////////\n    // me hook - Collection\n    // /////////////////////////////////////\n\n    for (const meHook of collection.config.hooks.me) {\n      const hookResult = await meHook({ args, user })\n\n      if (hookResult) {\n        result.user = hookResult.user\n        result.exp = hookResult.exp\n\n        break\n      }\n    }\n\n    result.collection = req.user.collection\n    /** @deprecated\n     * use:\n     * ```ts\n     * user._strategy\n     * ```\n     */\n    result.strategy = req.user._strategy\n\n    if (!result.user) {\n      result.user = user\n\n      if (currentToken) {\n        const decoded = decodeJwt(currentToken)\n        if (decoded) {\n          result.exp = decoded.exp\n        }\n        if (!collection.config.auth.removeTokenFromResponses) {\n          result.token = currentToken\n        }\n      }\n    }\n  }\n\n  // /////////////////////////////////////\n  // After Me - Collection\n  // /////////////////////////////////////\n\n  if (collection.config.hooks?.afterMe?.length) {\n    for (const hook of collection.config.hooks.afterMe) {\n      result =\n        (await hook({\n          collection: collection?.config,\n          context: req.context,\n          req,\n          response: result,\n        })) || result\n    }\n  }\n\n  return result\n}\n"],"names":["decodeJwt","meOperation","args","collection","currentToken","depth","draft","joins","populate","req","select","result","user","pathname","isGraphQL","payload","config","routes","graphQL","findByID","id","slug","auth","overrideAccess","showHiddenFields","_strategy","meHook","hooks","me","hookResult","exp","strategy","decoded","removeTokenFromResponses","token","afterMe","length","hook","context","response"],"mappings":";;;;AAAA,SAASA,SAAS,QAAQ,OAAM;;AAgCzB,MAAMC,cAAc,OAAOC;IAChC,MAAM,EAAEC,UAAU,EAAEC,YAAY,EAAEC,KAAK,EAAEC,KAAK,EAAEC,KAAK,EAAEC,QAAQ,EAAEC,GAAG,EAAEC,MAAM,EAAE,GAAGR;IAEjF,IAAIS,SAA4B;QAC9BC,MAAM;IACR;IAEA,IAAIH,IAAIG,IAAI,EAAE;QACZ,MAAM,EAAEC,QAAQ,EAAE,GAAGJ;QACrB,MAAMK,YAAYD,aAAa,CAAC,IAAI,EAAEJ,IAAIM,OAAO,CAACC,MAAM,CAACC,MAAM,CAACC,OAAO,EAAE;QAEzE,MAAMN,OAAQ,MAAMH,IAAIM,OAAO,CAACI,QAAQ,CAAC;YACvCC,IAAIX,IAAIG,IAAI,CAACQ,EAAE;YACfjB,YAAYA,WAAWa,MAAM,CAACK,IAAI;YAClChB,OAAOS,YAAY,IAAKT,SAASF,WAAWa,MAAM,CAACM,IAAI,CAACjB,KAAK;YAC7DC;YACAC;YACAgB,gBAAgB;YAChBf;YACAC;YACAC;YACAc,kBAAkB;QACpB;QAEA,IAAIZ,MAAM;YACRA,KAAKT,UAAU,GAAGA,WAAWa,MAAM,CAACK,IAAI;YACxCT,KAAKa,SAAS,GAAGhB,IAAIG,IAAI,CAACa,SAAS;QACrC;QAEA,IAAIhB,IAAIG,IAAI,CAACT,UAAU,KAAKA,WAAWa,MAAM,CAACK,IAAI,EAAE;YAClD,OAAO;gBACLT,MAAM;YACR;QACF;QAEA,wCAAwC;QACxC,uBAAuB;QACvB,wCAAwC;QAExC,KAAK,MAAMc,UAAUvB,WAAWa,MAAM,CAACW,KAAK,CAACC,EAAE,CAAE;YAC/C,MAAMC,aAAa,MAAMH,OAAO;gBAAExB;gBAAMU;YAAK;YAE7C,IAAIiB,YAAY;gBACdlB,OAAOC,IAAI,GAAGiB,WAAWjB,IAAI;gBAC7BD,OAAOmB,GAAG,GAAGD,WAAWC,GAAG;gBAE3B;YACF;QACF;QAEAnB,OAAOR,UAAU,GAAGM,IAAIG,IAAI,CAACT,UAAU;QACvC;;;;;KAKC,GACDQ,OAAOoB,QAAQ,GAAGtB,IAAIG,IAAI,CAACa,SAAS;QAEpC,IAAI,CAACd,OAAOC,IAAI,EAAE;YAChBD,OAAOC,IAAI,GAAGA;YAEd,IAAIR,cAAc;gBAChB,MAAM4B,cAAUhC,gLAAAA,EAAUI;gBAC1B,IAAI4B,SAAS;oBACXrB,OAAOmB,GAAG,GAAGE,QAAQF,GAAG;gBAC1B;gBACA,IAAI,CAAC3B,WAAWa,MAAM,CAACM,IAAI,CAACW,wBAAwB,EAAE;oBACpDtB,OAAOuB,KAAK,GAAG9B;gBACjB;YACF;QACF;IACF;IAEA,wCAAwC;IACxC,wBAAwB;IACxB,wCAAwC;IAExC,IAAID,WAAWa,MAAM,CAACW,KAAK,EAAEQ,SAASC,QAAQ;QAC5C,KAAK,MAAMC,QAAQlC,WAAWa,MAAM,CAACW,KAAK,CAACQ,OAAO,CAAE;YAClDxB,SACG,MAAM0B,KAAK;gBACVlC,YAAYA,YAAYa;gBACxBsB,SAAS7B,IAAI6B,OAAO;gBACpB7B;gBACA8B,UAAU5B;YACZ,MAAOA;QACX;IACF;IAEA,OAAOA;AACT,EAAC"}},
    {"offset": {"line": 1722, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/auth/endpoints/me.ts"],"sourcesContent":["import { status as httpStatus } from 'http-status'\n\nimport type { PayloadHandler } from '../../config/types.js'\nimport type { JoinParams } from '../../utilities/sanitizeJoinParams.js'\n\nimport { getRequestCollection } from '../../utilities/getRequestEntity.js'\nimport { headersWithCors } from '../../utilities/headersWithCors.js'\nimport { isNumber } from '../../utilities/isNumber.js'\nimport { sanitizeJoinParams } from '../../utilities/sanitizeJoinParams.js'\nimport { sanitizePopulateParam } from '../../utilities/sanitizePopulateParam.js'\nimport { sanitizeSelectParam } from '../../utilities/sanitizeSelectParam.js'\nimport { extractJWT } from '../extractJWT.js'\nimport { meOperation } from '../operations/me.js'\n\nexport const meHandler: PayloadHandler = async (req) => {\n  const { searchParams } = req\n  const collection = getRequestCollection(req)\n  const currentToken = extractJWT(req)\n  const depthFromSearchParams = searchParams.get('depth')\n  const draftFromSearchParams = searchParams.get('depth')\n\n  const {\n    depth: depthFromQuery,\n    draft: draftFromQuery,\n    joins,\n    populate,\n    select,\n  } = req.query as {\n    depth?: string\n    draft?: string\n    joins?: JoinParams\n    populate?: Record<string, unknown>\n    select?: Record<string, unknown>\n  }\n\n  const depth = depthFromQuery || depthFromSearchParams\n  const draft = draftFromQuery || draftFromSearchParams\n\n  const result = await meOperation({\n    collection,\n    currentToken: currentToken!,\n    depth: isNumber(depth) ? Number(depth) : undefined,\n    draft: draft === 'true',\n    joins: sanitizeJoinParams(joins),\n    populate: sanitizePopulateParam(populate),\n    req,\n    select: sanitizeSelectParam(select),\n  })\n\n  if (collection.config.auth.removeTokenFromResponses) {\n    delete result.token\n  }\n\n  return Response.json(\n    {\n      ...result,\n      message: req.t('authentication:account'),\n    },\n    {\n      headers: headersWithCors({\n        headers: new Headers(),\n        req,\n      }),\n      status: httpStatus.OK,\n    },\n  )\n}\n"],"names":["status","httpStatus","getRequestCollection","headersWithCors","isNumber","sanitizeJoinParams","sanitizePopulateParam","sanitizeSelectParam","extractJWT","meOperation","meHandler","req","searchParams","collection","currentToken","depthFromSearchParams","get","draftFromSearchParams","depth","depthFromQuery","draft","draftFromQuery","joins","populate","select","query","result","Number","undefined","config","auth","removeTokenFromResponses","token","Response","json","message","t","headers","Headers","OK"],"mappings":";;;;;AAAA,SAASA,UAAUC,UAAU,QAAQ,cAAa;AAKlD,SAASC,oBAAoB,QAAQ,sCAAqC;AAC1E,SAASC,eAAe,QAAQ,qCAAoC;AACpE,SAASC,QAAQ,QAAQ,8BAA6B;AACtD,SAASC,kBAAkB,QAAQ,wCAAuC;AAC1E,SAASC,qBAAqB,QAAQ,2CAA0C;AAChF,SAASC,mBAAmB,QAAQ,yCAAwC;AAC5E,SAASC,UAAU,QAAQ,mBAAkB;AAC7C,SAASC,WAAW,QAAQ,sBAAqB;;;;;;;;;;AAE1C,MAAMC,YAA4B,OAAOC;IAC9C,MAAM,EAAEC,YAAY,EAAE,GAAGD;IACzB,MAAME,iBAAaX,0LAAAA,EAAqBS;IACxC,MAAMG,mBAAeN,qKAAAA,EAAWG;IAChC,MAAMI,wBAAwBH,aAAaI,GAAG,CAAC;IAC/C,MAAMC,wBAAwBL,aAAaI,GAAG,CAAC;IAE/C,MAAM,EACJE,OAAOC,cAAc,EACrBC,OAAOC,cAAc,EACrBC,KAAK,EACLC,QAAQ,EACRC,MAAM,EACP,GAAGb,IAAIc,KAAK;IAQb,MAAMP,QAAQC,kBAAkBJ;IAChC,MAAMK,QAAQC,kBAAkBJ;IAEhC,MAAMS,SAAS,UAAMjB,4KAAAA,EAAY;QAC/BI;QACAC,cAAcA;QACdI,WAAOd,sKAAAA,EAASc,SAASS,OAAOT,SAASU;QACzCR,OAAOA,UAAU;QACjBE,WAAOjB,0LAAAA,EAAmBiB;QAC1BC,cAAUjB,gMAAAA,EAAsBiB;QAChCZ;QACAa,YAAQjB,4LAAAA,EAAoBiB;IAC9B;IAEA,IAAIX,WAAWgB,MAAM,CAACC,IAAI,CAACC,wBAAwB,EAAE;QACnD,OAAOL,OAAOM,KAAK;IACrB;IAEA,OAAOC,SAASC,IAAI,CAClB;QACE,GAAGR,MAAM;QACTS,SAASxB,IAAIyB,CAAC,CAAC;IACjB,GACA;QACEC,aAASlC,oLAAAA,EAAgB;YACvBkC,SAAS,IAAIC;YACb3B;QACF;QACAX,QAAQC,sMAAAA,CAAWsC,EAAE;IACvB;AAEJ,EAAC"}},
    {"offset": {"line": 1782, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/auth/operations/refresh.ts"],"sourcesContent":["import type { Collection } from '../../collections/config/types.js'\nimport type { Document, PayloadRequest } from '../../types/index.js'\n\nimport { buildAfterOperation } from '../../collections/operations/utilities/buildAfterOperation.js'\nimport { buildBeforeOperation } from '../../collections/operations/utilities/buildBeforeOperation.js'\nimport { Forbidden } from '../../errors/index.js'\nimport { commitTransaction } from '../../utilities/commitTransaction.js'\nimport { initTransaction } from '../../utilities/initTransaction.js'\nimport { killTransaction } from '../../utilities/killTransaction.js'\nimport { getFieldsToSign } from '../getFieldsToSign.js'\nimport { jwtSign } from '../jwt.js'\nimport { removeExpiredSessions } from '../sessions.js'\n\nexport type Result = {\n  exp: number\n  refreshedToken: string\n  setCookie?: boolean\n  /** @deprecated\n   * use:\n   * ```ts\n   * user._strategy\n   * ```\n   */\n  strategy?: string\n  user: Document\n}\n\nexport type Arguments = {\n  collection: Collection\n  req: PayloadRequest\n}\n\nexport const refreshOperation = async (incomingArgs: Arguments): Promise<Result> => {\n  let args = incomingArgs\n\n  try {\n    const shouldCommit = await initTransaction(args.req)\n\n    // /////////////////////////////////////\n    // beforeOperation - Collection\n    // /////////////////////////////////////\n\n    args = await buildBeforeOperation({\n      args,\n      collection: args.collection.config,\n      operation: 'refresh',\n      overrideAccess: false,\n    })\n\n    // /////////////////////////////////////\n    // Refresh\n    // /////////////////////////////////////\n\n    const {\n      collection: { config: collectionConfig },\n      req,\n      req: {\n        payload: { config, secret },\n      },\n    } = args\n\n    if (!args.req.user) {\n      throw new Forbidden(args.req.t)\n    }\n\n    const pathname = new URL(args.req.url!).pathname\n\n    const isGraphQL = pathname === config.routes.graphQL\n\n    let user = await req.payload.db.findOne<any>({\n      collection: collectionConfig.slug,\n      req,\n      where: { id: { equals: args.req.user.id } },\n    })\n\n    const sid = args.req.user._sid\n\n    if (collectionConfig.auth.useSessions && !collectionConfig.auth.disableLocalStrategy) {\n      if (!Array.isArray(user.sessions) || !sid) {\n        throw new Forbidden(args.req.t)\n      }\n\n      const existingSession = user.sessions.find(({ id }: { id: number }) => id === sid)\n\n      const now = new Date()\n      const tokenExpInMs = collectionConfig.auth.tokenExpiration * 1000\n      existingSession.expiresAt = new Date(now.getTime() + tokenExpInMs)\n\n      // Prevent updatedAt from being updated when only refreshing a session\n      user.updatedAt = null\n\n      await req.payload.db.updateOne({\n        id: user.id,\n        collection: collectionConfig.slug,\n        data: {\n          ...user,\n          sessions: removeExpiredSessions(user.sessions),\n        },\n        req,\n        returning: false,\n      })\n    }\n\n    user = await req.payload.findByID({\n      id: user.id,\n      collection: collectionConfig.slug,\n      depth: isGraphQL ? 0 : args.collection.config.auth.depth,\n      req: args.req,\n    })\n\n    if (user) {\n      user.collection = args.req.user.collection\n      user._strategy = args.req.user._strategy\n    }\n\n    let result!: Result\n\n    // /////////////////////////////////////\n    // refresh hook - Collection\n    // /////////////////////////////////////\n\n    for (const refreshHook of args.collection.config.hooks.refresh) {\n      const hookResult = await refreshHook({ args, user })\n\n      if (hookResult) {\n        result = hookResult\n        break\n      }\n    }\n\n    if (!result) {\n      const fieldsToSign = getFieldsToSign({\n        collectionConfig,\n        email: user?.email as string,\n        sid,\n        user: args?.req?.user,\n      })\n\n      const { exp, token: refreshedToken } = await jwtSign({\n        fieldsToSign,\n        secret,\n        tokenExpiration: collectionConfig.auth.tokenExpiration,\n      })\n\n      result = {\n        exp,\n        refreshedToken,\n        setCookie: true,\n        /** @deprecated\n         * use:\n         * ```ts\n         * user._strategy\n         * ```\n         */\n        strategy: args.req.user._strategy,\n        user,\n      }\n    }\n\n    // /////////////////////////////////////\n    // After Refresh - Collection\n    // /////////////////////////////////////\n\n    if (collectionConfig.hooks?.afterRefresh?.length) {\n      for (const hook of collectionConfig.hooks.afterRefresh) {\n        result =\n          (await hook({\n            collection: args.collection?.config,\n            context: args.req.context,\n            exp: result.exp,\n            req: args.req,\n            token: result.refreshedToken,\n          })) || result\n      }\n    }\n\n    // /////////////////////////////////////\n    // afterOperation - Collection\n    // /////////////////////////////////////\n\n    result = await buildAfterOperation({\n      args,\n      collection: args.collection?.config,\n      operation: 'refresh',\n      overrideAccess: false,\n      result,\n    })\n\n    // /////////////////////////////////////\n    // Return results\n    // /////////////////////////////////////\n\n    if (shouldCommit) {\n      await commitTransaction(req)\n    }\n\n    return result\n  } catch (error: unknown) {\n    await killTransaction(args.req)\n    throw error\n  }\n}\n"],"names":["buildAfterOperation","buildBeforeOperation","Forbidden","commitTransaction","initTransaction","killTransaction","getFieldsToSign","jwtSign","removeExpiredSessions","refreshOperation","incomingArgs","args","shouldCommit","req","collection","config","operation","overrideAccess","collectionConfig","payload","secret","user","t","pathname","URL","url","isGraphQL","routes","graphQL","db","findOne","slug","where","id","equals","sid","_sid","auth","useSessions","disableLocalStrategy","Array","isArray","sessions","existingSession","find","now","Date","tokenExpInMs","tokenExpiration","expiresAt","getTime","updatedAt","updateOne","data","returning","findByID","depth","_strategy","result","refreshHook","hooks","refresh","hookResult","fieldsToSign","email","exp","token","refreshedToken","setCookie","strategy","afterRefresh","length","hook","context","error"],"mappings":"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"}},
    {"offset": {"line": 1946, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/auth/endpoints/refresh.ts"],"sourcesContent":["import { status as httpStatus } from 'http-status'\n\nimport type { PayloadHandler } from '../../config/types.js'\n\nimport { getRequestCollection } from '../../utilities/getRequestEntity.js'\nimport { headersWithCors } from '../../utilities/headersWithCors.js'\nimport { generatePayloadCookie } from '../cookies.js'\nimport { refreshOperation } from '../operations/refresh.js'\n\nexport const refreshHandler: PayloadHandler = async (req) => {\n  const collection = getRequestCollection(req)\n  const { t } = req\n\n  const headers = headersWithCors({\n    headers: new Headers(),\n    req,\n  })\n\n  const result = await refreshOperation({\n    collection,\n    req,\n  })\n\n  if (result.setCookie) {\n    const cookie = generatePayloadCookie({\n      collectionAuthConfig: collection.config.auth,\n      cookiePrefix: req.payload.config.cookiePrefix,\n      token: result.refreshedToken,\n    })\n\n    if (collection.config.auth.removeTokenFromResponses) {\n      // @ts-expect-error - vestiges of when tsconfig was not strict. Feel free to improve\n      delete result.refreshedToken\n    }\n\n    headers.set('Set-Cookie', cookie)\n  }\n\n  return Response.json(\n    {\n      message: t('authentication:tokenRefreshSuccessful'),\n      ...result,\n    },\n    {\n      headers,\n      status: httpStatus.OK,\n    },\n  )\n}\n"],"names":["status","httpStatus","getRequestCollection","headersWithCors","generatePayloadCookie","refreshOperation","refreshHandler","req","collection","t","headers","Headers","result","setCookie","cookie","collectionAuthConfig","config","auth","cookiePrefix","payload","token","refreshedToken","removeTokenFromResponses","set","Response","json","message","OK"],"mappings":";;;;;AAAA,SAASA,UAAUC,UAAU,QAAQ,cAAa;AAIlD,SAASC,oBAAoB,QAAQ,sCAAqC;AAC1E,SAASC,eAAe,QAAQ,qCAAoC;AACpE,SAASC,qBAAqB,QAAQ,gBAAe;AACrD,SAASC,gBAAgB,QAAQ,2BAA0B;;;;;;AAEpD,MAAMC,iBAAiC,OAAOC;IACnD,MAAMC,iBAAaN,0LAAAA,EAAqBK;IACxC,MAAM,EAAEE,CAAC,EAAE,GAAGF;IAEd,MAAMG,cAAUP,oLAAAA,EAAgB;QAC9BO,SAAS,IAAIC;QACbJ;IACF;IAEA,MAAMK,SAAS,UAAMP,sLAAAA,EAAiB;QACpCG;QACAD;IACF;IAEA,IAAIK,OAAOC,SAAS,EAAE;QACpB,MAAMC,aAASV,6KAAAA,EAAsB;YACnCW,sBAAsBP,WAAWQ,MAAM,CAACC,IAAI;YAC5CC,cAAcX,IAAIY,OAAO,CAACH,MAAM,CAACE,YAAY;YAC7CE,OAAOR,OAAOS,cAAc;QAC9B;QAEA,IAAIb,WAAWQ,MAAM,CAACC,IAAI,CAACK,wBAAwB,EAAE;YACnD,oFAAoF;YACpF,OAAOV,OAAOS,cAAc;QAC9B;QAEAX,QAAQa,GAAG,CAAC,cAAcT;IAC5B;IAEA,OAAOU,SAASC,IAAI,CAClB;QACEC,SAASjB,EAAE;QACX,GAAGG,MAAM;IACX,GACA;QACEF;QACAV,QAAQC,sMAAAA,CAAW0B,EAAE;IACvB;AAEJ,EAAC"}},
    {"offset": {"line": 1996, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/auth/ensureUsernameOrEmail.ts"],"sourcesContent":["import type { RequiredDataFromCollectionSlug } from '../collections/config/types.js'\nimport type { AuthCollection, CollectionSlug, PayloadRequest } from '../index.js'\n\nimport { ValidationError } from '../errors/index.js'\n\ntype ValidateUsernameOrEmailArgs<TSlug extends CollectionSlug> = {\n  authOptions: AuthCollection['config']['auth']\n  collectionSlug: string\n  data: RequiredDataFromCollectionSlug<TSlug>\n  req: PayloadRequest\n} & (\n  | {\n      operation: 'create'\n      originalDoc?: never\n    }\n  | {\n      operation: 'update'\n      originalDoc: RequiredDataFromCollectionSlug<TSlug>\n    }\n)\nexport const ensureUsernameOrEmail = <TSlug extends CollectionSlug>({\n  authOptions: { disableLocalStrategy, loginWithUsername },\n  collectionSlug,\n  data,\n  operation,\n  originalDoc,\n  req,\n}: ValidateUsernameOrEmailArgs<TSlug>) => {\n  // neither username or email are required\n  // and neither are provided\n  // so we need to manually validate\n  if (\n    !disableLocalStrategy &&\n    loginWithUsername &&\n    !loginWithUsername.requireEmail &&\n    !loginWithUsername.requireUsername\n  ) {\n    let missingFields = false\n    if (operation === 'create' && !data.email && !data.username) {\n      missingFields = true\n    } else if (operation === 'update') {\n      // prevent clearing both email and username\n      if ('email' in data && !data.email && 'username' in data && !data.username) {\n        missingFields = true\n      }\n      // prevent clearing email if no username\n      if ('email' in data && !data.email && !originalDoc.username && !data?.username) {\n        missingFields = true\n      }\n      // prevent clearing username if no email\n      if ('username' in data && !data.username && !originalDoc.email && !data?.email) {\n        missingFields = true\n      }\n    }\n\n    if (missingFields) {\n      throw new ValidationError(\n        {\n          collection: collectionSlug,\n          errors: [\n            {\n              message: 'Username or email is required',\n              path: 'username',\n            },\n            {\n              message: 'Username or email is required',\n              path: 'email',\n            },\n          ],\n        },\n        req.t,\n      )\n    }\n  }\n\n  return\n}\n"],"names":["ValidationError","ensureUsernameOrEmail","authOptions","disableLocalStrategy","loginWithUsername","collectionSlug","data","operation","originalDoc","req","requireEmail","requireUsername","missingFields","email","username","collection","errors","message","path","t"],"mappings":";;;;AAGA,SAASA,eAAe,QAAQ,qBAAoB;;AAiB7C,MAAMC,wBAAwB,CAA+B,EAClEC,aAAa,EAAEC,oBAAoB,EAAEC,iBAAiB,EAAE,EACxDC,cAAc,EACdC,IAAI,EACJC,SAAS,EACTC,WAAW,EACXC,GAAG,EACgC;IACnC,yCAAyC;IACzC,2BAA2B;IAC3B,kCAAkC;IAClC,IACE,CAACN,wBACDC,qBACA,CAACA,kBAAkBM,YAAY,IAC/B,CAACN,kBAAkBO,eAAe,EAClC;QACA,IAAIC,gBAAgB;QACpB,IAAIL,cAAc,YAAY,CAACD,KAAKO,KAAK,IAAI,CAACP,KAAKQ,QAAQ,EAAE;YAC3DF,gBAAgB;QAClB,OAAO,IAAIL,cAAc,UAAU;YACjC,2CAA2C;YAC3C,IAAI,WAAWD,QAAQ,CAACA,KAAKO,KAAK,IAAI,cAAcP,QAAQ,CAACA,KAAKQ,QAAQ,EAAE;gBAC1EF,gBAAgB;YAClB;YACA,wCAAwC;YACxC,IAAI,WAAWN,QAAQ,CAACA,KAAKO,KAAK,IAAI,CAACL,YAAYM,QAAQ,IAAI,CAACR,MAAMQ,UAAU;gBAC9EF,gBAAgB;YAClB;YACA,wCAAwC;YACxC,IAAI,cAAcN,QAAQ,CAACA,KAAKQ,QAAQ,IAAI,CAACN,YAAYK,KAAK,IAAI,CAACP,MAAMO,OAAO;gBAC9ED,gBAAgB;YAClB;QACF;QAEA,IAAIA,eAAe;YACjB,MAAM,IAAIZ,iLAAAA,CACR;gBACEe,YAAYV;gBACZW,QAAQ;oBACN;wBACEC,SAAS;wBACTC,MAAM;oBACR;oBACA;wBACED,SAAS;wBACTC,MAAM;oBACR;iBACD;YACH,GACAT,IAAIU,CAAC;QAET;IACF;IAEA;AACF,EAAC"}},
    {"offset": {"line": 2046, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/auth/operations/registerFirstUser.ts"],"sourcesContent":["import type {\n  AuthOperationsFromCollectionSlug,\n  Collection,\n  DataFromCollectionSlug,\n  RequiredDataFromCollectionSlug,\n} from '../../collections/config/types.js'\nimport type { CollectionSlug } from '../../index.js'\nimport type { PayloadRequest, SelectType } from '../../types/index.js'\n\nimport { Forbidden } from '../../errors/index.js'\nimport { appendNonTrashedFilter } from '../../utilities/appendNonTrashedFilter.js'\nimport { commitTransaction } from '../../utilities/commitTransaction.js'\nimport { initTransaction } from '../../utilities/initTransaction.js'\nimport { killTransaction } from '../../utilities/killTransaction.js'\nimport { ensureUsernameOrEmail } from '../ensureUsernameOrEmail.js'\n\nexport type Arguments<TSlug extends CollectionSlug> = {\n  collection: Collection\n  data: AuthOperationsFromCollectionSlug<TSlug>['registerFirstUser'] &\n    RequiredDataFromCollectionSlug<TSlug>\n  req: PayloadRequest\n}\n\nexport type Result<TData> = {\n  exp?: number\n  token?: string\n  user?: TData\n}\n\nexport const registerFirstUserOperation = async <TSlug extends CollectionSlug>(\n  args: Arguments<TSlug>,\n): Promise<Result<DataFromCollectionSlug<TSlug>>> => {\n  const {\n    collection: {\n      config,\n      config: {\n        slug,\n        auth: { verify },\n      },\n    },\n    data,\n    req,\n    req: { payload },\n  } = args\n\n  if (config.auth.disableLocalStrategy) {\n    throw new Forbidden(req.t)\n  }\n\n  try {\n    const shouldCommit = await initTransaction(req)\n\n    ensureUsernameOrEmail<TSlug>({\n      authOptions: config.auth,\n      collectionSlug: slug,\n      data,\n      operation: 'create',\n      req,\n    })\n\n    const where = appendNonTrashedFilter({\n      enableTrash: Boolean(config.trash),\n      trash: false,\n      where: {}, // no initial filter; just exclude trashed docs\n    })\n\n    const doc = await payload.db.findOne({\n      collection: config.slug,\n      req,\n      where,\n    })\n\n    if (doc) {\n      throw new Forbidden(req.t)\n    }\n\n    // /////////////////////////////////////\n    // Register first user\n    // /////////////////////////////////////\n\n    const result = await payload.create<TSlug, SelectType>({\n      collection: slug as TSlug,\n      data,\n      overrideAccess: true,\n      req,\n    })\n\n    // auto-verify (if applicable)\n    if (verify) {\n      await payload.update({\n        id: result.id,\n        collection: slug,\n        data: {\n          _verified: true,\n        },\n        req,\n      })\n    }\n\n    // /////////////////////////////////////\n    // Log in new user\n    // /////////////////////////////////////\n\n    const { exp, token } = await payload.login({\n      ...args,\n      collection: slug,\n      req,\n    })\n\n    result.collection = slug\n    result._strategy = 'local-jwt'\n\n    if (shouldCommit) {\n      await commitTransaction(req)\n    }\n\n    return {\n      exp,\n      token,\n      user: result,\n    }\n  } catch (error: unknown) {\n    await killTransaction(req)\n    throw error\n  }\n}\n"],"names":["Forbidden","appendNonTrashedFilter","commitTransaction","initTransaction","killTransaction","ensureUsernameOrEmail","registerFirstUserOperation","args","collection","config","slug","auth","verify","data","req","payload","disableLocalStrategy","t","shouldCommit","authOptions","collectionSlug","operation","where","enableTrash","Boolean","trash","doc","db","findOne","result","create","overrideAccess","update","id","_verified","exp","token","login","_strategy","user","error"],"mappings":";;;;AASA,SAASA,SAAS,QAAQ,wBAAuB;AACjD,SAASC,sBAAsB,QAAQ,4CAA2C;AAClF,SAASC,iBAAiB,QAAQ,uCAAsC;AACxE,SAASC,eAAe,QAAQ,qCAAoC;AACpE,SAASC,eAAe,QAAQ,qCAAoC;AACpE,SAASC,qBAAqB,QAAQ,8BAA6B;;;;;;;AAe5D,MAAMC,6BAA6B,OACxCC;IAEA,MAAM,EACJC,YAAY,EACVC,MAAM,EACNA,QAAQ,EACNC,IAAI,EACJC,MAAM,EAAEC,MAAM,EAAE,EACjB,EACF,EACDC,IAAI,EACJC,GAAG,EACHA,KAAK,EAAEC,OAAO,EAAE,EACjB,GAAGR;IAEJ,IAAIE,OAAOE,IAAI,CAACK,oBAAoB,EAAE;QACpC,MAAM,IAAIhB,qKAAAA,CAAUc,IAAIG,CAAC;IAC3B;IAEA,IAAI;QACF,MAAMC,eAAe,UAAMf,oLAAAA,EAAgBW;YAE3CT,2LAAAA,EAA6B;YAC3Bc,aAAaV,OAAOE,IAAI;YACxBS,gBAAgBV;YAChBG;YACAQ,WAAW;YACXP;QACF;QAEA,MAAMQ,YAAQrB,kMAAAA,EAAuB;YACnCsB,aAAaC,QAAQf,OAAOgB,KAAK;YACjCA,OAAO;YACPH,OAAO,CAAC;QACV;QAEA,MAAMI,MAAM,MAAMX,QAAQY,EAAE,CAACC,OAAO,CAAC;YACnCpB,YAAYC,OAAOC,IAAI;YACvBI;YACAQ;QACF;QAEA,IAAII,KAAK;YACP,MAAM,IAAI1B,qKAAAA,CAAUc,IAAIG,CAAC;QAC3B;QAEA,wCAAwC;QACxC,sBAAsB;QACtB,wCAAwC;QAExC,MAAMY,SAAS,MAAMd,QAAQe,MAAM,CAAoB;YACrDtB,YAAYE;YACZG;YACAkB,gBAAgB;YAChBjB;QACF;QAEA,8BAA8B;QAC9B,IAAIF,QAAQ;YACV,MAAMG,QAAQiB,MAAM,CAAC;gBACnBC,IAAIJ,OAAOI,EAAE;gBACbzB,YAAYE;gBACZG,MAAM;oBACJqB,WAAW;gBACb;gBACApB;YACF;QACF;QAEA,wCAAwC;QACxC,kBAAkB;QAClB,wCAAwC;QAExC,MAAM,EAAEqB,GAAG,EAAEC,KAAK,EAAE,GAAG,MAAMrB,QAAQsB,KAAK,CAAC;YACzC,GAAG9B,IAAI;YACPC,YAAYE;YACZI;QACF;QAEAe,OAAOrB,UAAU,GAAGE;QACpBmB,OAAOS,SAAS,GAAG;QAEnB,IAAIpB,cAAc;YAChB,UAAMhB,wLAAAA,EAAkBY;QAC1B;QAEA,OAAO;YACLqB;YACAC;YACAG,MAAMV;QACR;IACF,EAAE,OAAOW,OAAgB;QACvB,UAAMpC,oLAAAA,EAAgBU;QACtB,MAAM0B;IACR;AACF,EAAC"}},
    {"offset": {"line": 2136, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/auth/endpoints/registerFirstUser.ts"],"sourcesContent":["import { status as httpStatus } from 'http-status'\n\nimport type { PayloadHandler } from '../../config/types.js'\n\nimport { getRequestCollection } from '../../utilities/getRequestEntity.js'\nimport { headersWithCors } from '../../utilities/headersWithCors.js'\nimport { generatePayloadCookie } from '../cookies.js'\nimport { registerFirstUserOperation } from '../operations/registerFirstUser.js'\n\nexport const registerFirstUserHandler: PayloadHandler = async (req) => {\n  const collection = getRequestCollection(req)\n  const { data, t } = req\n  const authData = collection.config.auth?.loginWithUsername\n    ? {\n        email: typeof req.data?.email === 'string' ? req.data.email : '',\n        password: typeof req.data?.password === 'string' ? req.data.password : '',\n        username: typeof req.data?.username === 'string' ? req.data.username : '',\n      }\n    : {\n        email: typeof req.data?.email === 'string' ? req.data.email : '',\n        password: typeof req.data?.password === 'string' ? req.data.password : '',\n      }\n\n  const result = await registerFirstUserOperation({\n    collection,\n    data: {\n      ...data,\n      ...authData,\n    },\n    req,\n  })\n\n  const cookie = generatePayloadCookie({\n    collectionAuthConfig: collection.config.auth,\n    cookiePrefix: req.payload.config.cookiePrefix,\n    token: result.token!,\n  })\n\n  return Response.json(\n    {\n      exp: result.exp,\n      message: t('authentication:successfullyRegisteredFirstUser'),\n      token: result.token,\n      user: result.user,\n    },\n    {\n      headers: headersWithCors({\n        headers: new Headers({\n          'Set-Cookie': cookie,\n        }),\n        req,\n      }),\n      status: httpStatus.OK,\n    },\n  )\n}\n"],"names":["status","httpStatus","getRequestCollection","headersWithCors","generatePayloadCookie","registerFirstUserOperation","registerFirstUserHandler","req","collection","data","t","authData","config","auth","loginWithUsername","email","password","username","result","cookie","collectionAuthConfig","cookiePrefix","payload","token","Response","json","exp","message","user","headers","Headers","OK"],"mappings":";;;;;AAAA,SAASA,UAAUC,UAAU,QAAQ,cAAa;AAIlD,SAASC,oBAAoB,QAAQ,sCAAqC;AAC1E,SAASC,eAAe,QAAQ,qCAAoC;AACpE,SAASC,qBAAqB,QAAQ,gBAAe;AACrD,SAASC,0BAA0B,QAAQ,qCAAoC;;;;;;AAExE,MAAMC,2BAA2C,OAAOC;IAC7D,MAAMC,iBAAaN,0LAAAA,EAAqBK;IACxC,MAAM,EAAEE,IAAI,EAAEC,CAAC,EAAE,GAAGH;IACpB,MAAMI,WAAWH,WAAWI,MAAM,CAACC,IAAI,EAAEC,oBACrC;QACEC,OAAO,OAAOR,IAAIE,IAAI,EAAEM,UAAU,WAAWR,IAAIE,IAAI,CAACM,KAAK,GAAG;QAC9DC,UAAU,OAAOT,IAAIE,IAAI,EAAEO,aAAa,WAAWT,IAAIE,IAAI,CAACO,QAAQ,GAAG;QACvEC,UAAU,OAAOV,IAAIE,IAAI,EAAEQ,aAAa,WAAWV,IAAIE,IAAI,CAACQ,QAAQ,GAAG;IACzE,IACA;QACEF,OAAO,OAAOR,IAAIE,IAAI,EAAEM,UAAU,WAAWR,IAAIE,IAAI,CAACM,KAAK,GAAG;QAC9DC,UAAU,OAAOT,IAAIE,IAAI,EAAEO,aAAa,WAAWT,IAAIE,IAAI,CAACO,QAAQ,GAAG;IACzE;IAEJ,MAAME,SAAS,UAAMb,0MAAAA,EAA2B;QAC9CG;QACAC,MAAM;YACJ,GAAGA,IAAI;YACP,GAAGE,QAAQ;QACb;QACAJ;IACF;IAEA,MAAMY,aAASf,6KAAAA,EAAsB;QACnCgB,sBAAsBZ,WAAWI,MAAM,CAACC,IAAI;QAC5CQ,cAAcd,IAAIe,OAAO,CAACV,MAAM,CAACS,YAAY;QAC7CE,OAAOL,OAAOK,KAAK;IACrB;IAEA,OAAOC,SAASC,IAAI,CAClB;QACEC,KAAKR,OAAOQ,GAAG;QACfC,SAASjB,EAAE;QACXa,OAAOL,OAAOK,KAAK;QACnBK,MAAMV,OAAOU,IAAI;IACnB,GACA;QACEC,aAAS1B,oLAAAA,EAAgB;YACvB0B,SAAS,IAAIC,QAAQ;gBACnB,cAAcX;YAChB;YACAZ;QACF;QACAP,QAAQC,sMAAAA,CAAW8B,EAAE;IACvB;AAEJ,EAAC"}},
    {"offset": {"line": 2194, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/auth/strategies/local/generatePasswordSaltHash.ts"],"sourcesContent":["import crypto from 'crypto'\n\nimport type { SanitizedCollectionConfig } from '../../../collections/config/types.js'\nimport type { PayloadRequest } from '../../../types/index.js'\n\nimport { ValidationError } from '../../../errors/index.js'\nimport { password } from '../../../fields/validations.js'\n\nfunction randomBytes(): Promise<Buffer> {\n  return new Promise((resolve, reject) =>\n    crypto.randomBytes(32, (err, saltBuffer) => (err ? reject(err) : resolve(saltBuffer))),\n  )\n}\n\nfunction pbkdf2Promisified(password: string, salt: string): Promise<Buffer> {\n  return new Promise((resolve, reject) =>\n    crypto.pbkdf2(password, salt, 25000, 512, 'sha256', (err, hashRaw) =>\n      err ? reject(err) : resolve(hashRaw),\n    ),\n  )\n}\n\ntype Args = {\n  collection: SanitizedCollectionConfig\n  password: string\n  req: PayloadRequest\n}\n\nexport const generatePasswordSaltHash = async ({\n  collection,\n  password: passwordToSet,\n  req,\n}: Args): Promise<{ hash: string; salt: string }> => {\n  const validationResult = password(passwordToSet, {\n    name: 'password',\n    type: 'text',\n    blockData: {},\n    data: {},\n    event: 'submit',\n    path: ['password'],\n    preferences: { fields: {} },\n    req,\n    required: true,\n    siblingData: {},\n  })\n\n  if (typeof validationResult === 'string') {\n    throw new ValidationError({\n      collection: collection?.slug,\n      errors: [{ message: validationResult, path: 'password' }],\n    })\n  }\n\n  const saltBuffer = await randomBytes()\n  const salt = saltBuffer.toString('hex')\n\n  const hashRaw = await pbkdf2Promisified(passwordToSet, salt)\n  const hash = hashRaw.toString('hex')\n\n  return { hash, salt }\n}\n"],"names":["crypto","ValidationError","password","randomBytes","Promise","resolve","reject","err","saltBuffer","pbkdf2Promisified","salt","pbkdf2","hashRaw","generatePasswordSaltHash","collection","passwordToSet","req","validationResult","name","type","blockData","data","event","path","preferences","fields","required","siblingData","slug","errors","message","toString","hash"],"mappings":";;;;AAAA,OAAOA,YAAY,SAAQ;AAK3B,SAASC,eAAe,QAAQ,2BAA0B;AAC1D,SAASC,QAAQ,QAAQ,iCAAgC;;;;AAEzD,SAASC;IACP,OAAO,IAAIC,QAAQ,CAACC,SAASC,SAC3BN,gHAAAA,CAAOG,WAAW,CAAC,IAAI,CAACI,KAAKC,aAAgBD,MAAMD,OAAOC,OAAOF,QAAQG;AAE7E;AAEA,SAASC,kBAAkBP,QAAgB,EAAEQ,IAAY;IACvD,OAAO,IAAIN,QAAQ,CAACC,SAASC,SAC3BN,gHAAAA,CAAOW,MAAM,CAACT,UAAUQ,MAAM,OAAO,KAAK,UAAU,CAACH,KAAKK,UACxDL,MAAMD,OAAOC,OAAOF,QAAQO;AAGlC;AAQO,MAAMC,2BAA2B,OAAO,EAC7CC,UAAU,EACVZ,UAAUa,aAAa,EACvBC,GAAG,EACE;IACL,MAAMC,uBAAmBf,sKAAAA,EAASa,eAAe;QAC/CG,MAAM;QACNC,MAAM;QACNC,WAAW,CAAC;QACZC,MAAM,CAAC;QACPC,OAAO;QACPC,MAAM;YAAC;SAAW;QAClBC,aAAa;YAAEC,QAAQ,CAAC;QAAE;QAC1BT;QACAU,UAAU;QACVC,aAAa,CAAC;IAChB;IAEA,IAAI,OAAOV,qBAAqB,UAAU;QACxC,MAAM,IAAIhB,iLAAAA,CAAgB;YACxBa,YAAYA,YAAYc;YACxBC,QAAQ;gBAAC;oBAAEC,SAASb;oBAAkBM,MAAM;gBAAW;aAAE;QAC3D;IACF;IAEA,MAAMf,aAAa,MAAML;IACzB,MAAMO,OAAOF,WAAWuB,QAAQ,CAAC;IAEjC,MAAMnB,UAAU,MAAMH,kBAAkBM,eAAeL;IACvD,MAAMsB,OAAOpB,QAAQmB,QAAQ,CAAC;IAE9B,OAAO;QAAEC;QAAMtB;IAAK;AACtB,EAAC"}},
    {"offset": {"line": 2251, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/auth/operations/resetPassword.ts"],"sourcesContent":["import { status as httpStatus } from 'http-status'\n\nimport type { Collection, DataFromCollectionSlug } from '../../collections/config/types.js'\nimport type { CollectionSlug, UntypedUser } from '../../index.js'\nimport type { PayloadRequest } from '../../types/index.js'\n\nimport { buildAfterOperation } from '../../collections/operations/utilities/buildAfterOperation.js'\nimport { buildBeforeOperation } from '../../collections/operations/utilities/buildBeforeOperation.js'\nimport { APIError, Forbidden } from '../../errors/index.js'\nimport { appendNonTrashedFilter } from '../../utilities/appendNonTrashedFilter.js'\nimport { commitTransaction } from '../../utilities/commitTransaction.js'\nimport { initTransaction } from '../../utilities/initTransaction.js'\nimport { killTransaction } from '../../utilities/killTransaction.js'\nimport { getFieldsToSign } from '../getFieldsToSign.js'\nimport { jwtSign } from '../jwt.js'\nimport { addSessionToUser, revokeSession } from '../sessions.js'\nimport { authenticateLocalStrategy } from '../strategies/local/authenticate.js'\nimport { generatePasswordSaltHash } from '../strategies/local/generatePasswordSaltHash.js'\n\nexport type Result = {\n  token?: string\n  user: Record<string, unknown>\n}\n\nexport type Arguments = {\n  collection: Collection\n  data: {\n    password: string\n    token: string\n  }\n  depth?: number\n  overrideAccess?: boolean\n  req: PayloadRequest\n}\n\nexport const resetPasswordOperation = async <TSlug extends CollectionSlug>(\n  args: Arguments,\n): Promise<Result> => {\n  const {\n    collection: { config: collectionConfig },\n    data,\n    depth,\n    overrideAccess,\n    req: {\n      payload: { secret },\n      payload,\n    },\n    req,\n  } = args\n\n  if (\n    !Object.prototype.hasOwnProperty.call(data, 'token') ||\n    !Object.prototype.hasOwnProperty.call(data, 'password')\n  ) {\n    throw new APIError('Missing required data.', httpStatus.BAD_REQUEST)\n  }\n\n  if (collectionConfig.auth.disableLocalStrategy) {\n    throw new Forbidden(req.t)\n  }\n\n  let sid: string | undefined\n  let user: null | UntypedUser = null\n\n  try {\n    const shouldCommit = await initTransaction(req)\n\n    args = await buildBeforeOperation({\n      args,\n      collection: args.collection.config,\n      operation: 'resetPassword',\n      overrideAccess,\n    })\n\n    // /////////////////////////////////////\n    // Reset Password\n    // /////////////////////////////////////\n\n    const where = appendNonTrashedFilter({\n      enableTrash: Boolean(collectionConfig.trash),\n      trash: false,\n      where: {\n        resetPasswordExpiration: { greater_than: new Date().toISOString() },\n        resetPasswordToken: { equals: data.token },\n      },\n    })\n\n    user = await payload.db.findOne<any>({\n      collection: collectionConfig.slug,\n      req,\n      where,\n    })\n\n    if (!user) {\n      throw new APIError('Token is either invalid or has expired.', httpStatus.FORBIDDEN)\n    }\n\n    // TODO: replace this method\n    const { hash, salt } = await generatePasswordSaltHash({\n      collection: collectionConfig,\n      password: data.password,\n      req,\n    })\n\n    user.salt = salt\n    user.hash = hash\n\n    user.resetPasswordExpiration = new Date().toISOString()\n\n    if (collectionConfig.auth.verify) {\n      user._verified = Boolean(user._verified)\n    }\n\n    // /////////////////////////////////////\n    // beforeValidate - Collection\n    // /////////////////////////////////////\n\n    if (collectionConfig.hooks?.beforeValidate?.length) {\n      for (const hook of collectionConfig.hooks.beforeValidate) {\n        await hook({\n          collection: args.collection?.config,\n          context: req.context,\n          data: user,\n          operation: 'update',\n          req,\n        })\n      }\n    }\n\n    // /////////////////////////////////////\n    // Update new password\n    // /////////////////////////////////////\n\n    // Ensure updatedAt date is always updated\n    user.updatedAt = new Date().toISOString()\n\n    const doc = await payload.db.updateOne({\n      id: user.id,\n      collection: collectionConfig.slug,\n      data: user,\n      req,\n    })\n\n    await authenticateLocalStrategy({ doc, password: data.password })\n\n    const fieldsToSignArgs: Parameters<typeof getFieldsToSign>[0] = {\n      collectionConfig,\n      email: user.email!,\n      user,\n    }\n\n    const session = await addSessionToUser({\n      collectionConfig,\n      payload,\n      req,\n      user,\n    })\n    sid = session.sid\n\n    if (sid) {\n      fieldsToSignArgs.sid = sid\n    }\n\n    const fieldsToSign = getFieldsToSign(fieldsToSignArgs)\n\n    // /////////////////////////////////////\n    // beforeLogin - Collection\n    // /////////////////////////////////////\n\n    let userBeforeLogin = user\n\n    if (collectionConfig.hooks?.beforeLogin?.length) {\n      for (const hook of collectionConfig.hooks.beforeLogin) {\n        userBeforeLogin =\n          (await hook({\n            collection: args.collection?.config,\n            context: args.req.context,\n            req: args.req,\n            user: userBeforeLogin,\n          })) || userBeforeLogin\n      }\n    }\n\n    const { token } = await jwtSign({\n      fieldsToSign,\n      secret,\n      tokenExpiration: collectionConfig.auth.tokenExpiration,\n    })\n\n    req.user = userBeforeLogin\n\n    // /////////////////////////////////////\n    // afterLogin - Collection\n    // /////////////////////////////////////\n\n    if (collectionConfig.hooks?.afterLogin?.length) {\n      for (const hook of collectionConfig.hooks.afterLogin) {\n        userBeforeLogin =\n          (await hook({\n            collection: args.collection?.config,\n            context: args.req.context,\n            req: args.req,\n            token,\n            user: userBeforeLogin,\n          })) || userBeforeLogin\n      }\n    }\n\n    const fullUser = await payload.findByID({\n      id: user.id,\n      collection: collectionConfig.slug,\n      depth,\n      overrideAccess,\n      req,\n      trash: false,\n    })\n\n    if (shouldCommit) {\n      await commitTransaction(req)\n    }\n\n    if (fullUser) {\n      fullUser.collection = collectionConfig.slug\n      fullUser._strategy = 'local-jwt'\n    }\n\n    let result: { user: DataFromCollectionSlug<TSlug> } & Result = {\n      token,\n      user: fullUser,\n    }\n\n    // /////////////////////////////////////\n    // afterOperation - Collection\n    // /////////////////////////////////////\n\n    result = await buildAfterOperation({\n      args,\n      collection: args.collection?.config,\n      operation: 'resetPassword',\n      overrideAccess,\n      result,\n    })\n\n    return result\n  } catch (error: unknown) {\n    if (sid) {\n      await revokeSession({\n        collectionConfig,\n        payload,\n        req,\n        sid,\n        user,\n      })\n    }\n    await killTransaction(req)\n    throw error\n  }\n}\n"],"names":["status","httpStatus","buildAfterOperation","buildBeforeOperation","APIError","Forbidden","appendNonTrashedFilter","commitTransaction","initTransaction","killTransaction","getFieldsToSign","jwtSign","addSessionToUser","revokeSession","authenticateLocalStrategy","generatePasswordSaltHash","resetPasswordOperation","args","collection","config","collectionConfig","data","depth","overrideAccess","req","payload","secret","Object","prototype","hasOwnProperty","call","BAD_REQUEST","auth","disableLocalStrategy","t","sid","user","shouldCommit","operation","where","enableTrash","Boolean","trash","resetPasswordExpiration","greater_than","Date","toISOString","resetPasswordToken","equals","token","db","findOne","slug","FORBIDDEN","hash","salt","password","verify","_verified","hooks","beforeValidate","length","hook","context","updatedAt","doc","updateOne","id","fieldsToSignArgs","email","session","fieldsToSign","userBeforeLogin","beforeLogin","tokenExpiration","afterLogin","fullUser","findByID","_strategy","result","error"],"mappings":"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"}},
    {"offset": {"line": 2463, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/auth/endpoints/resetPassword.ts"],"sourcesContent":["import { status as httpStatus } from 'http-status'\n\nimport type { PayloadHandler } from '../../config/types.js'\n\nimport { getRequestCollection } from '../../utilities/getRequestEntity.js'\nimport { headersWithCors } from '../../utilities/headersWithCors.js'\nimport { generatePayloadCookie } from '../cookies.js'\nimport { resetPasswordOperation } from '../operations/resetPassword.js'\n\nexport const resetPasswordHandler: PayloadHandler = async (req) => {\n  const collection = getRequestCollection(req)\n  const { searchParams, t } = req\n  const depth = searchParams.get('depth')\n\n  const result = await resetPasswordOperation({\n    collection,\n    data: {\n      password: typeof req.data?.password === 'string' ? req.data.password : '',\n      token: typeof req.data?.token === 'string' ? req.data.token : '',\n    },\n    depth: depth ? Number(depth) : undefined,\n    req,\n  })\n\n  const cookie = generatePayloadCookie({\n    collectionAuthConfig: collection.config.auth,\n    cookiePrefix: req.payload.config.cookiePrefix,\n    token: result.token!,\n  })\n\n  if (collection.config.auth.removeTokenFromResponses) {\n    delete result.token\n  }\n\n  return Response.json(\n    {\n      message: t('authentication:passwordResetSuccessfully'),\n      ...result,\n    },\n    {\n      headers: headersWithCors({\n        headers: new Headers({\n          'Set-Cookie': cookie,\n        }),\n        req,\n      }),\n      status: httpStatus.OK,\n    },\n  )\n}\n"],"names":["status","httpStatus","getRequestCollection","headersWithCors","generatePayloadCookie","resetPasswordOperation","resetPasswordHandler","req","collection","searchParams","t","depth","get","result","data","password","token","Number","undefined","cookie","collectionAuthConfig","config","auth","cookiePrefix","payload","removeTokenFromResponses","Response","json","message","headers","Headers","OK"],"mappings":";;;;;AAAA,SAASA,UAAUC,UAAU,QAAQ,cAAa;AAIlD,SAASC,oBAAoB,QAAQ,sCAAqC;AAC1E,SAASC,eAAe,QAAQ,qCAAoC;AACpE,SAASC,qBAAqB,QAAQ,gBAAe;AACrD,SAASC,sBAAsB,QAAQ,iCAAgC;;;;;;AAEhE,MAAMC,uBAAuC,OAAOC;IACzD,MAAMC,iBAAaN,0LAAAA,EAAqBK;IACxC,MAAM,EAAEE,YAAY,EAAEC,CAAC,EAAE,GAAGH;IAC5B,MAAMI,QAAQF,aAAaG,GAAG,CAAC;IAE/B,MAAMC,SAAS,UAAMR,kMAAAA,EAAuB;QAC1CG;QACAM,MAAM;YACJC,UAAU,OAAOR,IAAIO,IAAI,EAAEC,aAAa,WAAWR,IAAIO,IAAI,CAACC,QAAQ,GAAG;YACvEC,OAAO,OAAOT,IAAIO,IAAI,EAAEE,UAAU,WAAWT,IAAIO,IAAI,CAACE,KAAK,GAAG;QAChE;QACAL,OAAOA,QAAQM,OAAON,SAASO;QAC/BX;IACF;IAEA,MAAMY,aAASf,6KAAAA,EAAsB;QACnCgB,sBAAsBZ,WAAWa,MAAM,CAACC,IAAI;QAC5CC,cAAchB,IAAIiB,OAAO,CAACH,MAAM,CAACE,YAAY;QAC7CP,OAAOH,OAAOG,KAAK;IACrB;IAEA,IAAIR,WAAWa,MAAM,CAACC,IAAI,CAACG,wBAAwB,EAAE;QACnD,OAAOZ,OAAOG,KAAK;IACrB;IAEA,OAAOU,SAASC,IAAI,CAClB;QACEC,SAASlB,EAAE;QACX,GAAGG,MAAM;IACX,GACA;QACEgB,aAAS1B,oLAAAA,EAAgB;YACvB0B,SAAS,IAAIC,QAAQ;gBACnB,cAAcX;YAChB;YACAZ;QACF;QACAP,QAAQC,sMAAAA,CAAW8B,EAAE;IACvB;AAEJ,EAAC"}},
    {"offset": {"line": 2516, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/auth/executeAccess.ts"],"sourcesContent":["import type { Access, AccessResult } from '../config/types.js'\nimport type { PayloadRequest } from '../types/index.js'\n\nimport { Forbidden } from '../errors/index.js'\n\ntype OperationArgs = {\n  data?: any\n  disableErrors?: boolean\n  id?: number | string\n  isReadingStaticFile?: boolean\n  req: PayloadRequest\n}\nexport const executeAccess = async (\n  { id, data, disableErrors, isReadingStaticFile = false, req }: OperationArgs,\n  access: Access,\n): Promise<AccessResult> => {\n  if (access) {\n    const resolvedConstraint = await access({\n      id,\n      data,\n      isReadingStaticFile,\n      req,\n    })\n\n    if (!resolvedConstraint) {\n      if (!disableErrors) {\n        throw new Forbidden(req.t)\n      }\n    }\n\n    return resolvedConstraint\n  }\n\n  if (req.user) {\n    return true\n  }\n\n  if (!disableErrors) {\n    throw new Forbidden(req.t)\n  }\n  return false\n}\n"],"names":["Forbidden","executeAccess","id","data","disableErrors","isReadingStaticFile","req","access","resolvedConstraint","t","user"],"mappings":";;;;AAGA,SAASA,SAAS,QAAQ,qBAAoB;;AASvC,MAAMC,gBAAgB,OAC3B,EAAEC,EAAE,EAAEC,IAAI,EAAEC,aAAa,EAAEC,sBAAsB,KAAK,EAAEC,GAAG,EAAiB,EAC5EC;IAEA,IAAIA,QAAQ;QACV,MAAMC,qBAAqB,MAAMD,OAAO;YACtCL;YACAC;YACAE;YACAC;QACF;QAEA,IAAI,CAACE,oBAAoB;YACvB,IAAI,CAACJ,eAAe;gBAClB,MAAM,IAAIJ,qKAAAA,CAAUM,IAAIG,CAAC;YAC3B;QACF;QAEA,OAAOD;IACT;IAEA,IAAIF,IAAII,IAAI,EAAE;QACZ,OAAO;IACT;IAEA,IAAI,CAACN,eAAe;QAClB,MAAM,IAAIJ,qKAAAA,CAAUM,IAAIG,CAAC;IAC3B;IACA,OAAO;AACT,EAAC"}},
    {"offset": {"line": 2549, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/auth/operations/unlock.ts"],"sourcesContent":["import { status as httpStatus } from 'http-status'\n\nimport type {\n  AuthOperationsFromCollectionSlug,\n  Collection,\n} from '../../collections/config/types.js'\nimport type { CollectionSlug } from '../../index.js'\nimport type { PayloadRequest, Where } from '../../types/index.js'\n\nimport { buildAfterOperation } from '../../collections/operations/utilities/buildAfterOperation.js'\nimport { buildBeforeOperation } from '../../collections/operations/utilities/buildBeforeOperation.js'\nimport { APIError } from '../../errors/index.js'\nimport { combineQueries, Forbidden } from '../../index.js'\nimport { appendNonTrashedFilter } from '../../utilities/appendNonTrashedFilter.js'\nimport { commitTransaction } from '../../utilities/commitTransaction.js'\nimport { initTransaction } from '../../utilities/initTransaction.js'\nimport { killTransaction } from '../../utilities/killTransaction.js'\nimport { executeAccess } from '../executeAccess.js'\nimport { getLoginOptions } from '../getLoginOptions.js'\nimport { resetLoginAttempts } from '../strategies/local/resetLoginAttempts.js'\n\nexport type Arguments<TSlug extends CollectionSlug> = {\n  collection: Collection\n  data: AuthOperationsFromCollectionSlug<TSlug>['unlock']\n  overrideAccess?: boolean\n  req: PayloadRequest\n}\n\nexport const unlockOperation = async <TSlug extends CollectionSlug>(\n  args: Arguments<TSlug>,\n): Promise<boolean> => {\n  const {\n    collection: { config: collectionConfig },\n    overrideAccess,\n    req: { locale },\n    req,\n  } = args\n\n  const loginWithUsername = collectionConfig.auth.loginWithUsername\n\n  const { canLoginWithEmail, canLoginWithUsername } = getLoginOptions(loginWithUsername)\n\n  const sanitizedEmail = canLoginWithEmail && (args.data?.email || '').toLowerCase().trim()\n  const sanitizedUsername =\n    (canLoginWithUsername &&\n      'username' in args.data &&\n      typeof args.data.username === 'string' &&\n      args.data.username.toLowerCase().trim()) ||\n    null\n\n  if (collectionConfig.auth.disableLocalStrategy) {\n    throw new Forbidden(req.t)\n  }\n  if (!sanitizedEmail && !sanitizedUsername) {\n    throw new APIError(\n      `Missing ${collectionConfig.auth.loginWithUsername ? 'username' : 'email'}.`,\n      httpStatus.BAD_REQUEST,\n    )\n  }\n\n  try {\n    args = await buildBeforeOperation({\n      args,\n      collection: args.collection.config,\n      operation: 'unlock',\n      overrideAccess,\n    })\n\n    const shouldCommit = await initTransaction(req)\n    let whereConstraint: Where = {}\n\n    // /////////////////////////////////////\n    // Access\n    // /////////////////////////////////////\n\n    if (!overrideAccess) {\n      const accessResult = await executeAccess({ req }, collectionConfig.access.unlock)\n\n      if (accessResult && typeof accessResult === 'object') {\n        whereConstraint = accessResult\n      }\n    }\n\n    // /////////////////////////////////////\n    // Unlock\n    // /////////////////////////////////////\n\n    if (canLoginWithEmail && sanitizedEmail) {\n      whereConstraint = combineQueries(whereConstraint, {\n        email: {\n          equals: sanitizedEmail,\n        },\n      })\n    } else if (canLoginWithUsername && sanitizedUsername) {\n      whereConstraint = combineQueries(whereConstraint, {\n        username: {\n          equals: sanitizedUsername,\n        },\n      })\n    }\n\n    // Exclude trashed users unless `trash: true`\n    whereConstraint = appendNonTrashedFilter({\n      enableTrash: Boolean(collectionConfig.trash),\n      trash: false,\n      where: whereConstraint,\n    })\n\n    const user = await req.payload.db.findOne({\n      collection: collectionConfig.slug,\n      locale: locale!,\n      req,\n      where: whereConstraint,\n    })\n\n    let result: boolean | null = null\n\n    if (user) {\n      await resetLoginAttempts({\n        collection: collectionConfig,\n        doc: user,\n        payload: req.payload,\n        req,\n      })\n      result = true\n    } else {\n      result = null\n      throw new Forbidden(req.t)\n    }\n\n    if (shouldCommit) {\n      await commitTransaction(req)\n    }\n\n    result = await buildAfterOperation({\n      args,\n      collection: args.collection.config,\n      operation: 'unlock',\n      overrideAccess,\n      result,\n    })\n\n    return Boolean(result)\n  } catch (error: unknown) {\n    await killTransaction(req)\n    throw error\n  }\n}\n"],"names":["status","httpStatus","buildAfterOperation","buildBeforeOperation","APIError","combineQueries","Forbidden","appendNonTrashedFilter","commitTransaction","initTransaction","killTransaction","executeAccess","getLoginOptions","resetLoginAttempts","unlockOperation","args","collection","config","collectionConfig","overrideAccess","req","locale","loginWithUsername","auth","canLoginWithEmail","canLoginWithUsername","sanitizedEmail","data","email","toLowerCase","trim","sanitizedUsername","username","disableLocalStrategy","t","BAD_REQUEST","operation","shouldCommit","whereConstraint","accessResult","access","unlock","equals","enableTrash","Boolean","trash","where","user","payload","db","findOne","slug","result","doc","error"],"mappings":"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"}},
    {"offset": {"line": 2672, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/auth/endpoints/unlock.ts"],"sourcesContent":["import { status as httpStatus } from 'http-status'\n\nimport type { PayloadHandler } from '../../config/types.js'\n\nimport { getRequestCollection } from '../../utilities/getRequestEntity.js'\nimport { headersWithCors } from '../../utilities/headersWithCors.js'\nimport { unlockOperation } from '../operations/unlock.js'\n\nexport const unlockHandler: PayloadHandler = async (req) => {\n  const collection = getRequestCollection(req)\n  const { t } = req\n\n  const authData =\n    collection.config.auth?.loginWithUsername !== false\n      ? {\n          email: typeof req.data?.email === 'string' ? req.data.email : '',\n          username: typeof req.data?.username === 'string' ? req.data.username : '',\n        }\n      : {\n          email: typeof req.data?.email === 'string' ? req.data.email : '',\n        }\n\n  await unlockOperation({\n    collection,\n    data: authData,\n    req,\n  })\n\n  return Response.json(\n    {\n      message: t('general:success'),\n    },\n    {\n      headers: headersWithCors({\n        headers: new Headers(),\n        req,\n      }),\n      status: httpStatus.OK,\n    },\n  )\n}\n"],"names":["status","httpStatus","getRequestCollection","headersWithCors","unlockOperation","unlockHandler","req","collection","t","authData","config","auth","loginWithUsername","email","data","username","Response","json","message","headers","Headers","OK"],"mappings":";;;;;AAAA,SAASA,UAAUC,UAAU,QAAQ,cAAa;AAIlD,SAASC,oBAAoB,QAAQ,sCAAqC;AAC1E,SAASC,eAAe,QAAQ,qCAAoC;AACpE,SAASC,eAAe,QAAQ,0BAAyB;;;;;AAElD,MAAMC,gBAAgC,OAAOC;IAClD,MAAMC,iBAAaL,0LAAAA,EAAqBI;IACxC,MAAM,EAAEE,CAAC,EAAE,GAAGF;IAEd,MAAMG,WACJF,WAAWG,MAAM,CAACC,IAAI,EAAEC,sBAAsB,QAC1C;QACEC,OAAO,OAAOP,IAAIQ,IAAI,EAAED,UAAU,WAAWP,IAAIQ,IAAI,CAACD,KAAK,GAAG;QAC9DE,UAAU,OAAOT,IAAIQ,IAAI,EAAEC,aAAa,WAAWT,IAAIQ,IAAI,CAACC,QAAQ,GAAG;IACzE,IACA;QACEF,OAAO,OAAOP,IAAIQ,IAAI,EAAED,UAAU,WAAWP,IAAIQ,IAAI,CAACD,KAAK,GAAG;IAChE;IAEN,UAAMT,oLAAAA,EAAgB;QACpBG;QACAO,MAAML;QACNH;IACF;IAEA,OAAOU,SAASC,IAAI,CAClB;QACEC,SAASV,EAAE;IACb,GACA;QACEW,aAAShB,oLAAAA,EAAgB;YACvBgB,SAAS,IAAIC;YACbd;QACF;QACAN,QAAQC,sMAAAA,CAAWoB,EAAE;IACvB;AAEJ,EAAC"}},
    {"offset": {"line": 2713, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/auth/operations/verifyEmail.ts"],"sourcesContent":["import { status as httpStatus } from 'http-status'\n\nimport type { Collection } from '../../collections/config/types.js'\nimport type { PayloadRequest } from '../../types/index.js'\n\nimport { APIError, Forbidden } from '../../errors/index.js'\nimport { appendNonTrashedFilter } from '../../utilities/appendNonTrashedFilter.js'\nimport { commitTransaction } from '../../utilities/commitTransaction.js'\nimport { initTransaction } from '../../utilities/initTransaction.js'\nimport { killTransaction } from '../../utilities/killTransaction.js'\n\nexport type Args = {\n  collection: Collection\n  req: PayloadRequest\n  token: string\n}\n\nexport const verifyEmailOperation = async (args: Args): Promise<boolean> => {\n  const { collection, req, token } = args\n\n  if (collection.config.auth.disableLocalStrategy) {\n    throw new Forbidden(req.t)\n  }\n  if (!Object.prototype.hasOwnProperty.call(args, 'token')) {\n    throw new APIError('Missing required data.', httpStatus.BAD_REQUEST)\n  }\n\n  try {\n    const shouldCommit = await initTransaction(req)\n\n    const where = appendNonTrashedFilter({\n      enableTrash: Boolean(collection.config.trash),\n      trash: false,\n      where: {\n        _verificationToken: { equals: token },\n      },\n    })\n\n    const user = await req.payload.db.findOne<any>({\n      collection: collection.config.slug,\n      req,\n      where,\n    })\n\n    if (!user) {\n      throw new APIError('Verification token is invalid.', httpStatus.FORBIDDEN)\n    }\n\n    // Ensure updatedAt date is always updated\n    user.updatedAt = new Date().toISOString()\n\n    await req.payload.db.updateOne({\n      id: user.id,\n      collection: collection.config.slug,\n      data: {\n        ...user,\n        _verificationToken: null,\n        _verified: true,\n      },\n      req,\n      returning: false,\n    })\n\n    if (shouldCommit) {\n      await commitTransaction(req)\n    }\n\n    return true\n  } catch (error: unknown) {\n    await killTransaction(req)\n    throw error\n  }\n}\n"],"names":["status","httpStatus","APIError","Forbidden","appendNonTrashedFilter","commitTransaction","initTransaction","killTransaction","verifyEmailOperation","args","collection","req","token","config","auth","disableLocalStrategy","t","Object","prototype","hasOwnProperty","call","BAD_REQUEST","shouldCommit","where","enableTrash","Boolean","trash","_verificationToken","equals","user","payload","db","findOne","slug","FORBIDDEN","updatedAt","Date","toISOString","updateOne","id","data","_verified","returning","error"],"mappings":";;;;;AAAA,SAASA,UAAUC,UAAU,QAAQ,cAAa;;AAKlD,SAASC,QAAQ,EAAEC,SAAS,QAAQ,wBAAuB;AAC3D,SAASC,sBAAsB,QAAQ,4CAA2C;AAClF,SAASC,iBAAiB,QAAQ,uCAAsC;AACxE,SAASC,eAAe,QAAQ,qCAAoC;AACpE,SAASC,eAAe,QAAQ,qCAAoC;;;;;;;AAQ7D,MAAMC,uBAAuB,OAAOC;IACzC,MAAM,EAAEC,UAAU,EAAEC,GAAG,EAAEC,KAAK,EAAE,GAAGH;IAEnC,IAAIC,WAAWG,MAAM,CAACC,IAAI,CAACC,oBAAoB,EAAE;QAC/C,MAAM,IAAIZ,qKAAAA,CAAUQ,IAAIK,CAAC;IAC3B;IACA,IAAI,CAACC,OAAOC,SAAS,CAACC,cAAc,CAACC,IAAI,CAACX,MAAM,UAAU;QACxD,MAAM,IAAIP,mKAAAA,CAAS,0BAA0BD,sMAAAA,CAAWoB,WAAW;IACrE;IAEA,IAAI;QACF,MAAMC,eAAe,UAAMhB,oLAAAA,EAAgBK;QAE3C,MAAMY,YAAQnB,kMAAAA,EAAuB;YACnCoB,aAAaC,QAAQf,WAAWG,MAAM,CAACa,KAAK;YAC5CA,OAAO;YACPH,OAAO;gBACLI,oBAAoB;oBAAEC,QAAQhB;gBAAM;YACtC;QACF;QAEA,MAAMiB,OAAO,MAAMlB,IAAImB,OAAO,CAACC,EAAE,CAACC,OAAO,CAAM;YAC7CtB,YAAYA,WAAWG,MAAM,CAACoB,IAAI;YAClCtB;YACAY;QACF;QAEA,IAAI,CAACM,MAAM;YACT,MAAM,IAAI3B,mKAAAA,CAAS,kCAAkCD,sMAAAA,CAAWiC,SAAS;QAC3E;QAEA,0CAA0C;QAC1CL,KAAKM,SAAS,GAAG,IAAIC,OAAOC,WAAW;QAEvC,MAAM1B,IAAImB,OAAO,CAACC,EAAE,CAACO,SAAS,CAAC;YAC7BC,IAAIV,KAAKU,EAAE;YACX7B,YAAYA,WAAWG,MAAM,CAACoB,IAAI;YAClCO,MAAM;gBACJ,GAAGX,IAAI;gBACPF,oBAAoB;gBACpBc,WAAW;YACb;YACA9B;YACA+B,WAAW;QACb;QAEA,IAAIpB,cAAc;YAChB,UAAMjB,wLAAAA,EAAkBM;QAC1B;QAEA,OAAO;IACT,EAAE,OAAOgC,OAAgB;QACvB,UAAMpC,oLAAAA,EAAgBI;QACtB,MAAMgC;IACR;AACF,EAAC"}},
    {"offset": {"line": 2784, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/auth/endpoints/verifyEmail.ts"],"sourcesContent":["import { status as httpStatus } from 'http-status'\n\nimport type { PayloadHandler } from '../../config/types.js'\n\nimport { getRequestCollectionWithID } from '../../utilities/getRequestEntity.js'\nimport { headersWithCors } from '../../utilities/headersWithCors.js'\nimport { verifyEmailOperation } from '../operations/verifyEmail.js'\n\nexport const verifyEmailHandler: PayloadHandler = async (req) => {\n  const { id, collection } = getRequestCollectionWithID(req, { disableSanitize: true })\n  const { t } = req\n  await verifyEmailOperation({\n    collection,\n    req,\n    token: id,\n  })\n\n  return Response.json(\n    {\n      message: t('authentication:accountVerified'),\n    },\n    {\n      headers: headersWithCors({\n        headers: new Headers(),\n        req,\n      }),\n      status: httpStatus.OK,\n    },\n  )\n}\n"],"names":["status","httpStatus","getRequestCollectionWithID","headersWithCors","verifyEmailOperation","verifyEmailHandler","req","id","collection","disableSanitize","t","token","Response","json","message","headers","Headers","OK"],"mappings":";;;;;AAAA,SAASA,UAAUC,UAAU,QAAQ,cAAa;AAIlD,SAASC,0BAA0B,QAAQ,sCAAqC;AAChF,SAASC,eAAe,QAAQ,qCAAoC;AACpE,SAASC,oBAAoB,QAAQ,+BAA8B;;;;;AAE5D,MAAMC,qBAAqC,OAAOC;IACvD,MAAM,EAAEC,EAAE,EAAEC,UAAU,EAAE,OAAGN,gMAAAA,EAA2BI,KAAK;QAAEG,iBAAiB;IAAK;IACnF,MAAM,EAAEC,CAAC,EAAE,GAAGJ;IACd,UAAMF,8LAAAA,EAAqB;QACzBI;QACAF;QACAK,OAAOJ;IACT;IAEA,OAAOK,SAASC,IAAI,CAClB;QACEC,SAASJ,EAAE;IACb,GACA;QACEK,aAASZ,oLAAAA,EAAgB;YACvBY,SAAS,IAAIC;YACbV;QACF;QACAN,QAAQC,sMAAAA,CAAWgB,EAAE;IACvB;AAEJ,EAAC"}},
    {"offset": {"line": 2821, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/auth/endpoints/index.ts"],"sourcesContent":["import type { Endpoint } from '../../config/types.js'\n\nimport { wrapInternalEndpoints } from '../../utilities/wrapInternalEndpoints.js'\nimport { accessHandler } from './access.js'\nimport { forgotPasswordHandler } from './forgotPassword.js'\nimport { initHandler } from './init.js'\nimport { loginHandler } from './login.js'\nimport { logoutHandler } from './logout.js'\nimport { meHandler } from './me.js'\nimport { refreshHandler } from './refresh.js'\nimport { registerFirstUserHandler } from './registerFirstUser.js'\nimport { resetPasswordHandler } from './resetPassword.js'\nimport { unlockHandler } from './unlock.js'\nimport { verifyEmailHandler } from './verifyEmail.js'\n\nexport const authRootEndpoints: Endpoint[] = wrapInternalEndpoints([\n  {\n    handler: accessHandler,\n    method: 'get',\n    path: '/access',\n  },\n])\n\nexport const authCollectionEndpoints: Endpoint[] = wrapInternalEndpoints([\n  {\n    handler: forgotPasswordHandler,\n    method: 'post',\n    path: '/forgot-password',\n  },\n  {\n    handler: initHandler,\n    method: 'get',\n    path: '/init',\n  },\n  {\n    handler: loginHandler,\n    method: 'post',\n    path: '/login',\n  },\n  {\n    handler: logoutHandler,\n    method: 'post',\n    path: '/logout',\n  },\n  {\n    handler: meHandler,\n    method: 'get',\n    path: '/me',\n  },\n  {\n    handler: refreshHandler,\n    method: 'post',\n    path: '/refresh-token',\n  },\n  {\n    handler: registerFirstUserHandler,\n    method: 'post',\n    path: '/first-register',\n  },\n  {\n    handler: resetPasswordHandler,\n    method: 'post',\n    path: '/reset-password',\n  },\n  {\n    handler: unlockHandler,\n    method: 'post',\n    path: '/unlock',\n  },\n  {\n    handler: verifyEmailHandler,\n    method: 'post',\n    path: '/verify/:id',\n  },\n])\n"],"names":["wrapInternalEndpoints","accessHandler","forgotPasswordHandler","initHandler","loginHandler","logoutHandler","meHandler","refreshHandler","registerFirstUserHandler","resetPasswordHandler","unlockHandler","verifyEmailHandler","authRootEndpoints","handler","method","path","authCollectionEndpoints"],"mappings":";;;;;;AAEA,SAASA,qBAAqB,QAAQ,2CAA0C;AAChF,SAASC,aAAa,QAAQ,cAAa;AAC3C,SAASC,qBAAqB,QAAQ,sBAAqB;AAC3D,SAASC,WAAW,QAAQ,YAAW;AACvC,SAASC,YAAY,QAAQ,aAAY;AACzC,SAASC,aAAa,QAAQ,cAAa;AAC3C,SAASC,SAAS,QAAQ,UAAS;AACnC,SAASC,cAAc,QAAQ,eAAc;AAC7C,SAASC,wBAAwB,QAAQ,yBAAwB;AACjE,SAASC,oBAAoB,QAAQ,qBAAoB;AACzD,SAASC,aAAa,QAAQ,cAAa;AAC3C,SAASC,kBAAkB,QAAQ,mBAAkB;;;;;;;;;;;;;AAE9C,MAAMC,wBAAgCZ,gMAAAA,EAAsB;IACjE;QACEa,SAASZ,iLAAAA;QACTa,QAAQ;QACRC,MAAM;IACR;CACD,EAAC;AAEK,MAAMC,8BAAsChB,gMAAAA,EAAsB;IACvE;QACEa,SAASX,iMAAAA;QACTY,QAAQ;QACRC,MAAM;IACR;IACA;QACEF,SAASV,6KAAAA;QACTW,QAAQ;QACRC,MAAM;IACR;IACA;QACEF,SAAST,+KAAAA;QACTU,QAAQ;QACRC,MAAM;IACR;IACA;QACEF,SAASR,iLAAAA;QACTS,QAAQ;QACRC,MAAM;IACR;IACA;QACEF,SAASP,yKAAAA;QACTQ,QAAQ;QACRC,MAAM;IACR;IACA;QACEF,SAASN,mLAAAA;QACTO,QAAQ;QACRC,MAAM;IACR;IACA;QACEF,SAASL,uMAAAA;QACTM,QAAQ;QACRC,MAAM;IACR;IACA;QACEF,SAASJ,+LAAAA;QACTK,QAAQ;QACRC,MAAM;IACR;IACA;QACEF,SAASH,iLAAAA;QACTI,QAAQ;QACRC,MAAM;IACR;IACA;QACEF,SAASF,2LAAAA;QACTG,QAAQ;QACRC,MAAM;IACR;CACD,EAAC"}},
    {"offset": {"line": 2914, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/auth/baseFields/accountLock.ts"],"sourcesContent":["import type { Field } from '../../fields/config/types.js'\n\nexport const accountLockFields: Field[] = [\n  {\n    name: 'loginAttempts',\n    type: 'number',\n    defaultValue: 0,\n    hidden: true,\n  },\n  {\n    name: 'lockUntil',\n    type: 'date',\n    hidden: true,\n  },\n] as Field[]\n"],"names":["accountLockFields","name","type","defaultValue","hidden"],"mappings":";;;;AAEO,MAAMA,oBAA6B;IACxC;QACEC,MAAM;QACNC,MAAM;QACNC,cAAc;QACdC,QAAQ;IACV;IACA;QACEH,MAAM;QACNC,MAAM;QACNE,QAAQ;IACV;CACD,CAAW"}},
    {"offset": {"line": 2935, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/auth/baseFields/apiKey.ts"],"sourcesContent":["import crypto from 'crypto'\n\nimport type { Field, FieldHook } from '../../fields/config/types.js'\n\nconst encryptKey: FieldHook = ({ req, value }) =>\n  value ? req.payload.encrypt(value as string) : null\nconst decryptKey: FieldHook = ({ req, value }) =>\n  value ? req.payload.decrypt(value as string) : undefined\n\nexport const apiKeyFields = [\n  {\n    name: 'enableAPIKey',\n    type: 'checkbox',\n    admin: {\n      components: {\n        Field: false,\n      },\n    },\n    label: ({ t }) => t('authentication:enableAPIKey'),\n  },\n  {\n    name: 'apiKey',\n    type: 'text',\n    admin: {\n      components: {\n        Field: false,\n      },\n    },\n    hooks: {\n      afterRead: [decryptKey],\n      beforeChange: [encryptKey],\n    },\n    label: ({ t }) => t('authentication:apiKey'),\n  },\n  {\n    name: 'apiKeyIndex',\n    type: 'text',\n    admin: {\n      disabled: true,\n    },\n    hidden: true,\n    hooks: {\n      beforeValidate: [\n        ({ data, req, value }) => {\n          if (data?.apiKey === false || data?.apiKey === null) {\n            return null\n          }\n          if (data?.enableAPIKey === false || data?.enableAPIKey === null) {\n            return null\n          }\n          if (data?.apiKey) {\n            return crypto\n              .createHmac('sha256', req.payload.secret)\n              .update(data.apiKey as string)\n              .digest('hex')\n          }\n          return value\n        },\n      ],\n    },\n  },\n] as Field[]\n"],"names":["crypto","encryptKey","req","value","payload","encrypt","decryptKey","decrypt","undefined","apiKeyFields","name","type","admin","components","Field","label","t","hooks","afterRead","beforeChange","disabled","hidden","beforeValidate","data","apiKey","enableAPIKey","createHmac","secret","update","digest"],"mappings":";;;;AAAA,OAAOA,YAAY,SAAQ;;AAI3B,MAAMC,aAAwB,CAAC,EAAEC,GAAG,EAAEC,KAAK,EAAE,GAC3CA,QAAQD,IAAIE,OAAO,CAACC,OAAO,CAACF,SAAmB;AACjD,MAAMG,aAAwB,CAAC,EAAEJ,GAAG,EAAEC,KAAK,EAAE,GAC3CA,QAAQD,IAAIE,OAAO,CAACG,OAAO,CAACJ,SAAmBK;AAE1C,MAAMC,eAAe;IAC1B;QACEC,MAAM;QACNC,MAAM;QACNC,OAAO;YACLC,YAAY;gBACVC,OAAO;YACT;QACF;QACAC,OAAO,CAAC,EAAEC,CAAC,EAAE,GAAKA,EAAE;IACtB;IACA;QACEN,MAAM;QACNC,MAAM;QACNC,OAAO;YACLC,YAAY;gBACVC,OAAO;YACT;QACF;QACAG,OAAO;YACLC,WAAW;gBAACZ;aAAW;YACvBa,cAAc;gBAAClB;aAAW;QAC5B;QACAc,OAAO,CAAC,EAAEC,CAAC,EAAE,GAAKA,EAAE;IACtB;IACA;QACEN,MAAM;QACNC,MAAM;QACNC,OAAO;YACLQ,UAAU;QACZ;QACAC,QAAQ;QACRJ,OAAO;YACLK,gBAAgB;gBACd,CAAC,EAAEC,IAAI,EAAErB,GAAG,EAAEC,KAAK,EAAE;oBACnB,IAAIoB,MAAMC,WAAW,SAASD,MAAMC,WAAW,MAAM;wBACnD,OAAO;oBACT;oBACA,IAAID,MAAME,iBAAiB,SAASF,MAAME,iBAAiB,MAAM;wBAC/D,OAAO;oBACT;oBACA,IAAIF,MAAMC,QAAQ;wBAChB,OAAOxB,gHAAAA,CACJ0B,UAAU,CAAC,UAAUxB,IAAIE,OAAO,CAACuB,MAAM,EACvCC,MAAM,CAACL,KAAKC,MAAM,EAClBK,MAAM,CAAC;oBACZ;oBACA,OAAO1B;gBACT;aACD;QACH;IACF;CACD,CAAW"}},
    {"offset": {"line": 3001, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/auth/baseFields/auth.ts"],"sourcesContent":["import type { Field } from '../../fields/config/types.js'\n\nexport const baseAuthFields: Field[] = [\n  {\n    name: 'resetPasswordToken',\n    type: 'text',\n    hidden: true,\n  },\n  {\n    name: 'resetPasswordExpiration',\n    type: 'date',\n    hidden: true,\n  },\n  {\n    name: 'salt',\n    type: 'text',\n    hidden: true,\n  },\n  {\n    name: 'hash',\n    type: 'text',\n    hidden: true,\n  },\n]\n"],"names":["baseAuthFields","name","type","hidden"],"mappings":";;;;AAEO,MAAMA,iBAA0B;IACrC;QACEC,MAAM;QACNC,MAAM;QACNC,QAAQ;IACV;IACA;QACEF,MAAM;QACNC,MAAM;QACNC,QAAQ;IACV;IACA;QACEF,MAAM;QACNC,MAAM;QACNC,QAAQ;IACV;IACA;QACEF,MAAM;QACNC,MAAM;QACNC,QAAQ;IACV;CACD,CAAA"}},
    {"offset": {"line": 3031, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/auth/baseFields/email.ts"],"sourcesContent":["import type { EmailField } from '../../fields/config/types.js'\n\nimport { email } from '../../fields/validations.js'\n\nexport const emailFieldConfig: EmailField = {\n  name: 'email',\n  type: 'email',\n  admin: {\n    components: {\n      Field: false,\n    },\n  },\n  hooks: {\n    beforeChange: [\n      ({ value }) => {\n        if (value) {\n          return value.toLowerCase().trim()\n        }\n      },\n    ],\n  },\n  label: ({ t }) => t('general:email'),\n  required: true,\n  unique: true,\n  validate: email,\n}\n"],"names":["email","emailFieldConfig","name","type","admin","components","Field","hooks","beforeChange","value","toLowerCase","trim","label","t","required","unique","validate"],"mappings":";;;;AAEA,SAASA,KAAK,QAAQ,8BAA6B;;AAE5C,MAAMC,mBAA+B;IAC1CC,MAAM;IACNC,MAAM;IACNC,OAAO;QACLC,YAAY;YACVC,OAAO;QACT;IACF;IACAC,OAAO;QACLC,cAAc;YACZ,CAAC,EAAEC,KAAK,EAAE;gBACR,IAAIA,OAAO;oBACT,OAAOA,MAAMC,WAAW,GAAGC,IAAI;gBACjC;YACF;SACD;IACH;IACAC,OAAO,CAAC,EAAEC,CAAC,EAAE,GAAKA,EAAE;IACpBC,UAAU;IACVC,QAAQ;IACRC,UAAUhB,mKAAAA;AACZ,EAAC"}},
    {"offset": {"line": 3063, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/auth/baseFields/sessions.ts"],"sourcesContent":["import type { ArrayField } from '../../fields/config/types.js'\n\nexport const sessionsFieldConfig: ArrayField = {\n  name: 'sessions',\n  type: 'array',\n  access: {\n    read: ({ doc, req: { user } }) => {\n      return user?.id === doc?.id\n    },\n    update: () => false,\n  },\n  admin: {\n    disabled: true,\n  },\n  fields: [\n    {\n      name: 'id',\n      type: 'text',\n      required: true,\n    },\n    {\n      name: 'createdAt',\n      type: 'date',\n      defaultValue: () => new Date(),\n    },\n    {\n      name: 'expiresAt',\n      type: 'date',\n      required: true,\n    },\n  ],\n}\n"],"names":["sessionsFieldConfig","name","type","access","read","doc","req","user","id","update","admin","disabled","fields","required","defaultValue","Date"],"mappings":";;;;AAEO,MAAMA,sBAAkC;IAC7CC,MAAM;IACNC,MAAM;IACNC,QAAQ;QACNC,MAAM,CAAC,EAAEC,GAAG,EAAEC,KAAK,EAAEC,IAAI,EAAE,EAAE;YAC3B,OAAOA,MAAMC,OAAOH,KAAKG;QAC3B;QACAC,QAAQ,IAAM;IAChB;IACAC,OAAO;QACLC,UAAU;IACZ;IACAC,QAAQ;QACN;YACEX,MAAM;YACNC,MAAM;YACNW,UAAU;QACZ;QACA;YACEZ,MAAM;YACNC,MAAM;YACNY,cAAc,IAAM,IAAIC;QAC1B;QACA;YACEd,MAAM;YACNC,MAAM;YACNW,UAAU;QACZ;KACD;AACH,EAAC"}},
    {"offset": {"line": 3101, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/auth/baseFields/username.ts"],"sourcesContent":["import type { TextField } from '../../fields/config/types.js'\n\nimport { username } from '../../fields/validations.js'\n\nexport const usernameFieldConfig: TextField = {\n  name: 'username',\n  type: 'text',\n  admin: {\n    components: {\n      Field: false,\n    },\n  },\n  hooks: {\n    beforeChange: [\n      ({ value }) => {\n        if (value) {\n          return value.toLowerCase().trim()\n        }\n      },\n    ],\n  },\n  label: ({ t }) => t('authentication:username'),\n  required: true,\n  unique: true,\n  validate: username,\n}\n"],"names":["username","usernameFieldConfig","name","type","admin","components","Field","hooks","beforeChange","value","toLowerCase","trim","label","t","required","unique","validate"],"mappings":";;;;AAEA,SAASA,QAAQ,QAAQ,8BAA6B;;AAE/C,MAAMC,sBAAiC;IAC5CC,MAAM;IACNC,MAAM;IACNC,OAAO;QACLC,YAAY;YACVC,OAAO;QACT;IACF;IACAC,OAAO;QACLC,cAAc;YACZ,CAAC,EAAEC,KAAK,EAAE;gBACR,IAAIA,OAAO;oBACT,OAAOA,MAAMC,WAAW,GAAGC,IAAI;gBACjC;YACF;SACD;IACH;IACAC,OAAO,CAAC,EAAEC,CAAC,EAAE,GAAKA,EAAE;IACpBC,UAAU;IACVC,QAAQ;IACRC,UAAUhB,sKAAAA;AACZ,EAAC"}},
    {"offset": {"line": 3133, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/auth/baseFields/verification.ts"],"sourcesContent":["import type { Field, FieldHook } from '../../fields/config/types.js'\n\nconst autoRemoveVerificationToken: FieldHook = ({ data, operation, originalDoc, value }) => {\n  // If a user manually sets `_verified` to true,\n  // and it was `false`, set _verificationToken to `null`.\n  // This is useful because the admin panel\n  // allows users to set `_verified` to true manually\n\n  if (operation === 'update') {\n    if (data?._verified === true && originalDoc?._verified === false) {\n      return null\n    }\n  }\n\n  return value\n}\n\nexport const verificationFields: Field[] = [\n  {\n    name: '_verified',\n    type: 'checkbox',\n    access: {\n      create: ({ req: { user } }) => Boolean(user),\n      read: ({ req: { user } }) => Boolean(user),\n      update: ({ req: { user } }) => Boolean(user),\n    },\n    admin: {\n      components: {\n        Field: false,\n      },\n    },\n    label: ({ t }) => t('authentication:verified'),\n  },\n  {\n    name: '_verificationToken',\n    type: 'text',\n    hidden: true,\n    hooks: {\n      beforeChange: [autoRemoveVerificationToken],\n    },\n  },\n] as Field[]\n"],"names":["autoRemoveVerificationToken","data","operation","originalDoc","value","_verified","verificationFields","name","type","access","create","req","user","Boolean","read","update","admin","components","Field","label","t","hidden","hooks","beforeChange"],"mappings":";;;;AAEA,MAAMA,8BAAyC,CAAC,EAAEC,IAAI,EAAEC,SAAS,EAAEC,WAAW,EAAEC,KAAK,EAAE;IACrF,+CAA+C;IAC/C,wDAAwD;IACxD,yCAAyC;IACzC,mDAAmD;IAEnD,IAAIF,cAAc,UAAU;QAC1B,IAAID,MAAMI,cAAc,QAAQF,aAAaE,cAAc,OAAO;YAChE,OAAO;QACT;IACF;IAEA,OAAOD;AACT;AAEO,MAAME,qBAA8B;IACzC;QACEC,MAAM;QACNC,MAAM;QACNC,QAAQ;YACNC,QAAQ,CAAC,EAAEC,KAAK,EAAEC,IAAI,EAAE,EAAE,GAAKC,QAAQD;YACvCE,MAAM,CAAC,EAAEH,KAAK,EAAEC,IAAI,EAAE,EAAE,GAAKC,QAAQD;YACrCG,QAAQ,CAAC,EAAEJ,KAAK,EAAEC,IAAI,EAAE,EAAE,GAAKC,QAAQD;QACzC;QACAI,OAAO;YACLC,YAAY;gBACVC,OAAO;YACT;QACF;QACAC,OAAO,CAAC,EAAEC,CAAC,EAAE,GAAKA,EAAE;IACtB;IACA;QACEb,MAAM;QACNC,MAAM;QACNa,QAAQ;QACRC,OAAO;YACLC,cAAc;gBAACvB;aAA4B;QAC7C;IACF;CACD,CAAW"}},
    {"offset": {"line": 3180, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/auth/getAuthFields.ts"],"sourcesContent":["import type { Field, TextField } from '../fields/config/types.js'\nimport type { IncomingAuthType } from './types.js'\n\nimport { accountLockFields } from './baseFields/accountLock.js'\nimport { apiKeyFields } from './baseFields/apiKey.js'\nimport { baseAuthFields } from './baseFields/auth.js'\nimport { emailFieldConfig } from './baseFields/email.js'\nimport { sessionsFieldConfig } from './baseFields/sessions.js'\nimport { usernameFieldConfig } from './baseFields/username.js'\nimport { verificationFields } from './baseFields/verification.js'\n\nexport const getBaseAuthFields = (authConfig: IncomingAuthType): Field[] => {\n  const authFields: Field[] = []\n\n  if (authConfig.useAPIKey) {\n    authFields.push(...apiKeyFields)\n  }\n\n  if (\n    !authConfig.disableLocalStrategy ||\n    (typeof authConfig.disableLocalStrategy === 'object' &&\n      authConfig.disableLocalStrategy.enableFields)\n  ) {\n    const emailField = { ...emailFieldConfig }\n    let usernameField: TextField | undefined\n\n    if (authConfig.loginWithUsername) {\n      usernameField = { ...usernameFieldConfig }\n      if (typeof authConfig.loginWithUsername === 'object') {\n        if (authConfig.loginWithUsername.requireEmail === false) {\n          emailField.required = false\n        }\n        if (authConfig.loginWithUsername.requireUsername === false) {\n          usernameField.required = false\n        }\n        if (authConfig.loginWithUsername.allowEmailLogin === false) {\n          emailField.unique = false\n        }\n      }\n    }\n\n    authFields.push(emailField)\n    if (usernameField) {\n      authFields.push(usernameField)\n    }\n\n    authFields.push(...baseAuthFields)\n\n    if (authConfig.verify) {\n      authFields.push(...verificationFields)\n    }\n\n    if (authConfig?.maxLoginAttempts && authConfig.maxLoginAttempts > 0) {\n      authFields.push(...accountLockFields)\n    }\n\n    if (authConfig.useSessions) {\n      authFields.push(sessionsFieldConfig)\n    }\n  }\n\n  return authFields\n}\n"],"names":["accountLockFields","apiKeyFields","baseAuthFields","emailFieldConfig","sessionsFieldConfig","usernameFieldConfig","verificationFields","getBaseAuthFields","authConfig","authFields","useAPIKey","push","disableLocalStrategy","enableFields","emailField","usernameField","loginWithUsername","requireEmail","required","requireUsername","allowEmailLogin","unique","verify","maxLoginAttempts","useSessions"],"mappings":";;;;AAGA,SAASA,iBAAiB,QAAQ,8BAA6B;AAC/D,SAASC,YAAY,QAAQ,yBAAwB;AACrD,SAASC,cAAc,QAAQ,uBAAsB;AACrD,SAASC,gBAAgB,QAAQ,wBAAuB;AACxD,SAASC,mBAAmB,QAAQ,2BAA0B;AAC9D,SAASC,mBAAmB,QAAQ,2BAA0B;AAC9D,SAASC,kBAAkB,QAAQ,+BAA8B;;;;;;;;AAE1D,MAAMC,oBAAoB,CAACC;IAChC,MAAMC,aAAsB,EAAE;IAE9B,IAAID,WAAWE,SAAS,EAAE;QACxBD,WAAWE,IAAI,IAAIV,iLAAAA;IACrB;IAEA,IACE,CAACO,WAAWI,oBAAoB,IAC/B,OAAOJ,WAAWI,oBAAoB,KAAK,YAC1CJ,WAAWI,oBAAoB,CAACC,YAAY,EAC9C;QACA,MAAMC,aAAa;YAAE,GAAGX,oLAAgB;QAAC;QACzC,IAAIY;QAEJ,IAAIP,WAAWQ,iBAAiB,EAAE;YAChCD,gBAAgB;gBAAE,GAAGV,0LAAmB;YAAC;YACzC,IAAI,OAAOG,WAAWQ,iBAAiB,KAAK,UAAU;gBACpD,IAAIR,WAAWQ,iBAAiB,CAACC,YAAY,KAAK,OAAO;oBACvDH,WAAWI,QAAQ,GAAG;gBACxB;gBACA,IAAIV,WAAWQ,iBAAiB,CAACG,eAAe,KAAK,OAAO;oBAC1DJ,cAAcG,QAAQ,GAAG;gBAC3B;gBACA,IAAIV,WAAWQ,iBAAiB,CAACI,eAAe,KAAK,OAAO;oBAC1DN,WAAWO,MAAM,GAAG;gBACtB;YACF;QACF;QAEAZ,WAAWE,IAAI,CAACG;QAChB,IAAIC,eAAe;YACjBN,WAAWE,IAAI,CAACI;QAClB;QAEAN,WAAWE,IAAI,IAAIT,iLAAAA;QAEnB,IAAIM,WAAWc,MAAM,EAAE;YACrBb,WAAWE,IAAI,IAAIL,6LAAAA;QACrB;QAEA,IAAIE,YAAYe,oBAAoBf,WAAWe,gBAAgB,GAAG,GAAG;YACnEd,WAAWE,IAAI,IAAIX,2LAAAA;QACrB;QAEA,IAAIQ,WAAWgB,WAAW,EAAE;YAC1Bf,WAAWE,IAAI,CAACP,0LAAAA;QAClB;IACF;IAEA,OAAOK;AACT,EAAC"}},
    {"offset": {"line": 3245, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/auth/sendVerificationEmail.ts"],"sourcesContent":["import { URL } from 'url'\n\nimport type { Collection } from '../collections/config/types.js'\nimport type { SanitizedConfig } from '../config/types.js'\nimport type { InitializedEmailAdapter } from '../email/types.js'\nimport type { TypedUser } from '../index.js'\nimport type { PayloadRequest } from '../types/index.js'\nimport type { VerifyConfig } from './types.js'\n\nimport { formatAdminURL } from '../utilities/formatAdminURL.js'\n\ntype Args = {\n  collection: Collection\n  config: SanitizedConfig\n  disableEmail: boolean\n  email: InitializedEmailAdapter\n  req: PayloadRequest\n  token: string\n  user: TypedUser\n}\n\nexport async function sendVerificationEmail(args: Args): Promise<void> {\n  // Verify token from e-mail\n  const {\n    collection: { config: collectionConfig },\n    config,\n    disableEmail,\n    email,\n    req,\n    token,\n    user,\n  } = args\n\n  if (!disableEmail) {\n    const protocol = new URL(req.url!).protocol // includes the final :\n    const serverURL =\n      config.serverURL !== null && config.serverURL !== ''\n        ? config.serverURL\n        : `${protocol}//${req.headers.get('host')}`\n\n    const verificationURL = formatAdminURL({\n      adminRoute: config.routes.admin,\n      path: `/${collectionConfig.slug}/verify/${token}`,\n      serverURL,\n    })\n\n    let html = `${req.t('authentication:newAccountCreated', {\n      serverURL: config.serverURL,\n      verificationURL,\n    })}`\n\n    const verify = collectionConfig.auth.verify as VerifyConfig\n\n    // Allow config to override email content\n    if (typeof verify.generateEmailHTML === 'function') {\n      html = await verify.generateEmailHTML({\n        req,\n        token,\n        user,\n      })\n    }\n\n    let subject = req.t('authentication:verifyYourEmail')\n\n    // Allow config to override email subject\n    if (typeof verify.generateEmailSubject === 'function') {\n      subject = await verify.generateEmailSubject({\n        req,\n        token,\n        user,\n      })\n    }\n\n    await email.sendEmail({\n      from: `\"${email.defaultFromName}\" <${email.defaultFromAddress}>`,\n      html,\n      subject,\n      to: user.email,\n    })\n  }\n}\n"],"names":["URL","formatAdminURL","sendVerificationEmail","args","collection","config","collectionConfig","disableEmail","email","req","token","user","protocol","url","serverURL","headers","get","verificationURL","adminRoute","routes","admin","path","slug","html","t","verify","auth","generateEmailHTML","subject","generateEmailSubject","sendEmail","from","defaultFromName","defaultFromAddress","to"],"mappings":";;;;AAAA,SAASA,GAAG,QAAQ,MAAK;AASzB,SAASC,cAAc,QAAQ,iCAAgC;;;AAYxD,eAAeC,sBAAsBC,IAAU;IACpD,2BAA2B;IAC3B,MAAM,EACJC,YAAY,EAAEC,QAAQC,gBAAgB,EAAE,EACxCD,MAAM,EACNE,YAAY,EACZC,KAAK,EACLC,GAAG,EACHC,KAAK,EACLC,IAAI,EACL,GAAGR;IAEJ,IAAI,CAACI,cAAc;QACjB,MAAMK,WAAW,IAAIZ,sGAAAA,CAAIS,IAAII,GAAG,EAAGD,QAAQ,CAAC,uBAAuB;;QACnE,MAAME,YACJT,OAAOS,SAAS,KAAK,QAAQT,OAAOS,SAAS,KAAK,KAC9CT,OAAOS,SAAS,GAChB,GAAGF,SAAS,EAAE,EAAEH,IAAIM,OAAO,CAACC,GAAG,CAAC,SAAS;QAE/C,MAAMC,sBAAkBhB,kLAAAA,EAAe;YACrCiB,YAAYb,OAAOc,MAAM,CAACC,KAAK;YAC/BC,MAAM,CAAC,CAAC,EAAEf,iBAAiBgB,IAAI,CAAC,QAAQ,EAAEZ,OAAO;YACjDI;QACF;QAEA,IAAIS,OAAO,GAAGd,IAAIe,CAAC,CAAC,oCAAoC;YACtDV,WAAWT,OAAOS,SAAS;YAC3BG;QACF,IAAI;QAEJ,MAAMQ,SAASnB,iBAAiBoB,IAAI,CAACD,MAAM;QAE3C,yCAAyC;QACzC,IAAI,OAAOA,OAAOE,iBAAiB,KAAK,YAAY;YAClDJ,OAAO,MAAME,OAAOE,iBAAiB,CAAC;gBACpClB;gBACAC;gBACAC;YACF;QACF;QAEA,IAAIiB,UAAUnB,IAAIe,CAAC,CAAC;QAEpB,yCAAyC;QACzC,IAAI,OAAOC,OAAOI,oBAAoB,KAAK,YAAY;YACrDD,UAAU,MAAMH,OAAOI,oBAAoB,CAAC;gBAC1CpB;gBACAC;gBACAC;YACF;QACF;QAEA,MAAMH,MAAMsB,SAAS,CAAC;YACpBC,MAAM,CAAC,CAAC,EAAEvB,MAAMwB,eAAe,CAAC,GAAG,EAAExB,MAAMyB,kBAAkB,CAAC,CAAC,CAAC;YAChEV;YACAK;YACAM,IAAIvB,KAAKH,KAAK;QAChB;IACF;AACF"}},
    {"offset": {"line": 3299, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/auth/strategies/local/register.ts"],"sourcesContent":["import type { SanitizedCollectionConfig } from '../../../collections/config/types.js'\nimport type { JsonObject, Payload } from '../../../index.js'\nimport type { PayloadRequest, SelectType, Where } from '../../../types/index.js'\n\nimport { ValidationError } from '../../../errors/index.js'\nimport { getLoginOptions } from '../../getLoginOptions.js'\nimport { generatePasswordSaltHash } from './generatePasswordSaltHash.js'\n\ntype Args = {\n  collection: SanitizedCollectionConfig\n  doc: JsonObject\n  password: string\n  payload: Payload\n  req: PayloadRequest\n}\n\nexport const registerLocalStrategy = async ({\n  collection,\n  doc,\n  password,\n  payload,\n  req,\n}: Args): Promise<Record<string, unknown>> => {\n  const loginWithUsername = collection?.auth?.loginWithUsername\n\n  const { canLoginWithEmail, canLoginWithUsername } = getLoginOptions(loginWithUsername)\n\n  let whereConstraint: Where\n\n  if (!canLoginWithUsername) {\n    whereConstraint = {\n      email: {\n        equals: doc.email,\n      },\n    }\n  } else {\n    whereConstraint = {\n      or: [],\n    }\n\n    if (canLoginWithEmail && doc.email) {\n      whereConstraint.or?.push({\n        email: {\n          equals: doc.email,\n        },\n      })\n    }\n\n    if (doc.username) {\n      whereConstraint.or?.push({\n        username: {\n          equals: doc.username,\n        },\n      })\n    }\n  }\n\n  const existingUser = await payload.find({\n    collection: collection.slug,\n    depth: 0,\n    limit: 1,\n    pagination: false,\n    req,\n    where: whereConstraint,\n  })\n\n  if (existingUser.docs.length > 0) {\n    throw new ValidationError({\n      collection: collection.slug,\n      errors: [\n        canLoginWithUsername\n          ? {\n              message: req.t('error:usernameAlreadyRegistered'),\n              path: 'username',\n            }\n          : { message: req.t('error:userEmailAlreadyRegistered'), path: 'email' },\n      ],\n    })\n  }\n\n  const { hash, salt } = await generatePasswordSaltHash({ collection, password, req })\n\n  const sanitizedDoc = { ...doc }\n  if (sanitizedDoc.password) {\n    delete sanitizedDoc.password\n  }\n\n  return payload.db.create({\n    collection: collection.slug,\n    data: {\n      ...sanitizedDoc,\n      hash,\n      salt,\n    },\n    req,\n  })\n}\n"],"names":["ValidationError","getLoginOptions","generatePasswordSaltHash","registerLocalStrategy","collection","doc","password","payload","req","loginWithUsername","auth","canLoginWithEmail","canLoginWithUsername","whereConstraint","email","equals","or","push","username","existingUser","find","slug","depth","limit","pagination","where","docs","length","errors","message","t","path","hash","salt","sanitizedDoc","db","create","data"],"mappings":";;;;AAIA,SAASA,eAAe,QAAQ,2BAA0B;AAC1D,SAASC,eAAe,QAAQ,2BAA0B;AAC1D,SAASC,wBAAwB,QAAQ,gCAA+B;;;;AAUjE,MAAMC,wBAAwB,OAAO,EAC1CC,UAAU,EACVC,GAAG,EACHC,QAAQ,EACRC,OAAO,EACPC,GAAG,EACE;IACL,MAAMC,oBAAoBL,YAAYM,MAAMD;IAE5C,MAAM,EAAEE,iBAAiB,EAAEC,oBAAoB,EAAE,OAAGX,+KAAAA,EAAgBQ;IAEpE,IAAII;IAEJ,IAAI,CAACD,sBAAsB;QACzBC,kBAAkB;YAChBC,OAAO;gBACLC,QAAQV,IAAIS,KAAK;YACnB;QACF;IACF,OAAO;QACLD,kBAAkB;YAChBG,IAAI,EAAE;QACR;QAEA,IAAIL,qBAAqBN,IAAIS,KAAK,EAAE;YAClCD,gBAAgBG,EAAE,EAAEC,KAAK;gBACvBH,OAAO;oBACLC,QAAQV,IAAIS,KAAK;gBACnB;YACF;QACF;QAEA,IAAIT,IAAIa,QAAQ,EAAE;YAChBL,gBAAgBG,EAAE,EAAEC,KAAK;gBACvBC,UAAU;oBACRH,QAAQV,IAAIa,QAAQ;gBACtB;YACF;QACF;IACF;IAEA,MAAMC,eAAe,MAAMZ,QAAQa,IAAI,CAAC;QACtChB,YAAYA,WAAWiB,IAAI;QAC3BC,OAAO;QACPC,OAAO;QACPC,YAAY;QACZhB;QACAiB,OAAOZ;IACT;IAEA,IAAIM,aAAaO,IAAI,CAACC,MAAM,GAAG,GAAG;QAChC,MAAM,IAAI3B,iLAAAA,CAAgB;YACxBI,YAAYA,WAAWiB,IAAI;YAC3BO,QAAQ;gBACNhB,uBACI;oBACEiB,SAASrB,IAAIsB,CAAC,CAAC;oBACfC,MAAM;gBACR,IACA;oBAAEF,SAASrB,IAAIsB,CAAC,CAAC;oBAAqCC,MAAM;gBAAQ;aACzE;QACH;IACF;IAEA,MAAM,EAAEC,IAAI,EAAEC,IAAI,EAAE,GAAG,UAAM/B,wNAAAA,EAAyB;QAAEE;QAAYE;QAAUE;IAAI;IAElF,MAAM0B,eAAe;QAAE,GAAG7B,GAAG;IAAC;IAC9B,IAAI6B,aAAa5B,QAAQ,EAAE;QACzB,OAAO4B,aAAa5B,QAAQ;IAC9B;IAEA,OAAOC,QAAQ4B,EAAE,CAACC,MAAM,CAAC;QACvBhC,YAAYA,WAAWiB,IAAI;QAC3BgB,MAAM;YACJ,GAAGH,YAAY;YACfF;YACAC;QACF;QACAzB;IACF;AACF,EAAC"}},
    {"offset": {"line": 3385, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/auth/defaultAccess.ts"],"sourcesContent":["import type { PayloadRequest } from '../types/index.js'\n\nexport const defaultAccess = ({ req: { user } }: { req: PayloadRequest }): boolean => Boolean(user)\n"],"names":["defaultAccess","req","user","Boolean"],"mappings":";;;;AAEO,MAAMA,gBAAgB,CAAC,EAAEC,KAAK,EAAEC,IAAI,EAAE,EAA2B,GAAcC,QAAQD,MAAK"}}]
}