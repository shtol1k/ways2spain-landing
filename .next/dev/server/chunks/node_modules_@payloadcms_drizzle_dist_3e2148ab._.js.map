{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/transactions/beginTransaction.ts"],"sourcesContent":["import type { BeginTransaction } from 'payload'\n\nimport { v4 as uuid } from 'uuid'\n\nimport type { DrizzleAdapter, DrizzleTransaction } from '../types.js'\n\nexport const beginTransaction: BeginTransaction = async function beginTransaction(\n  this: DrizzleAdapter,\n  options: DrizzleAdapter['transactionOptions'],\n) {\n  let id\n  try {\n    id = uuid()\n\n    let reject: () => Promise<void>\n    let resolve: () => Promise<void>\n    let transaction: DrizzleTransaction\n\n    let transactionReady: () => void\n\n    // Await initialization here\n    // Prevent race conditions where the adapter may be\n    // re-initializing, and `this.drizzle` is potentially undefined\n    await this.initializing\n\n    // Drizzle only exposes a transactions API that is sufficient if you\n    // can directly pass around the `tx` argument. But our operations are spread\n    // over many files and we don't want to pass the `tx` around like that,\n    // so instead, we \"lift\" up the `resolve` and `reject` methods\n    // and will call them in our respective transaction methods\n    const done = this.drizzle\n      .transaction(async (tx) => {\n        transaction = tx\n        await new Promise<void>((res, rej) => {\n          resolve = () => {\n            res()\n            return done\n          }\n          reject = () => {\n            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n            rej()\n            return done\n          }\n          transactionReady()\n        })\n      }, options || this.transactionOptions)\n      .catch(() => {\n        // swallow\n      })\n\n    // Need to wait until the transaction is ready\n    // before binding its `resolve` and `reject` methods below\n    await new Promise<void>((resolve) => (transactionReady = resolve))\n\n    this.sessions[id] = {\n      db: transaction,\n      reject,\n      resolve,\n    }\n  } catch (err) {\n    this.payload.logger.error({ err, msg: `Error: cannot begin transaction: ${err.message}` })\n    throw new Error(`Error: cannot begin transaction: ${err.message}`)\n  }\n\n  return id\n}\n"],"names":["v4","uuid","beginTransaction","options","id","reject","resolve","transaction","transactionReady","initializing","done","drizzle","tx","Promise","res","rej","transactionOptions","catch","sessions","db","err","payload","logger","error","msg","message","Error"],"mappings":";;;;AAEA,SAASA,MAAMC,IAAI,QAAQ,OAAM;;AAI1B,MAAMC,mBAAqC,eAAeA,iBAE/DC,OAA6C;IAE7C,IAAIC;IACJ,IAAI;QACFA,SAAKH,qOAAAA;QAEL,IAAII;QACJ,IAAIC;QACJ,IAAIC;QAEJ,IAAIC;QAEJ,4BAA4B;QAC5B,mDAAmD;QACnD,+DAA+D;QAC/D,MAAM,IAAI,CAACC,YAAY;QAEvB,oEAAoE;QACpE,4EAA4E;QAC5E,uEAAuE;QACvE,8DAA8D;QAC9D,2DAA2D;QAC3D,MAAMC,OAAO,IAAI,CAACC,OAAO,CACtBJ,WAAW,CAAC,OAAOK;YAClBL,cAAcK;YACd,MAAM,IAAIC,QAAc,CAACC,KAAKC;gBAC5BT,UAAU;oBACRQ;oBACA,OAAOJ;gBACT;gBACAL,SAAS;oBACP,2EAA2E;oBAC3EU;oBACA,OAAOL;gBACT;gBACAF;YACF;QACF,GAAGL,WAAW,IAAI,CAACa,kBAAkB,EACpCC,KAAK,CAAC;QACL,UAAU;QACZ;QAEF,8CAA8C;QAC9C,0DAA0D;QAC1D,MAAM,IAAIJ,QAAc,CAACP,UAAaE,mBAAmBF;QAEzD,IAAI,CAACY,QAAQ,CAACd,GAAG,GAAG;YAClBe,IAAIZ;YACJF;YACAC;QACF;IACF,EAAE,OAAOc,KAAK;QACZ,IAAI,CAACC,OAAO,CAACC,MAAM,CAACC,KAAK,CAAC;YAAEH;YAAKI,KAAK,CAAC,iCAAiC,EAAEJ,IAAIK,OAAO,EAAE;QAAC;QACxF,MAAM,IAAIC,MAAM,CAAC,iCAAiC,EAAEN,IAAIK,OAAO,EAAE;IACnE;IAEA,OAAOrB;AACT,EAAC"}},
    {"offset": {"line": 65, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/utilities/getMigrationTemplate.ts"],"sourcesContent":["import type { MigrationTemplateArgs } from 'payload'\n\nexport const indent = (text: string) =>\n  text\n    .split('\\n')\n    .map((line) => `  ${line}`)\n    .join('\\n')\n\nexport const getMigrationTemplate = ({\n  downSQL,\n  imports,\n  packageName,\n  upSQL,\n}: MigrationTemplateArgs): string => `import { MigrateUpArgs, MigrateDownArgs, sql } from '${packageName}'\n${imports ? `${imports}\\n` : ''}\nexport async function up({ db, payload, req }: MigrateUpArgs): Promise<void> {\n${indent(upSQL)}\n}\n\nexport async function down({ db, payload, req }: MigrateDownArgs): Promise<void> {\n${indent(downSQL)}\n}\n`\n"],"names":["indent","text","split","map","line","join","getMigrationTemplate","downSQL","imports","packageName","upSQL"],"mappings":";;;;;;AAEO,MAAMA,SAAS,CAACC,OACrBA,KACGC,KAAK,CAAC,MACNC,GAAG,CAAC,CAACC,OAAS,CAAC,EAAE,EAAEA,MAAM,EACzBC,IAAI,CAAC,MAAK;AAER,MAAMC,uBAAuB,CAAC,EACnCC,OAAO,EACPC,OAAO,EACPC,WAAW,EACXC,KAAK,EACiB,GAAa,CAAC,qDAAqD,EAAED,YAAY;AACzG,EAAED,UAAU,GAAGA,QAAQ,EAAE,CAAC,GAAG,GAAG;;AAEhC,EAAER,OAAOU,OAAO;;;;AAIhB,EAAEV,OAAOO,SAAS;;AAElB,CAAC,CAAA"}},
    {"offset": {"line": 86, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/utilities/buildCreateMigration.ts"],"sourcesContent":["import type { DrizzleSnapshotJSON } from 'drizzle-kit/api'\nimport type { CreateMigration, Payload } from 'payload'\n\nimport fs from 'fs'\nimport path from 'path'\nimport { getPredefinedMigration, writeMigrationIndex } from 'payload'\nimport prompts from 'prompts'\n\nimport type { DrizzleAdapter } from '../types.js'\n\nimport { getMigrationTemplate } from './getMigrationTemplate.js'\n\nexport const buildCreateMigration = ({\n  executeMethod,\n  filename,\n  sanitizeStatements,\n}: {\n  executeMethod: string\n  filename: string\n  sanitizeStatements: (args: { sqlExecute: string; statements: string[] }) => string\n}): CreateMigration => {\n  const dirname = path.dirname(filename)\n  return async function createMigration(\n    this: DrizzleAdapter,\n    { file, forceAcceptWarning, migrationName, payload, skipEmpty },\n  ) {\n    const dir = payload.db.migrationDir\n    if (!fs.existsSync(dir)) {\n      fs.mkdirSync(dir)\n    }\n\n    const { generateDrizzleJson, generateMigration, upSnapshot } = this.requireDrizzleKit()\n\n    const drizzleJsonAfter = await generateDrizzleJson(this.schema)\n\n    const [yyymmdd, hhmmss] = new Date().toISOString().split('T')\n    const formattedDate = yyymmdd.replace(/\\D/g, '')\n    const formattedTime = hhmmss.split('.')[0].replace(/\\D/g, '')\n    let imports: string = ''\n    let downSQL: string\n    let upSQL: string\n\n    const predefinedMigration = await getPredefinedMigration({\n      dirname,\n      file,\n      migrationName,\n      payload,\n    })\n\n    imports = predefinedMigration.imports\n    downSQL = predefinedMigration.downSQL\n    upSQL = predefinedMigration.upSQL\n\n    const timestamp = `${formattedDate}_${formattedTime}`\n\n    const name = migrationName || file?.split('/').slice(2).join('/')\n    const fileName = `${timestamp}${name ? `_${name.replace(/\\W/g, '_')}` : ''}`\n\n    const filePath = `${dir}/${fileName}`\n\n    if (typeof predefinedMigration.dynamic === 'function') {\n      const dynamicResult = await predefinedMigration.dynamic({ filePath, payload })\n\n      if (dynamicResult.upSQL) {\n        upSQL = dynamicResult.upSQL\n      }\n\n      if (dynamicResult.downSQL) {\n        downSQL = dynamicResult.downSQL\n      }\n\n      if (dynamicResult.imports) {\n        imports = dynamicResult.imports\n      }\n    }\n\n    let drizzleJsonBefore = this.defaultDrizzleSnapshot as DrizzleSnapshotJSON\n\n    if (this.schemaName) {\n      drizzleJsonBefore.schemas = {\n        [this.schemaName]: this.schemaName,\n      }\n    }\n\n    if (!upSQL) {\n      // Get latest migration snapshot\n      const latestSnapshot = fs\n        .readdirSync(dir)\n        .filter((file) => file.endsWith('.json'))\n        .sort()\n        .reverse()?.[0]\n\n      if (latestSnapshot) {\n        drizzleJsonBefore = JSON.parse(fs.readFileSync(`${dir}/${latestSnapshot}`, 'utf8'))\n\n        if (upSnapshot && drizzleJsonBefore.version < drizzleJsonAfter.version) {\n          drizzleJsonBefore = upSnapshot(drizzleJsonBefore)\n        }\n      }\n\n      const sqlStatementsUp = await generateMigration(drizzleJsonBefore, drizzleJsonAfter)\n      const sqlStatementsDown = await generateMigration(drizzleJsonAfter, drizzleJsonBefore)\n      const sqlExecute = `await db.${executeMethod}(` + 'sql`'\n\n      if (sqlStatementsUp?.length) {\n        upSQL = sanitizeStatements({ sqlExecute, statements: sqlStatementsUp })\n      }\n      if (sqlStatementsDown?.length) {\n        downSQL = sanitizeStatements({ sqlExecute, statements: sqlStatementsDown })\n      }\n\n      if (!upSQL?.length && !downSQL?.length && !forceAcceptWarning) {\n        if (skipEmpty) {\n          process.exit(0)\n        }\n\n        const { confirm: shouldCreateBlankMigration } = await prompts(\n          {\n            name: 'confirm',\n            type: 'confirm',\n            initial: false,\n            message: 'No schema changes detected. Would you like to create a blank migration file?',\n          },\n          {\n            onCancel: () => {\n              process.exit(0)\n            },\n          },\n        )\n\n        if (!shouldCreateBlankMigration) {\n          process.exit(0)\n        }\n      }\n\n      // write schema\n      fs.writeFileSync(`${filePath}.json`, JSON.stringify(drizzleJsonAfter, null, 2))\n    }\n\n    const data = getMigrationTemplate({\n      downSQL: downSQL || `  // Migration code`,\n      imports,\n      packageName: payload.db.packageName,\n      upSQL: upSQL || `  // Migration code`,\n    })\n\n    const fullPath = `${filePath}.ts`\n\n    // write migration\n    fs.writeFileSync(fullPath, data)\n\n    writeMigrationIndex({ migrationsDir: payload.db.migrationDir })\n\n    payload.logger.info({ msg: `Migration created at ${fullPath}` })\n  }\n}\n"],"names":["fs","path","getPredefinedMigration","writeMigrationIndex","prompts","getMigrationTemplate","buildCreateMigration","executeMethod","filename","sanitizeStatements","dirname","createMigration","file","forceAcceptWarning","migrationName","payload","skipEmpty","dir","db","migrationDir","existsSync","mkdirSync","generateDrizzleJson","generateMigration","upSnapshot","requireDrizzleKit","drizzleJsonAfter","schema","yyymmdd","hhmmss","Date","toISOString","split","formattedDate","replace","formattedTime","imports","downSQL","upSQL","predefinedMigration","timestamp","name","slice","join","fileName","filePath","dynamic","dynamicResult","drizzleJsonBefore","defaultDrizzleSnapshot","schemaName","schemas","latestSnapshot","readdirSync","filter","endsWith","sort","reverse","JSON","parse","readFileSync","version","sqlStatementsUp","sqlStatementsDown","sqlExecute","length","statements","process","exit","confirm","shouldCreateBlankMigration","type","initial","message","onCancel","writeFileSync","stringify","data","packageName","fullPath","migrationsDir","logger","info","msg"],"mappings":"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"}},
    {"offset": {"line": 216, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/transactions/commitTransaction.ts"],"sourcesContent":["import type { CommitTransaction } from 'payload'\n\nexport const commitTransaction: CommitTransaction = async function commitTransaction(\n  incomingID = '',\n) {\n  const transactionID = incomingID instanceof Promise ? await incomingID : incomingID\n\n  // if the session was deleted it has already been aborted\n  if (!this.sessions[transactionID]) {\n    return\n  }\n\n  const session = this.sessions[transactionID]\n\n  // Delete from registry FIRST to prevent race conditions\n  // This ensures other operations can't retrieve this session while we're ending it\n  delete this.sessions[transactionID]\n\n  try {\n    await session.resolve()\n  } catch (_) {\n    await session.reject()\n  }\n}\n"],"names":["commitTransaction","incomingID","transactionID","Promise","sessions","session","resolve","_","reject"],"mappings":";;;;AAEO,MAAMA,oBAAuC,eAAeA,kBACjEC,aAAa,EAAE;IAEf,MAAMC,gBAAgBD,sBAAsBE,UAAU,MAAMF,aAAaA;IAEzE,yDAAyD;IACzD,IAAI,CAAC,IAAI,CAACG,QAAQ,CAACF,cAAc,EAAE;QACjC;IACF;IAEA,MAAMG,UAAU,IAAI,CAACD,QAAQ,CAACF,cAAc;IAE5C,wDAAwD;IACxD,kFAAkF;IAClF,OAAO,IAAI,CAACE,QAAQ,CAACF,cAAc;IAEnC,IAAI;QACF,MAAMG,QAAQC,OAAO;IACvB,EAAE,OAAOC,GAAG;QACV,MAAMF,QAAQG,MAAM;IACtB;AACF,EAAC"}},
    {"offset": {"line": 240, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/utilities/getNameFromDrizzleTable.ts"],"sourcesContent":["import type { Table } from 'drizzle-orm'\n\nimport { getTableName } from 'drizzle-orm'\n\nexport const getNameFromDrizzleTable = (table: Table): string => {\n  return getTableName(table)\n}\n"],"names":["getTableName","getNameFromDrizzleTable","table"],"mappings":";;;;AAEA,SAASA,YAAY,QAAQ,cAAa;;AAEnC,MAAMC,0BAA0B,CAACC;IACtC,WAAOF,yJAAAA,EAAaE;AACtB,EAAC"}},
    {"offset": {"line": 253, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/utilities/isPolymorphicRelationship.ts"],"sourcesContent":["import type { CollectionSlug } from 'payload'\n\nexport const isPolymorphicRelationship = (\n  value: unknown,\n): value is {\n  relationTo: CollectionSlug\n  value: number | string\n} => {\n  return (\n    value &&\n    typeof value === 'object' &&\n    'relationTo' in value &&\n    typeof value.relationTo === 'string' &&\n    'value' in value\n  )\n}\n"],"names":["isPolymorphicRelationship","value","relationTo"],"mappings":";;;;AAEO,MAAMA,4BAA4B,CACvCC;IAKA,OACEA,SACA,OAAOA,UAAU,YACjB,gBAAgBA,SAChB,OAAOA,MAAMC,UAAU,KAAK,YAC5B,WAAWD;AAEf,EAAC"}},
    {"offset": {"line": 264, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/utilities/json.ts"],"sourcesContent":["import type { Column, SQL } from 'drizzle-orm'\n\nimport { sql } from 'drizzle-orm'\n\nimport type { DrizzleAdapter } from '../types.js'\n\nexport function jsonAgg(adapter: DrizzleAdapter, expression: SQL) {\n  if (adapter.name === 'sqlite') {\n    return sql`coalesce(json_group_array(${expression}), '[]')`\n  }\n\n  return sql`coalesce(json_agg(${expression}), '[]'::json)`\n}\n\n/**\n * @param shape Potential for SQL injections, so you shouldn't allow user-specified key names\n */\nexport function jsonBuildObject<T extends Record<string, Column | SQL>>(\n  adapter: DrizzleAdapter,\n  shape: T,\n) {\n  const chunks: SQL[] = []\n\n  Object.entries(shape).forEach(([key, value]) => {\n    if (chunks.length > 0) {\n      chunks.push(sql.raw(','))\n    }\n    chunks.push(sql.raw(`'${key}',`))\n    chunks.push(sql`${value}`)\n  })\n\n  if (adapter.name === 'sqlite') {\n    return sql`json_object(${sql.join(chunks)})`\n  }\n\n  return sql`json_build_object(${sql.join(chunks)})`\n}\n\nexport const jsonAggBuildObject = <T extends Record<string, Column | SQL>>(\n  adapter: DrizzleAdapter,\n  shape: T,\n) => {\n  return jsonAgg(adapter, jsonBuildObject(adapter, shape))\n}\n"],"names":["sql","jsonAgg","adapter","expression","name","jsonBuildObject","shape","chunks","Object","entries","forEach","key","value","length","push","raw","join","jsonAggBuildObject"],"mappings":";;;;;;;;AAEA,SAASA,GAAG,QAAQ,cAAa;;AAI1B,SAASC,QAAQC,OAAuB,EAAEC,UAAe;IAC9D,IAAID,QAAQE,IAAI,KAAK,UAAU;QAC7B,OAAOJ,qJAAG,CAAC,0BAA0B,EAAEG,WAAW,QAAQ,CAAC;IAC7D;IAEA,OAAOH,qJAAG,CAAC,kBAAkB,EAAEG,WAAW,cAAc,CAAC;AAC3D;AAKO,SAASE,gBACdH,OAAuB,EACvBI,KAAQ;IAER,MAAMC,SAAgB,EAAE;IAExBC,OAAOC,OAAO,CAACH,OAAOI,OAAO,CAAC,CAAC,CAACC,KAAKC,MAAM;QACzC,IAAIL,OAAOM,MAAM,GAAG,GAAG;YACrBN,OAAOO,IAAI,CAACd,qJAAAA,CAAIe,GAAG,CAAC;QACtB;QACAR,OAAOO,IAAI,CAACd,qJAAAA,CAAIe,GAAG,CAAC,CAAC,CAAC,EAAEJ,IAAI,EAAE,CAAC;QAC/BJ,OAAOO,IAAI,CAACd,qJAAG,CAAC,EAAEY,MAAM,CAAC;IAC3B;IAEA,IAAIV,QAAQE,IAAI,KAAK,UAAU;QAC7B,OAAOJ,qJAAG,CAAC,YAAY,EAAEA,qJAAAA,CAAIgB,IAAI,CAACT,QAAQ,CAAC,CAAC;IAC9C;IAEA,OAAOP,qJAAG,CAAC,kBAAkB,EAAEA,qJAAAA,CAAIgB,IAAI,CAACT,QAAQ,CAAC,CAAC;AACpD;AAEO,MAAMU,qBAAqB,CAChCf,SACAI;IAEA,OAAOL,QAAQC,SAASG,gBAAgBH,SAASI;AACnD,EAAC"}},
    {"offset": {"line": 301, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/utilities/rawConstraint.ts"],"sourcesContent":["const RawConstraintSymbol = Symbol('RawConstraint')\n\nexport const DistinctSymbol = Symbol('DistinctSymbol')\n\n/**\n * You can use this to inject a raw query to where\n */\nexport const rawConstraint = (value: unknown) => ({\n  type: RawConstraintSymbol,\n  value,\n})\n\nexport const isRawConstraint = (value: unknown): value is ReturnType<typeof rawConstraint> => {\n  return value && typeof value === 'object' && 'type' in value && value.type === RawConstraintSymbol\n}\n"],"names":["RawConstraintSymbol","Symbol","DistinctSymbol","rawConstraint","value","type","isRawConstraint"],"mappings":";;;;;;;;AAAA,MAAMA,sBAAsBC,OAAO;AAE5B,MAAMC,iBAAiBD,OAAO,kBAAiB;AAK/C,MAAME,gBAAgB,CAACC,QAAoB,CAAA;QAChDC,MAAML;QACNI;IACF,CAAA,EAAE;AAEK,MAAME,kBAAkB,CAACF;IAC9B,OAAOA,SAAS,OAAOA,UAAU,YAAY,UAAUA,SAASA,MAAMC,IAAI,KAAKL;AACjF,EAAC"}},
    {"offset": {"line": 322, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/utilities/validateExistingBlockIsIdentical.ts"],"sourcesContent":["import type { Block, Field, FlattenedBlock } from 'payload'\n\nimport {\n  fieldAffectsData,\n  fieldHasSubFields,\n  fieldShouldBeLocalized,\n  tabHasName,\n} from 'payload/shared'\n\nimport type { RawTable } from '../types.js'\n\ntype Args = {\n  block: Block\n  localized: boolean\n  /**\n   * @todo make required in v4.0. Usually you'd wanna pass this in\n   */\n  parentIsLocalized?: boolean\n  rootTableName: string\n  table: RawTable\n  tableLocales?: RawTable\n}\n\nconst getFlattenedFieldNames = (args: {\n  fields: Field[]\n  parentIsLocalized: boolean\n  prefix?: string\n}): { localized?: boolean; name: string }[] => {\n  const { fields, parentIsLocalized, prefix = '' } = args\n  return fields.reduce((fieldsToUse, field) => {\n    let fieldPrefix = prefix\n\n    if (\n      ['array', 'blocks', 'relationship', 'upload'].includes(field.type) ||\n      ('hasMany' in field && field.hasMany === true)\n    ) {\n      return fieldsToUse\n    }\n\n    if (fieldHasSubFields(field)) {\n      fieldPrefix = 'name' in field ? `${prefix}${field.name}_` : prefix\n      return [\n        ...fieldsToUse,\n        ...getFlattenedFieldNames({\n          fields: field.fields,\n          parentIsLocalized: parentIsLocalized || ('localized' in field && field.localized),\n          prefix: fieldPrefix,\n        }),\n      ]\n    }\n\n    if (field.type === 'tabs') {\n      return [\n        ...fieldsToUse,\n        ...field.tabs.reduce((tabFields, tab) => {\n          fieldPrefix = 'name' in tab ? `${prefix}_${tab.name}` : prefix\n          return [\n            ...tabFields,\n            ...(tabHasName(tab)\n              ? [{ ...tab, type: 'tab' }]\n              : getFlattenedFieldNames({\n                  fields: tab.fields,\n                  parentIsLocalized: parentIsLocalized || tab.localized,\n                  prefix: fieldPrefix,\n                })),\n          ]\n        }, []),\n      ]\n    }\n\n    if (fieldAffectsData(field)) {\n      return [\n        ...fieldsToUse,\n        {\n          name: `${fieldPrefix}${field.name}`,\n          localized: fieldShouldBeLocalized({ field, parentIsLocalized }),\n        },\n      ]\n    }\n\n    return fieldsToUse\n  }, [])\n}\n\n/**\n * returns true if all the fields in a block are identical to the existing table\n */\nexport const validateExistingBlockIsIdentical = ({\n  block,\n  localized,\n  parentIsLocalized,\n  table,\n  tableLocales,\n}: Args): boolean => {\n  const fieldNames = getFlattenedFieldNames({\n    fields: block.fields,\n    parentIsLocalized: parentIsLocalized || localized,\n  })\n\n  const missingField =\n    // ensure every field from the config is in the matching table\n    fieldNames.find(({ name, localized }) => {\n      const fieldTable = localized && tableLocales ? tableLocales : table\n      return Object.keys(fieldTable.columns).indexOf(name) === -1\n    }) ||\n    // ensure every table column is matched for every field from the config\n    Object.keys(table).find((fieldName) => {\n      if (!['_locale', '_order', '_parentID', '_path', '_uuid'].includes(fieldName)) {\n        return fieldNames.findIndex((field) => field.name) === -1\n      }\n    })\n\n  if (missingField) {\n    return false\n  }\n\n  return Boolean(localized) === Boolean(table.columns._locale)\n}\n\nexport const InternalBlockTableNameIndex = Symbol('InternalBlockTableNameIndex')\nexport const setInternalBlockIndex = (block: FlattenedBlock, index: number) => {\n  block[InternalBlockTableNameIndex] = index\n}\n\nexport const resolveBlockTableName = (block: FlattenedBlock, originalTableName: string) => {\n  if (!block[InternalBlockTableNameIndex]) {\n    return originalTableName\n  }\n\n  return `${originalTableName}_${block[InternalBlockTableNameIndex]}`\n}\n"],"names":["fieldAffectsData","fieldHasSubFields","fieldShouldBeLocalized","tabHasName","getFlattenedFieldNames","args","fields","parentIsLocalized","prefix","reduce","fieldsToUse","field","fieldPrefix","includes","type","hasMany","name","localized","tabs","tabFields","tab","validateExistingBlockIsIdentical","block","table","tableLocales","fieldNames","missingField","find","fieldTable","Object","keys","columns","indexOf","fieldName","findIndex","Boolean","_locale","InternalBlockTableNameIndex","Symbol","setInternalBlockIndex","index","resolveBlockTableName","originalTableName"],"mappings":";;;;;;;;;;AAEA,SACEA,gBAAgB,EAChBC,iBAAiB,EACjBC,sBAAsB,EACtBC,UAAU,QACL,iBAAgB;;AAgBvB,MAAMC,yBAAyB,CAACC;IAK9B,MAAM,EAAEC,MAAM,EAAEC,iBAAiB,EAAEC,SAAS,EAAE,EAAE,GAAGH;IACnD,OAAOC,OAAOG,MAAM,CAAC,CAACC,aAAaC;QACjC,IAAIC,cAAcJ;QAElB,IACE;YAAC;YAAS;YAAU;YAAgB;SAAS,CAACK,QAAQ,CAACF,MAAMG,IAAI,KAChE,aAAaH,SAASA,MAAMI,OAAO,KAAK,MACzC;YACA,OAAOL;QACT;QAEA,QAAIT,mLAAAA,EAAkBU,QAAQ;YAC5BC,cAAc,UAAUD,QAAQ,GAAGH,SAASG,MAAMK,IAAI,CAAC,CAAC,CAAC,GAAGR;YAC5D,OAAO;mBACFE;mBACAN,uBAAuB;oBACxBE,QAAQK,MAAML,MAAM;oBACpBC,mBAAmBA,qBAAsB,eAAeI,SAASA,MAAMM,SAAS;oBAChFT,QAAQI;gBACV;aACD;QACH;QAEA,IAAID,MAAMG,IAAI,KAAK,QAAQ;YACzB,OAAO;mBACFJ;mBACAC,MAAMO,IAAI,CAACT,MAAM,CAAC,CAACU,WAAWC;oBAC/BR,cAAc,UAAUQ,MAAM,GAAGZ,OAAO,CAAC,EAAEY,IAAIJ,IAAI,EAAE,GAAGR;oBACxD,OAAO;2BACFW;+BACChB,4KAAAA,EAAWiB,OACX;4BAAC;gCAAE,GAAGA,GAAG;gCAAEN,MAAM;4BAAM;yBAAE,GACzBV,uBAAuB;4BACrBE,QAAQc,IAAId,MAAM;4BAClBC,mBAAmBA,qBAAqBa,IAAIH,SAAS;4BACrDT,QAAQI;wBACV;qBACL;gBACH,GAAG,EAAE;aACN;QACH;QAEA,QAAIZ,kLAAAA,EAAiBW,QAAQ;YAC3B,OAAO;mBACFD;gBACH;oBACEM,MAAM,GAAGJ,cAAcD,MAAMK,IAAI,EAAE;oBACnCC,eAAWf,wLAAAA,EAAuB;wBAAES;wBAAOJ;oBAAkB;gBAC/D;aACD;QACH;QAEA,OAAOG;IACT,GAAG,EAAE;AACP;AAKO,MAAMW,mCAAmC,CAAC,EAC/CC,KAAK,EACLL,SAAS,EACTV,iBAAiB,EACjBgB,KAAK,EACLC,YAAY,EACP;IACL,MAAMC,aAAarB,uBAAuB;QACxCE,QAAQgB,MAAMhB,MAAM;QACpBC,mBAAmBA,qBAAqBU;IAC1C;IAEA,MAAMS,eACJ,AACAD,WAAWE,IAAI,CAAC,CAAC,EAAEX,IAAI,EAAEC,SAAS,EAAE,0BAD0B;QAE5D,MAAMW,aAAaX,aAAaO,eAAeA,eAAeD;QAC9D,OAAOM,OAAOC,IAAI,CAACF,WAAWG,OAAO,EAAEC,OAAO,CAAChB,UAAU,CAAC;IAC5D,MACA,uEAAuE;IACvEa,OAAOC,IAAI,CAACP,OAAOI,IAAI,CAAC,CAACM;QACvB,IAAI,CAAC;YAAC;YAAW;YAAU;YAAa;YAAS;SAAQ,CAACpB,QAAQ,CAACoB,YAAY;YAC7E,OAAOR,WAAWS,SAAS,CAAC,CAACvB,QAAUA,MAAMK,IAAI,MAAM,CAAC;QAC1D;IACF;IAEF,IAAIU,cAAc;QAChB,OAAO;IACT;IAEA,OAAOS,QAAQlB,eAAekB,QAAQZ,MAAMQ,OAAO,CAACK,OAAO;AAC7D,EAAC;AAEM,MAAMC,8BAA8BC,OAAO,+BAA8B;AACzE,MAAMC,wBAAwB,CAACjB,OAAuBkB;IAC3DlB,KAAK,CAACe,4BAA4B,GAAGG;AACvC,EAAC;AAEM,MAAMC,wBAAwB,CAACnB,OAAuBoB;IAC3D,IAAI,CAACpB,KAAK,CAACe,4BAA4B,EAAE;QACvC,OAAOK;IACT;IAEA,OAAO,GAAGA,kBAAkB,CAAC,EAAEpB,KAAK,CAACe,4BAA4B,EAAE;AACrE,EAAC"}},
    {"offset": {"line": 432, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/queries/addJoinTable.ts"],"sourcesContent":["import { type SQL } from 'drizzle-orm'\nimport { type PgTableWithColumns } from 'drizzle-orm/pg-core'\n\nimport type { GenericTable } from '../types.js'\nimport type { BuildQueryJoinAliases } from './buildQuery.js'\n\nimport { getNameFromDrizzleTable } from '../utilities/getNameFromDrizzleTable.js'\n\nexport const addJoinTable = ({\n  type,\n  condition,\n  joins,\n  queryPath,\n  table,\n}: {\n  condition: SQL\n  joins: BuildQueryJoinAliases\n  queryPath?: string\n  table: GenericTable | PgTableWithColumns<any>\n  type?: 'innerJoin' | 'leftJoin' | 'rightJoin'\n}) => {\n  const name = getNameFromDrizzleTable(table)\n\n  if (!joins.some((eachJoin) => getNameFromDrizzleTable(eachJoin.table) === name)) {\n    joins.push({ type, condition, queryPath, table })\n  }\n}\n"],"names":["getNameFromDrizzleTable","addJoinTable","type","condition","joins","queryPath","table","name","some","eachJoin","push"],"mappings":";;;;AAMA,SAASA,uBAAuB,QAAQ,0CAAyC;;AAE1E,MAAMC,eAAe,CAAC,EAC3BC,IAAI,EACJC,SAAS,EACTC,KAAK,EACLC,SAAS,EACTC,KAAK,EAON;IACC,MAAMC,WAAOP,oNAAAA,EAAwBM;IAErC,IAAI,CAACF,MAAMI,IAAI,CAAC,CAACC,eAAaT,oNAAAA,EAAwBS,SAASH,KAAK,MAAMC,OAAO;QAC/EH,MAAMM,IAAI,CAAC;YAAER;YAAMC;YAAWE;YAAWC;QAAM;IACjD;AACF,EAAC"}},
    {"offset": {"line": 453, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/queries/getTableAlias.ts"],"sourcesContent":["import type { PgTableWithColumns } from 'drizzle-orm/pg-core'\nimport type { SQLiteTableWithColumns } from 'drizzle-orm/sqlite-core'\n\nimport { alias } from 'drizzle-orm/pg-core'\nimport { alias as aliasSQLite } from 'drizzle-orm/sqlite-core/alias'\nimport toSnakeCase from 'to-snake-case'\nimport { v4 as uuid } from 'uuid'\n\nimport type { DrizzleAdapter } from '../types.js'\n\ntype Table = PgTableWithColumns<any> | SQLiteTableWithColumns<any>\nexport const getTableAlias = ({\n  adapter,\n  tableName,\n}: {\n  adapter: DrizzleAdapter\n  tableName: string\n}): {\n  newAliasTable: Table\n  newAliasTableName: string\n} => {\n  const newAliasTableName = toSnakeCase(uuid())\n  let newAliasTable\n\n  if (adapter.name === 'postgres') {\n    newAliasTable = alias(adapter.tables[tableName], newAliasTableName)\n  }\n  if (adapter.name === 'sqlite') {\n    newAliasTable = aliasSQLite(adapter.tables[tableName], newAliasTableName)\n  }\n\n  return { newAliasTable, newAliasTableName }\n}\n"],"names":["alias","aliasSQLite","toSnakeCase","v4","uuid","getTableAlias","adapter","tableName","newAliasTableName","newAliasTable","name","tables"],"mappings":";;;;AAGA,SAASA,KAAK,QAAQ,sBAAqB;AAC3C,SAASA,SAASC,WAAW,QAAQ,gCAA+B;AACpE,OAAOC,iBAAiB,gBAAe;AACvC,SAASC,MAAMC,IAAI,QAAQ,OAAM;;;;;AAK1B,MAAMC,gBAAgB,CAAC,EAC5BC,OAAO,EACPC,SAAS,EAIV;IAIC,MAAMC,wBAAoBN,yJAAAA,MAAYE,qOAAAA;IACtC,IAAIK;IAEJ,IAAIH,QAAQI,IAAI,KAAK,YAAY;QAC/BD,oBAAgBT,gKAAAA,EAAMM,QAAQK,MAAM,CAACJ,UAAU,EAAEC;IACnD;IACA,IAAIF,QAAQI,IAAI,KAAK,UAAU;QAC7BD,oBAAgBR,oKAAAA,EAAYK,QAAQK,MAAM,CAACJ,UAAU,EAAEC;IACzD;IAEA,OAAO;QAAEC;QAAeD;IAAkB;AAC5C,EAAC"}},
    {"offset": {"line": 483, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/queries/getTableColumnFromPath.ts"],"sourcesContent":["import type { SQL, Table } from 'drizzle-orm'\nimport type { SQLiteTableWithColumns } from 'drizzle-orm/sqlite-core'\nimport type {\n  FlattenedBlock,\n  FlattenedField,\n  NumberField,\n  RelationshipField,\n  TextField,\n} from 'payload'\n\nimport { and, eq, getTableName, like, or, sql } from 'drizzle-orm'\nimport { type PgTableWithColumns } from 'drizzle-orm/pg-core'\nimport { APIError, getFieldByPath } from 'payload'\nimport { fieldShouldBeLocalized, tabHasName } from 'payload/shared'\nimport toSnakeCase from 'to-snake-case'\nimport { validate as uuidValidate } from 'uuid'\n\nimport type { DrizzleAdapter, GenericColumn } from '../types.js'\nimport type { BuildQueryJoinAliases } from './buildQuery.js'\n\nimport { isPolymorphicRelationship } from '../utilities/isPolymorphicRelationship.js'\nimport { jsonBuildObject } from '../utilities/json.js'\nimport { DistinctSymbol } from '../utilities/rawConstraint.js'\nimport { resolveBlockTableName } from '../utilities/validateExistingBlockIsIdentical.js'\nimport { addJoinTable } from './addJoinTable.js'\nimport { getTableAlias } from './getTableAlias.js'\n\ntype Constraint = {\n  columnName: string\n  table: PgTableWithColumns<any> | SQLiteTableWithColumns<any>\n  value: unknown\n}\n\ntype TableColumn = {\n  columnName?: string\n  columns?: {\n    idType: 'number' | 'text' | 'uuid'\n    rawColumn: SQL<unknown>\n  }[]\n  constraints: Constraint[]\n  field: FlattenedField\n  getNotNullColumnByValue?: (val: unknown) => string\n  pathSegments?: string[]\n  rawColumn?: SQL\n  table: PgTableWithColumns<any> | SQLiteTableWithColumns<any>\n}\n\ntype Args = {\n  adapter: DrizzleAdapter\n  aliasTable?: PgTableWithColumns<any> | SQLiteTableWithColumns<any>\n  collectionPath: string\n  columnPrefix?: string\n  constraintPath?: string\n  constraints?: Constraint[]\n  fields: FlattenedField[]\n  joins: BuildQueryJoinAliases\n  locale?: string\n  parentAliasTable?: PgTableWithColumns<any> | SQLiteTableWithColumns<any>\n  parentIsLocalized: boolean\n  pathSegments: string[]\n  rootTableName?: string\n  selectFields: Record<string, GenericColumn>\n  selectLocale?: boolean\n  tableName: string\n  /**\n   * If creating a new table name for arrays and blocks, this suffix should be appended to the table name\n   */\n  tableNameSuffix?: string\n  /**\n   * The raw value of the query before sanitization\n   */\n  value: unknown\n}\n/**\n * Transforms path to table and column name or to a list of OR columns\n * Adds tables to `join`\n * @returns TableColumn\n */\nexport const getTableColumnFromPath = ({\n  adapter,\n  aliasTable,\n  collectionPath,\n  columnPrefix = '',\n  constraintPath: incomingConstraintPath,\n  constraints = [],\n  fields,\n  joins,\n  locale: incomingLocale,\n  parentAliasTable,\n  parentIsLocalized,\n  pathSegments: incomingSegments,\n  rootTableName: incomingRootTableName,\n  selectFields,\n  selectLocale,\n  tableName,\n  tableNameSuffix = '',\n  value,\n}: Args): TableColumn => {\n  const fieldPath = incomingSegments[0]\n  let locale = incomingLocale\n  const rootTableName = incomingRootTableName || tableName\n  let constraintPath = incomingConstraintPath || ''\n\n  const field = fields.find((fieldToFind) => fieldToFind.name === fieldPath)\n  let newTableName = tableName\n\n  if (!field && fieldPath === 'id') {\n    selectFields.id = adapter.tables[newTableName].id\n    return {\n      columnName: 'id',\n      constraints,\n      field: {\n        name: 'id',\n        type: adapter.idType === 'uuid' ? 'text' : 'number',\n      } as NumberField | TextField,\n      table: adapter.tables[newTableName],\n    }\n  }\n\n  let localizedPathQuery = false\n  if (field) {\n    const pathSegments = [...incomingSegments]\n\n    const isFieldLocalized = fieldShouldBeLocalized({ field, parentIsLocalized })\n\n    // If next segment is a locale,\n    // we need to take it out and use it as the locale from this point on\n    if (isFieldLocalized && adapter.payload.config.localization) {\n      const matchedLocale = adapter.payload.config.localization.localeCodes.find(\n        (locale) => locale === pathSegments[1],\n      )\n\n      if (matchedLocale) {\n        locale = matchedLocale\n        localizedPathQuery = true\n        pathSegments.splice(1, 1)\n      }\n    }\n\n    switch (field.type) {\n      case 'array': {\n        newTableName = adapter.tableNameMap.get(\n          `${tableName}_${tableNameSuffix}${toSnakeCase(field.name)}`,\n        )\n\n        const arrayParentTable = aliasTable || adapter.tables[tableName]\n\n        constraintPath = `${constraintPath}${field.name}.%.`\n        if (locale && isFieldLocalized && adapter.payload.config.localization) {\n          const conditions = [eq(arrayParentTable.id, adapter.tables[newTableName]._parentID)]\n\n          if (selectLocale) {\n            selectFields._locale = adapter.tables[newTableName]._locale\n          }\n\n          if (locale !== 'all') {\n            conditions.push(eq(adapter.tables[newTableName]._locale, locale))\n          }\n          addJoinTable({\n            condition: and(...conditions),\n            joins,\n            table: adapter.tables[newTableName],\n          })\n        } else {\n          addJoinTable({\n            condition: eq(arrayParentTable.id, adapter.tables[newTableName]._parentID),\n            joins,\n            table: adapter.tables[newTableName],\n          })\n        }\n\n        return getTableColumnFromPath({\n          adapter,\n          collectionPath,\n          constraintPath,\n          constraints,\n          fields: field.flattenedFields,\n          joins,\n          locale,\n          parentAliasTable: aliasTable,\n          parentIsLocalized: parentIsLocalized || field.localized,\n          pathSegments: pathSegments.slice(1),\n          rootTableName,\n          selectFields,\n          selectLocale,\n          tableName: newTableName,\n          value,\n        })\n      }\n      case 'blocks': {\n        if (adapter.blocksAsJSON) {\n          break\n        }\n        let blockTableColumn: TableColumn\n        let newTableName: string\n\n        // handle blockType queries\n        if (pathSegments[1] === 'blockType') {\n          // find the block config using the value\n          const blockTypes = Array.isArray(value) ? value : [value]\n          blockTypes.forEach((blockType) => {\n            const block =\n              adapter.payload.blocks[blockType] ??\n              ((field.blockReferences ?? field.blocks).find(\n                (block) => typeof block !== 'string' && block.slug === blockType,\n              ) as FlattenedBlock | undefined)\n\n            newTableName = resolveBlockTableName(\n              block,\n              adapter.tableNameMap.get(`${tableName}_blocks_${toSnakeCase(block.slug)}`),\n            )\n\n            const { newAliasTable } = getTableAlias({ adapter, tableName: newTableName })\n\n            joins.push({\n              condition: eq(adapter.tables[tableName].id, newAliasTable._parentID),\n              table: newAliasTable,\n            })\n            constraints.push({\n              columnName: '_path',\n              table: newAliasTable,\n              value: pathSegments[0],\n            })\n          })\n          return {\n            constraints,\n            field,\n            getNotNullColumnByValue: () => 'id',\n            table: adapter.tables[tableName],\n          }\n        }\n\n        const hasBlockField = (field.blockReferences ?? field.blocks).some((_block) => {\n          const block = typeof _block === 'string' ? adapter.payload.blocks[_block] : _block\n\n          newTableName = resolveBlockTableName(\n            block,\n            adapter.tableNameMap.get(`${tableName}_blocks_${toSnakeCase(block.slug)}`),\n          )\n\n          constraintPath = `${constraintPath}${field.name}.%.`\n\n          let result: TableColumn\n          const blockConstraints = []\n          const blockSelectFields = {}\n\n          let blockJoin: BuildQueryJoinAliases[0]\n          if (isFieldLocalized && adapter.payload.config.localization) {\n            const conditions = [\n              eq(\n                (aliasTable || adapter.tables[tableName]).id,\n                adapter.tables[newTableName]._parentID,\n              ),\n            ]\n\n            if (locale !== 'all') {\n              conditions.push(eq(adapter.tables[newTableName]._locale, locale))\n            }\n\n            blockJoin = {\n              condition: and(...conditions),\n              table: adapter.tables[newTableName],\n            }\n          } else {\n            blockJoin = {\n              condition: eq(\n                (aliasTable || adapter.tables[tableName]).id,\n                adapter.tables[newTableName]._parentID,\n              ),\n              table: adapter.tables[newTableName],\n            }\n          }\n\n          // Create a new reference for nested joins\n          const newJoins = [...joins]\n\n          try {\n            result = getTableColumnFromPath({\n              adapter,\n              collectionPath,\n              constraintPath,\n              constraints: blockConstraints,\n              fields: block.flattenedFields,\n              joins: newJoins,\n              locale,\n              parentIsLocalized: parentIsLocalized || field.localized,\n              pathSegments: pathSegments.slice(1),\n              rootTableName,\n              selectFields: blockSelectFields,\n              selectLocale,\n              tableName: newTableName,\n              value,\n            })\n          } catch (_) {\n            // this is fine, not every block will have the field\n          }\n          if (!result) {\n            return\n          }\n          blockTableColumn = result\n          constraints = constraints.concat(blockConstraints)\n          selectFields = { ...selectFields, ...blockSelectFields }\n\n          const previousLength = joins.length\n          joins.push(blockJoin)\n          // Append new joins AFTER the block join to prevent errors with missing FROM clause.\n          if (newJoins.length > previousLength) {\n            for (let i = previousLength; i < newJoins.length; i++) {\n              joins.push(newJoins[i])\n            }\n          }\n          return true\n        })\n        if (hasBlockField) {\n          return {\n            columnName: blockTableColumn.columnName,\n            constraints,\n            field: blockTableColumn.field,\n            pathSegments: pathSegments.slice(1),\n            rawColumn: blockTableColumn.rawColumn,\n            table: blockTableColumn.table,\n          }\n        }\n        break\n      }\n\n      case 'group': {\n        if (locale && isFieldLocalized && adapter.payload.config.localization) {\n          newTableName = `${tableName}${adapter.localesSuffix}`\n\n          let condition = eq(adapter.tables[tableName].id, adapter.tables[newTableName]._parentID)\n\n          if (locale !== 'all') {\n            condition = and(condition, eq(adapter.tables[newTableName]._locale, locale))\n          }\n\n          addJoinTable({\n            condition,\n            joins,\n            table: adapter.tables[newTableName],\n          })\n        }\n        return getTableColumnFromPath({\n          adapter,\n          aliasTable,\n          collectionPath,\n          columnPrefix: `${columnPrefix}${field.name}_`,\n          constraintPath: `${constraintPath}${field.name}.`,\n          constraints,\n          fields: field.flattenedFields,\n          joins,\n          locale,\n          parentIsLocalized: parentIsLocalized || field.localized,\n          pathSegments: pathSegments.slice(1),\n          rootTableName,\n          selectFields,\n          selectLocale,\n          tableName: newTableName,\n          tableNameSuffix: `${tableNameSuffix}${toSnakeCase(field.name)}_`,\n          value,\n        })\n      }\n\n      case 'join': {\n        if (Array.isArray(field.collection)) {\n          throw new APIError('Not supported')\n        }\n\n        const newCollectionPath = pathSegments.slice(1).join('.')\n\n        if (field.hasMany) {\n          const relationTableName = `${adapter.tableNameMap.get(toSnakeCase(field.collection))}${adapter.relationshipsSuffix}`\n\n          const existingTable = joins.find(\n            (e) => e.queryPath === `${constraintPath}${field.name}._rels`,\n          )\n\n          const aliasRelationshipTable = (existingTable?.table ??\n            getTableAlias({\n              adapter,\n              tableName: relationTableName,\n            }).newAliasTable) as PgTableWithColumns<any>\n\n          const relationshipField = getFieldByPath({\n            fields: adapter.payload.collections[field.collection].config.flattenedFields,\n            path: field.on,\n          })\n          if (!relationshipField) {\n            throw new APIError('Relationship was not found')\n          }\n\n          if (!existingTable) {\n            addJoinTable({\n              condition: and(\n                eq(\n                  adapter.tables[rootTableName].id,\n                  aliasRelationshipTable[\n                    `${(relationshipField.field as RelationshipField).relationTo as string}ID`\n                  ],\n                ),\n                like(aliasRelationshipTable.path, field.on),\n              ),\n              joins,\n              queryPath: `${constraintPath}${field.name}._rels`,\n              table: aliasRelationshipTable,\n            })\n          }\n\n          if (newCollectionPath === 'id') {\n            return {\n              columnName: 'parent',\n              constraints,\n              field: {\n                name: 'id',\n                type: adapter.idType === 'uuid' ? 'text' : 'number',\n              } as NumberField | TextField,\n              table: aliasRelationshipTable,\n            }\n          }\n\n          const relationshipConfig = adapter.payload.collections[field.collection].config\n          const relationshipTableName = adapter.tableNameMap.get(\n            toSnakeCase(relationshipConfig.slug),\n          )\n\n          // parent to relationship join table\n          const relationshipFields = relationshipConfig.flattenedFields\n\n          const existingMainTable = joins.find(\n            (e) => e.queryPath === `${constraintPath}${field.name}`,\n          )\n\n          const relationshipTable = (existingMainTable?.table ??\n            getTableAlias({\n              adapter,\n              tableName: relationshipTableName,\n            }).newAliasTable) as PgTableWithColumns<any>\n\n          if (!existingMainTable) {\n            joins.push({\n              condition: eq(aliasRelationshipTable.parent, relationshipTable.id),\n              queryPath: `${constraintPath}${field.name}`,\n              table: relationshipTable,\n            })\n          }\n\n          return getTableColumnFromPath({\n            adapter,\n            aliasTable: relationshipTable,\n            collectionPath: newCollectionPath,\n            constraints,\n            // relationshipFields are fields from a different collection => no parentIsLocalized\n            fields: relationshipFields,\n            joins,\n            locale,\n            parentIsLocalized: false,\n            pathSegments: pathSegments.slice(1),\n            rootTableName: relationshipTableName,\n            selectFields,\n            selectLocale,\n            tableName: relationshipTableName,\n            value,\n          })\n        }\n\n        const newTableName = adapter.tableNameMap.get(\n          toSnakeCase(adapter.payload.collections[field.collection].config.slug),\n        )\n\n        const existingTable = joins.find(\n          (e) => e.queryPath === `${constraintPath}${field.name}`,\n        )?.table\n        const newAliasTable =\n          existingTable || getTableAlias({ adapter, tableName: newTableName }).newAliasTable\n\n        if (!existingTable) {\n          joins.push({\n            condition: eq(\n              newAliasTable[field.on.replaceAll('.', '_')],\n              aliasTable ? aliasTable.id : adapter.tables[tableName].id,\n            ),\n            queryPath: `${constraintPath}${field.name}`,\n            table: newAliasTable,\n          })\n        }\n\n        if (newCollectionPath === 'id') {\n          return {\n            columnName: 'id',\n            constraints,\n            field: {\n              name: 'id',\n              type: adapter.idType === 'uuid' ? 'text' : 'number',\n            } as NumberField | TextField,\n            table: newAliasTable,\n          }\n        }\n\n        return getTableColumnFromPath({\n          adapter,\n          aliasTable: newAliasTable,\n          collectionPath: newCollectionPath,\n          constraintPath: '',\n          constraints,\n          fields: adapter.payload.collections[field.collection].config.flattenedFields,\n          joins,\n          locale,\n          parentIsLocalized: parentIsLocalized || field.localized,\n          pathSegments: pathSegments.slice(1),\n          selectFields,\n          tableName: newTableName,\n          value,\n        })\n\n        break\n      }\n\n      case 'number':\n      case 'text': {\n        if (field.hasMany) {\n          let tableType = 'texts'\n          let columnName = 'text'\n          if (field.type === 'number') {\n            tableType = 'numbers'\n            columnName = 'number'\n          }\n          newTableName = `${rootTableName}_${tableType}`\n\n          const existingTable = joins.find((e) => e.queryPath === `${constraintPath}${field.name}`)\n\n          const table = (existingTable?.table ??\n            getTableAlias({ adapter, tableName: newTableName })\n              .newAliasTable) as PgTableWithColumns<any>\n\n          const joinConstraints = [\n            eq(adapter.tables[rootTableName].id, table.parent),\n            like(table.path, `${constraintPath}${field.name}`),\n          ]\n\n          if (locale && isFieldLocalized && adapter.payload.config.localization) {\n            const conditions = [...joinConstraints]\n\n            if (locale !== 'all') {\n              conditions.push(eq(table._locale, locale))\n            }\n\n            addJoinTable({\n              condition: and(...conditions),\n              joins,\n              queryPath: `${constraintPath}${field.name}`,\n              table,\n            })\n          } else {\n            addJoinTable({\n              condition: and(...joinConstraints),\n              joins,\n              queryPath: `${constraintPath}${field.name}`,\n              table,\n            })\n          }\n\n          return {\n            columnName,\n            constraints,\n            field,\n            table,\n          }\n        }\n        break\n      }\n      case 'relationship':\n      case 'upload': {\n        const newCollectionPath = pathSegments.slice(1).join('.')\n\n        if (Array.isArray(field.relationTo) || field.hasMany) {\n          let relationshipFields: FlattenedField[]\n          const relationTableName = `${rootTableName}${adapter.relationshipsSuffix}`\n\n          const existingJoin = joins.find((e) => e.queryPath === `${constraintPath}.${field.name}`)\n\n          let aliasRelationshipTable: PgTableWithColumns<any> | SQLiteTableWithColumns<any>\n          let aliasRelationshipTableName: string\n          if (existingJoin) {\n            aliasRelationshipTable = existingJoin.table\n            aliasRelationshipTableName = getTableName(existingJoin.table)\n          } else {\n            const res = getTableAlias({\n              adapter,\n              tableName: relationTableName,\n            })\n            aliasRelationshipTable = res.newAliasTable\n            aliasRelationshipTableName = res.newAliasTableName\n          }\n\n          if (selectLocale && isFieldLocalized && adapter.payload.config.localization) {\n            selectFields._locale = aliasRelationshipTable.locale\n          }\n\n          // Join in the relationships table\n          if (locale && isFieldLocalized && adapter.payload.config.localization) {\n            const conditions = [\n              eq(\n                (parentAliasTable || aliasTable || adapter.tables[rootTableName]).id,\n                aliasRelationshipTable.parent,\n              ),\n              like(aliasRelationshipTable.path, `${constraintPath}${field.name}`),\n            ]\n\n            if (locale !== 'all') {\n              conditions.push(eq(aliasRelationshipTable.locale, locale))\n            }\n\n            addJoinTable({\n              condition: and(...conditions),\n              joins,\n              queryPath: `${constraintPath}.${field.name}`,\n              table: aliasRelationshipTable,\n            })\n          } else {\n            // Join in the relationships table\n            addJoinTable({\n              condition: and(\n                eq(\n                  (parentAliasTable || aliasTable || adapter.tables[rootTableName]).id,\n                  aliasRelationshipTable.parent,\n                ),\n                like(aliasRelationshipTable.path, `${constraintPath}${field.name}`),\n              ),\n              joins,\n              queryPath: `${constraintPath}.${field.name}`,\n              table: aliasRelationshipTable,\n            })\n          }\n\n          selectFields[`${relationTableName}.path`] = aliasRelationshipTable.path\n\n          let newAliasTable\n\n          if (typeof field.relationTo === 'string') {\n            const relationshipConfig = adapter.payload.collections[field.relationTo].config\n\n            newTableName = adapter.tableNameMap.get(toSnakeCase(relationshipConfig.slug))\n\n            // parent to relationship join table\n            relationshipFields = relationshipConfig.flattenedFields\n            ;({ newAliasTable } = getTableAlias({ adapter, tableName: newTableName }))\n\n            joins.push({\n              condition: eq(newAliasTable.id, aliasRelationshipTable[`${field.relationTo}ID`]),\n              table: newAliasTable,\n            })\n\n            if (newCollectionPath === '' || newCollectionPath === 'id') {\n              return {\n                columnName: `${field.relationTo}ID`,\n                constraints,\n                field,\n                table: aliasRelationshipTable,\n              }\n            }\n          } else if (newCollectionPath === 'value') {\n            const hasCustomCollectionWithCustomID = field.relationTo.some(\n              (relationTo) => !!adapter.payload.collections[relationTo].customIDType,\n            )\n\n            const columns: TableColumn['columns'] = field.relationTo\n              .map((relationTo) => {\n                let idType: 'number' | 'text' | 'uuid' =\n                  adapter.idType === 'uuid' ? 'uuid' : 'number'\n\n                const { customIDType } = adapter.payload.collections[relationTo]\n\n                if (customIDType) {\n                  idType = customIDType\n                }\n\n                const idTypeTextOrUuid = idType === 'text' || idType === 'uuid'\n\n                // Do not add the column to OR if we know that it can't match by the type\n                // We can't do the same with idType: 'number' because `value` can be from the REST search query params\n                if (typeof value === 'number' && idTypeTextOrUuid) {\n                  return null\n                }\n\n                if (\n                  Array.isArray(value) &&\n                  value.every((val) => typeof val === 'number') &&\n                  idTypeTextOrUuid\n                ) {\n                  return null\n                }\n\n                // Do not add the UUID type column if incoming query value doesn't match UUID. If there aren't any collections with\n                // a custom ID type, we skip this check\n                // We need this because Postgres throws an error if querying by UUID column with a value that isn't a valid UUID.\n                if (\n                  value &&\n                  !Array.isArray(value) &&\n                  idType === 'uuid' &&\n                  hasCustomCollectionWithCustomID\n                ) {\n                  if (!uuidValidate(value)) {\n                    return null\n                  }\n                }\n\n                if (\n                  Array.isArray(value) &&\n                  idType === 'uuid' &&\n                  hasCustomCollectionWithCustomID &&\n                  !value.some((val) => uuidValidate(val))\n                ) {\n                  return null\n                }\n\n                const relationTableName = adapter.tableNameMap.get(\n                  toSnakeCase(adapter.payload.collections[relationTo].config.slug),\n                )\n\n                return {\n                  idType,\n                  rawColumn: sql.raw(`\"${aliasRelationshipTableName}\".\"${relationTableName}_id\"`),\n                }\n              })\n              .filter(Boolean)\n\n            return {\n              columns,\n              constraints,\n              field,\n              table: aliasRelationshipTable,\n            }\n          } else if (newCollectionPath === 'relationTo') {\n            const relationTo = Array.isArray(field.relationTo)\n              ? field.relationTo\n              : [field.relationTo]\n\n            return {\n              constraints,\n              field,\n              getNotNullColumnByValue: (val) => {\n                const matchedRelation = relationTo.find((relation) => relation === val)\n                if (matchedRelation) {\n                  return `${matchedRelation}ID`\n                }\n                return undefined\n              },\n              table: aliasRelationshipTable,\n            }\n          } else if (isPolymorphicRelationship(value)) {\n            const { relationTo } = value\n\n            const relationTableName = adapter.tableNameMap.get(\n              toSnakeCase(adapter.payload.collections[relationTo].config.slug),\n            )\n\n            return {\n              constraints,\n              field,\n              rawColumn: sql.raw(`\"${aliasRelationshipTableName}\".\"${relationTableName}_id\"`),\n              table: aliasRelationshipTable,\n            }\n          } else if (value === DistinctSymbol) {\n            const obj: Record<string, SQL> = {}\n\n            field.relationTo.forEach((relationTo) => {\n              const relationTableName = adapter.tableNameMap.get(\n                toSnakeCase(adapter.payload.collections[relationTo].config.slug),\n              )\n\n              obj[relationTo] = sql.raw(`\"${aliasRelationshipTableName}\".\"${relationTableName}_id\"`)\n            })\n\n            let rawColumn = jsonBuildObject(adapter, obj)\n            if (adapter.name === 'postgres') {\n              rawColumn = sql`${rawColumn}::text`\n            }\n\n            return {\n              constraints,\n              field,\n              rawColumn,\n              table: aliasRelationshipTable,\n            }\n          } else {\n            throw new APIError('Not supported')\n          }\n\n          return getTableColumnFromPath({\n            adapter,\n            aliasTable: newAliasTable,\n            collectionPath: newCollectionPath,\n            constraints,\n            // relationshipFields are fields from a different collection => no parentIsLocalized\n            fields: relationshipFields,\n            joins,\n            locale,\n            parentIsLocalized: false,\n            pathSegments: pathSegments.slice(1),\n            rootTableName: newTableName,\n            selectFields,\n            selectLocale,\n            tableName: newTableName,\n            value,\n          })\n        } else if (\n          pathSegments.length > 1 &&\n          !(pathSegments.length === 2 && pathSegments[1] === 'id')\n        ) {\n          // simple relationships\n          const columnName = `${columnPrefix}${field.name}`\n          const newTableName = adapter.tableNameMap.get(\n            toSnakeCase(adapter.payload.collections[field.relationTo].config.slug),\n          )\n          const { newAliasTable } = getTableAlias({ adapter, tableName: newTableName })\n\n          if (isFieldLocalized && adapter.payload.config.localization) {\n            const { newAliasTable: aliasLocaleTable } = getTableAlias({\n              adapter,\n              tableName: `${rootTableName}${adapter.localesSuffix}`,\n            })\n\n            const condtions = [eq(aliasLocaleTable._parentID, adapter.tables[rootTableName].id)]\n\n            if (selectLocale) {\n              selectFields._locale = aliasLocaleTable._locale\n            }\n\n            if (locale !== 'all') {\n              condtions.push(eq(aliasLocaleTable._locale, locale))\n            }\n\n            const localesTable = adapter.tables[`${rootTableName}${adapter.localesSuffix}`]\n\n            addJoinTable({\n              condition: and(...condtions),\n              joins,\n              table: localesTable,\n            })\n\n            joins.push({\n              condition: eq(localesTable[columnName], newAliasTable.id),\n              table: newAliasTable,\n            })\n          } else {\n            joins.push({\n              condition: eq(\n                newAliasTable.id,\n                aliasTable ? aliasTable[columnName] : adapter.tables[tableName][columnName],\n              ),\n              table: newAliasTable,\n            })\n          }\n\n          return getTableColumnFromPath({\n            adapter,\n            aliasTable: newAliasTable,\n            collectionPath: newCollectionPath,\n            constraintPath: '',\n            constraints,\n            fields: adapter.payload.collections[field.relationTo].config.flattenedFields,\n            joins,\n            locale,\n            parentIsLocalized: parentIsLocalized || field.localized,\n            pathSegments: pathSegments.slice(1),\n            selectFields,\n            tableName: newTableName,\n            value,\n          })\n        }\n\n        break\n      }\n\n      case 'select': {\n        if (field.hasMany) {\n          const newTableName = adapter.tableNameMap.get(\n            `${tableName}_${tableNameSuffix}${toSnakeCase(field.name)}`,\n          )\n\n          const idColumn = (aliasTable ?? adapter.tables[tableName]).id\n          if (locale && isFieldLocalized && adapter.payload.config.localization) {\n            const conditions = [\n              eq(idColumn, adapter.tables[newTableName].parent),\n              eq(adapter.tables[newTableName]._locale, locale),\n            ]\n\n            if (locale !== 'all') {\n              conditions.push(eq(adapter.tables[newTableName]._locale, locale))\n            }\n\n            addJoinTable({\n              condition: and(...conditions),\n              joins,\n              table: adapter.tables[newTableName],\n            })\n          } else {\n            addJoinTable({\n              condition: eq(idColumn, adapter.tables[newTableName].parent),\n              joins,\n              table: adapter.tables[newTableName],\n            })\n          }\n\n          return {\n            columnName: 'value',\n            constraints,\n            field,\n            table: adapter.tables[newTableName],\n          }\n        }\n        break\n      }\n\n      case 'tab': {\n        if (tabHasName(field)) {\n          return getTableColumnFromPath({\n            adapter,\n            aliasTable,\n            collectionPath,\n            columnPrefix: `${columnPrefix}${field.name}_`,\n            constraintPath: `${constraintPath}${field.name}.`,\n            constraints,\n            fields: field.flattenedFields,\n            joins,\n            locale,\n            parentIsLocalized: parentIsLocalized || field.localized,\n            pathSegments: pathSegments.slice(1),\n            rootTableName,\n            selectFields,\n            selectLocale,\n            tableName: newTableName,\n            tableNameSuffix: `${tableNameSuffix}${toSnakeCase(field.name)}_`,\n            value,\n          })\n        }\n        return getTableColumnFromPath({\n          adapter,\n          aliasTable,\n          collectionPath,\n          columnPrefix,\n          constraintPath,\n          constraints,\n          fields: field.flattenedFields,\n          joins,\n          locale,\n          parentIsLocalized: parentIsLocalized || field.localized,\n          pathSegments: pathSegments.slice(1),\n          rootTableName,\n          selectFields,\n          selectLocale,\n          tableName: newTableName,\n          tableNameSuffix,\n          value,\n        })\n      }\n\n      default: {\n        // fall through\n        break\n      }\n    }\n\n    let newTable = adapter.tables[newTableName]\n\n    if (isFieldLocalized && adapter.payload.config.localization) {\n      // If localized, we go to localized table and set aliasTable to undefined\n      // so it is not picked up below to be used as targetTable\n      const parentTable = aliasTable || adapter.tables[tableName]\n      newTableName = `${tableName}${adapter.localesSuffix}`\n\n      // use an alias because the same query may contain constraints with different locale value\n      if (localizedPathQuery) {\n        const { newAliasTable } = getTableAlias({ adapter, tableName: newTableName })\n        newTable = newAliasTable\n      } else {\n        newTable = adapter.tables[newTableName]\n      }\n\n      let condition = eq(parentTable.id, newTable._parentID)\n\n      if (locale !== 'all') {\n        condition = and(condition, eq(newTable._locale, locale))\n      }\n\n      if (selectLocale) {\n        selectFields._locale = newTable._locale\n      }\n\n      addJoinTable({\n        condition,\n        joins,\n        table: newTable,\n      })\n\n      aliasTable = undefined\n    }\n\n    const targetTable = aliasTable || newTable\n\n    selectFields[`${newTableName}.${columnPrefix}${field.name}`] =\n      targetTable[`${columnPrefix}${field.name}`]\n\n    return {\n      columnName: `${columnPrefix}${field.name}`,\n      constraints,\n      field,\n      pathSegments,\n      table: targetTable,\n    }\n  }\n\n  throw new APIError(`Cannot find field for path at ${fieldPath}`)\n}\n"],"names":["and","eq","getTableName","like","sql","APIError","getFieldByPath","fieldShouldBeLocalized","tabHasName","toSnakeCase","validate","uuidValidate","isPolymorphicRelationship","jsonBuildObject","DistinctSymbol","resolveBlockTableName","addJoinTable","getTableAlias","getTableColumnFromPath","adapter","aliasTable","collectionPath","columnPrefix","constraintPath","incomingConstraintPath","constraints","fields","joins","locale","incomingLocale","parentAliasTable","parentIsLocalized","pathSegments","incomingSegments","rootTableName","incomingRootTableName","selectFields","selectLocale","tableName","tableNameSuffix","value","fieldPath","field","find","fieldToFind","name","newTableName","id","tables","columnName","type","idType","table","localizedPathQuery","isFieldLocalized","payload","config","localization","matchedLocale","localeCodes","splice","tableNameMap","get","arrayParentTable","conditions","_parentID","_locale","push","condition","flattenedFields","localized","slice","blocksAsJSON","blockTableColumn","blockTypes","Array","isArray","forEach","blockType","block","blocks","blockReferences","slug","newAliasTable","getNotNullColumnByValue","hasBlockField","some","_block","result","blockConstraints","blockSelectFields","blockJoin","newJoins","_","concat","previousLength","length","i","rawColumn","localesSuffix","collection","newCollectionPath","join","hasMany","relationTableName","relationshipsSuffix","existingTable","e","queryPath","aliasRelationshipTable","relationshipField","collections","path","on","relationTo","relationshipConfig","relationshipTableName","relationshipFields","existingMainTable","relationshipTable","parent","replaceAll","tableType","joinConstraints","existingJoin","aliasRelationshipTableName","res","newAliasTableName","hasCustomCollectionWithCustomID","customIDType","columns","map","idTypeTextOrUuid","every","val","raw","filter","Boolean","matchedRelation","relation","undefined","obj","aliasLocaleTable","condtions","localesTable","idColumn","newTable","parentTable","targetTable"],"mappings":"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"}},
    {"offset": {"line": 1268, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/queries/buildOrderBy.ts"],"sourcesContent":["import type { SQL, Table } from 'drizzle-orm'\nimport type { FlattenedField, Sort } from 'payload'\n\nimport { asc, desc } from 'drizzle-orm'\n\nimport type { DrizzleAdapter, GenericColumn } from '../types.js'\nimport type { BuildQueryJoinAliases, BuildQueryResult } from './buildQuery.js'\n\nimport { getNameFromDrizzleTable } from '../utilities/getNameFromDrizzleTable.js'\nimport { getTableColumnFromPath } from './getTableColumnFromPath.js'\n\ntype Args = {\n  adapter: DrizzleAdapter\n  aliasTable?: Table\n  fields: FlattenedField[]\n  joins: BuildQueryJoinAliases\n  locale?: string\n  parentIsLocalized: boolean\n  rawSort?: SQL\n  selectFields: Record<string, GenericColumn>\n  sort?: Sort\n  tableName: string\n}\n\n/**\n * Gets the order by column and direction constructed from the sort argument adds the column to the select fields and joins if necessary\n */\nexport const buildOrderBy = ({\n  adapter,\n  aliasTable,\n  fields,\n  joins,\n  locale,\n  parentIsLocalized,\n  rawSort,\n  selectFields,\n  sort,\n  tableName,\n}: Args): BuildQueryResult['orderBy'] => {\n  const orderBy: BuildQueryResult['orderBy'] = []\n\n  const createdAt = adapter.tables[tableName]?.createdAt\n\n  if (!sort) {\n    if (createdAt) {\n      sort = '-createdAt'\n    } else {\n      sort = '-id'\n    }\n  }\n\n  if (typeof sort === 'string') {\n    sort = [sort]\n  }\n\n  // In the case of Mongo, when sorting by a field that is not unique, the results are not guaranteed to be in the same order each time.\n  // So we add a fallback sort to ensure that the results are always in the same order.\n  let fallbackSort = '-id'\n\n  if (createdAt) {\n    fallbackSort = '-createdAt'\n  }\n\n  if (!(sort.includes(fallbackSort) || sort.includes(fallbackSort.replace('-', '')))) {\n    sort.push(fallbackSort)\n  }\n\n  for (const sortItem of sort) {\n    let sortProperty: string\n    let sortDirection: 'asc' | 'desc'\n    if (sortItem[0] === '-') {\n      sortProperty = sortItem.substring(1)\n      sortDirection = 'desc'\n    } else {\n      sortProperty = sortItem\n      sortDirection = 'asc'\n    }\n    try {\n      const { columnName: sortTableColumnName, table: sortTable } = getTableColumnFromPath({\n        adapter,\n        collectionPath: sortProperty,\n        fields,\n        joins,\n        locale,\n        parentIsLocalized,\n        pathSegments: sortProperty.replace(/__/g, '.').split('.'),\n        selectFields,\n        tableName,\n        value: sortProperty,\n      })\n      if (sortTable?.[sortTableColumnName]) {\n        let order = sortDirection === 'asc' ? asc : desc\n\n        if (rawSort) {\n          order = () => rawSort\n        }\n\n        orderBy.push({\n          column:\n            aliasTable && tableName === getNameFromDrizzleTable(sortTable)\n              ? aliasTable[sortTableColumnName]\n              : sortTable[sortTableColumnName],\n          order,\n        })\n\n        selectFields[sortTableColumnName] = sortTable[sortTableColumnName]\n      }\n    } catch (_) {\n      // continue\n    }\n  }\n\n  return orderBy\n}\n"],"names":["asc","desc","getNameFromDrizzleTable","getTableColumnFromPath","buildOrderBy","adapter","aliasTable","fields","joins","locale","parentIsLocalized","rawSort","selectFields","sort","tableName","orderBy","createdAt","tables","fallbackSort","includes","replace","push","sortItem","sortProperty","sortDirection","substring","columnName","sortTableColumnName","table","sortTable","collectionPath","pathSegments","split","value","order","column","_"],"mappings":";;;;AAGA,SAASA,GAAG,EAAEC,IAAI,QAAQ,cAAa;AAKvC,SAASC,uBAAuB,QAAQ,0CAAyC;AACjF,SAASC,sBAAsB,QAAQ,8BAA6B;;;;AAkB7D,MAAMC,eAAe,CAAC,EAC3BC,OAAO,EACPC,UAAU,EACVC,MAAM,EACNC,KAAK,EACLC,MAAM,EACNC,iBAAiB,EACjBC,OAAO,EACPC,YAAY,EACZC,IAAI,EACJC,SAAS,EACJ;IACL,MAAMC,UAAuC,EAAE;IAE/C,MAAMC,YAAYX,QAAQY,MAAM,CAACH,UAAU,EAAEE;IAE7C,IAAI,CAACH,MAAM;QACT,IAAIG,WAAW;YACbH,OAAO;QACT,OAAO;YACLA,OAAO;QACT;IACF;IAEA,IAAI,OAAOA,SAAS,UAAU;QAC5BA,OAAO;YAACA;SAAK;IACf;IAEA,sIAAsI;IACtI,qFAAqF;IACrF,IAAIK,eAAe;IAEnB,IAAIF,WAAW;QACbE,eAAe;IACjB;IAEA,IAAI,CAAEL,CAAAA,KAAKM,QAAQ,CAACD,iBAAiBL,KAAKM,QAAQ,CAACD,aAAaE,OAAO,CAAC,KAAK,IAAG,GAAI;QAClFP,KAAKQ,IAAI,CAACH;IACZ;IAEA,KAAK,MAAMI,YAAYT,KAAM;QAC3B,IAAIU;QACJ,IAAIC;QACJ,IAAIF,QAAQ,CAAC,EAAE,KAAK,KAAK;YACvBC,eAAeD,SAASG,SAAS,CAAC;YAClCD,gBAAgB;QAClB,OAAO;YACLD,eAAeD;YACfE,gBAAgB;QAClB;QACA,IAAI;YACF,MAAM,EAAEE,YAAYC,mBAAmB,EAAEC,OAAOC,SAAS,EAAE,OAAG1B,gNAAAA,EAAuB;gBACnFE;gBACAyB,gBAAgBP;gBAChBhB;gBACAC;gBACAC;gBACAC;gBACAqB,cAAcR,aAAaH,OAAO,CAAC,OAAO,KAAKY,KAAK,CAAC;gBACrDpB;gBACAE;gBACAmB,OAAOV;YACT;YACA,IAAIM,WAAW,CAACF,oBAAoB,EAAE;gBACpC,IAAIO,QAAQV,kBAAkB,QAAQxB,uKAAAA,GAAMC,wKAAAA;gBAE5C,IAAIU,SAAS;oBACXuB,QAAQ,IAAMvB;gBAChB;gBAEAI,QAAQM,IAAI,CAAC;oBACXc,QACE7B,cAAcQ,kBAAcZ,oNAAAA,EAAwB2B,aAChDvB,UAAU,CAACqB,oBAAoB,GAC/BE,SAAS,CAACF,oBAAoB;oBACpCO;gBACF;gBAEAtB,YAAY,CAACe,oBAAoB,GAAGE,SAAS,CAACF,oBAAoB;YACpE;QACF,EAAE,OAAOS,GAAG;QACV,WAAW;QACb;IACF;IAEA,OAAOrB;AACT,EAAC"}},
    {"offset": {"line": 1346, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/utilities/escapeSQLValue.ts"],"sourcesContent":["import { APIError } from 'payload'\n\nexport const SAFE_STRING_REGEX = /^[\\w @.\\-+:]*$/\n\nexport const escapeSQLValue = (value: unknown): boolean | null | number | string => {\n  if (value === null) {\n    return null\n  }\n\n  if (typeof value === 'number' || typeof value === 'boolean') {\n    return value\n  }\n\n  if (typeof value !== 'string') {\n    throw new Error('Invalid value type')\n  }\n\n  if (!SAFE_STRING_REGEX.test(value)) {\n    throw new APIError(`${value} is not allowed as a JSON query value`, 400)\n  }\n\n  const escaped = value.replace(/\\\\/g, '\\\\\\\\').replace(/\"/g, '\\\\\"')\n\n  return escaped\n}\n"],"names":["APIError","SAFE_STRING_REGEX","escapeSQLValue","value","Error","test","escaped","replace"],"mappings":";;;;;;AAAA,SAASA,QAAQ,QAAQ,UAAS;;AAE3B,MAAMC,oBAAoB,iBAAgB;AAE1C,MAAMC,iBAAiB,CAACC;IAC7B,IAAIA,UAAU,MAAM;QAClB,OAAO;IACT;IAEA,IAAI,OAAOA,UAAU,YAAY,OAAOA,UAAU,WAAW;QAC3D,OAAOA;IACT;IAEA,IAAI,OAAOA,UAAU,UAAU;QAC7B,MAAM,IAAIC,MAAM;IAClB;IAEA,IAAI,CAACH,kBAAkBI,IAAI,CAACF,QAAQ;QAClC,MAAM,IAAIH,mKAAAA,CAAS,GAAGG,MAAM,qCAAqC,CAAC,EAAE;IACtE;IAEA,MAAMG,UAAUH,MAAMI,OAAO,CAAC,OAAO,QAAQA,OAAO,CAAC,MAAM;IAE3D,OAAOD;AACT,EAAC"}},
    {"offset": {"line": 1375, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/utilities/isValidStringID.ts"],"sourcesContent":["export function isValidStringID(value: string) {\n  return /^[\\w-]+$/.test(value)\n}\n"],"names":["isValidStringID","value","test"],"mappings":";;;;AAAO,SAASA,gBAAgBC,KAAa;IAC3C,OAAO,WAAWC,IAAI,CAACD;AACzB"}},
    {"offset": {"line": 1386, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/queries/buildAndOrConditions.ts"],"sourcesContent":["import type { SQL, Table } from 'drizzle-orm'\nimport type { FlattenedField, Where } from 'payload'\n\nimport type { DrizzleAdapter, GenericColumn } from '../types.js'\nimport type { BuildQueryJoinAliases } from './buildQuery.js'\nimport type { QueryContext } from './parseParams.js'\n\nimport { parseParams } from './parseParams.js'\n\nexport function buildAndOrConditions({\n  adapter,\n  aliasTable,\n  context,\n  fields,\n  joins,\n  locale,\n  parentIsLocalized,\n  selectFields,\n  selectLocale,\n  tableName,\n  where,\n}: {\n  adapter: DrizzleAdapter\n  aliasTable?: Table\n  collectionSlug?: string\n  context: QueryContext\n  fields: FlattenedField[]\n  globalSlug?: string\n  joins: BuildQueryJoinAliases\n  locale?: string\n  parentIsLocalized: boolean\n  selectFields: Record<string, GenericColumn>\n  selectLocale?: boolean\n  tableName: string\n  where: Where[]\n}): SQL[] {\n  const completedConditions = []\n  // Loop over all AND / OR operations and add them to the AND / OR query param\n  // Operations should come through as an array\n\n  for (const condition of where) {\n    // If the operation is properly formatted as an object\n    if (typeof condition === 'object') {\n      const result = parseParams({\n        adapter,\n        aliasTable,\n        context,\n        fields,\n        joins,\n        locale,\n        parentIsLocalized,\n        selectFields,\n        selectLocale,\n        tableName,\n        where: condition,\n      })\n      if (result && Object.keys(result).length > 0) {\n        completedConditions.push(result)\n      }\n    }\n  }\n  return completedConditions\n}\n"],"names":["parseParams","buildAndOrConditions","adapter","aliasTable","context","fields","joins","locale","parentIsLocalized","selectFields","selectLocale","tableName","where","completedConditions","condition","result","Object","keys","length","push"],"mappings":";;;;AAOA,SAASA,WAAW,QAAQ,mBAAkB;;AAEvC,SAASC,qBAAqB,EACnCC,OAAO,EACPC,UAAU,EACVC,OAAO,EACPC,MAAM,EACNC,KAAK,EACLC,MAAM,EACNC,iBAAiB,EACjBC,YAAY,EACZC,YAAY,EACZC,SAAS,EACTC,KAAK,EAeN;IACC,MAAMC,sBAAsB,EAAE;IAC9B,6EAA6E;IAC7E,6CAA6C;IAE7C,KAAK,MAAMC,aAAaF,MAAO;QAC7B,sDAAsD;QACtD,IAAI,OAAOE,cAAc,UAAU;YACjC,MAAMC,aAASf,0LAAAA,EAAY;gBACzBE;gBACAC;gBACAC;gBACAC;gBACAC;gBACAC;gBACAC;gBACAC;gBACAC;gBACAC;gBACAC,OAAOE;YACT;YACA,IAAIC,UAAUC,OAAOC,IAAI,CAACF,QAAQG,MAAM,GAAG,GAAG;gBAC5CL,oBAAoBM,IAAI,CAACJ;YAC3B;QACF;IACF;IACA,OAAOF;AACT"}},
    {"offset": {"line": 1423, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/utilities/getCollectionIdType.ts"],"sourcesContent":["import type { Collection } from 'payload'\n\nimport type { DrizzleAdapter } from '../types.js'\n\nconst typeMap: Record<string, 'number' | 'text'> = {\n  number: 'number',\n  serial: 'number',\n  text: 'text',\n  uuid: 'text',\n}\n\nexport const getCollectionIdType = ({\n  adapter,\n  collection,\n}: {\n  adapter: DrizzleAdapter\n  collection: Collection\n}) => {\n  return collection.customIDType ?? typeMap[adapter.idType]\n}\n"],"names":["typeMap","number","serial","text","uuid","getCollectionIdType","adapter","collection","customIDType","idType"],"mappings":";;;;AAIA,MAAMA,UAA6C;IACjDC,QAAQ;IACRC,QAAQ;IACRC,MAAM;IACNC,MAAM;AACR;AAEO,MAAMC,sBAAsB,CAAC,EAClCC,OAAO,EACPC,UAAU,EAIX;IACC,OAAOA,WAAWC,YAAY,IAAIR,OAAO,CAACM,QAAQG,MAAM,CAAC;AAC3D,EAAC"}},
    {"offset": {"line": 1440, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/queries/sanitizeQueryValue.ts"],"sourcesContent":["import type { SQL } from 'drizzle-orm'\n\nimport { APIError, createArrayFromCommaDelineated, type Field, type TabAsField } from 'payload'\nimport { fieldAffectsData } from 'payload/shared'\nimport { validate as uuidValidate } from 'uuid'\n\nimport type { DrizzleAdapter } from '../types.js'\n\nimport { getCollectionIdType } from '../utilities/getCollectionIdType.js'\nimport { isPolymorphicRelationship } from '../utilities/isPolymorphicRelationship.js'\nimport { isRawConstraint } from '../utilities/rawConstraint.js'\n\ntype SanitizeQueryValueArgs = {\n  adapter: DrizzleAdapter\n  columns?: {\n    idType: 'number' | 'text' | 'uuid'\n    rawColumn: SQL<unknown>\n  }[]\n  field: Field | TabAsField\n  isUUID: boolean\n  operator: string\n  relationOrPath: string\n  val: any\n}\n\ntype SanitizedColumn = {\n  rawColumn: SQL<unknown>\n  value: unknown\n}\n\nexport const sanitizeQueryValue = ({\n  adapter,\n  columns,\n  field,\n  isUUID,\n  operator: operatorArg,\n  relationOrPath,\n  val,\n}: SanitizeQueryValueArgs): {\n  columns?: SanitizedColumn[]\n  operator: string\n  value: unknown\n} => {\n  let operator = operatorArg\n  let formattedValue = val\n  let formattedColumns: SanitizedColumn[]\n\n  if (!fieldAffectsData(field)) {\n    return { operator, value: formattedValue }\n  }\n\n  if (isRawConstraint(val)) {\n    return { operator, value: val.value }\n  }\n  if (\n    (field.type === 'relationship' || field.type === 'upload') &&\n    !relationOrPath.endsWith('relationTo') &&\n    Array.isArray(formattedValue)\n  ) {\n    const allPossibleIDTypes: (number | string)[] = []\n    formattedValue.forEach((val) => {\n      if (adapter.idType !== 'uuid' && typeof val === 'string') {\n        allPossibleIDTypes.push(val, parseInt(val))\n      } else if (typeof val === 'string') {\n        allPossibleIDTypes.push(val)\n      } else {\n        allPossibleIDTypes.push(val, String(val))\n      }\n    })\n    formattedValue = allPossibleIDTypes\n  }\n\n  // Cast incoming values as proper searchable types\n  if (field.type === 'checkbox' && typeof val === 'string') {\n    if (val.toLowerCase() === 'true') {\n      formattedValue = true\n    }\n    if (val.toLowerCase() === 'false') {\n      formattedValue = false\n    }\n  }\n\n  if (['all', 'in', 'not_in'].includes(operator)) {\n    if (typeof formattedValue === 'string') {\n      formattedValue = createArrayFromCommaDelineated(formattedValue)\n\n      if (field.type === 'number') {\n        formattedValue = formattedValue.map((arrayVal) => parseFloat(arrayVal))\n      }\n    } else if (typeof formattedValue === 'number') {\n      formattedValue = [formattedValue]\n    }\n\n    if (!Array.isArray(formattedValue)) {\n      return null\n    }\n  }\n\n  if (field.type === 'number' && typeof formattedValue === 'string') {\n    formattedValue = Number(val)\n\n    if (Number.isNaN(formattedValue)) {\n      formattedValue = null\n    }\n  }\n\n  if (isUUID && typeof formattedValue === 'string') {\n    if (!uuidValidate(val)) {\n      formattedValue = null\n    }\n  }\n\n  // Helper function to convert a single date value to ISO string\n  const convertDateToISO = (item: unknown): unknown => {\n    if (typeof item === 'string') {\n      if (item === 'null' || item === '') {\n        return null\n      }\n      const date = new Date(item)\n      return Number.isNaN(date.getTime()) ? undefined : date.toISOString()\n    } else if (typeof item === 'number') {\n      return new Date(item).toISOString()\n    } else if (item instanceof Date) {\n      return item.toISOString()\n    }\n    return item\n  }\n\n  if (field.type === 'date' && operator !== 'exists') {\n    if (Array.isArray(formattedValue)) {\n      // Handle arrays of dates for 'in' and 'not_in' operators\n      formattedValue = formattedValue.map(convertDateToISO).filter((item) => item !== undefined)\n    } else {\n      const converted = convertDateToISO(val)\n      if (converted === undefined) {\n        return { operator, value: undefined }\n      }\n      formattedValue = converted\n    }\n  }\n\n  if (field.type === 'relationship' || field.type === 'upload') {\n    if (val === 'null') {\n      formattedValue = null\n    } else if (!(formattedValue === null || typeof formattedValue === 'boolean')) {\n      // convert the value to the idType of the relationship\n      let idType: 'number' | 'text'\n      if (typeof field.relationTo === 'string') {\n        idType = getCollectionIdType({\n          adapter,\n          collection: adapter.payload.collections[field.relationTo],\n        })\n      } else {\n        if (isPolymorphicRelationship(val)) {\n          if (operator !== 'equals') {\n            throw new APIError(\n              `Only 'equals' operator is supported for polymorphic relationship object notation. Given - ${operator}`,\n            )\n          }\n          idType = getCollectionIdType({\n            adapter,\n            collection: adapter.payload.collections[val.relationTo],\n          })\n\n          if (isRawConstraint(val.value)) {\n            return {\n              operator,\n              value: val.value.value,\n            }\n          }\n          return {\n            operator,\n            value: idType === 'number' ? Number(val.value) : String(val.value),\n          }\n        }\n\n        formattedColumns = columns\n          .map(({ idType, rawColumn }) => {\n            let formattedValue: number | number[] | string | string[]\n\n            if (Array.isArray(val)) {\n              formattedValue = val\n                .map((eachVal) => {\n                  let formattedValue: number | string\n\n                  if (idType === 'number') {\n                    formattedValue = Number(eachVal)\n\n                    if (Number.isNaN(formattedValue)) {\n                      return null\n                    }\n                  } else {\n                    if (idType === 'uuid' && !uuidValidate(eachVal)) {\n                      return null\n                    }\n\n                    formattedValue = String(eachVal)\n                  }\n\n                  return formattedValue\n                })\n                .filter(Boolean) as number[] | string[]\n            } else if (idType === 'number') {\n              formattedValue = Number(val)\n\n              if (Number.isNaN(formattedValue)) {\n                return null\n              }\n            } else {\n              formattedValue = String(val)\n            }\n\n            return {\n              rawColumn,\n              value: formattedValue,\n            }\n          })\n          .filter(Boolean)\n      }\n      if (Array.isArray(formattedValue)) {\n        formattedValue = formattedValue.map((value) => {\n          if (idType === 'number') {\n            return Number(value)\n          }\n          if (idType === 'text') {\n            return String(value)\n          }\n          return value\n        })\n      } else {\n        if (idType === 'number') {\n          formattedValue = Number(val)\n        }\n        if (idType === 'text') {\n          formattedValue = String(val)\n        }\n      }\n    }\n  }\n\n  if ('hasMany' in field && field.hasMany && operator === 'contains') {\n    operator = 'equals'\n  }\n\n  if (operator === 'near' && field.type === 'point' && typeof formattedValue === 'string') {\n    const [lng, lat, maxDistance, minDistance] = formattedValue.split(',')\n\n    formattedValue = [Number(lng), Number(lat), Number(maxDistance), Number(minDistance)]\n  }\n\n  if (operator === 'contains') {\n    formattedValue = `%${formattedValue}%`\n  }\n\n  if (operator === 'exists') {\n    formattedValue = val === 'true' || val === true\n\n    if (formattedValue) {\n      operator = 'exists'\n    } else {\n      operator = 'isNull'\n    }\n  }\n\n  return {\n    columns: formattedColumns,\n    operator,\n    value: formattedValue,\n  }\n}\n"],"names":["APIError","createArrayFromCommaDelineated","fieldAffectsData","validate","uuidValidate","getCollectionIdType","isPolymorphicRelationship","isRawConstraint","sanitizeQueryValue","adapter","columns","field","isUUID","operator","operatorArg","relationOrPath","val","formattedValue","formattedColumns","value","type","endsWith","Array","isArray","allPossibleIDTypes","forEach","idType","push","parseInt","String","toLowerCase","includes","map","arrayVal","parseFloat","Number","isNaN","convertDateToISO","item","date","Date","getTime","undefined","toISOString","filter","converted","relationTo","collection","payload","collections","rawColumn","eachVal","Boolean","hasMany","lng","lat","maxDistance","minDistance","split"],"mappings":"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"}},
    {"offset": {"line": 1671, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/queries/parseParams.ts"],"sourcesContent":["import type { SQL, Table } from 'drizzle-orm'\nimport type { FlattenedField, Operator, Sort, Where } from 'payload'\n\nimport { and, getTableName, isNotNull, isNull, ne, notInArray, or, sql } from 'drizzle-orm'\nimport { PgUUID } from 'drizzle-orm/pg-core'\nimport { APIError, QueryError } from 'payload'\nimport { validOperatorSet } from 'payload/shared'\n\nimport type { DrizzleAdapter, GenericColumn } from '../types.js'\nimport type { BuildQueryJoinAliases } from './buildQuery.js'\n\nimport { escapeSQLValue } from '../utilities/escapeSQLValue.js'\nimport { getNameFromDrizzleTable } from '../utilities/getNameFromDrizzleTable.js'\nimport { isValidStringID } from '../utilities/isValidStringID.js'\nimport { DistinctSymbol } from '../utilities/rawConstraint.js'\nimport { buildAndOrConditions } from './buildAndOrConditions.js'\nimport { getTableColumnFromPath } from './getTableColumnFromPath.js'\nimport { sanitizeQueryValue } from './sanitizeQueryValue.js'\n\nexport type QueryContext = { rawSort?: SQL; sort: Sort }\n\ntype Args = {\n  adapter: DrizzleAdapter\n  aliasTable?: Table\n  context: QueryContext\n  fields: FlattenedField[]\n  joins: BuildQueryJoinAliases\n  locale?: string\n  parentIsLocalized: boolean\n  selectFields: Record<string, GenericColumn>\n  selectLocale?: boolean\n  tableName: string\n  where: Where\n}\n\nexport function parseParams({\n  adapter,\n  aliasTable,\n  context,\n  fields,\n  joins,\n  locale,\n  parentIsLocalized,\n  selectFields,\n  selectLocale,\n  tableName,\n  where,\n}: Args): SQL {\n  let result: SQL\n  const constraints: SQL[] = []\n\n  if (typeof where === 'object' && Object.keys(where).length > 0) {\n    // We need to determine if the whereKey is an AND, OR, or a schema path\n    for (const relationOrPath of Object.keys(where)) {\n      if (relationOrPath) {\n        const condition = where[relationOrPath]\n        let conditionOperator: typeof and | typeof or\n        if (relationOrPath.toLowerCase() === 'and') {\n          conditionOperator = and\n        } else if (relationOrPath.toLowerCase() === 'or') {\n          conditionOperator = or\n        }\n        if (Array.isArray(condition)) {\n          const builtConditions = buildAndOrConditions({\n            adapter,\n            aliasTable,\n            context,\n            fields,\n            joins,\n            locale,\n            parentIsLocalized,\n            selectFields,\n            selectLocale,\n            tableName,\n            where: condition,\n          })\n          if (builtConditions.length > 0) {\n            result = conditionOperator(...builtConditions)\n          }\n        } else {\n          // It's a path - and there can be multiple comparisons on a single path.\n          // For example - title like 'test' and title not equal to 'tester'\n          // So we need to loop on keys again here to handle each operator independently\n          const pathOperators = where[relationOrPath]\n          if (typeof pathOperators === 'object') {\n            for (let operator of Object.keys(pathOperators)) {\n              if (validOperatorSet.has(operator as Operator)) {\n                const val = where[relationOrPath][operator]\n\n                const {\n                  columnName,\n                  columns,\n                  constraints: queryConstraints,\n                  field,\n                  getNotNullColumnByValue,\n                  pathSegments,\n                  rawColumn,\n                  table,\n                } = getTableColumnFromPath({\n                  adapter,\n                  aliasTable,\n                  collectionPath: relationOrPath,\n                  fields,\n                  joins,\n                  locale,\n                  parentIsLocalized,\n                  pathSegments: relationOrPath.replace(/__/g, '.').split('.'),\n                  selectFields,\n                  selectLocale,\n                  tableName,\n                  value: val,\n                })\n\n                const resolvedColumn =\n                  rawColumn ||\n                  (aliasTable && tableName === getNameFromDrizzleTable(table)\n                    ? aliasTable[columnName]\n                    : table[columnName])\n\n                if (val === DistinctSymbol) {\n                  selectFields['_selected'] = resolvedColumn\n                  break\n                }\n\n                queryConstraints.forEach(({ columnName: col, table: constraintTable, value }) => {\n                  if (typeof value === 'string' && value.indexOf('%') > -1) {\n                    constraints.push(adapter.operators.like(constraintTable[col], value))\n                  } else {\n                    constraints.push(adapter.operators.equals(constraintTable[col], value))\n                  }\n                })\n\n                if (\n                  (['json', 'richText'].includes(field.type) ||\n                    (field.type === 'blocks' && adapter.blocksAsJSON)) &&\n                  Array.isArray(pathSegments) &&\n                  pathSegments.length > 1\n                ) {\n                  if (adapter.name === 'postgres') {\n                    const constraint = adapter.createJSONQuery({\n                      column: rawColumn || table[columnName],\n                      operator,\n                      pathSegments,\n                      value: val,\n                    })\n\n                    constraints.push(sql.raw(constraint))\n                    break\n                  }\n\n                  const segments = pathSegments.slice(1)\n                  segments.unshift(table[columnName].name)\n\n                  if (field.type === 'richText') {\n                    // use the table name from the nearest join to handle blocks, arrays, etc. or use the tableName arg\n                    const jsonTable =\n                      joins.length === 0\n                        ? tableName\n                        : joins[joins.length - 1].table[\n                            Object.getOwnPropertySymbols(joins[joins.length - 1].table)[0]\n                          ]\n                    const jsonQuery = adapter.createJSONQuery({\n                      operator,\n                      pathSegments: segments,\n                      table: jsonTable,\n                      treatAsArray: ['children'],\n                      treatRootAsArray: true,\n                      value: val,\n                    })\n\n                    constraints.push(sql.raw(jsonQuery))\n                    break\n                  }\n\n                  const jsonQuery = adapter.convertPathToJSONTraversal(pathSegments)\n                  const operatorKeys: Record<string, { operator: string; wildcard: string }> = {\n                    contains: { operator: 'like', wildcard: '%' },\n                    equals: { operator: '=', wildcard: '' },\n                    exists: { operator: val === true ? 'is not null' : 'is null', wildcard: '' },\n                    in: { operator: 'in', wildcard: '' },\n                    like: { operator: 'like', wildcard: '%' },\n                    not_equals: { operator: '<>', wildcard: '' },\n                    not_in: { operator: 'not in', wildcard: '' },\n                    not_like: { operator: 'not like', wildcard: '%' },\n                  }\n\n                  let formattedValue = val\n                  if (adapter.name === 'sqlite' && operator === 'equals' && !isNaN(val)) {\n                    formattedValue = val\n                  } else if (['in', 'not_in'].includes(operator) && Array.isArray(val)) {\n                    formattedValue = `(${val.map((v) => `${escapeSQLValue(v)}`).join(',')})`\n                  } else {\n                    formattedValue = `'${operatorKeys[operator].wildcard}${escapeSQLValue(val)}${operatorKeys[operator].wildcard}'`\n                  }\n                  if (operator === 'exists') {\n                    formattedValue = ''\n                  }\n\n                  let jsonQuerySelector = `${table[columnName].name}${jsonQuery}`\n\n                  if (adapter.name === 'sqlite' && operator === 'not_like') {\n                    jsonQuerySelector = `COALESCE(${table[columnName].name}${jsonQuery}, '')`\n                  }\n\n                  const rawSQLQuery = `${jsonQuerySelector} ${operatorKeys[operator].operator} ${formattedValue}`\n\n                  constraints.push(sql.raw(rawSQLQuery))\n\n                  break\n                }\n\n                if (getNotNullColumnByValue) {\n                  const columnName = getNotNullColumnByValue(val)\n                  if (columnName) {\n                    constraints.push(isNotNull(table[columnName]))\n                  } else {\n                    throw new QueryError([{ path: relationOrPath }])\n                  }\n                  break\n                }\n\n                if (\n                  operator === 'like' &&\n                  (field.type === 'number' ||\n                    field.type === 'relationship' ||\n                    field.type === 'upload' ||\n                    table[columnName].columnType === 'PgUUID')\n                ) {\n                  operator = 'equals'\n                }\n\n                if (operator === 'like') {\n                  constraints.push(\n                    and(\n                      ...val\n                        .split(' ')\n                        .map((word) => adapter.operators.like(table[columnName], `%${word}%`)),\n                    ),\n                  )\n                  break\n                }\n\n                const sanitizedQueryValue = sanitizeQueryValue({\n                  adapter,\n                  columns,\n                  field,\n                  isUUID: table?.[columnName] instanceof PgUUID,\n                  operator,\n                  relationOrPath,\n                  val,\n                })\n\n                if (sanitizedQueryValue === null) {\n                  break\n                }\n\n                const {\n                  columns: queryColumns,\n                  operator: queryOperator,\n                  value: queryValue,\n                } = sanitizedQueryValue\n\n                // Handle polymorphic relationships by value\n                if (queryColumns) {\n                  if (!queryColumns.length) {\n                    break\n                  }\n\n                  let wrapOperator = or\n\n                  if (queryValue === null && ['equals', 'not_equals'].includes(operator)) {\n                    if (operator === 'equals') {\n                      wrapOperator = and\n                    }\n\n                    constraints.push(\n                      wrapOperator(\n                        ...queryColumns.map(({ rawColumn }) =>\n                          operator === 'equals' ? isNull(rawColumn) : isNotNull(rawColumn),\n                        ),\n                      ),\n                    )\n                    break\n                  }\n\n                  if (['not_equals', 'not_in'].includes(operator)) {\n                    wrapOperator = and\n                  }\n\n                  constraints.push(\n                    wrapOperator(\n                      ...queryColumns.map(({ rawColumn, value }) =>\n                        adapter.operators[queryOperator](rawColumn, value),\n                      ),\n                    ),\n                  )\n\n                  break\n                }\n\n                if (queryOperator === 'not_equals' && queryValue !== null) {\n                  constraints.push(\n                    or(\n                      isNull(resolvedColumn),\n                      /* eslint-disable @typescript-eslint/no-explicit-any */\n                      ne<any>(resolvedColumn, queryValue),\n                    ),\n                  )\n                  break\n                }\n\n                if (\n                  (field.type === 'relationship' || field.type === 'upload') &&\n                  Array.isArray(queryValue) &&\n                  operator === 'not_in'\n                ) {\n                  constraints.push(\n                    sql`(${notInArray(table[columnName], queryValue)} OR\n                    ${table[columnName]}\n                    IS\n                    NULL)`,\n                  )\n\n                  break\n                }\n\n                if (operator === 'equals' && queryValue === null) {\n                  constraints.push(isNull(resolvedColumn))\n                  break\n                }\n\n                if (operator === 'not_equals' && queryValue === null) {\n                  constraints.push(isNotNull(resolvedColumn))\n                  break\n                }\n\n                if (field.type === 'point' && adapter.name === 'postgres') {\n                  switch (operator) {\n                    case 'intersects': {\n                      constraints.push(\n                        sql`ST_Intersects(${table[columnName]}, ST_GeomFromGeoJSON(${JSON.stringify(queryValue)}))`,\n                      )\n                      break\n                    }\n\n                    case 'near': {\n                      const [lng, lat, maxDistance, minDistance] = queryValue as number[]\n                      const geoConstraints: SQL[] = []\n\n                      if (typeof maxDistance === 'number' && !Number.isNaN(maxDistance)) {\n                        geoConstraints.push(\n                          sql`ST_DWithin(ST_Transform(${table[columnName]}, 3857), ST_Transform(ST_SetSRID(ST_MakePoint(${lng}, ${lat}), 4326), 3857), ${maxDistance})`,\n                        )\n                      }\n\n                      if (typeof minDistance === 'number' && !Number.isNaN(minDistance)) {\n                        geoConstraints.push(\n                          sql`ST_Distance(ST_Transform(${table[columnName]}, 3857), ST_Transform(ST_SetSRID(ST_MakePoint(${lng}, ${lat}), 4326), 3857)) >= ${minDistance}`,\n                        )\n                      }\n                      if (geoConstraints.length) {\n                        context.sort = relationOrPath\n                        context.rawSort = sql`${table[columnName]} <-> ST_SetSRID(ST_MakePoint(${lng}, ${lat}), 4326)`\n                        constraints.push(and(...geoConstraints))\n                      }\n                      break\n                    }\n\n                    case 'within': {\n                      constraints.push(\n                        sql`ST_Within(${table[columnName]}, ST_GeomFromGeoJSON(${JSON.stringify(queryValue)}))`,\n                      )\n                      break\n                    }\n\n                    default:\n                      break\n                  }\n                  break\n                }\n\n                const orConditions: SQL<unknown>[] = []\n                let resolvedQueryValue = queryValue\n                if (\n                  operator === 'in' &&\n                  Array.isArray(queryValue) &&\n                  queryValue.some((v) => v === null)\n                ) {\n                  orConditions.push(isNull(resolvedColumn))\n                  resolvedQueryValue = queryValue.filter((v) => v !== null)\n                }\n\n                let constraint = adapter.operators[queryOperator](\n                  resolvedColumn,\n                  resolvedQueryValue,\n                )\n\n                if (\n                  adapter.limitedBoundParameters &&\n                  (operator === 'in' || operator === 'not_in') &&\n                  relationOrPath === 'id' &&\n                  Array.isArray(queryValue)\n                ) {\n                  let isInvalid = false\n                  for (const val of queryValue) {\n                    if (typeof val === 'number' || val === null) {\n                      continue\n                    }\n                    if (typeof val === 'string') {\n                      if (!isValidStringID(val)) {\n                        isInvalid = true\n                        break\n                      } else {\n                        continue\n                      }\n                    }\n                    isInvalid = true\n                    break\n                  }\n\n                  if (isInvalid) {\n                    throw new APIError(`Invalid ID value in ${JSON.stringify(queryValue)}`)\n                  }\n\n                  constraints.push(\n                    sql.raw(\n                      `\"${getTableName(resolvedColumn.table)}\".\"${resolvedColumn.name}\" ${operator === 'in' ? 'IN' : 'NOT IN'} (${queryValue\n                        .map((e) => {\n                          if (e === null) {\n                            return `NULL`\n                          }\n\n                          if (typeof e === 'number') {\n                            return e\n                          }\n\n                          return `'${e}'`\n                        })\n                        .join(',')})`,\n                    ),\n                  )\n                  break\n                }\n\n                if (orConditions.length) {\n                  orConditions.push(constraint)\n                  constraint = or(...orConditions)\n                }\n                constraints.push(constraint)\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  if (constraints.length > 0) {\n    if (result) {\n      result = and(result, ...constraints)\n    } else {\n      result = and(...constraints)\n    }\n  }\n  if (constraints.length === 1 && !result) {\n    ;[result] = constraints\n  }\n\n  return result\n}\n"],"names":["and","getTableName","isNotNull","isNull","ne","notInArray","or","sql","PgUUID","APIError","QueryError","validOperatorSet","escapeSQLValue","getNameFromDrizzleTable","isValidStringID","DistinctSymbol","buildAndOrConditions","getTableColumnFromPath","sanitizeQueryValue","parseParams","adapter","aliasTable","context","fields","joins","locale","parentIsLocalized","selectFields","selectLocale","tableName","where","result","constraints","Object","keys","length","relationOrPath","condition","conditionOperator","toLowerCase","Array","isArray","builtConditions","pathOperators","operator","has","val","columnName","columns","queryConstraints","field","getNotNullColumnByValue","pathSegments","rawColumn","table","collectionPath","replace","split","value","resolvedColumn","forEach","col","constraintTable","indexOf","push","operators","like","equals","includes","type","blocksAsJSON","name","constraint","createJSONQuery","column","raw","segments","slice","unshift","jsonTable","getOwnPropertySymbols","jsonQuery","treatAsArray","treatRootAsArray","convertPathToJSONTraversal","operatorKeys","contains","wildcard","exists","in","not_equals","not_in","not_like","formattedValue","isNaN","map","v","join","jsonQuerySelector","rawSQLQuery","path","columnType","word","sanitizedQueryValue","isUUID","queryColumns","queryOperator","queryValue","wrapOperator","JSON","stringify","lng","lat","maxDistance","minDistance","geoConstraints","Number","sort","rawSort","orConditions","resolvedQueryValue","some","filter","limitedBoundParameters","isInvalid","e"],"mappings":"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"}},
    {"offset": {"line": 2033, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/queries/buildQuery.ts"],"sourcesContent":["import type { asc, desc, SQL, Table } from 'drizzle-orm'\nimport type { PgTableWithColumns } from 'drizzle-orm/pg-core'\nimport type { FlattenedField, Sort, Where } from 'payload'\n\nimport type { DrizzleAdapter, GenericColumn, GenericTable } from '../types.js'\nimport type { QueryContext } from './parseParams.js'\n\nimport { buildOrderBy } from './buildOrderBy.js'\nimport { parseParams } from './parseParams.js'\n\nexport type BuildQueryJoinAliases = {\n  condition: SQL\n  queryPath?: string\n  table: GenericTable | PgTableWithColumns<any>\n  type?: 'innerJoin' | 'leftJoin' | 'rightJoin'\n}[]\n\ntype BuildQueryArgs = {\n  adapter: DrizzleAdapter\n  aliasTable?: Table\n  fields: FlattenedField[]\n  joins?: BuildQueryJoinAliases\n  locale?: string\n  parentIsLocalized?: boolean\n  selectLocale?: boolean\n  sort?: Sort\n  tableName: string\n  where: Where\n}\n\nexport type BuildQueryResult = {\n  joins: BuildQueryJoinAliases\n  orderBy: {\n    column: GenericColumn\n    order: typeof asc | typeof desc\n  }[]\n  selectFields: Record<string, GenericColumn>\n  where: SQL\n}\n\nexport const buildQuery = function buildQuery({\n  adapter,\n  aliasTable,\n  fields,\n  joins = [],\n  locale,\n  parentIsLocalized,\n  selectLocale,\n  sort,\n  tableName,\n  where: incomingWhere,\n}: BuildQueryArgs): BuildQueryResult {\n  const selectFields: Record<string, GenericColumn> = {\n    id: adapter.tables[tableName].id,\n  }\n\n  let where: SQL\n\n  const context: QueryContext = { sort }\n  if (incomingWhere && Object.keys(incomingWhere).length > 0) {\n    where = parseParams({\n      adapter,\n      aliasTable,\n      context,\n      fields,\n      joins,\n      locale,\n      parentIsLocalized,\n      selectFields,\n      selectLocale,\n      tableName,\n      where: incomingWhere,\n    })\n  }\n\n  const orderBy = buildOrderBy({\n    adapter,\n    aliasTable,\n    fields,\n    joins,\n    locale,\n    parentIsLocalized,\n    rawSort: context.rawSort,\n    selectFields,\n    sort: context.sort,\n    tableName,\n  })\n\n  return {\n    joins,\n    orderBy,\n    selectFields,\n    where,\n  }\n}\n"],"names":["buildOrderBy","parseParams","buildQuery","adapter","aliasTable","fields","joins","locale","parentIsLocalized","selectLocale","sort","tableName","where","incomingWhere","selectFields","id","tables","context","Object","keys","length","orderBy","rawSort"],"mappings":";;;;AAOA,SAASA,YAAY,QAAQ,oBAAmB;AAChD,SAASC,WAAW,QAAQ,mBAAkB;;;AAgCvC,MAAMC,aAAa,SAASA,WAAW,EAC5CC,OAAO,EACPC,UAAU,EACVC,MAAM,EACNC,QAAQ,EAAE,EACVC,MAAM,EACNC,iBAAiB,EACjBC,YAAY,EACZC,IAAI,EACJC,SAAS,EACTC,OAAOC,aAAa,EACL;IACf,MAAMC,eAA8C;QAClDC,IAAIZ,QAAQa,MAAM,CAACL,UAAU,CAACI,EAAE;IAClC;IAEA,IAAIH;IAEJ,MAAMK,UAAwB;QAAEP;IAAK;IACrC,IAAIG,iBAAiBK,OAAOC,IAAI,CAACN,eAAeO,MAAM,GAAG,GAAG;QAC1DR,YAAQX,0LAAAA,EAAY;YAClBE;YACAC;YACAa;YACAZ;YACAC;YACAC;YACAC;YACAM;YACAL;YACAE;YACAC,OAAOC;QACT;IACF;IAEA,MAAMQ,cAAUrB,4LAAAA,EAAa;QAC3BG;QACAC;QACAC;QACAC;QACAC;QACAC;QACAc,SAASL,QAAQK,OAAO;QACxBR;QACAJ,MAAMO,QAAQP,IAAI;QAClBC;IACF;IAEA,OAAO;QACLL;QACAe;QACAP;QACAF;IACF;AACF,EAAC"}},
    {"offset": {"line": 2087, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/utilities/getTransaction.ts"],"sourcesContent":["import type { PayloadRequest } from 'payload'\n\nimport type { DrizzleAdapter } from '../types.js'\n\n/**\n * Returns current db transaction instance from req or adapter.drizzle itself\n *\n * If a transaction session doesn't exist (e.g., it was already committed/rolled back),\n * falls back to the default adapter.drizzle instance to prevent errors.\n */\nexport const getTransaction = async <T extends DrizzleAdapter = DrizzleAdapter>(\n  adapter: T,\n  req?: Partial<PayloadRequest>,\n): Promise<T['drizzle']> => {\n  if (!req?.transactionID) {\n    return adapter.drizzle\n  }\n\n  return (adapter.sessions[await req.transactionID]?.db as T['drizzle']) || adapter.drizzle\n}\n"],"names":["getTransaction","adapter","req","transactionID","drizzle","sessions","db"],"mappings":"AAIA;;;;;CAKC,GACD;;;;AAAO,MAAMA,iBAAiB,OAC5BC,SACAC;IAEA,IAAI,CAACA,KAAKC,eAAe;QACvB,OAAOF,QAAQG,OAAO;IACxB;IAEA,OAAQH,QAAQI,QAAQ,CAAC,MAAMH,IAAIC,aAAa,CAAC,EAAEG,MAAuBL,QAAQG,OAAO;AAC3F,EAAC"}},
    {"offset": {"line": 2106, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/count.ts"],"sourcesContent":["import type { Count, SanitizedCollectionConfig } from 'payload'\n\nimport toSnakeCase from 'to-snake-case'\n\nimport type { DrizzleAdapter } from './types.js'\n\nimport { buildQuery } from './queries/buildQuery.js'\nimport { getTransaction } from './utilities/getTransaction.js'\n\nexport const count: Count = async function count(\n  this: DrizzleAdapter,\n  { collection, locale, req, where: whereArg },\n) {\n  const collectionConfig: SanitizedCollectionConfig = this.payload.collections[collection].config\n\n  const tableName = this.tableNameMap.get(toSnakeCase(collectionConfig.slug))\n\n  const { joins, where } = buildQuery({\n    adapter: this,\n    fields: collectionConfig.flattenedFields,\n    locale,\n    tableName,\n    where: whereArg,\n  })\n\n  const db = await getTransaction(this, req)\n\n  const countResult = await this.countDistinct({\n    db,\n    joins,\n    tableName,\n    where,\n  })\n\n  return { totalDocs: countResult }\n}\n"],"names":["toSnakeCase","buildQuery","getTransaction","count","collection","locale","req","where","whereArg","collectionConfig","payload","collections","config","tableName","tableNameMap","get","slug","joins","adapter","fields","flattenedFields","db","countResult","countDistinct","totalDocs"],"mappings":";;;;AAEA,OAAOA,iBAAiB,gBAAe;AAIvC,SAASC,UAAU,QAAQ,0BAAyB;AACpD,SAASC,cAAc,QAAQ,gCAA+B;;;;AAEvD,MAAMC,QAAe,eAAeA,MAEzC,EAAEC,UAAU,EAAEC,MAAM,EAAEC,GAAG,EAAEC,OAAOC,QAAQ,EAAE;IAE5C,MAAMC,mBAA8C,IAAI,CAACC,OAAO,CAACC,WAAW,CAACP,WAAW,CAACQ,MAAM;IAE/F,MAAMC,YAAY,IAAI,CAACC,YAAY,CAACC,GAAG,KAACf,yJAAAA,EAAYS,iBAAiBO,IAAI;IAEzE,MAAM,EAAEC,KAAK,EAAEV,KAAK,EAAE,OAAGN,wLAAAA,EAAW;QAClCiB,SAAS,IAAI;QACbC,QAAQV,iBAAiBW,eAAe;QACxCf;QACAQ;QACAN,OAAOC;IACT;IAEA,MAAMa,KAAK,UAAMnB,kMAAAA,EAAe,IAAI,EAAEI;IAEtC,MAAMgB,cAAc,MAAM,IAAI,CAACC,aAAa,CAAC;QAC3CF;QACAJ;QACAJ;QACAN;IACF;IAEA,OAAO;QAAEiB,WAAWF;IAAY;AAClC,EAAC"}},
    {"offset": {"line": 2141, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/countGlobalVersions.ts"],"sourcesContent":["import type { CountGlobalVersions, SanitizedGlobalConfig } from 'payload'\n\nimport { buildVersionGlobalFields } from 'payload'\nimport toSnakeCase from 'to-snake-case'\n\nimport type { DrizzleAdapter } from './types.js'\n\nimport { buildQuery } from './queries/buildQuery.js'\nimport { getTransaction } from './utilities/getTransaction.js'\n\nexport const countGlobalVersions: CountGlobalVersions = async function countGlobalVersions(\n  this: DrizzleAdapter,\n  { global, locale, req, where: whereArg },\n) {\n  const globalConfig: SanitizedGlobalConfig = this.payload.globals.config.find(\n    ({ slug }) => slug === global,\n  )\n\n  const tableName = this.tableNameMap.get(\n    `_${toSnakeCase(globalConfig.slug)}${this.versionsSuffix}`,\n  )\n\n  const fields = buildVersionGlobalFields(this.payload.config, globalConfig, true)\n\n  const { joins, where } = buildQuery({\n    adapter: this,\n    fields,\n    locale,\n    tableName,\n    where: whereArg,\n  })\n\n  const db = await getTransaction(this, req)\n\n  const countResult = await this.countDistinct({\n    db,\n    joins,\n    tableName,\n    where,\n  })\n\n  return { totalDocs: countResult }\n}\n"],"names":["buildVersionGlobalFields","toSnakeCase","buildQuery","getTransaction","countGlobalVersions","global","locale","req","where","whereArg","globalConfig","payload","globals","config","find","slug","tableName","tableNameMap","get","versionsSuffix","fields","joins","adapter","db","countResult","countDistinct","totalDocs"],"mappings":";;;;AAEA,SAASA,wBAAwB,QAAQ,UAAS;AAClD,OAAOC,iBAAiB,gBAAe;AAIvC,SAASC,UAAU,QAAQ,0BAAyB;AACpD,SAASC,cAAc,QAAQ,gCAA+B;;;;;AAEvD,MAAMC,sBAA2C,eAAeA,oBAErE,EAAEC,MAAM,EAAEC,MAAM,EAAEC,GAAG,EAAEC,OAAOC,QAAQ,EAAE;IAExC,MAAMC,eAAsC,IAAI,CAACC,OAAO,CAACC,OAAO,CAACC,MAAM,CAACC,IAAI,CAC1E,CAAC,EAAEC,IAAI,EAAE,GAAKA,SAASV;IAGzB,MAAMW,YAAY,IAAI,CAACC,YAAY,CAACC,GAAG,CACrC,CAAC,CAAC,MAAEjB,yJAAAA,EAAYS,aAAaK,IAAI,IAAI,IAAI,CAACI,cAAc,EAAE;IAG5D,MAAMC,aAASpB,8LAAAA,EAAyB,IAAI,CAACW,OAAO,CAACE,MAAM,EAAEH,cAAc;IAE3E,MAAM,EAAEW,KAAK,EAAEb,KAAK,EAAE,OAAGN,wLAAAA,EAAW;QAClCoB,SAAS,IAAI;QACbF;QACAd;QACAU;QACAR,OAAOC;IACT;IAEA,MAAMc,KAAK,UAAMpB,kMAAAA,EAAe,IAAI,EAAEI;IAEtC,MAAMiB,cAAc,MAAM,IAAI,CAACC,aAAa,CAAC;QAC3CF;QACAF;QACAL;QACAR;IACF;IAEA,OAAO;QAAEkB,WAAWF;IAAY;AAClC,EAAC"}},
    {"offset": {"line": 2179, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/countVersions.ts"],"sourcesContent":["import type { CountVersions, SanitizedCollectionConfig } from 'payload'\n\nimport { buildVersionCollectionFields } from 'payload'\nimport toSnakeCase from 'to-snake-case'\n\nimport type { DrizzleAdapter } from './types.js'\n\nimport { buildQuery } from './queries/buildQuery.js'\nimport { getTransaction } from './utilities/getTransaction.js'\n\nexport const countVersions: CountVersions = async function countVersions(\n  this: DrizzleAdapter,\n  { collection, locale, req, where: whereArg },\n) {\n  const collectionConfig: SanitizedCollectionConfig = this.payload.collections[collection].config\n\n  const tableName = this.tableNameMap.get(\n    `_${toSnakeCase(collectionConfig.slug)}${this.versionsSuffix}`,\n  )\n\n  const fields = buildVersionCollectionFields(this.payload.config, collectionConfig, true)\n\n  const { joins, where } = buildQuery({\n    adapter: this,\n    fields,\n    locale,\n    tableName,\n    where: whereArg,\n  })\n\n  const db = await getTransaction(this, req)\n\n  const countResult = await this.countDistinct({\n    db,\n    joins,\n    tableName,\n    where,\n  })\n\n  return { totalDocs: countResult }\n}\n"],"names":["buildVersionCollectionFields","toSnakeCase","buildQuery","getTransaction","countVersions","collection","locale","req","where","whereArg","collectionConfig","payload","collections","config","tableName","tableNameMap","get","slug","versionsSuffix","fields","joins","adapter","db","countResult","countDistinct","totalDocs"],"mappings":";;;;AAEA,SAASA,4BAA4B,QAAQ,UAAS;AACtD,OAAOC,iBAAiB,gBAAe;AAIvC,SAASC,UAAU,QAAQ,0BAAyB;AACpD,SAASC,cAAc,QAAQ,gCAA+B;;;;;AAEvD,MAAMC,gBAA+B,eAAeA,cAEzD,EAAEC,UAAU,EAAEC,MAAM,EAAEC,GAAG,EAAEC,OAAOC,QAAQ,EAAE;IAE5C,MAAMC,mBAA8C,IAAI,CAACC,OAAO,CAACC,WAAW,CAACP,WAAW,CAACQ,MAAM;IAE/F,MAAMC,YAAY,IAAI,CAACC,YAAY,CAACC,GAAG,CACrC,CAAC,CAAC,MAAEf,yJAAAA,EAAYS,iBAAiBO,IAAI,IAAI,IAAI,CAACC,cAAc,EAAE;IAGhE,MAAMC,aAASnB,sMAAAA,EAA6B,IAAI,CAACW,OAAO,CAACE,MAAM,EAAEH,kBAAkB;IAEnF,MAAM,EAAEU,KAAK,EAAEZ,KAAK,EAAE,OAAGN,wLAAAA,EAAW;QAClCmB,SAAS,IAAI;QACbF;QACAb;QACAQ;QACAN,OAAOC;IACT;IAEA,MAAMa,KAAK,UAAMnB,kMAAAA,EAAe,IAAI,EAAEI;IAEtC,MAAMgB,cAAc,MAAM,IAAI,CAACC,aAAa,CAAC;QAC3CF;QACAF;QACAN;QACAN;IACF;IAEA,OAAO;QAAEiB,WAAWF;IAAY;AAClC,EAAC"}},
    {"offset": {"line": 2217, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/queries/operatorMap.ts"],"sourcesContent":["import {\n  and,\n  type Column,\n  eq,\n  gt,\n  gte,\n  ilike,\n  inArray,\n  isNotNull,\n  isNull,\n  lt,\n  lte,\n  ne,\n  notIlike,\n  notInArray,\n  or,\n  type SQL,\n} from 'drizzle-orm'\n\ntype OperatorKeys =\n  | 'and'\n  | 'contains'\n  | 'equals'\n  | 'exists'\n  | 'greater_than'\n  | 'greater_than_equal'\n  | 'in'\n  | 'isNull'\n  | 'less_than'\n  | 'less_than_equal'\n  | 'like'\n  | 'not_equals'\n  | 'not_in'\n  | 'not_like'\n  | 'or'\n\nexport type Operators = Record<OperatorKeys, (column: Column, value: unknown) => SQL>\n\nexport const operatorMap: Operators = {\n  and,\n  contains: ilike,\n  equals: eq,\n  exists: isNotNull,\n  greater_than: gt,\n  greater_than_equal: gte,\n  in: inArray,\n  isNull, // handles exists: false\n  less_than: lt,\n  less_than_equal: lte,\n  like: ilike,\n  not_equals: ne,\n  not_like: notIlike,\n  // TODO: support this\n  // all: all,\n  not_in: notInArray,\n  or,\n}\n"],"names":["and","eq","gt","gte","ilike","inArray","isNotNull","isNull","lt","lte","ne","notIlike","notInArray","or","operatorMap","contains","equals","exists","greater_than","greater_than_equal","in","less_than","less_than_equal","like","not_equals","not_like","not_in"],"mappings":";;;;AAAA,SACEA,GAAG,EAEHC,EAAE,EACFC,EAAE,EACFC,GAAG,EACHC,KAAK,EACLC,OAAO,EACPC,SAAS,EACTC,MAAM,EACNC,EAAE,EACFC,GAAG,EACHC,EAAE,EACFC,QAAQ,EACRC,UAAU,EACVC,EAAE,QAEG,cAAa;;AAqBb,MAAMC,cAAyB;SACpCd,2KAAAA;IACAe,UAAUX,6KAAAA;IACVY,QAAQf,0KAAAA;IACRgB,QAAQX,iLAAAA;IACRY,cAAchB,0KAAAA;IACdiB,oBAAoBhB,2KAAAA;IACpBiB,IAAIf,+KAAAA;YACJE,8KAAAA;IACAc,WAAWb,0KAAAA;IACXc,iBAAiBb,2KAAAA;IACjBc,MAAMnB,6KAAAA;IACNoB,YAAYd,0KAAAA;IACZe,UAAUd,gLAAAA;IACV,qBAAqB;IACrB,YAAY;IACZe,QAAQd,kLAAAA;QACRC,0KAAAA;AACF,EAAC"}},
    {"offset": {"line": 2246, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/utilities/getArrayRelationName.ts"],"sourcesContent":["import type { ArrayField } from 'payload'\n\nexport const getArrayRelationName = ({\n  field,\n  path,\n  tableName,\n}: {\n  field: ArrayField\n  path: string\n  tableName: string\n}) => {\n  if (field.dbName && path.length > 63) {\n    return `_${tableName}`\n  }\n\n  return path\n}\n"],"names":["getArrayRelationName","field","path","tableName","dbName","length"],"mappings":";;;;AAEO,MAAMA,uBAAuB,CAAC,EACnCC,KAAK,EACLC,IAAI,EACJC,SAAS,EAKV;IACC,IAAIF,MAAMG,MAAM,IAAIF,KAAKG,MAAM,GAAG,IAAI;QACpC,OAAO,CAAC,CAAC,EAAEF,WAAW;IACxB;IAEA,OAAOD;AACT,EAAC"}},
    {"offset": {"line": 2260, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/find/traverseFields.ts"],"sourcesContent":["import type { LibSQLDatabase } from 'drizzle-orm/libsql'\nimport type { SQLiteSelect, SQLiteSelectBase } from 'drizzle-orm/sqlite-core'\n\nimport { and, asc, count, desc, eq, getTableName, or, sql } from 'drizzle-orm'\nimport {\n  appendVersionToQueryKey,\n  buildVersionCollectionFields,\n  combineQueries,\n  type FlattenedField,\n  getFieldByPath,\n  getQueryDraftsSort,\n  type JoinQuery,\n  type SelectMode,\n  type SelectType,\n  type Where,\n} from 'payload'\nimport { fieldIsVirtual, fieldShouldBeLocalized, hasDraftsEnabled } from 'payload/shared'\nimport toSnakeCase from 'to-snake-case'\n\nimport type { BuildQueryJoinAliases, DrizzleAdapter } from '../types.js'\nimport type { Result } from './buildFindManyArgs.js'\n\nimport { buildQuery } from '../queries/buildQuery.js'\nimport { getTableAlias } from '../queries/getTableAlias.js'\nimport { operatorMap } from '../queries/operatorMap.js'\nimport { getArrayRelationName } from '../utilities/getArrayRelationName.js'\nimport { getNameFromDrizzleTable } from '../utilities/getNameFromDrizzleTable.js'\nimport { jsonAggBuildObject } from '../utilities/json.js'\nimport { rawConstraint } from '../utilities/rawConstraint.js'\nimport {\n  InternalBlockTableNameIndex,\n  resolveBlockTableName,\n} from '../utilities/validateExistingBlockIsIdentical.js'\n\nconst flattenAllWherePaths = (where: Where, paths: { path: string; ref: any }[]) => {\n  for (const k in where) {\n    if (['AND', 'OR'].includes(k.toUpperCase())) {\n      if (Array.isArray(where[k])) {\n        for (const whereField of where[k]) {\n          flattenAllWherePaths(whereField, paths)\n        }\n      }\n    } else {\n      // TODO: explore how to support arrays/relationship querying.\n      paths.push({ path: k.split('.').join('_'), ref: where })\n    }\n  }\n}\n\nconst buildSQLWhere = (where: Where, alias: string) => {\n  for (const k in where) {\n    if (['AND', 'OR'].includes(k.toUpperCase())) {\n      if (Array.isArray(where[k])) {\n        const op = 'AND' === k.toUpperCase() ? and : or\n        const accumulated = []\n        for (const whereField of where[k]) {\n          accumulated.push(buildSQLWhere(whereField, alias))\n        }\n        return op(...accumulated)\n      }\n    } else {\n      let payloadOperator = Object.keys(where[k])[0]\n\n      const value = where[k][payloadOperator]\n      if (payloadOperator === '$raw') {\n        return sql.raw(value)\n      }\n\n      // Handle exists: false -> use isNull instead of isNotNull\n\n      // This logic is duplicated from sanitizeQueryValue.ts because buildSQLWhere\n      // is a simplified WHERE builder for polymorphic joins that doesn't have access\n      // to field definitions needed by sanitizeQueryValue\n      if (payloadOperator === 'exists' && value === false) {\n        payloadOperator = 'isNull'\n      }\n\n      return operatorMap[payloadOperator](sql.raw(`\"${alias}\".\"${k.split('.').join('_')}\"`), value)\n    }\n  }\n}\n\ntype SQLSelect = SQLiteSelectBase<any, any, any, any>\n\ntype TraverseFieldArgs = {\n  _locales: Result\n  adapter: DrizzleAdapter\n  collectionSlug?: string\n  currentArgs: Result\n  currentTableName: string\n  depth?: number\n  draftsEnabled?: boolean\n  fields: FlattenedField[]\n  forceWithFields?: boolean\n  joinQuery: JoinQuery\n  joins?: BuildQueryJoinAliases\n  locale?: string\n  parentIsLocalized?: boolean\n  path: string\n  select?: SelectType\n  selectAllOnCurrentLevel?: boolean\n  selectMode?: SelectMode\n  tablePath: string\n  topLevelArgs: Record<string, unknown>\n  topLevelTableName: string\n  versions?: boolean\n  withTabledFields: {\n    numbers?: boolean\n    rels?: boolean\n    texts?: boolean\n  }\n}\n\nexport const traverseFields = ({\n  _locales,\n  adapter,\n  collectionSlug,\n  currentArgs,\n  currentTableName,\n  depth,\n  draftsEnabled,\n  fields,\n  forceWithFields,\n  joinQuery = {},\n  joins,\n  locale,\n  parentIsLocalized = false,\n  path,\n  select,\n  selectAllOnCurrentLevel = false,\n  selectMode,\n  tablePath,\n  topLevelArgs,\n  topLevelTableName,\n  versions,\n  withTabledFields,\n}: TraverseFieldArgs) => {\n  fields.forEach((field) => {\n    if (fieldIsVirtual(field)) {\n      return\n    }\n\n    const isFieldLocalized = fieldShouldBeLocalized({\n      field,\n      parentIsLocalized,\n    })\n\n    // handle simple relationship\n    if (\n      depth > 0 &&\n      (field.type === 'upload' || field.type === 'relationship') &&\n      !field.hasMany &&\n      typeof field.relationTo === 'string'\n    ) {\n      if (isFieldLocalized) {\n        _locales.with[`${path}${field.name}`] = true\n      } else {\n        currentArgs.with[`${path}${field.name}`] = true\n      }\n    }\n\n    switch (field.type) {\n      case 'array': {\n        const arraySelect = selectAllOnCurrentLevel ? true : select?.[field.name]\n\n        if (select) {\n          if (\n            (selectMode === 'include' && typeof arraySelect === 'undefined') ||\n            (selectMode === 'exclude' && arraySelect === false)\n          ) {\n            break\n          }\n        }\n\n        const withArray: Result = {\n          columns:\n            typeof arraySelect === 'object'\n              ? {\n                  id: true,\n                  _order: true,\n                }\n              : {\n                  _parentID: false,\n                },\n          orderBy: ({ _order }, { asc }) => [asc(_order)],\n          with: {},\n        }\n\n        const arrayTableName = adapter.tableNameMap.get(\n          `${currentTableName}_${tablePath}${toSnakeCase(field.name)}`,\n        )\n\n        if (typeof arraySelect === 'object') {\n          if (adapter.tables[arrayTableName]._locale) {\n            withArray.columns._locale = true\n          }\n\n          if (adapter.tables[arrayTableName]._uuid) {\n            withArray.columns._uuid = true\n          }\n        }\n\n        const arrayTableNameWithLocales = `${arrayTableName}${adapter.localesSuffix}`\n\n        if (adapter.tables[arrayTableNameWithLocales]) {\n          withArray.with._locales = {\n            columns:\n              typeof arraySelect === 'object'\n                ? {\n                    _locale: true,\n                  }\n                : {\n                    id: false,\n                    _parentID: false,\n                  },\n            with: {},\n          }\n        }\n\n        const relationName = getArrayRelationName({\n          field,\n          path: `${path}${field.name}`,\n          tableName: arrayTableName,\n        })\n\n        currentArgs.with[relationName] = withArray\n\n        traverseFields({\n          _locales: withArray.with._locales,\n          adapter,\n          currentArgs: withArray,\n          currentTableName: arrayTableName,\n          depth,\n          draftsEnabled,\n          fields: field.flattenedFields,\n          forceWithFields,\n          joinQuery,\n          locale,\n          parentIsLocalized: parentIsLocalized || field.localized,\n          path: '',\n          select: typeof arraySelect === 'object' ? arraySelect : undefined,\n          selectMode,\n          tablePath: '',\n          topLevelArgs,\n          topLevelTableName,\n          withTabledFields,\n        })\n\n        if (\n          typeof arraySelect === 'object' &&\n          withArray.with._locales &&\n          Object.keys(withArray.with._locales).length === 1\n        ) {\n          delete withArray.with._locales\n        }\n\n        break\n      }\n\n      case 'blocks': {\n        const blocksSelect = selectAllOnCurrentLevel ? true : select?.[field.name]\n\n        if (select) {\n          if (\n            (selectMode === 'include' && !blocksSelect) ||\n            (selectMode === 'exclude' && blocksSelect === false)\n          ) {\n            break\n          }\n        }\n\n        if (adapter.blocksAsJSON) {\n          if (select || selectAllOnCurrentLevel) {\n            const fieldPath = `${path}${field.name}`\n\n            if ((isFieldLocalized || parentIsLocalized) && _locales) {\n              _locales.columns[fieldPath] = true\n            } else if (adapter.tables[currentTableName]?.[fieldPath]) {\n              currentArgs.columns[fieldPath] = true\n            }\n          }\n\n          break\n        }\n\n        ;(field.blockReferences ?? field.blocks).forEach((_block) => {\n          const block = typeof _block === 'string' ? adapter.payload.blocks[_block] : _block\n          const blockKey = `_blocks_${block.slug}${!block[InternalBlockTableNameIndex] ? '' : `_${block[InternalBlockTableNameIndex]}`}`\n\n          let blockSelect: boolean | SelectType | undefined\n\n          let blockSelectMode = selectMode\n\n          if (selectMode === 'include' && blocksSelect === true) {\n            blockSelect = true\n          }\n\n          if (typeof blocksSelect === 'object') {\n            if (typeof blocksSelect[block.slug] === 'object') {\n              blockSelect = blocksSelect[block.slug]\n            } else if (\n              (selectMode === 'include' && typeof blocksSelect[block.slug] === 'undefined') ||\n              (selectMode === 'exclude' && blocksSelect[block.slug] === false)\n            ) {\n              blockSelect = {}\n              blockSelectMode = 'include'\n            } else if (selectMode === 'include' && Boolean(blocksSelect[block.slug])) {\n              blockSelect = true\n            }\n          }\n\n          if (!topLevelArgs[blockKey]) {\n            const withBlock: Result = {\n              columns:\n                typeof blockSelect === 'object'\n                  ? {\n                      id: true,\n                      _order: true,\n                      _path: true,\n                    }\n                  : {\n                      _parentID: false,\n                    },\n              orderBy: ({ _order }, { asc }) => [asc(_order)],\n              with: {},\n            }\n\n            const tableName = resolveBlockTableName(\n              block,\n              adapter.tableNameMap.get(`${topLevelTableName}_blocks_${toSnakeCase(block.slug)}`),\n            )\n\n            if (typeof blockSelect === 'object') {\n              if (adapter.tables[tableName]._locale) {\n                withBlock.columns._locale = true\n              }\n\n              if (adapter.tables[tableName]._uuid) {\n                withBlock.columns._uuid = true\n              }\n            }\n\n            if (adapter.tables[`${tableName}${adapter.localesSuffix}`]) {\n              withBlock.with._locales = {\n                with: {},\n              }\n\n              if (typeof blockSelect === 'object') {\n                withBlock.with._locales.columns = {\n                  _locale: true,\n                }\n              }\n            }\n            topLevelArgs.with[blockKey] = withBlock\n\n            traverseFields({\n              _locales: withBlock.with._locales,\n              adapter,\n              currentArgs: withBlock,\n              currentTableName: tableName,\n              depth,\n              draftsEnabled,\n              fields: block.flattenedFields,\n              forceWithFields: blockSelect === true,\n              joinQuery,\n              locale,\n              parentIsLocalized: parentIsLocalized || field.localized,\n              path: '',\n              select: typeof blockSelect === 'object' ? blockSelect : undefined,\n              selectMode: blockSelectMode,\n              tablePath: '',\n              topLevelArgs,\n              topLevelTableName,\n              withTabledFields,\n            })\n\n            if (\n              typeof blockSelect === 'object' &&\n              withBlock.with._locales &&\n              Object.keys(withBlock.with._locales.columns).length === 1\n            ) {\n              delete withBlock.with._locales\n            }\n          }\n        })\n\n        break\n      }\n\n      case 'group':\n      case 'tab': {\n        const fieldSelect = select?.[field.name]\n\n        if (fieldSelect === false) {\n          break\n        }\n\n        traverseFields({\n          _locales,\n          adapter,\n          collectionSlug,\n          currentArgs,\n          currentTableName,\n          depth,\n          draftsEnabled,\n          fields: field.flattenedFields,\n          forceWithFields,\n          joinQuery,\n          joins,\n          locale,\n          parentIsLocalized: parentIsLocalized || field.localized,\n          path: `${path}${field.name}_`,\n          select: typeof fieldSelect === 'object' ? fieldSelect : undefined,\n          selectAllOnCurrentLevel:\n            selectAllOnCurrentLevel ||\n            fieldSelect === true ||\n            (selectMode === 'exclude' && typeof fieldSelect === 'undefined'),\n          selectMode,\n          tablePath: `${tablePath}${toSnakeCase(field.name)}_`,\n          topLevelArgs,\n          topLevelTableName,\n          versions,\n          withTabledFields,\n        })\n\n        break\n      }\n      case 'join': {\n        // when `joinsQuery` is false, do not join\n        if (joinQuery === false) {\n          break\n        }\n\n        if (\n          (select && selectMode === 'include' && !select[field.name]) ||\n          (selectMode === 'exclude' && select[field.name] === false)\n        ) {\n          break\n        }\n\n        const joinSchemaPath = `${path.replaceAll('_', '.')}${field.name}`\n\n        if (joinQuery[joinSchemaPath] === false) {\n          break\n        }\n\n        const {\n          count: shouldCount = false,\n          limit: limitArg = field.defaultLimit ?? 10,\n          page,\n          sort = field.defaultSort,\n          where,\n        } = joinQuery[joinSchemaPath] || {}\n        let limit = limitArg\n\n        if (limit !== 0) {\n          // get an additional document and slice it later to determine if there is a next page\n          limit += 1\n        }\n\n        const columnName = `${path.replaceAll('.', '_')}${field.name}`\n\n        const db = adapter.drizzle as LibSQLDatabase\n\n        if (Array.isArray(field.collection)) {\n          let currentQuery: null | SQLSelect = null\n          const onPath = field.on.split('.').join('_')\n\n          if (Array.isArray(sort)) {\n            throw new Error('Not implemented')\n          }\n\n          let sanitizedSort = sort\n\n          if (!sanitizedSort) {\n            if (\n              field.collection.some((collection) =>\n                adapter.payload.collections[collection].config.fields.some(\n                  (f) => f.type === 'date' && f.name === 'createdAt',\n                ),\n              )\n            ) {\n              sanitizedSort = '-createdAt'\n            } else {\n              sanitizedSort = 'id'\n            }\n          }\n\n          const sortOrder = sanitizedSort.startsWith('-') ? desc : asc\n          sanitizedSort = sanitizedSort.replace('-', '')\n\n          const sortPath = sanitizedSort.split('.').join('_')\n\n          const wherePaths: { path: string; ref: any }[] = []\n\n          if (where) {\n            flattenAllWherePaths(where, wherePaths)\n          }\n\n          for (const collection of field.collection) {\n            const joinCollectionTableName = adapter.tableNameMap.get(toSnakeCase(collection))\n\n            const table = adapter.tables[joinCollectionTableName]\n\n            const sortColumn = table[sortPath]\n\n            const selectFields = {\n              id: adapter.tables[joinCollectionTableName].id,\n              parent: sql`${adapter.tables[joinCollectionTableName][onPath]}`.as(onPath),\n              relationTo: sql`${collection}`.as('relationTo'),\n              sortPath: sql`${sortColumn ? sortColumn : null}`.as('sortPath'),\n            }\n\n            const collectionQueryWhere: any[] = []\n            // Select for WHERE and Fallback NULL\n            for (const { path, ref } of wherePaths) {\n              const collectioConfig = adapter.payload.collections[collection].config\n              const field = getFieldByPath({ fields: collectioConfig.flattenedFields, path })\n\n              if (field && field.field.type === 'select' && field.field.hasMany) {\n                let tableName = adapter.tableNameMap.get(\n                  `${toSnakeCase(collection)}_${toSnakeCase(path)}`,\n                )\n                let parentTable = getTableName(table)\n\n                if (adapter.schemaName) {\n                  tableName = `\"${adapter.schemaName}\".\"${tableName}\"`\n                  parentTable = `\"${adapter.schemaName}\".\"${parentTable}\"`\n                }\n\n                if (adapter.name === 'postgres') {\n                  selectFields[path] = sql\n                    .raw(\n                      `(select jsonb_agg(${tableName}.value) from ${tableName} where ${tableName}.parent_id = ${parentTable}.id)`,\n                    )\n                    .as(path)\n                } else {\n                  selectFields[path] = sql\n                    .raw(\n                      `(select json_group_array(${tableName}.value) from ${tableName} where ${tableName}.parent_id = ${parentTable}.id)`,\n                    )\n                    .as(path)\n                }\n\n                const constraint = ref[path]\n                const operator = Object.keys(constraint)[0]\n                const value: any = Object.values(constraint)[0]\n\n                const query = adapter.createJSONQuery({\n                  column: `\"${path}\"`,\n                  operator,\n                  pathSegments: [field.field.name],\n                  table: parentTable,\n                  value,\n                })\n                ref[path] = { $raw: query }\n              } else if (adapter.tables[joinCollectionTableName][path]) {\n                selectFields[path] = sql`${adapter.tables[joinCollectionTableName][path]}`.as(path)\n                // Allow to filter by collectionSlug\n              } else if (path !== 'relationTo') {\n                // For timestamp fields like deletedAt, we need to cast to timestamp in Postgres\n                // SQLite doesn't require explicit type casting for UNION queries\n                if (path === 'deletedAt' && adapter.name === 'postgres') {\n                  selectFields[path] = sql`null::timestamp with time zone`.as(path)\n                } else {\n                  selectFields[path] = sql`null`.as(path)\n                }\n              }\n            }\n\n            let query: any = db.select(selectFields).from(adapter.tables[joinCollectionTableName])\n            if (collectionQueryWhere.length) {\n              query = query.where(and(...collectionQueryWhere))\n            }\n            if (currentQuery === null) {\n              currentQuery = query as unknown as SQLSelect\n            } else {\n              currentQuery = currentQuery.unionAll(query) as SQLSelect\n            }\n          }\n\n          const subQueryAlias = `${columnName}_subquery`\n\n          let sqlWhere = eq(\n            sql.raw(`\"${currentTableName}\".\"id\"`),\n            sql.raw(`\"${subQueryAlias}\".\"${onPath}\"`),\n          )\n\n          if (where && Object.keys(where).length > 0) {\n            sqlWhere = and(sqlWhere, buildSQLWhere(where, subQueryAlias))\n          }\n\n          if (shouldCount) {\n            currentArgs.extras[`${columnName}_count`] = sql`${db\n              .select({ count: count() })\n              .from(sql`${currentQuery.as(subQueryAlias)}`)\n              .where(sqlWhere)}`.as(`${columnName}_count`)\n          }\n\n          currentQuery = currentQuery.orderBy(sortOrder(sql`\"sortPath\"`)) as SQLSelect\n\n          if (page && limit !== 0) {\n            const offset = (page - 1) * limit\n            if (offset > 0) {\n              currentQuery = currentQuery.offset(offset) as SQLSelect\n            }\n          }\n\n          if (limit) {\n            currentQuery = currentQuery.limit(limit) as SQLSelect\n          }\n\n          currentArgs.extras[columnName] = sql`${db\n            .select({\n              id: jsonAggBuildObject(adapter, {\n                id: sql.raw(`\"${subQueryAlias}\".\"id\"`),\n                relationTo: sql.raw(`\"${subQueryAlias}\".\"relationTo\"`),\n              }),\n            })\n            .from(sql`${currentQuery.as(subQueryAlias)}`)\n            .where(sqlWhere)}`.as(columnName)\n        } else {\n          const useDrafts =\n            (versions || draftsEnabled) &&\n            hasDraftsEnabled(adapter.payload.collections[field.collection].config)\n\n          const fields = useDrafts\n            ? buildVersionCollectionFields(\n                adapter.payload.config,\n                adapter.payload.collections[field.collection].config,\n                true,\n              )\n            : adapter.payload.collections[field.collection].config.flattenedFields\n\n          const joinCollectionTableName = adapter.tableNameMap.get(\n            useDrafts\n              ? `_${toSnakeCase(field.collection)}${adapter.versionsSuffix}`\n              : toSnakeCase(field.collection),\n          )\n\n          const joins: BuildQueryJoinAliases = []\n\n          const currentIDColumn = versions\n            ? adapter.tables[currentTableName].parent\n            : adapter.tables[currentTableName].id\n\n          let joinQueryWhere: Where\n\n          const currentIDRaw = sql.raw(\n            `\"${getNameFromDrizzleTable(currentIDColumn.table)}\".\"${currentIDColumn.name}\"`,\n          )\n\n          if (Array.isArray(field.targetField.relationTo)) {\n            joinQueryWhere = {\n              [field.on]: {\n                equals: {\n                  relationTo: collectionSlug,\n                  value: rawConstraint(currentIDRaw),\n                },\n              },\n            }\n          } else {\n            joinQueryWhere = {\n              [field.on]: {\n                equals: rawConstraint(currentIDRaw),\n              },\n            }\n          }\n\n          if (where && Object.keys(where).length) {\n            joinQueryWhere = {\n              and: [joinQueryWhere, where],\n            }\n          }\n\n          if (useDrafts) {\n            joinQueryWhere = combineQueries(appendVersionToQueryKey(joinQueryWhere), {\n              latest: { equals: true },\n            })\n          }\n\n          const columnName = `${path.replaceAll('.', '_')}${field.name}`\n\n          const subQueryAlias = `${columnName}_alias`\n\n          const { newAliasTable } = getTableAlias({\n            adapter,\n            tableName: joinCollectionTableName,\n          })\n\n          const {\n            orderBy,\n            selectFields,\n            where: subQueryWhere,\n          } = buildQuery({\n            adapter,\n            aliasTable: newAliasTable,\n            fields,\n            joins,\n            locale,\n            parentIsLocalized,\n            selectLocale: true,\n            sort: useDrafts\n              ? getQueryDraftsSort({\n                  collectionConfig: adapter.payload.collections[field.collection].config,\n                  sort,\n                })\n              : sort,\n            tableName: joinCollectionTableName,\n            where: joinQueryWhere,\n          })\n\n          for (let key in selectFields) {\n            const val = selectFields[key]\n\n            if (val.table && getNameFromDrizzleTable(val.table) === joinCollectionTableName) {\n              delete selectFields[key]\n              key = key.split('.').pop()\n              selectFields[key] = newAliasTable[key]\n            }\n          }\n\n          if (useDrafts) {\n            selectFields.parent = newAliasTable.parent\n          }\n\n          let query: SQLiteSelect = db\n            .select(selectFields as any)\n            .from(newAliasTable)\n            .where(subQueryWhere)\n            .orderBy(() => orderBy.map(({ column, order }) => order(column)))\n            .$dynamic()\n\n          joins.forEach(({ type, condition, table }) => {\n            query = query[type ?? 'leftJoin'](table, condition)\n          })\n\n          if (page && limit !== 0) {\n            const offset = (page - 1) * limit - 1\n            if (offset > 0) {\n              query = query.offset(offset)\n            }\n          }\n\n          if (limit !== 0) {\n            query = query.limit(limit)\n          }\n\n          const subQuery = query.as(subQueryAlias)\n\n          if (shouldCount) {\n            let countSubquery: SQLiteSelect = db\n              .select(selectFields as any)\n\n              .from(newAliasTable)\n              .where(subQueryWhere)\n              .$dynamic()\n\n            joins.forEach(({ type, condition, table }) => {\n              countSubquery = countSubquery[type ?? 'leftJoin'](table, condition)\n            })\n\n            currentArgs.extras[`${columnName}_count`] = sql`${db\n              .select({\n                count: count(),\n              })\n              .from(sql`${countSubquery.as(`${subQueryAlias}_count_subquery`)}`)}`.as(\n              `${subQueryAlias}_count`,\n            )\n          }\n\n          currentArgs.extras[columnName] = sql`${db\n            .select({\n              result: jsonAggBuildObject(adapter, {\n                id: sql.raw(`\"${subQueryAlias}\".${useDrafts ? 'parent_id' : 'id'}`),\n                ...(selectFields._locale && {\n                  locale: sql.raw(`\"${subQueryAlias}\".${selectFields._locale.name}`),\n                }),\n              }),\n            })\n            .from(sql`${subQuery}`)}`.as(subQueryAlias)\n        }\n\n        break\n      }\n\n      case 'point': {\n        if (adapter.name === 'sqlite') {\n          break\n        }\n\n        const args = isFieldLocalized ? _locales : currentArgs\n        if (!args.columns) {\n          args.columns = {}\n        }\n\n        if (!args.extras) {\n          args.extras = {}\n        }\n\n        const name = `${path}${field.name}`\n\n        // Drizzle handles that poorly. See https://github.com/drizzle-team/drizzle-orm/issues/2526\n        // Additionally, this way we format the column value straight in the database using ST_AsGeoJSON\n        args.columns[name] = false\n\n        let shouldSelect = false\n\n        if (select || selectAllOnCurrentLevel) {\n          if (\n            selectAllOnCurrentLevel ||\n            (selectMode === 'include' && Boolean(select[field.name])) ||\n            (selectMode === 'exclude' && typeof select[field.name] === 'undefined')\n          ) {\n            shouldSelect = true\n          }\n        } else {\n          shouldSelect = true\n        }\n        const tableName = fieldShouldBeLocalized({ field, parentIsLocalized })\n          ? `${currentTableName}${adapter.localesSuffix}`\n          : currentTableName\n\n        if (shouldSelect) {\n          args.extras[name] = sql\n            .raw(`ST_AsGeoJSON(\"${adapter.tables[tableName][name].name}\")::jsonb`)\n            .as(name)\n        }\n        break\n      }\n\n      case 'select': {\n        if (select && !selectAllOnCurrentLevel) {\n          if (\n            (selectMode === 'include' && !select[field.name]) ||\n            (selectMode === 'exclude' && select[field.name] === false)\n          ) {\n            break\n          }\n        }\n\n        if (field.hasMany) {\n          const withSelect: Result = {\n            columns: {\n              id: false,\n              order: false,\n              parent: false,\n            },\n            orderBy: ({ order }, { asc }) => [asc(order)],\n          }\n\n          currentArgs.with[`${path}${field.name}`] = withSelect\n          break\n        }\n\n        if (select || selectAllOnCurrentLevel) {\n          const fieldPath = `${path}${field.name}`\n\n          if ((isFieldLocalized || parentIsLocalized) && _locales) {\n            _locales.columns[fieldPath] = true\n          } else if (adapter.tables[currentTableName]?.[fieldPath]) {\n            currentArgs.columns[fieldPath] = true\n          }\n        }\n\n        break\n      }\n\n      default: {\n        if (forceWithFields) {\n          if (\n            (field.type === 'relationship' || field.type === 'upload') &&\n            (field.hasMany || Array.isArray(field.relationTo))\n          ) {\n            withTabledFields.rels = true\n          }\n\n          if (field.type === 'number' && field.hasMany) {\n            withTabledFields.numbers = true\n          }\n\n          if (field.type === 'text' && field.hasMany) {\n            withTabledFields.texts = true\n          }\n        }\n\n        if (!select && !selectAllOnCurrentLevel) {\n          break\n        }\n\n        if (\n          selectAllOnCurrentLevel ||\n          (selectMode === 'include' && Boolean(select[field.name])) ||\n          (selectMode === 'exclude' && typeof select[field.name] === 'undefined')\n        ) {\n          const fieldPath = `${path}${field.name}`\n\n          if ((isFieldLocalized || parentIsLocalized) && _locales) {\n            _locales.columns[fieldPath] = true\n          } else if (adapter.tables[currentTableName]?.[fieldPath]) {\n            currentArgs.columns[fieldPath] = true\n          }\n\n          if (\n            !withTabledFields.rels &&\n            (field.type === 'relationship' || field.type === 'upload') &&\n            (field.hasMany || Array.isArray(field.relationTo))\n          ) {\n            withTabledFields.rels = true\n          }\n\n          if (!withTabledFields.numbers && field.type === 'number' && field.hasMany) {\n            withTabledFields.numbers = true\n          }\n\n          if (!withTabledFields.texts && field.type === 'text' && field.hasMany) {\n            withTabledFields.texts = true\n          }\n        }\n\n        break\n      }\n    }\n  })\n\n  return topLevelArgs\n}\n"],"names":["and","asc","count","desc","eq","getTableName","or","sql","appendVersionToQueryKey","buildVersionCollectionFields","combineQueries","getFieldByPath","getQueryDraftsSort","fieldIsVirtual","fieldShouldBeLocalized","hasDraftsEnabled","toSnakeCase","buildQuery","getTableAlias","operatorMap","getArrayRelationName","getNameFromDrizzleTable","jsonAggBuildObject","rawConstraint","InternalBlockTableNameIndex","resolveBlockTableName","flattenAllWherePaths","where","paths","k","includes","toUpperCase","Array","isArray","whereField","push","path","split","join","ref","buildSQLWhere","alias","op","accumulated","payloadOperator","Object","keys","value","raw","traverseFields","_locales","adapter","collectionSlug","currentArgs","currentTableName","depth","draftsEnabled","fields","forceWithFields","joinQuery","joins","locale","parentIsLocalized","select","selectAllOnCurrentLevel","selectMode","tablePath","topLevelArgs","topLevelTableName","versions","withTabledFields","forEach","field","isFieldLocalized","type","hasMany","relationTo","with","name","arraySelect","withArray","columns","id","_order","_parentID","orderBy","arrayTableName","tableNameMap","get","tables","_locale","_uuid","arrayTableNameWithLocales","localesSuffix","relationName","tableName","flattenedFields","localized","undefined","length","blocksSelect","blocksAsJSON","fieldPath","blockReferences","blocks","_block","block","payload","blockKey","slug","blockSelect","blockSelectMode","Boolean","withBlock","_path","fieldSelect","joinSchemaPath","replaceAll","shouldCount","limit","limitArg","defaultLimit","page","sort","defaultSort","columnName","db","drizzle","collection","currentQuery","onPath","on","Error","sanitizedSort","some","collections","config","f","sortOrder","startsWith","replace","sortPath","wherePaths","joinCollectionTableName","table","sortColumn","selectFields","parent","as","collectionQueryWhere","collectioConfig","parentTable","schemaName","constraint","operator","values","query","createJSONQuery","column","pathSegments","$raw","from","unionAll","subQueryAlias","sqlWhere","extras","offset","useDrafts","versionsSuffix","currentIDColumn","joinQueryWhere","currentIDRaw","targetField","equals","latest","newAliasTable","subQueryWhere","aliasTable","selectLocale","collectionConfig","key","val","pop","map","order","$dynamic","condition","subQuery","countSubquery","result","args","shouldSelect","withSelect","rels","numbers","texts"],"mappings":";;;;;;;;AAGA,SAASA,GAAG,EAAEC,GAAG,EAAEC,KAAK,EAAEC,IAAI,EAAEC,EAAE,EAAEC,YAAY,EAAEC,EAAE,EAAEC,GAAG,QAAQ,cAAa;;;;;AAC9E,SACEC,uBAAuB,EACvBC,4BAA4B,EAC5BC,cAAc,EAEdC,cAAc,EACdC,kBAAkB,QAKb,UAAS;;AAChB,SAASC,cAAc,EAAEC,sBAAsB,EAAEC,gBAAgB,QAAQ,iBAAgB;AACzF,OAAOC,iBAAiB,gBAAe;AAKvC,SAASC,UAAU,QAAQ,2BAA0B;AACrD,SAASC,aAAa,QAAQ,8BAA6B;AAC3D,SAASC,WAAW,QAAQ,4BAA2B;AACvD,SAASC,oBAAoB,QAAQ,uCAAsC;AAC3E,SAASC,uBAAuB,QAAQ,0CAAyC;AACjF,SAASC,kBAAkB,QAAQ,uBAAsB;AACzD,SAASC,aAAa,QAAQ,gCAA+B;AAC7D,SACEC,2BAA2B,EAC3BC,qBAAqB,QAChB,mDAAkD;;;;;;;;;;;;;AAEzD,MAAMC,uBAAuB,CAACC,OAAcC;IAC1C,IAAK,MAAMC,KAAKF,MAAO;QACrB,IAAI;YAAC;YAAO;SAAK,CAACG,QAAQ,CAACD,EAAEE,WAAW,KAAK;YAC3C,IAAIC,MAAMC,OAAO,CAACN,KAAK,CAACE,EAAE,GAAG;gBAC3B,KAAK,MAAMK,cAAcP,KAAK,CAACE,EAAE,CAAE;oBACjCH,qBAAqBQ,YAAYN;gBACnC;YACF;QACF,OAAO;YACL,6DAA6D;YAC7DA,MAAMO,IAAI,CAAC;gBAAEC,MAAMP,EAAEQ,KAAK,CAAC,KAAKC,IAAI,CAAC;gBAAMC,KAAKZ;YAAM;QACxD;IACF;AACF;AAEA,MAAMa,gBAAgB,CAACb,OAAcc;IACnC,IAAK,MAAMZ,KAAKF,MAAO;QACrB,IAAI;YAAC;YAAO;SAAK,CAACG,QAAQ,CAACD,EAAEE,WAAW,KAAK;YAC3C,IAAIC,MAAMC,OAAO,CAACN,KAAK,CAACE,EAAE,GAAG;gBAC3B,MAAMa,KAAK,UAAUb,EAAEE,WAAW,KAAK/B,2KAAAA,GAAMM,0KAAAA;gBAC7C,MAAMqC,cAAc,EAAE;gBACtB,KAAK,MAAMT,cAAcP,KAAK,CAACE,EAAE,CAAE;oBACjCc,YAAYR,IAAI,CAACK,cAAcN,YAAYO;gBAC7C;gBACA,OAAOC,MAAMC;YACf;QACF,OAAO;YACL,IAAIC,kBAAkBC,OAAOC,IAAI,CAACnB,KAAK,CAACE,EAAE,CAAC,CAAC,EAAE;YAE9C,MAAMkB,QAAQpB,KAAK,CAACE,EAAE,CAACe,gBAAgB;YACvC,IAAIA,oBAAoB,QAAQ;gBAC9B,OAAOrC,qJAAAA,CAAIyC,GAAG,CAACD;YACjB;YAEA,0DAA0D;YAE1D,4EAA4E;YAC5E,+EAA+E;YAC/E,oDAAoD;YACpD,IAAIH,oBAAoB,YAAYG,UAAU,OAAO;gBACnDH,kBAAkB;YACpB;YAEA,OAAOzB,0LAAW,CAACyB,gBAAgB,CAACrC,qJAAAA,CAAIyC,GAAG,CAAC,CAAC,CAAC,EAAEP,MAAM,GAAG,EAAEZ,EAAEQ,KAAK,CAAC,KAAKC,IAAI,CAAC,KAAK,CAAC,CAAC,GAAGS;QACzF;IACF;AACF;AAiCO,MAAME,iBAAiB,CAAC,EAC7BC,QAAQ,EACRC,OAAO,EACPC,cAAc,EACdC,WAAW,EACXC,gBAAgB,EAChBC,KAAK,EACLC,aAAa,EACbC,MAAM,EACNC,eAAe,EACfC,YAAY,CAAC,CAAC,EACdC,KAAK,EACLC,MAAM,EACNC,oBAAoB,KAAK,EACzB1B,IAAI,EACJ2B,MAAM,EACNC,0BAA0B,KAAK,EAC/BC,UAAU,EACVC,SAAS,EACTC,YAAY,EACZC,iBAAiB,EACjBC,QAAQ,EACRC,gBAAgB,EACE;IAClBb,OAAOc,OAAO,CAAC,CAACC;QACd,QAAI3D,gLAAAA,EAAe2D,QAAQ;YACzB;QACF;QAEA,MAAMC,uBAAmB3D,wLAAAA,EAAuB;YAC9C0D;YACAV;QACF;QAEA,6BAA6B;QAC7B,IACEP,QAAQ,KACPiB,CAAAA,MAAME,IAAI,KAAK,YAAYF,MAAME,IAAI,KAAK,cAAa,KACxD,CAACF,MAAMG,OAAO,IACd,OAAOH,MAAMI,UAAU,KAAK,UAC5B;YACA,IAAIH,kBAAkB;gBACpBvB,SAAS2B,IAAI,CAAC,GAAGzC,OAAOoC,MAAMM,IAAI,EAAE,CAAC,GAAG;YAC1C,OAAO;gBACLzB,YAAYwB,IAAI,CAAC,GAAGzC,OAAOoC,MAAMM,IAAI,EAAE,CAAC,GAAG;YAC7C;QACF;QAEA,OAAQN,MAAME,IAAI;YAChB,KAAK;gBAAS;oBACZ,MAAMK,cAAcf,0BAA0B,OAAOD,QAAQ,CAACS,MAAMM,IAAI,CAAC;oBAEzE,IAAIf,QAAQ;wBACV,IACGE,eAAe,aAAa,OAAOc,gBAAgB,eACnDd,eAAe,aAAac,gBAAgB,OAC7C;4BACA;wBACF;oBACF;oBAEA,MAAMC,YAAoB;wBACxBC,SACE,OAAOF,gBAAgB,WACnB;4BACEG,IAAI;4BACJC,QAAQ;wBACV,IACA;4BACEC,WAAW;wBACb;wBACNC,SAAS,CAAC,EAAEF,MAAM,EAAE,EAAE,EAAElF,GAAG,EAAE,GAAK;gCAACA,IAAIkF;6BAAQ;wBAC/CN,MAAM,CAAC;oBACT;oBAEA,MAAMS,iBAAiBnC,QAAQoC,YAAY,CAACC,GAAG,CAC7C,GAAGlC,iBAAiB,CAAC,EAAEY,gBAAYlD,yJAAAA,EAAYwD,MAAMM,IAAI,GAAG;oBAG9D,IAAI,OAAOC,gBAAgB,UAAU;wBACnC,IAAI5B,QAAQsC,MAAM,CAACH,eAAe,CAACI,OAAO,EAAE;4BAC1CV,UAAUC,OAAO,CAACS,OAAO,GAAG;wBAC9B;wBAEA,IAAIvC,QAAQsC,MAAM,CAACH,eAAe,CAACK,KAAK,EAAE;4BACxCX,UAAUC,OAAO,CAACU,KAAK,GAAG;wBAC5B;oBACF;oBAEA,MAAMC,4BAA4B,GAAGN,iBAAiBnC,QAAQ0C,aAAa,EAAE;oBAE7E,IAAI1C,QAAQsC,MAAM,CAACG,0BAA0B,EAAE;wBAC7CZ,UAAUH,IAAI,CAAC3B,QAAQ,GAAG;4BACxB+B,SACE,OAAOF,gBAAgB,WACnB;gCACEW,SAAS;4BACX,IACA;gCACER,IAAI;gCACJE,WAAW;4BACb;4BACNP,MAAM,CAAC;wBACT;oBACF;oBAEA,MAAMiB,mBAAe1E,8MAAAA,EAAqB;wBACxCoD;wBACApC,MAAM,GAAGA,OAAOoC,MAAMM,IAAI,EAAE;wBAC5BiB,WAAWT;oBACb;oBAEAjC,YAAYwB,IAAI,CAACiB,aAAa,GAAGd;oBAEjC/B,eAAe;wBACbC,UAAU8B,UAAUH,IAAI,CAAC3B,QAAQ;wBACjCC;wBACAE,aAAa2B;wBACb1B,kBAAkBgC;wBAClB/B;wBACAC;wBACAC,QAAQe,MAAMwB,eAAe;wBAC7BtC;wBACAC;wBACAE;wBACAC,mBAAmBA,qBAAqBU,MAAMyB,SAAS;wBACvD7D,MAAM;wBACN2B,QAAQ,OAAOgB,gBAAgB,WAAWA,cAAcmB;wBACxDjC;wBACAC,WAAW;wBACXC;wBACAC;wBACAE;oBACF;oBAEA,IACE,OAAOS,gBAAgB,YACvBC,UAAUH,IAAI,CAAC3B,QAAQ,IACvBL,OAAOC,IAAI,CAACkC,UAAUH,IAAI,CAAC3B,QAAQ,EAAEiD,MAAM,KAAK,GAChD;wBACA,OAAOnB,UAAUH,IAAI,CAAC3B,QAAQ;oBAChC;oBAEA;gBACF;YAEA,KAAK;gBAAU;oBACb,MAAMkD,eAAepC,0BAA0B,OAAOD,QAAQ,CAACS,MAAMM,IAAI,CAAC;oBAE1E,IAAIf,QAAQ;wBACV,IACGE,eAAe,aAAa,CAACmC,gBAC7BnC,eAAe,aAAamC,iBAAiB,OAC9C;4BACA;wBACF;oBACF;oBAEA,IAAIjD,QAAQkD,YAAY,EAAE;wBACxB,IAAItC,UAAUC,yBAAyB;4BACrC,MAAMsC,YAAY,GAAGlE,OAAOoC,MAAMM,IAAI,EAAE;4BAExC,IAAKL,CAAAA,oBAAoBX,iBAAgB,KAAMZ,UAAU;gCACvDA,SAAS+B,OAAO,CAACqB,UAAU,GAAG;4BAChC,OAAO,IAAInD,QAAQsC,MAAM,CAACnC,iBAAiB,EAAE,CAACgD,UAAU,EAAE;gCACxDjD,YAAY4B,OAAO,CAACqB,UAAU,GAAG;4BACnC;wBACF;wBAEA;oBACF;;oBAEE9B,CAAAA,MAAM+B,eAAe,IAAI/B,MAAMgC,MAAK,EAAGjC,OAAO,CAAC,CAACkC;wBAChD,MAAMC,QAAQ,OAAOD,WAAW,WAAWtD,QAAQwD,OAAO,CAACH,MAAM,CAACC,OAAO,GAAGA;wBAC5E,MAAMG,WAAW,CAAC,QAAQ,EAAEF,MAAMG,IAAI,GAAG,CAACH,KAAK,CAAClF,iOAAAA,CAA4B,GAAG,KAAK,CAAC,CAAC,EAAEkF,KAAK,CAAClF,iOAAAA,CAA4B,EAAE,EAAE;wBAE9H,IAAIsF;wBAEJ,IAAIC,kBAAkB9C;wBAEtB,IAAIA,eAAe,aAAamC,iBAAiB,MAAM;4BACrDU,cAAc;wBAChB;wBAEA,IAAI,OAAOV,iBAAiB,UAAU;4BACpC,IAAI,OAAOA,YAAY,CAACM,MAAMG,IAAI,CAAC,KAAK,UAAU;gCAChDC,cAAcV,YAAY,CAACM,MAAMG,IAAI,CAAC;4BACxC,OAAO,IACJ5C,eAAe,aAAa,OAAOmC,YAAY,CAACM,MAAMG,IAAI,CAAC,KAAK,eAChE5C,eAAe,aAAamC,YAAY,CAACM,MAAMG,IAAI,CAAC,KAAK,OAC1D;gCACAC,cAAc,CAAC;gCACfC,kBAAkB;4BACpB,OAAO,IAAI9C,eAAe,aAAa+C,QAAQZ,YAAY,CAACM,MAAMG,IAAI,CAAC,GAAG;gCACxEC,cAAc;4BAChB;wBACF;wBAEA,IAAI,CAAC3C,YAAY,CAACyC,SAAS,EAAE;4BAC3B,MAAMK,YAAoB;gCACxBhC,SACE,OAAO6B,gBAAgB,WACnB;oCACE5B,IAAI;oCACJC,QAAQ;oCACR+B,OAAO;gCACT,IACA;oCACE9B,WAAW;gCACb;gCACNC,SAAS,CAAC,EAAEF,MAAM,EAAE,EAAE,EAAElF,GAAG,EAAE,GAAK;wCAACA,IAAIkF;qCAAQ;gCAC/CN,MAAM,CAAC;4BACT;4BAEA,MAAMkB,gBAAYtE,2NAAAA,EAChBiF,OACAvD,QAAQoC,YAAY,CAACC,GAAG,CAAC,GAAGpB,kBAAkB,QAAQ,MAAEpD,yJAAAA,EAAY0F,MAAMG,IAAI,GAAG;4BAGnF,IAAI,OAAOC,gBAAgB,UAAU;gCACnC,IAAI3D,QAAQsC,MAAM,CAACM,UAAU,CAACL,OAAO,EAAE;oCACrCuB,UAAUhC,OAAO,CAACS,OAAO,GAAG;gCAC9B;gCAEA,IAAIvC,QAAQsC,MAAM,CAACM,UAAU,CAACJ,KAAK,EAAE;oCACnCsB,UAAUhC,OAAO,CAACU,KAAK,GAAG;gCAC5B;4BACF;4BAEA,IAAIxC,QAAQsC,MAAM,CAAC,GAAGM,YAAY5C,QAAQ0C,aAAa,EAAE,CAAC,EAAE;gCAC1DoB,UAAUpC,IAAI,CAAC3B,QAAQ,GAAG;oCACxB2B,MAAM,CAAC;gCACT;gCAEA,IAAI,OAAOiC,gBAAgB,UAAU;oCACnCG,UAAUpC,IAAI,CAAC3B,QAAQ,CAAC+B,OAAO,GAAG;wCAChCS,SAAS;oCACX;gCACF;4BACF;4BACAvB,aAAaU,IAAI,CAAC+B,SAAS,GAAGK;4BAE9BhE,eAAe;gCACbC,UAAU+D,UAAUpC,IAAI,CAAC3B,QAAQ;gCACjCC;gCACAE,aAAa4D;gCACb3D,kBAAkByC;gCAClBxC;gCACAC;gCACAC,QAAQiD,MAAMV,eAAe;gCAC7BtC,iBAAiBoD,gBAAgB;gCACjCnD;gCACAE;gCACAC,mBAAmBA,qBAAqBU,MAAMyB,SAAS;gCACvD7D,MAAM;gCACN2B,QAAQ,OAAO+C,gBAAgB,WAAWA,cAAcZ;gCACxDjC,YAAY8C;gCACZ7C,WAAW;gCACXC;gCACAC;gCACAE;4BACF;4BAEA,IACE,OAAOwC,gBAAgB,YACvBG,UAAUpC,IAAI,CAAC3B,QAAQ,IACvBL,OAAOC,IAAI,CAACmE,UAAUpC,IAAI,CAAC3B,QAAQ,CAAC+B,OAAO,EAAEkB,MAAM,KAAK,GACxD;gCACA,OAAOc,UAAUpC,IAAI,CAAC3B,QAAQ;4BAChC;wBACF;oBACF;oBAEA;gBACF;YAEA,KAAK;YACL,KAAK;gBAAO;oBACV,MAAMiE,cAAcpD,QAAQ,CAACS,MAAMM,IAAI,CAAC;oBAExC,IAAIqC,gBAAgB,OAAO;wBACzB;oBACF;oBAEAlE,eAAe;wBACbC;wBACAC;wBACAC;wBACAC;wBACAC;wBACAC;wBACAC;wBACAC,QAAQe,MAAMwB,eAAe;wBAC7BtC;wBACAC;wBACAC;wBACAC;wBACAC,mBAAmBA,qBAAqBU,MAAMyB,SAAS;wBACvD7D,MAAM,GAAGA,OAAOoC,MAAMM,IAAI,CAAC,CAAC,CAAC;wBAC7Bf,QAAQ,OAAOoD,gBAAgB,WAAWA,cAAcjB;wBACxDlC,yBACEA,2BACAmD,gBAAgB,QACflD,eAAe,aAAa,OAAOkD,gBAAgB;wBACtDlD;wBACAC,WAAW,GAAGA,gBAAYlD,yJAAAA,EAAYwD,MAAMM,IAAI,EAAE,CAAC,CAAC;wBACpDX;wBACAC;wBACAC;wBACAC;oBACF;oBAEA;gBACF;YACA,KAAK;gBAAQ;oBACX,0CAA0C;oBAC1C,IAAIX,cAAc,OAAO;wBACvB;oBACF;oBAEA,IACGI,UAAUE,eAAe,aAAa,CAACF,MAAM,CAACS,MAAMM,IAAI,CAAC,IACzDb,eAAe,aAAaF,MAAM,CAACS,MAAMM,IAAI,CAAC,KAAK,OACpD;wBACA;oBACF;oBAEA,MAAMsC,iBAAiB,GAAGhF,KAAKiF,UAAU,CAAC,KAAK,OAAO7C,MAAMM,IAAI,EAAE;oBAElE,IAAInB,SAAS,CAACyD,eAAe,KAAK,OAAO;wBACvC;oBACF;oBAEA,MAAM,EACJlH,OAAOoH,cAAc,KAAK,EAC1BC,OAAOC,WAAWhD,MAAMiD,YAAY,IAAI,EAAE,EAC1CC,IAAI,EACJC,OAAOnD,MAAMoD,WAAW,EACxBjG,KAAK,EACN,GAAGgC,SAAS,CAACyD,eAAe,IAAI,CAAC;oBAClC,IAAIG,QAAQC;oBAEZ,IAAID,UAAU,GAAG;wBACf,qFAAqF;wBACrFA,SAAS;oBACX;oBAEA,MAAMM,aAAa,GAAGzF,KAAKiF,UAAU,CAAC,KAAK,OAAO7C,MAAMM,IAAI,EAAE;oBAE9D,MAAMgD,KAAK3E,QAAQ4E,OAAO;oBAE1B,IAAI/F,MAAMC,OAAO,CAACuC,MAAMwD,UAAU,GAAG;wBACnC,IAAIC,eAAiC;wBACrC,MAAMC,SAAS1D,MAAM2D,EAAE,CAAC9F,KAAK,CAAC,KAAKC,IAAI,CAAC;wBAExC,IAAIN,MAAMC,OAAO,CAAC0F,OAAO;4BACvB,MAAM,IAAIS,MAAM;wBAClB;wBAEA,IAAIC,gBAAgBV;wBAEpB,IAAI,CAACU,eAAe;4BAClB,IACE7D,MAAMwD,UAAU,CAACM,IAAI,CAAC,CAACN,aACrB7E,QAAQwD,OAAO,CAAC4B,WAAW,CAACP,WAAW,CAACQ,MAAM,CAAC/E,MAAM,CAAC6E,IAAI,CACxD,CAACG,IAAMA,EAAE/D,IAAI,KAAK,UAAU+D,EAAE3D,IAAI,KAAK,eAG3C;gCACAuD,gBAAgB;4BAClB,OAAO;gCACLA,gBAAgB;4BAClB;wBACF;wBAEA,MAAMK,YAAYL,cAAcM,UAAU,CAAC,OAAOxI,wKAAAA,GAAOF,uKAAAA;wBACzDoI,gBAAgBA,cAAcO,OAAO,CAAC,KAAK;wBAE3C,MAAMC,WAAWR,cAAchG,KAAK,CAAC,KAAKC,IAAI,CAAC;wBAE/C,MAAMwG,aAA2C,EAAE;wBAEnD,IAAInH,OAAO;4BACTD,qBAAqBC,OAAOmH;wBAC9B;wBAEA,KAAK,MAAMd,cAAcxD,MAAMwD,UAAU,CAAE;4BACzC,MAAMe,0BAA0B5F,QAAQoC,YAAY,CAACC,GAAG,KAACxE,yJAAAA,EAAYgH;4BAErE,MAAMgB,QAAQ7F,QAAQsC,MAAM,CAACsD,wBAAwB;4BAErD,MAAME,aAAaD,KAAK,CAACH,SAAS;4BAElC,MAAMK,eAAe;gCACnBhE,IAAI/B,QAAQsC,MAAM,CAACsD,wBAAwB,CAAC7D,EAAE;gCAC9CiE,QAAQ5I,qJAAG,CAAC,EAAE4C,QAAQsC,MAAM,CAACsD,wBAAwB,CAACb,OAAO,CAAC,CAAC,CAACkB,EAAE,CAAClB;gCACnEtD,YAAYrE,qJAAG,CAAC,EAAEyH,WAAW,CAAC,CAACoB,EAAE,CAAC;gCAClCP,UAAUtI,qJAAG,CAAC,EAAE0I,aAAaA,aAAa,KAAK,CAAC,CAACG,EAAE,CAAC;4BACtD;4BAEA,MAAMC,uBAA8B,EAAE;4BACtC,qCAAqC;4BACrC,KAAK,MAAM,EAAEjH,IAAI,EAAEG,GAAG,EAAE,IAAIuG,WAAY;gCACtC,MAAMQ,kBAAkBnG,QAAQwD,OAAO,CAAC4B,WAAW,CAACP,WAAW,CAACQ,MAAM;gCACtE,MAAMhE,YAAQ7D,kLAAAA,EAAe;oCAAE8C,QAAQ6F,gBAAgBtD,eAAe;oCAAE5D;gCAAK;gCAE7E,IAAIoC,SAASA,MAAMA,KAAK,CAACE,IAAI,KAAK,YAAYF,MAAMA,KAAK,CAACG,OAAO,EAAE;oCACjE,IAAIoB,YAAY5C,QAAQoC,YAAY,CAACC,GAAG,CACtC,OAAGxE,yJAAAA,EAAYgH,YAAY,CAAC,MAAEhH,yJAAAA,EAAYoB,OAAO;oCAEnD,IAAImH,kBAAclJ,yJAAAA,EAAa2I;oCAE/B,IAAI7F,QAAQqG,UAAU,EAAE;wCACtBzD,YAAY,CAAC,CAAC,EAAE5C,QAAQqG,UAAU,CAAC,GAAG,EAAEzD,UAAU,CAAC,CAAC;wCACpDwD,cAAc,CAAC,CAAC,EAAEpG,QAAQqG,UAAU,CAAC,GAAG,EAAED,YAAY,CAAC,CAAC;oCAC1D;oCAEA,IAAIpG,QAAQ2B,IAAI,KAAK,YAAY;wCAC/BoE,YAAY,CAAC9G,KAAK,GAAG7B,qJAAAA,CAClByC,GAAG,CACF,CAAC,kBAAkB,EAAE+C,UAAU,aAAa,EAAEA,UAAU,OAAO,EAAEA,UAAU,aAAa,EAAEwD,YAAY,IAAI,CAAC,EAE5GH,EAAE,CAAChH;oCACR,OAAO;wCACL8G,YAAY,CAAC9G,KAAK,GAAG7B,qJAAAA,CAClByC,GAAG,CACF,CAAC,yBAAyB,EAAE+C,UAAU,aAAa,EAAEA,UAAU,OAAO,EAAEA,UAAU,aAAa,EAAEwD,YAAY,IAAI,CAAC,EAEnHH,EAAE,CAAChH;oCACR;oCAEA,MAAMqH,aAAalH,GAAG,CAACH,KAAK;oCAC5B,MAAMsH,WAAW7G,OAAOC,IAAI,CAAC2G,WAAW,CAAC,EAAE;oCAC3C,MAAM1G,QAAaF,OAAO8G,MAAM,CAACF,WAAW,CAAC,EAAE;oCAE/C,MAAMG,QAAQzG,QAAQ0G,eAAe,CAAC;wCACpCC,QAAQ,CAAC,CAAC,EAAE1H,KAAK,CAAC,CAAC;wCACnBsH;wCACAK,cAAc;4CAACvF,MAAMA,KAAK,CAACM,IAAI;yCAAC;wCAChCkE,OAAOO;wCACPxG;oCACF;oCACAR,GAAG,CAACH,KAAK,GAAG;wCAAE4H,MAAMJ;oCAAM;gCAC5B,OAAO,IAAIzG,QAAQsC,MAAM,CAACsD,wBAAwB,CAAC3G,KAAK,EAAE;oCACxD8G,YAAY,CAAC9G,KAAK,GAAG7B,qJAAG,CAAC,EAAE4C,QAAQsC,MAAM,CAACsD,wBAAwB,CAAC3G,KAAK,CAAC,CAAC,CAACgH,EAAE,CAAChH;gCAC9E,oCAAoC;gCACtC,OAAO,IAAIA,SAAS,cAAc;oCAChC,gFAAgF;oCAChF,iEAAiE;oCACjE,IAAIA,SAAS,eAAee,QAAQ2B,IAAI,KAAK,YAAY;wCACvDoE,YAAY,CAAC9G,KAAK,GAAG7B,qJAAG,CAAC,8BAA8B,CAAC,CAAC6I,EAAE,CAAChH;oCAC9D,OAAO;wCACL8G,YAAY,CAAC9G,KAAK,GAAG7B,qJAAG,CAAC,IAAI,CAAC,CAAC6I,EAAE,CAAChH;oCACpC;gCACF;4BACF;4BAEA,IAAIwH,QAAa9B,GAAG/D,MAAM,CAACmF,cAAce,IAAI,CAAC9G,QAAQsC,MAAM,CAACsD,wBAAwB;4BACrF,IAAIM,qBAAqBlD,MAAM,EAAE;gCAC/ByD,QAAQA,MAAMjI,KAAK,KAAC3B,2KAAAA,KAAOqJ;4BAC7B;4BACA,IAAIpB,iBAAiB,MAAM;gCACzBA,eAAe2B;4BACjB,OAAO;gCACL3B,eAAeA,aAAaiC,QAAQ,CAACN;4BACvC;wBACF;wBAEA,MAAMO,gBAAgB,GAAGtC,WAAW,SAAS,CAAC;wBAE9C,IAAIuC,eAAWhK,0KAAAA,EACbG,qJAAAA,CAAIyC,GAAG,CAAC,CAAC,CAAC,EAAEM,iBAAiB,MAAM,CAAC,GACpC/C,qJAAAA,CAAIyC,GAAG,CAAC,CAAC,CAAC,EAAEmH,cAAc,GAAG,EAAEjC,OAAO,CAAC,CAAC;wBAG1C,IAAIvG,SAASkB,OAAOC,IAAI,CAACnB,OAAOwE,MAAM,GAAG,GAAG;4BAC1CiE,eAAWpK,2KAAAA,EAAIoK,UAAU5H,cAAcb,OAAOwI;wBAChD;wBAEA,IAAI7C,aAAa;4BACfjE,YAAYgH,MAAM,CAAC,GAAGxC,WAAW,MAAM,CAAC,CAAC,GAAGtH,qJAAG,CAAC,EAAEuH,GAC/C/D,MAAM,CAAC;gCAAE7D,WAAOA,0KAAAA;4BAAQ,GACxB+J,IAAI,CAAC1J,qJAAG,CAAC,EAAE0H,aAAamB,EAAE,CAACe,eAAe,CAAC,EAC3CxI,KAAK,CAACyI,UAAU,CAAC,CAAChB,EAAE,CAAC,GAAGvB,WAAW,MAAM,CAAC;wBAC/C;wBAEAI,eAAeA,aAAa5C,OAAO,CAACqD,UAAUnI,qJAAG,CAAC,UAAU,CAAC;wBAE7D,IAAImH,QAAQH,UAAU,GAAG;4BACvB,MAAM+C,SAAU5C,CAAAA,OAAO,CAAA,IAAKH;4BAC5B,IAAI+C,SAAS,GAAG;gCACdrC,eAAeA,aAAaqC,MAAM,CAACA;4BACrC;wBACF;wBAEA,IAAI/C,OAAO;4BACTU,eAAeA,aAAaV,KAAK,CAACA;wBACpC;wBAEAlE,YAAYgH,MAAM,CAACxC,WAAW,GAAGtH,qJAAG,CAAC,EAAEuH,GACpC/D,MAAM,CAAC;4BACNmB,QAAI5D,4LAAAA,EAAmB6B,SAAS;gCAC9B+B,IAAI3E,qJAAAA,CAAIyC,GAAG,CAAC,CAAC,CAAC,EAAEmH,cAAc,MAAM,CAAC;gCACrCvF,YAAYrE,qJAAAA,CAAIyC,GAAG,CAAC,CAAC,CAAC,EAAEmH,cAAc,cAAc,CAAC;4BACvD;wBACF,GACCF,IAAI,CAAC1J,qJAAG,CAAC,EAAE0H,aAAamB,EAAE,CAACe,eAAe,CAAC,EAC3CxI,KAAK,CAACyI,UAAU,CAAC,CAAChB,EAAE,CAACvB;oBAC1B,OAAO;wBACL,MAAM0C,YACHlG,CAAAA,YAAYb,aAAY,SACzBzC,uLAAAA,EAAiBoC,QAAQwD,OAAO,CAAC4B,WAAW,CAAC/D,MAAMwD,UAAU,CAAC,CAACQ,MAAM;wBAEvE,MAAM/E,SAAS8G,gBACX9J,sMAAAA,EACE0C,QAAQwD,OAAO,CAAC6B,MAAM,EACtBrF,QAAQwD,OAAO,CAAC4B,WAAW,CAAC/D,MAAMwD,UAAU,CAAC,CAACQ,MAAM,EACpD,QAEFrF,QAAQwD,OAAO,CAAC4B,WAAW,CAAC/D,MAAMwD,UAAU,CAAC,CAACQ,MAAM,CAACxC,eAAe;wBAExE,MAAM+C,0BAA0B5F,QAAQoC,YAAY,CAACC,GAAG,CACtD+E,YACI,CAAC,CAAC,MAAEvJ,yJAAAA,EAAYwD,MAAMwD,UAAU,IAAI7E,QAAQqH,cAAc,EAAE,OAC5DxJ,yJAAAA,EAAYwD,MAAMwD,UAAU;wBAGlC,MAAMpE,QAA+B,EAAE;wBAEvC,MAAM6G,kBAAkBpG,WACpBlB,QAAQsC,MAAM,CAACnC,iBAAiB,CAAC6F,MAAM,GACvChG,QAAQsC,MAAM,CAACnC,iBAAiB,CAAC4B,EAAE;wBAEvC,IAAIwF;wBAEJ,MAAMC,eAAepK,qJAAAA,CAAIyC,GAAG,CAC1B,CAAC,CAAC,MAAE3B,oNAAAA,EAAwBoJ,gBAAgBzB,KAAK,EAAE,GAAG,EAAEyB,gBAAgB3F,IAAI,CAAC,CAAC,CAAC;wBAGjF,IAAI9C,MAAMC,OAAO,CAACuC,MAAMoG,WAAW,CAAChG,UAAU,GAAG;4BAC/C8F,iBAAiB;gCACf,CAAClG,MAAM2D,EAAE,CAAC,EAAE;oCACV0C,QAAQ;wCACNjG,YAAYxB;wCACZL,WAAOxB,gMAAAA,EAAcoJ;oCACvB;gCACF;4BACF;wBACF,OAAO;4BACLD,iBAAiB;gCACf,CAAClG,MAAM2D,EAAE,CAAC,EAAE;oCACV0C,YAAQtJ,gMAAAA,EAAcoJ;gCACxB;4BACF;wBACF;wBAEA,IAAIhJ,SAASkB,OAAOC,IAAI,CAACnB,OAAOwE,MAAM,EAAE;4BACtCuE,iBAAiB;gCACf1K,KAAK;oCAAC0K;oCAAgB/I;iCAAM;4BAC9B;wBACF;wBAEA,IAAI4I,WAAW;4BACbG,qBAAiBhK,iLAAAA,MAAeF,6MAAAA,EAAwBkK,iBAAiB;gCACvEI,QAAQ;oCAAED,QAAQ;gCAAK;4BACzB;wBACF;wBAEA,MAAMhD,aAAa,GAAGzF,KAAKiF,UAAU,CAAC,KAAK,OAAO7C,MAAMM,IAAI,EAAE;wBAE9D,MAAMqF,gBAAgB,GAAGtC,WAAW,MAAM,CAAC;wBAE3C,MAAM,EAAEkD,aAAa,EAAE,OAAG7J,8LAAAA,EAAc;4BACtCiC;4BACA4C,WAAWgD;wBACb;wBAEA,MAAM,EACJ1D,OAAO,EACP6D,YAAY,EACZvH,OAAOqJ,aAAa,EACrB,OAAG/J,wLAAAA,EAAW;4BACbkC;4BACA8H,YAAYF;4BACZtH;4BACAG;4BACAC;4BACAC;4BACAoH,cAAc;4BACdvD,MAAM4C,gBACF3J,mMAAAA,EAAmB;gCACjBuK,kBAAkBhI,QAAQwD,OAAO,CAAC4B,WAAW,CAAC/D,MAAMwD,UAAU,CAAC,CAACQ,MAAM;gCACtEb;4BACF,KACAA;4BACJ5B,WAAWgD;4BACXpH,OAAO+I;wBACT;wBAEA,IAAK,IAAIU,OAAOlC,aAAc;4BAC5B,MAAMmC,MAAMnC,YAAY,CAACkC,IAAI;4BAE7B,IAAIC,IAAIrC,KAAK,QAAI3H,oNAAAA,EAAwBgK,IAAIrC,KAAK,MAAMD,yBAAyB;gCAC/E,OAAOG,YAAY,CAACkC,IAAI;gCACxBA,MAAMA,IAAI/I,KAAK,CAAC,KAAKiJ,GAAG;gCACxBpC,YAAY,CAACkC,IAAI,GAAGL,aAAa,CAACK,IAAI;4BACxC;wBACF;wBAEA,IAAIb,WAAW;4BACbrB,aAAaC,MAAM,GAAG4B,cAAc5B,MAAM;wBAC5C;wBAEA,IAAIS,QAAsB9B,GACvB/D,MAAM,CAACmF,cACPe,IAAI,CAACc,eACLpJ,KAAK,CAACqJ,eACN3F,OAAO,CAAC,IAAMA,QAAQkG,GAAG,CAAC,CAAC,EAAEzB,MAAM,EAAE0B,KAAK,EAAE,GAAKA,MAAM1B,UACvD2B,QAAQ;wBAEX7H,MAAMW,OAAO,CAAC,CAAC,EAAEG,IAAI,EAAEgH,SAAS,EAAE1C,KAAK,EAAE;4BACvCY,QAAQA,KAAK,CAAClF,QAAQ,WAAW,CAACsE,OAAO0C;wBAC3C;wBAEA,IAAIhE,QAAQH,UAAU,GAAG;4BACvB,MAAM+C,SAAU5C,CAAAA,OAAO,CAAA,IAAKH,QAAQ;4BACpC,IAAI+C,SAAS,GAAG;gCACdV,QAAQA,MAAMU,MAAM,CAACA;4BACvB;wBACF;wBAEA,IAAI/C,UAAU,GAAG;4BACfqC,QAAQA,MAAMrC,KAAK,CAACA;wBACtB;wBAEA,MAAMoE,WAAW/B,MAAMR,EAAE,CAACe;wBAE1B,IAAI7C,aAAa;4BACf,IAAIsE,gBAA8B9D,GAC/B/D,MAAM,CAACmF,cAEPe,IAAI,CAACc,eACLpJ,KAAK,CAACqJ,eACNS,QAAQ;4BAEX7H,MAAMW,OAAO,CAAC,CAAC,EAAEG,IAAI,EAAEgH,SAAS,EAAE1C,KAAK,EAAE;gCACvC4C,gBAAgBA,aAAa,CAAClH,QAAQ,WAAW,CAACsE,OAAO0C;4BAC3D;4BAEArI,YAAYgH,MAAM,CAAC,GAAGxC,WAAW,MAAM,CAAC,CAAC,GAAGtH,qJAAG,CAAC,EAAEuH,GAC/C/D,MAAM,CAAC;gCACN7D,WAAOA,0KAAAA;4BACT,GACC+J,IAAI,CAAC1J,qJAAG,CAAC,EAAEqL,cAAcxC,EAAE,CAAC,GAAGe,cAAc,eAAe,CAAC,EAAE,CAAC,EAAE,CAAC,CAACf,EAAE,CACvE,GAAGe,cAAc,MAAM,CAAC;wBAE5B;wBAEA9G,YAAYgH,MAAM,CAACxC,WAAW,GAAGtH,qJAAG,CAAC,EAAEuH,GACpC/D,MAAM,CAAC;4BACN8H,YAAQvK,4LAAAA,EAAmB6B,SAAS;gCAClC+B,IAAI3E,qJAAAA,CAAIyC,GAAG,CAAC,CAAC,CAAC,EAAEmH,cAAc,EAAE,EAAEI,YAAY,cAAc,MAAM;gCAClE,GAAIrB,aAAaxD,OAAO,IAAI;oCAC1B7B,QAAQtD,qJAAAA,CAAIyC,GAAG,CAAC,CAAC,CAAC,EAAEmH,cAAc,EAAE,EAAEjB,aAAaxD,OAAO,CAACZ,IAAI,EAAE;gCACnE,CAAC;4BACH;wBACF,GACCmF,IAAI,CAAC1J,qJAAG,CAAC,EAAEoL,SAAS,CAAC,EAAE,CAAC,CAACvC,EAAE,CAACe;oBACjC;oBAEA;gBACF;YAEA,KAAK;gBAAS;oBACZ,IAAIhH,QAAQ2B,IAAI,KAAK,UAAU;wBAC7B;oBACF;oBAEA,MAAMgH,OAAOrH,mBAAmBvB,WAAWG;oBAC3C,IAAI,CAACyI,KAAK7G,OAAO,EAAE;wBACjB6G,KAAK7G,OAAO,GAAG,CAAC;oBAClB;oBAEA,IAAI,CAAC6G,KAAKzB,MAAM,EAAE;wBAChByB,KAAKzB,MAAM,GAAG,CAAC;oBACjB;oBAEA,MAAMvF,OAAO,GAAG1C,OAAOoC,MAAMM,IAAI,EAAE;oBAEnC,2FAA2F;oBAC3F,gGAAgG;oBAChGgH,KAAK7G,OAAO,CAACH,KAAK,GAAG;oBAErB,IAAIiH,eAAe;oBAEnB,IAAIhI,UAAUC,yBAAyB;wBACrC,IACEA,2BACCC,eAAe,aAAa+C,QAAQjD,MAAM,CAACS,MAAMM,IAAI,CAAC,KACtDb,eAAe,aAAa,OAAOF,MAAM,CAACS,MAAMM,IAAI,CAAC,KAAK,aAC3D;4BACAiH,eAAe;wBACjB;oBACF,OAAO;wBACLA,eAAe;oBACjB;oBACA,MAAMhG,gBAAYjF,wLAAAA,EAAuB;wBAAE0D;wBAAOV;oBAAkB,KAChE,GAAGR,mBAAmBH,QAAQ0C,aAAa,EAAE,GAC7CvC;oBAEJ,IAAIyI,cAAc;wBAChBD,KAAKzB,MAAM,CAACvF,KAAK,GAAGvE,qJAAAA,CACjByC,GAAG,CAAC,CAAC,cAAc,EAAEG,QAAQsC,MAAM,CAACM,UAAU,CAACjB,KAAK,CAACA,IAAI,CAAC,SAAS,CAAC,EACpEsE,EAAE,CAACtE;oBACR;oBACA;gBACF;YAEA,KAAK;gBAAU;oBACb,IAAIf,UAAU,CAACC,yBAAyB;wBACtC,IACGC,eAAe,aAAa,CAACF,MAAM,CAACS,MAAMM,IAAI,CAAC,IAC/Cb,eAAe,aAAaF,MAAM,CAACS,MAAMM,IAAI,CAAC,KAAK,OACpD;4BACA;wBACF;oBACF;oBAEA,IAAIN,MAAMG,OAAO,EAAE;wBACjB,MAAMqH,aAAqB;4BACzB/G,SAAS;gCACPC,IAAI;gCACJsG,OAAO;gCACPrC,QAAQ;4BACV;4BACA9D,SAAS,CAAC,EAAEmG,KAAK,EAAE,EAAE,EAAEvL,GAAG,EAAE,GAAK;oCAACA,IAAIuL;iCAAO;wBAC/C;wBAEAnI,YAAYwB,IAAI,CAAC,GAAGzC,OAAOoC,MAAMM,IAAI,EAAE,CAAC,GAAGkH;wBAC3C;oBACF;oBAEA,IAAIjI,UAAUC,yBAAyB;wBACrC,MAAMsC,YAAY,GAAGlE,OAAOoC,MAAMM,IAAI,EAAE;wBAExC,IAAKL,CAAAA,oBAAoBX,iBAAgB,KAAMZ,UAAU;4BACvDA,SAAS+B,OAAO,CAACqB,UAAU,GAAG;wBAChC,OAAO,IAAInD,QAAQsC,MAAM,CAACnC,iBAAiB,EAAE,CAACgD,UAAU,EAAE;4BACxDjD,YAAY4B,OAAO,CAACqB,UAAU,GAAG;wBACnC;oBACF;oBAEA;gBACF;YAEA;gBAAS;oBACP,IAAI5C,iBAAiB;wBACnB,IACGc,CAAAA,MAAME,IAAI,KAAK,kBAAkBF,MAAME,IAAI,KAAK,QAAO,KACvDF,CAAAA,MAAMG,OAAO,IAAI3C,MAAMC,OAAO,CAACuC,MAAMI,UAAU,CAAA,GAChD;4BACAN,iBAAiB2H,IAAI,GAAG;wBAC1B;wBAEA,IAAIzH,MAAME,IAAI,KAAK,YAAYF,MAAMG,OAAO,EAAE;4BAC5CL,iBAAiB4H,OAAO,GAAG;wBAC7B;wBAEA,IAAI1H,MAAME,IAAI,KAAK,UAAUF,MAAMG,OAAO,EAAE;4BAC1CL,iBAAiB6H,KAAK,GAAG;wBAC3B;oBACF;oBAEA,IAAI,CAACpI,UAAU,CAACC,yBAAyB;wBACvC;oBACF;oBAEA,IACEA,2BACCC,eAAe,aAAa+C,QAAQjD,MAAM,CAACS,MAAMM,IAAI,CAAC,KACtDb,eAAe,aAAa,OAAOF,MAAM,CAACS,MAAMM,IAAI,CAAC,KAAK,aAC3D;wBACA,MAAMwB,YAAY,GAAGlE,OAAOoC,MAAMM,IAAI,EAAE;wBAExC,IAAKL,CAAAA,oBAAoBX,iBAAgB,KAAMZ,UAAU;4BACvDA,SAAS+B,OAAO,CAACqB,UAAU,GAAG;wBAChC,OAAO,IAAInD,QAAQsC,MAAM,CAACnC,iBAAiB,EAAE,CAACgD,UAAU,EAAE;4BACxDjD,YAAY4B,OAAO,CAACqB,UAAU,GAAG;wBACnC;wBAEA,IACE,CAAChC,iBAAiB2H,IAAI,IACrBzH,CAAAA,MAAME,IAAI,KAAK,kBAAkBF,MAAME,IAAI,KAAK,QAAO,KACvDF,CAAAA,MAAMG,OAAO,IAAI3C,MAAMC,OAAO,CAACuC,MAAMI,UAAU,CAAA,GAChD;4BACAN,iBAAiB2H,IAAI,GAAG;wBAC1B;wBAEA,IAAI,CAAC3H,iBAAiB4H,OAAO,IAAI1H,MAAME,IAAI,KAAK,YAAYF,MAAMG,OAAO,EAAE;4BACzEL,iBAAiB4H,OAAO,GAAG;wBAC7B;wBAEA,IAAI,CAAC5H,iBAAiB6H,KAAK,IAAI3H,MAAME,IAAI,KAAK,UAAUF,MAAMG,OAAO,EAAE;4BACrEL,iBAAiB6H,KAAK,GAAG;wBAC3B;oBACF;oBAEA;gBACF;QACF;IACF;IAEA,OAAOhI;AACT,EAAC"}},
    {"offset": {"line": 2918, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/find/buildFindManyArgs.ts"],"sourcesContent":["import type { DBQueryConfig } from 'drizzle-orm'\nimport type { FlattenedField, JoinQuery, SelectType } from 'payload'\n\nimport { getSelectMode } from 'payload/shared'\n\nimport type { BuildQueryJoinAliases, DrizzleAdapter } from '../types.js'\n\nimport { traverseFields } from './traverseFields.js'\n\ntype BuildFindQueryArgs = {\n  adapter: DrizzleAdapter\n  collectionSlug?: string\n  depth: number\n  draftsEnabled?: boolean\n  fields: FlattenedField[]\n  joinQuery?: JoinQuery\n  /**\n   * The joins array will be mutated by pushing any joins needed for the where queries of join field joins\n   */\n  joins?: BuildQueryJoinAliases\n  locale?: string\n  select?: SelectType\n  tableName: string\n  versions?: boolean\n}\n\nexport type Result = {\n  with?: {\n    _locales?: DBQueryConfig<'many', true, any, any>\n  } & DBQueryConfig<'many', true, any, any>\n} & DBQueryConfig<'many', true, any, any>\n\n// Generate the Drizzle query for findMany based on\n// a collection field structure\nexport const buildFindManyArgs = ({\n  adapter,\n  collectionSlug,\n  depth,\n  draftsEnabled,\n  fields,\n  joinQuery,\n  joins = [],\n  locale,\n  select,\n  tableName,\n  versions,\n}: BuildFindQueryArgs): Result => {\n  const result: Result = {\n    extras: {},\n    with: {},\n  }\n\n  if (select) {\n    result.columns = {\n      id: true,\n    }\n  }\n\n  const _locales: Result = {\n    columns: select\n      ? { _locale: true }\n      : {\n          id: false,\n          _parentID: false,\n        },\n    extras: {},\n    with: {},\n  }\n\n  const withTabledFields = select\n    ? {}\n    : {\n        numbers: true,\n        rels: true,\n        texts: true,\n      }\n\n  traverseFields({\n    _locales,\n    adapter,\n    collectionSlug,\n    currentArgs: result,\n    currentTableName: tableName,\n    depth,\n    draftsEnabled,\n    fields,\n    joinQuery,\n    joins,\n    locale,\n    path: '',\n    select,\n    selectMode: select ? getSelectMode(select) : undefined,\n    tablePath: '',\n    topLevelArgs: result,\n    topLevelTableName: tableName,\n    versions,\n    withTabledFields,\n  })\n\n  if (adapter.tables[`${tableName}_texts`] && withTabledFields.texts) {\n    result.with._texts = {\n      columns: {\n        id: false,\n        parent: false,\n      },\n      orderBy: ({ order }, { asc: ASC }) => [ASC(order)],\n    }\n  }\n\n  if (adapter.tables[`${tableName}_numbers`] && withTabledFields.numbers) {\n    result.with._numbers = {\n      columns: {\n        id: false,\n        parent: false,\n      },\n      orderBy: ({ order }, { asc: ASC }) => [ASC(order)],\n    }\n  }\n\n  if (adapter.tables[`${tableName}${adapter.relationshipsSuffix}`] && withTabledFields.rels) {\n    result.with._rels = {\n      columns: {\n        id: false,\n        parent: false,\n      },\n      orderBy: ({ order }, { asc: ASC }) => [ASC(order)],\n    }\n  }\n\n  if (\n    adapter.tables[`${tableName}${adapter.localesSuffix}`] &&\n    (!select || Object.keys(_locales.columns).length > 1)\n  ) {\n    result.with._locales = _locales\n  }\n\n  // Delete properties that are empty\n  for (const key of Object.keys(result)) {\n    if (!Object.keys(result[key]).length) {\n      delete result[key]\n    }\n  }\n\n  return result\n}\n"],"names":["getSelectMode","traverseFields","buildFindManyArgs","adapter","collectionSlug","depth","draftsEnabled","fields","joinQuery","joins","locale","select","tableName","versions","result","extras","with","columns","id","_locales","_locale","_parentID","withTabledFields","numbers","rels","texts","currentArgs","currentTableName","path","selectMode","undefined","tablePath","topLevelArgs","topLevelTableName","tables","_texts","parent","orderBy","order","asc","ASC","_numbers","relationshipsSuffix","_rels","localesSuffix","Object","keys","length","key"],"mappings":";;;;AAGA,SAASA,aAAa,QAAQ,iBAAgB;AAI9C,SAASC,cAAc,QAAQ,sBAAqB;;;AA2B7C,MAAMC,oBAAoB,CAAC,EAChCC,OAAO,EACPC,cAAc,EACdC,KAAK,EACLC,aAAa,EACbC,MAAM,EACNC,SAAS,EACTC,QAAQ,EAAE,EACVC,MAAM,EACNC,MAAM,EACNC,SAAS,EACTC,QAAQ,EACW;IACnB,MAAMC,SAAiB;QACrBC,QAAQ,CAAC;QACTC,MAAM,CAAC;IACT;IAEA,IAAIL,QAAQ;QACVG,OAAOG,OAAO,GAAG;YACfC,IAAI;QACN;IACF;IAEA,MAAMC,WAAmB;QACvBF,SAASN,SACL;YAAES,SAAS;QAAK,IAChB;YACEF,IAAI;YACJG,WAAW;QACb;QACJN,QAAQ,CAAC;QACTC,MAAM,CAAC;IACT;IAEA,MAAMM,mBAAmBX,SACrB,CAAC,IACD;QACEY,SAAS;QACTC,MAAM;QACNC,OAAO;IACT;QAEJxB,6LAAAA,EAAe;QACbkB;QACAhB;QACAC;QACAsB,aAAaZ;QACba,kBAAkBf;QAClBP;QACAC;QACAC;QACAC;QACAC;QACAC;QACAkB,MAAM;QACNjB;QACAkB,YAAYlB,aAASX,gLAAAA,EAAcW,UAAUmB;QAC7CC,WAAW;QACXC,cAAclB;QACdmB,mBAAmBrB;QACnBC;QACAS;IACF;IAEA,IAAInB,QAAQ+B,MAAM,CAAC,GAAGtB,UAAU,MAAM,CAAC,CAAC,IAAIU,iBAAiBG,KAAK,EAAE;QAClEX,OAAOE,IAAI,CAACmB,MAAM,GAAG;YACnBlB,SAAS;gBACPC,IAAI;gBACJkB,QAAQ;YACV;YACAC,SAAS,CAAC,EAAEC,KAAK,EAAE,EAAE,EAAEC,KAAKC,GAAG,EAAE,GAAK;oBAACA,IAAIF;iBAAO;QACpD;IACF;IAEA,IAAInC,QAAQ+B,MAAM,CAAC,GAAGtB,UAAU,QAAQ,CAAC,CAAC,IAAIU,iBAAiBC,OAAO,EAAE;QACtET,OAAOE,IAAI,CAACyB,QAAQ,GAAG;YACrBxB,SAAS;gBACPC,IAAI;gBACJkB,QAAQ;YACV;YACAC,SAAS,CAAC,EAAEC,KAAK,EAAE,EAAE,EAAEC,KAAKC,GAAG,EAAE,GAAK;oBAACA,IAAIF;iBAAO;QACpD;IACF;IAEA,IAAInC,QAAQ+B,MAAM,CAAC,GAAGtB,YAAYT,QAAQuC,mBAAmB,EAAE,CAAC,IAAIpB,iBAAiBE,IAAI,EAAE;QACzFV,OAAOE,IAAI,CAAC2B,KAAK,GAAG;YAClB1B,SAAS;gBACPC,IAAI;gBACJkB,QAAQ;YACV;YACAC,SAAS,CAAC,EAAEC,KAAK,EAAE,EAAE,EAAEC,KAAKC,GAAG,EAAE,GAAK;oBAACA,IAAIF;iBAAO;QACpD;IACF;IAEA,IACEnC,QAAQ+B,MAAM,CAAC,GAAGtB,YAAYT,QAAQyC,aAAa,EAAE,CAAC,IACrD,CAAA,CAACjC,UAAUkC,OAAOC,IAAI,CAAC3B,SAASF,OAAO,EAAE8B,MAAM,GAAG,CAAA,GACnD;QACAjC,OAAOE,IAAI,CAACG,QAAQ,GAAGA;IACzB;IAEA,mCAAmC;IACnC,KAAK,MAAM6B,OAAOH,OAAOC,IAAI,CAAChC,QAAS;QACrC,IAAI,CAAC+B,OAAOC,IAAI,CAAChC,MAAM,CAACkC,IAAI,EAAED,MAAM,EAAE;YACpC,OAAOjC,MAAM,CAACkC,IAAI;QACpB;IACF;IAEA,OAAOlC;AACT,EAAC"}},
    {"offset": {"line": 3020, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/utilities/createBlocksMap.ts"],"sourcesContent":["export type BlocksMap = {\n  [path: string]: Record<string, unknown>[]\n}\n\nexport const createBlocksMap = (data: Record<string, unknown>): BlocksMap => {\n  const blocksMap: BlocksMap = {}\n\n  Object.entries(data).forEach(([key, rows]) => {\n    if (key.startsWith('_blocks_') && Array.isArray(rows)) {\n      let blockType = key.replace('_blocks_', '')\n      const parsed = blockType.split('_')\n      if (parsed.length === 2 && Number.isInteger(Number(parsed[1]))) {\n        blockType = parsed[0]\n      }\n\n      rows.forEach((row) => {\n        if ('_path' in row) {\n          if (!(row._path in blocksMap)) {\n            blocksMap[row._path] = []\n          }\n\n          row.blockType = blockType\n          blocksMap[row._path].push(row)\n\n          delete row._path\n        }\n      })\n\n      delete data[key]\n    }\n  })\n\n  Object.entries(blocksMap).reduce((sortedBlocksMap, [path, blocks]) => {\n    sortedBlocksMap[path] = blocks.sort((a, b) => {\n      if (typeof a._order === 'number' && typeof b._order === 'number') {\n        return a._order - b._order\n      }\n\n      return 0\n    })\n\n    return sortedBlocksMap\n  }, {})\n\n  return blocksMap\n}\n"],"names":["createBlocksMap","data","blocksMap","Object","entries","forEach","key","rows","startsWith","Array","isArray","blockType","replace","parsed","split","length","Number","isInteger","row","_path","push","reduce","sortedBlocksMap","path","blocks","sort","a","b","_order"],"mappings":";;;;AAIO,MAAMA,kBAAkB,CAACC;IAC9B,MAAMC,YAAuB,CAAC;IAE9BC,OAAOC,OAAO,CAACH,MAAMI,OAAO,CAAC,CAAC,CAACC,KAAKC,KAAK;QACvC,IAAID,IAAIE,UAAU,CAAC,eAAeC,MAAMC,OAAO,CAACH,OAAO;YACrD,IAAII,YAAYL,IAAIM,OAAO,CAAC,YAAY;YACxC,MAAMC,SAASF,UAAUG,KAAK,CAAC;YAC/B,IAAID,OAAOE,MAAM,KAAK,KAAKC,OAAOC,SAAS,CAACD,OAAOH,MAAM,CAAC,EAAE,IAAI;gBAC9DF,YAAYE,MAAM,CAAC,EAAE;YACvB;YAEAN,KAAKF,OAAO,CAAC,CAACa;gBACZ,IAAI,WAAWA,KAAK;oBAClB,IAAI,CAAEA,CAAAA,IAAIC,KAAK,IAAIjB,SAAQ,GAAI;wBAC7BA,SAAS,CAACgB,IAAIC,KAAK,CAAC,GAAG,EAAE;oBAC3B;oBAEAD,IAAIP,SAAS,GAAGA;oBAChBT,SAAS,CAACgB,IAAIC,KAAK,CAAC,CAACC,IAAI,CAACF;oBAE1B,OAAOA,IAAIC,KAAK;gBAClB;YACF;YAEA,OAAOlB,IAAI,CAACK,IAAI;QAClB;IACF;IAEAH,OAAOC,OAAO,CAACF,WAAWmB,MAAM,CAAC,CAACC,iBAAiB,CAACC,MAAMC,OAAO;QAC/DF,eAAe,CAACC,KAAK,GAAGC,OAAOC,IAAI,CAAC,CAACC,GAAGC;YACtC,IAAI,OAAOD,EAAEE,MAAM,KAAK,YAAY,OAAOD,EAAEC,MAAM,KAAK,UAAU;gBAChE,OAAOF,EAAEE,MAAM,GAAGD,EAAEC,MAAM;YAC5B;YAEA,OAAO;QACT;QAEA,OAAON;IACT,GAAG,CAAC;IAEJ,OAAOpB;AACT,EAAC"}},
    {"offset": {"line": 3061, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/utilities/createRelationshipMap.ts"],"sourcesContent":["// Flatten rows to object with path keys\n// for easier retrieval\nexport const createPathMap = (rows: unknown): Record<string, Record<string, unknown>[]> => {\n  let rowsByPath = {}\n\n  if (Array.isArray(rows)) {\n    rowsByPath = rows.reduce((res, row) => {\n      const formattedRow = {\n        ...row,\n      }\n\n      delete formattedRow.path\n\n      if (!res[row.path]) {\n        res[row.path] = []\n      }\n      res[row.path].push(row)\n\n      return res\n    }, {})\n  }\n\n  return rowsByPath\n}\n"],"names":["createPathMap","rows","rowsByPath","Array","isArray","reduce","res","row","formattedRow","path","push"],"mappings":"AAAA,wCAAwC;AACxC,uBAAuB;;;;;AAChB,MAAMA,gBAAgB,CAACC;IAC5B,IAAIC,aAAa,CAAC;IAElB,IAAIC,MAAMC,OAAO,CAACH,OAAO;QACvBC,aAAaD,KAAKI,MAAM,CAAC,CAACC,KAAKC;YAC7B,MAAMC,eAAe;gBACnB,GAAGD,GAAG;YACR;YAEA,OAAOC,aAAaC,IAAI;YAExB,IAAI,CAACH,GAAG,CAACC,IAAIE,IAAI,CAAC,EAAE;gBAClBH,GAAG,CAACC,IAAIE,IAAI,CAAC,GAAG,EAAE;YACpB;YACAH,GAAG,CAACC,IAAIE,IAAI,CAAC,CAACC,IAAI,CAACH;YAEnB,OAAOD;QACT,GAAG,CAAC;IACN;IAEA,OAAOJ;AACT,EAAC"}},
    {"offset": {"line": 3088, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/transform/read/hasManyNumber.ts"],"sourcesContent":["import type { NumberField } from 'payload'\n\ntype Args = {\n  field: NumberField\n  locale?: string\n  numberRows: Record<string, unknown>[]\n  ref: Record<string, unknown>\n  withinArrayOrBlockLocale?: string\n}\n\nexport const transformHasManyNumber = ({\n  field,\n  locale,\n  numberRows,\n  ref,\n  withinArrayOrBlockLocale,\n}: Args) => {\n  let result: unknown[]\n\n  if (withinArrayOrBlockLocale) {\n    result = numberRows.reduce((acc, { locale, number }) => {\n      if (locale === withinArrayOrBlockLocale) {\n        if (typeof number === 'string') {\n          number = Number(number)\n        }\n        acc.push(number)\n      }\n\n      return acc\n    }, [])\n  } else {\n    result = numberRows.map(({ number }) => {\n      if (typeof number === 'string') {\n        number = Number(number)\n      }\n      return number\n    })\n  }\n\n  if (locale) {\n    ref[field.name][locale] = result\n  } else {\n    ref[field.name] = result\n  }\n}\n"],"names":["transformHasManyNumber","field","locale","numberRows","ref","withinArrayOrBlockLocale","result","reduce","acc","number","Number","push","map","name"],"mappings":";;;;AAUO,MAAMA,yBAAyB,CAAC,EACrCC,KAAK,EACLC,MAAM,EACNC,UAAU,EACVC,GAAG,EACHC,wBAAwB,EACnB;IACL,IAAIC;IAEJ,IAAID,0BAA0B;QAC5BC,SAASH,WAAWI,MAAM,CAAC,CAACC,KAAK,EAAEN,MAAM,EAAEO,MAAM,EAAE;YACjD,IAAIP,WAAWG,0BAA0B;gBACvC,IAAI,OAAOI,WAAW,UAAU;oBAC9BA,SAASC,OAAOD;gBAClB;gBACAD,IAAIG,IAAI,CAACF;YACX;YAEA,OAAOD;QACT,GAAG,EAAE;IACP,OAAO;QACLF,SAASH,WAAWS,GAAG,CAAC,CAAC,EAAEH,MAAM,EAAE;YACjC,IAAI,OAAOA,WAAW,UAAU;gBAC9BA,SAASC,OAAOD;YAClB;YACA,OAAOA;QACT;IACF;IAEA,IAAIP,QAAQ;QACVE,GAAG,CAACH,MAAMY,IAAI,CAAC,CAACX,OAAO,GAAGI;IAC5B,OAAO;QACLF,GAAG,CAACH,MAAMY,IAAI,CAAC,GAAGP;IACpB;AACF,EAAC"}},
    {"offset": {"line": 3122, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/transform/read/hasManyText.ts"],"sourcesContent":["import type { TextField } from 'payload'\n\ntype Args = {\n  field: TextField\n  locale?: string\n  ref: Record<string, unknown>\n  textRows: Record<string, unknown>[]\n  withinArrayOrBlockLocale?: string\n}\n\nexport const transformHasManyText = ({\n  field,\n  locale,\n  ref,\n  textRows,\n  withinArrayOrBlockLocale,\n}: Args) => {\n  let result: unknown[]\n\n  if (withinArrayOrBlockLocale) {\n    result = textRows.reduce((acc, { locale, text }) => {\n      if (locale === withinArrayOrBlockLocale) {\n        acc.push(text)\n      }\n\n      return acc\n    }, [])\n  } else {\n    result = textRows.map(({ text }) => text)\n  }\n\n  if (locale) {\n    ref[field.name][locale] = result\n  } else {\n    ref[field.name] = result\n  }\n}\n"],"names":["transformHasManyText","field","locale","ref","textRows","withinArrayOrBlockLocale","result","reduce","acc","text","push","map","name"],"mappings":";;;;AAUO,MAAMA,uBAAuB,CAAC,EACnCC,KAAK,EACLC,MAAM,EACNC,GAAG,EACHC,QAAQ,EACRC,wBAAwB,EACnB;IACL,IAAIC;IAEJ,IAAID,0BAA0B;QAC5BC,SAASF,SAASG,MAAM,CAAC,CAACC,KAAK,EAAEN,MAAM,EAAEO,IAAI,EAAE;YAC7C,IAAIP,WAAWG,0BAA0B;gBACvCG,IAAIE,IAAI,CAACD;YACX;YAEA,OAAOD;QACT,GAAG,EAAE;IACP,OAAO;QACLF,SAASF,SAASO,GAAG,CAAC,CAAC,EAAEF,IAAI,EAAE,GAAKA;IACtC;IAEA,IAAIP,QAAQ;QACVC,GAAG,CAACF,MAAMW,IAAI,CAAC,CAACV,OAAO,GAAGI;IAC5B,OAAO;QACLH,GAAG,CAACF,MAAMW,IAAI,CAAC,GAAGN;IACpB;AACF,EAAC"}},
    {"offset": {"line": 3148, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/transform/read/relationship.ts"],"sourcesContent":["import type { RelationshipField, UploadField } from 'payload'\n\ntype Args = {\n  field: RelationshipField | UploadField\n  locale?: string\n  ref: Record<string, unknown>\n  relations: Record<string, unknown>[]\n  withinArrayOrBlockLocale?: string\n}\n\nexport const transformRelationship = ({\n  field,\n  locale,\n  ref,\n  relations,\n  withinArrayOrBlockLocale,\n}: Args) => {\n  let result: unknown\n\n  if (!('hasMany' in field) || field.hasMany === false) {\n    let relation = relations[0]\n\n    if (withinArrayOrBlockLocale) {\n      relation = relations.find((rel) => rel.locale === withinArrayOrBlockLocale)\n    }\n\n    if (relation) {\n      // Handle hasOne Poly\n      if (Array.isArray(field.relationTo)) {\n        const matchedRelation = Object.entries(relation).find(([key, val]) => {\n          return val !== null && !['id', 'locale', 'order', 'parent', 'path'].includes(key)\n        })\n\n        if (matchedRelation) {\n          const relationTo = matchedRelation[0].replace('ID', '')\n\n          result = {\n            relationTo,\n            value: matchedRelation[1],\n          }\n        }\n      }\n    }\n  } else {\n    const transformedRelations = []\n\n    relations.forEach((relation) => {\n      let matchedLocale = true\n\n      if (withinArrayOrBlockLocale) {\n        matchedLocale = relation.locale === withinArrayOrBlockLocale\n      }\n\n      // Handle hasMany\n      if (!Array.isArray(field.relationTo)) {\n        const relatedData = relation[`${field.relationTo}ID`]\n\n        if (relatedData && matchedLocale) {\n          transformedRelations.push(relatedData)\n        }\n      } else {\n        // Handle hasMany Poly\n        const matchedRelation = Object.entries(relation).find(\n          ([key, val]) =>\n            val !== null &&\n            !['id', 'locale', 'order', 'parent', 'path'].includes(key) &&\n            matchedLocale,\n        )\n\n        if (matchedRelation) {\n          const relationTo = matchedRelation[0].replace('ID', '')\n\n          transformedRelations.push({\n            relationTo,\n            value: matchedRelation[1],\n          })\n        }\n      }\n    })\n\n    result = transformedRelations\n  }\n\n  if (locale) {\n    ref[field.name][locale] = result\n  } else {\n    ref[field.name] = result\n  }\n}\n"],"names":["transformRelationship","field","locale","ref","relations","withinArrayOrBlockLocale","result","hasMany","relation","find","rel","Array","isArray","relationTo","matchedRelation","Object","entries","key","val","includes","replace","value","transformedRelations","forEach","matchedLocale","relatedData","push","name"],"mappings":";;;;AAUO,MAAMA,wBAAwB,CAAC,EACpCC,KAAK,EACLC,MAAM,EACNC,GAAG,EACHC,SAAS,EACTC,wBAAwB,EACnB;IACL,IAAIC;IAEJ,IAAI,CAAE,CAAA,aAAaL,KAAI,KAAMA,MAAMM,OAAO,KAAK,OAAO;QACpD,IAAIC,WAAWJ,SAAS,CAAC,EAAE;QAE3B,IAAIC,0BAA0B;YAC5BG,WAAWJ,UAAUK,IAAI,CAAC,CAACC,MAAQA,IAAIR,MAAM,KAAKG;QACpD;QAEA,IAAIG,UAAU;YACZ,qBAAqB;YACrB,IAAIG,MAAMC,OAAO,CAACX,MAAMY,UAAU,GAAG;gBACnC,MAAMC,kBAAkBC,OAAOC,OAAO,CAACR,UAAUC,IAAI,CAAC,CAAC,CAACQ,KAAKC,IAAI;oBAC/D,OAAOA,QAAQ,QAAQ,CAAC;wBAAC;wBAAM;wBAAU;wBAAS;wBAAU;qBAAO,CAACC,QAAQ,CAACF;gBAC/E;gBAEA,IAAIH,iBAAiB;oBACnB,MAAMD,aAAaC,eAAe,CAAC,EAAE,CAACM,OAAO,CAAC,MAAM;oBAEpDd,SAAS;wBACPO;wBACAQ,OAAOP,eAAe,CAAC,EAAE;oBAC3B;gBACF;YACF;QACF;IACF,OAAO;QACL,MAAMQ,uBAAuB,EAAE;QAE/BlB,UAAUmB,OAAO,CAAC,CAACf;YACjB,IAAIgB,gBAAgB;YAEpB,IAAInB,0BAA0B;gBAC5BmB,gBAAgBhB,SAASN,MAAM,KAAKG;YACtC;YAEA,iBAAiB;YACjB,IAAI,CAACM,MAAMC,OAAO,CAACX,MAAMY,UAAU,GAAG;gBACpC,MAAMY,cAAcjB,QAAQ,CAAC,GAAGP,MAAMY,UAAU,CAAC,EAAE,CAAC,CAAC;gBAErD,IAAIY,eAAeD,eAAe;oBAChCF,qBAAqBI,IAAI,CAACD;gBAC5B;YACF,OAAO;gBACL,sBAAsB;gBACtB,MAAMX,kBAAkBC,OAAOC,OAAO,CAACR,UAAUC,IAAI,CACnD,CAAC,CAACQ,KAAKC,IAAI,GACTA,QAAQ,QACR,CAAC;wBAAC;wBAAM;wBAAU;wBAAS;wBAAU;qBAAO,CAACC,QAAQ,CAACF,QACtDO;gBAGJ,IAAIV,iBAAiB;oBACnB,MAAMD,aAAaC,eAAe,CAAC,EAAE,CAACM,OAAO,CAAC,MAAM;oBAEpDE,qBAAqBI,IAAI,CAAC;wBACxBb;wBACAQ,OAAOP,eAAe,CAAC,EAAE;oBAC3B;gBACF;YACF;QACF;QAEAR,SAASgB;IACX;IAEA,IAAIpB,QAAQ;QACVC,GAAG,CAACF,MAAM0B,IAAI,CAAC,CAACzB,OAAO,GAAGI;IAC5B,OAAO;QACLH,GAAG,CAACF,MAAM0B,IAAI,CAAC,GAAGrB;IACpB;AACF,EAAC"}},
    {"offset": {"line": 3223, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/transform/read/traverseFields.ts"],"sourcesContent":["import type { FlattenedBlock, FlattenedField, JoinQuery, SanitizedConfig } from 'payload'\n\nimport { fieldIsVirtual, fieldShouldBeLocalized } from 'payload/shared'\nimport toSnakeCase from 'to-snake-case'\n\nimport type { DrizzleAdapter } from '../../types.js'\nimport type { BlocksMap } from '../../utilities/createBlocksMap.js'\n\nimport { getArrayRelationName } from '../../utilities/getArrayRelationName.js'\nimport { resolveBlockTableName } from '../../utilities/validateExistingBlockIsIdentical.js'\nimport { transformHasManyNumber } from './hasManyNumber.js'\nimport { transformHasManyText } from './hasManyText.js'\nimport { transformRelationship } from './relationship.js'\n\ntype TraverseFieldsArgs = {\n  /**\n   * The DB adapter\n   */\n  adapter: DrizzleAdapter\n  /**\n   * Pre-formatted blocks map\n   */\n  blocks: BlocksMap\n  /**\n   * The full Payload config\n   */\n  config: SanitizedConfig\n  currentTableName: string\n  /**\n   * The data reference to be mutated within this recursive function\n   */\n  dataRef: Record<string, unknown>\n  /**\n   * Data that needs to be removed from the result after all fields have populated\n   */\n  deletions: (() => void)[]\n  /**\n   * Column prefix can be built up by group and named tab fields\n   */\n  fieldPrefix: string\n  /**\n   * An array of Payload fields to traverse\n   */\n  fields: FlattenedField[]\n  /**\n   *\n   */\n  joinQuery?: JoinQuery\n  /**\n   * All hasMany number fields, as returned by Drizzle, keyed on an object by field path\n   */\n  numbers: Record<string, Record<string, unknown>[]>\n  parentIsLocalized: boolean\n  /**\n   * The current field path (in dot notation), used to merge in relationships\n   */\n  path: string\n  /**\n   * All related documents, as returned by Drizzle, keyed on an object by field path\n   */\n  relationships: Record<string, Record<string, unknown>[]>\n  /**\n   * Data structure representing the nearest table from db\n   */\n  table: Record<string, unknown>\n  tablePath: string\n  /**\n   * All hasMany text fields, as returned by Drizzle, keyed on an object by field path\n   */\n  texts: Record<string, Record<string, unknown>[]>\n  topLevelTableName: string\n  /**\n   * Set to a locale if this group of fields is within a localized array or block.\n   */\n  withinArrayOrBlockLocale?: string\n}\n\n// Traverse fields recursively, transforming data\n// for each field type into required Payload shape\nexport const traverseFields = <T extends Record<string, unknown>>({\n  adapter,\n  blocks,\n  config,\n  currentTableName,\n  dataRef,\n  deletions,\n  fieldPrefix,\n  fields,\n  joinQuery,\n  numbers,\n  parentIsLocalized,\n  path,\n  relationships,\n  table,\n  tablePath,\n  texts,\n  topLevelTableName,\n  withinArrayOrBlockLocale,\n}: TraverseFieldsArgs): T => {\n  const sanitizedPath = path ? `${path}.` : path\n  const localeCodes =\n    adapter.payload.config.localization && adapter.payload.config.localization.localeCodes\n\n  const formatted = fields.reduce((result, field) => {\n    if (fieldIsVirtual(field)) {\n      return result\n    }\n\n    const fieldName = `${fieldPrefix || ''}${field.name}`\n    let fieldData = table[fieldName]\n    const localizedFieldData = {}\n    const valuesToTransform: {\n      ref: Record<string, unknown>\n      table: Record<string, unknown>\n    }[] = []\n\n    if (fieldPrefix) {\n      deletions.push(() => delete table[fieldName])\n    }\n\n    const isLocalized = fieldShouldBeLocalized({ field, parentIsLocalized })\n\n    if (field.type === 'array') {\n      const arrayTableName = adapter.tableNameMap.get(\n        `${currentTableName}_${tablePath}${toSnakeCase(field.name)}`,\n      )\n\n      fieldData = table[getArrayRelationName({ field, path: fieldName, tableName: arrayTableName })]\n\n      if (Array.isArray(fieldData)) {\n        if (isLocalized) {\n          result[field.name] = fieldData.reduce((arrayResult, row) => {\n            if (typeof row._locale === 'string') {\n              if (!arrayResult[row._locale]) {\n                arrayResult[row._locale] = []\n              }\n              const locale = row._locale\n              const data = {}\n              delete row._locale\n              if (row._uuid) {\n                row.id = row._uuid\n                delete row._uuid\n              }\n\n              const rowResult = traverseFields<T>({\n                adapter,\n                blocks,\n                config,\n                currentTableName: arrayTableName,\n                dataRef: data,\n                deletions,\n                fieldPrefix: '',\n                fields: field.flattenedFields,\n                numbers,\n                parentIsLocalized: parentIsLocalized || field.localized,\n                path: `${sanitizedPath}${field.name}.${row._order - 1}`,\n                relationships,\n                table: row,\n                tablePath: '',\n                texts,\n                topLevelTableName,\n                withinArrayOrBlockLocale: locale,\n              })\n\n              if ('_order' in rowResult) {\n                delete rowResult._order\n              }\n\n              arrayResult[locale].push(rowResult)\n            }\n\n            return arrayResult\n          }, {})\n        } else {\n          result[field.name] = fieldData.reduce((acc, row, i) => {\n            if (row._uuid) {\n              row.id = row._uuid\n              delete row._uuid\n            }\n\n            if ('_order' in row) {\n              delete row._order\n            }\n\n            if (\n              !withinArrayOrBlockLocale ||\n              (withinArrayOrBlockLocale && withinArrayOrBlockLocale === row._locale)\n            ) {\n              if (row._locale) {\n                delete row._locale\n              }\n\n              acc.push(\n                traverseFields<T>({\n                  adapter,\n                  blocks,\n                  config,\n                  currentTableName: arrayTableName,\n                  dataRef: row,\n                  deletions,\n                  fieldPrefix: '',\n                  fields: field.flattenedFields,\n                  numbers,\n                  parentIsLocalized: parentIsLocalized || field.localized,\n                  path: `${sanitizedPath}${field.name}.${i}`,\n                  relationships,\n                  table: row,\n                  tablePath: '',\n                  texts,\n                  topLevelTableName,\n                  withinArrayOrBlockLocale,\n                }),\n              )\n            }\n\n            return acc\n          }, [])\n        }\n      }\n\n      return result\n    }\n\n    if (field.type === 'blocks' && !adapter.blocksAsJSON) {\n      const blockFieldPath = `${sanitizedPath}${field.name}`\n      const blocksByPath = blocks[blockFieldPath]\n\n      if (Array.isArray(blocksByPath)) {\n        if (isLocalized) {\n          result[field.name] = {}\n\n          blocksByPath.forEach((row) => {\n            if (row._uuid) {\n              row.id = row._uuid\n              delete row._uuid\n            }\n            if (typeof row._locale === 'string') {\n              if (!result[field.name][row._locale]) {\n                result[field.name][row._locale] = []\n              }\n              result[field.name][row._locale].push(row)\n              delete row._locale\n            }\n          })\n\n          Object.entries(result[field.name]).forEach(([locale, localizedBlocks]) => {\n            result[field.name][locale] = localizedBlocks.map((row) => {\n              const block =\n                adapter.payload.blocks[row.blockType] ??\n                ((field.blockReferences ?? field.blocks).find(\n                  (block) => typeof block !== 'string' && block.slug === row.blockType,\n                ) as FlattenedBlock | undefined)\n\n              const tableName = resolveBlockTableName(\n                block,\n                adapter.tableNameMap.get(`${topLevelTableName}_blocks_${toSnakeCase(block.slug)}`),\n              )\n\n              if (block) {\n                const blockResult = traverseFields<T>({\n                  adapter,\n                  blocks,\n                  config,\n                  currentTableName: tableName,\n                  dataRef: row,\n                  deletions,\n                  fieldPrefix: '',\n                  fields: block.flattenedFields,\n                  numbers,\n                  parentIsLocalized: parentIsLocalized || field.localized,\n                  path: `${blockFieldPath}.${row._order - 1}`,\n                  relationships,\n                  table: row,\n                  tablePath: '',\n                  texts,\n                  topLevelTableName,\n                  withinArrayOrBlockLocale: locale,\n                })\n\n                delete blockResult._order\n                return blockResult\n              }\n\n              return {}\n            })\n          })\n        } else {\n          // Add locale-specific index to have a proper blockFieldPath for current locale\n          // because blocks can be in the same array for different locales!\n          if (withinArrayOrBlockLocale && config.localization) {\n            for (const locale of config.localization.localeCodes) {\n              let localeIndex = 0\n\n              for (let i = 0; i < blocksByPath.length; i++) {\n                const row = blocksByPath[i]\n                if (row._locale === locale) {\n                  row._index = localeIndex\n                  localeIndex++\n                }\n              }\n            }\n          }\n\n          result[field.name] = blocksByPath.reduce((acc, row, i) => {\n            delete row._order\n            if (row._uuid) {\n              row.id = row._uuid\n              delete row._uuid\n            }\n\n            if (typeof row.blockType !== 'string') {\n              return acc\n            }\n\n            const block =\n              adapter.payload.blocks[row.blockType] ??\n              ((field.blockReferences ?? field.blocks).find(\n                (block) => typeof block !== 'string' && block.slug === row.blockType,\n              ) as FlattenedBlock | undefined)\n\n            if (block) {\n              if (\n                !withinArrayOrBlockLocale ||\n                (withinArrayOrBlockLocale && withinArrayOrBlockLocale === row._locale)\n              ) {\n                if (row._locale) {\n                  delete row._locale\n                }\n                if (typeof row._index === 'number') {\n                  i = row._index\n                  delete row._index\n                }\n\n                const tableName = resolveBlockTableName(\n                  block,\n                  adapter.tableNameMap.get(\n                    `${topLevelTableName}_blocks_${toSnakeCase(block.slug)}`,\n                  ),\n                )\n\n                acc.push(\n                  traverseFields<T>({\n                    adapter,\n                    blocks,\n                    config,\n                    currentTableName: tableName,\n                    dataRef: row,\n                    deletions,\n                    fieldPrefix: '',\n                    fields: block.flattenedFields,\n                    numbers,\n                    parentIsLocalized: parentIsLocalized || field.localized,\n                    path: `${blockFieldPath}.${i}`,\n                    relationships,\n                    table: row,\n                    tablePath: '',\n                    texts,\n                    topLevelTableName,\n                    withinArrayOrBlockLocale,\n                  }),\n                )\n\n                return acc\n              }\n            } else {\n              acc.push({})\n            }\n\n            return acc\n          }, [])\n        }\n      }\n\n      return result\n    }\n\n    if (\n      (field.type === 'relationship' || field.type === 'upload') &&\n      (Array.isArray(field.relationTo) || field.hasMany)\n    ) {\n      const relationPathMatch = relationships[`${sanitizedPath}${field.name}`]\n\n      if (!relationPathMatch) {\n        if ('hasMany' in field && field.hasMany) {\n          if (isLocalized && config.localization && config.localization.locales) {\n            result[field.name] = {\n              [config.localization.defaultLocale]: [],\n            }\n          } else {\n            result[field.name] = []\n          }\n        }\n\n        return result\n      }\n\n      if (isLocalized) {\n        result[field.name] = {}\n        const relationsByLocale: Record<string, Record<string, unknown>[]> = {}\n\n        relationPathMatch.forEach((row) => {\n          if (typeof row.locale === 'string') {\n            if (!relationsByLocale[row.locale]) {\n              relationsByLocale[row.locale] = []\n            }\n            relationsByLocale[row.locale].push(row)\n          }\n        })\n\n        Object.entries(relationsByLocale).forEach(([locale, relations]) => {\n          transformRelationship({\n            field,\n            locale,\n            ref: result,\n            relations,\n          })\n        })\n      } else {\n        transformRelationship({\n          field,\n          ref: result,\n          relations: relationPathMatch,\n          withinArrayOrBlockLocale,\n        })\n      }\n      return result\n    }\n\n    if (field.type === 'join') {\n      const { count, limit = field.defaultLimit ?? 10 } =\n        joinQuery?.[`${fieldPrefix.replaceAll('_', '.')}${field.name}`] || {}\n\n      // raw hasMany results from SQLite\n      if (typeof fieldData === 'string') {\n        fieldData = JSON.parse(fieldData)\n      }\n\n      let fieldResult:\n        | { docs: unknown[]; hasNextPage: boolean; totalDocs?: number }\n        | Record<string, { docs: unknown[]; hasNextPage: boolean; totalDocs?: number }>\n      if (Array.isArray(fieldData)) {\n        if (isLocalized && adapter.payload.config.localization) {\n          fieldResult = fieldData.reduce(\n            (joinResult, row) => {\n              if (typeof row.locale === 'string') {\n                joinResult[row.locale].docs.push(row.id)\n              }\n\n              return joinResult\n            },\n\n            // initialize with defaults so empty won't be undefined\n            adapter.payload.config.localization.localeCodes.reduce((acc, code) => {\n              acc[code] = {\n                docs: [],\n                hasNextPage: false,\n              }\n              return acc\n            }, {}),\n          )\n          Object.keys(fieldResult).forEach((locale) => {\n            fieldResult[locale].hasNextPage = fieldResult[locale].docs.length > limit\n            fieldResult[locale].docs = fieldResult[locale].docs.slice(0, limit)\n          })\n        } else {\n          const hasNextPage = limit !== 0 && fieldData.length > limit\n          fieldResult = {\n            docs: (hasNextPage ? fieldData.slice(0, limit) : fieldData).map(\n              ({ id, relationTo }) => {\n                if (relationTo) {\n                  return { relationTo, value: id }\n                }\n                return { id }\n              },\n            ),\n            hasNextPage,\n          }\n        }\n      }\n\n      if (count) {\n        const countPath = `${fieldName}_count`\n        if (typeof table[countPath] !== 'undefined') {\n          let value = Number(table[countPath])\n          if (Number.isNaN(value)) {\n            value = 0\n          }\n          fieldResult.totalDocs = value\n        }\n      }\n\n      result[field.name] = fieldResult\n      return result\n    }\n\n    if (field.type === 'text' && field?.hasMany) {\n      const textPathMatch = texts[`${sanitizedPath}${field.name}`]\n      if (!textPathMatch) {\n        result[field.name] =\n          isLocalized && localeCodes\n            ? Object.fromEntries(localeCodes.map((locale) => [locale, []]))\n            : []\n        return result\n      }\n\n      if (isLocalized) {\n        result[field.name] = {}\n        const textsByLocale: Record<string, Record<string, unknown>[]> = {}\n\n        textPathMatch.forEach((row) => {\n          if (typeof row.locale === 'string') {\n            if (!textsByLocale[row.locale]) {\n              textsByLocale[row.locale] = []\n            }\n            textsByLocale[row.locale].push(row)\n          }\n        })\n\n        Object.entries(textsByLocale).forEach(([locale, texts]) => {\n          transformHasManyText({\n            field,\n            locale,\n            ref: result,\n            textRows: texts,\n          })\n        })\n      } else {\n        transformHasManyText({\n          field,\n          ref: result,\n          textRows: textPathMatch,\n          withinArrayOrBlockLocale,\n        })\n      }\n\n      return result\n    }\n\n    if (field.type === 'number' && field.hasMany) {\n      const numberPathMatch = numbers[`${sanitizedPath}${field.name}`]\n      if (!numberPathMatch) {\n        result[field.name] =\n          isLocalized && localeCodes\n            ? Object.fromEntries(localeCodes.map((locale) => [locale, []]))\n            : []\n        return result\n      }\n\n      if (isLocalized) {\n        result[field.name] = {}\n        const numbersByLocale: Record<string, Record<string, unknown>[]> = {}\n\n        numberPathMatch.forEach((row) => {\n          if (typeof row.locale === 'string') {\n            if (!numbersByLocale[row.locale]) {\n              numbersByLocale[row.locale] = []\n            }\n            numbersByLocale[row.locale].push(row)\n          }\n        })\n\n        Object.entries(numbersByLocale).forEach(([locale, numbers]) => {\n          transformHasManyNumber({\n            field,\n            locale,\n            numberRows: numbers,\n            ref: result,\n          })\n        })\n      } else {\n        transformHasManyNumber({\n          field,\n          numberRows: numberPathMatch,\n          ref: result,\n          withinArrayOrBlockLocale,\n        })\n      }\n\n      return result\n    }\n\n    if (field.type === 'select' && field.hasMany) {\n      if (Array.isArray(fieldData)) {\n        if (isLocalized) {\n          result[field.name] = fieldData.reduce((selectResult, row) => {\n            if (typeof row.locale === 'string') {\n              if (!selectResult[row.locale]) {\n                selectResult[row.locale] = []\n              }\n              selectResult[row.locale].push(row.value)\n            }\n\n            return selectResult\n          }, {})\n        } else {\n          let selectData = fieldData\n          if (withinArrayOrBlockLocale) {\n            selectData = selectData.filter(({ locale }) => locale === withinArrayOrBlockLocale)\n          }\n          result[field.name] = selectData.map(({ value }) => value)\n        }\n      }\n      return result\n    }\n\n    if (isLocalized && Array.isArray(table._locales)) {\n      if (!table._locales.length && localeCodes) {\n        localeCodes.forEach((_locale) => (table._locales as unknown[]).push({ _locale }))\n      }\n\n      table._locales.forEach((localeRow) => {\n        valuesToTransform.push({\n          ref: localizedFieldData,\n          table: {\n            ...table,\n            ...localeRow,\n          },\n        })\n      })\n    } else {\n      valuesToTransform.push({ ref: result, table })\n    }\n\n    valuesToTransform.forEach(({ ref, table }) => {\n      const fieldData = table[`${fieldPrefix || ''}${field.name}`]\n      const locale = table?._locale\n      let val = fieldData\n\n      switch (field.type) {\n        case 'date': {\n          if (typeof fieldData === 'string') {\n            val = new Date(fieldData).toISOString()\n          }\n\n          break\n        }\n\n        case 'group':\n        case 'tab': {\n          const groupFieldPrefix = `${fieldPrefix || ''}${field.name}_`\n          const groupData = {}\n          const locale = table._locale as string\n          const refKey = isLocalized && locale ? locale : field.name\n\n          if (isLocalized && locale) {\n            delete table._locale\n          }\n          ref[refKey] = traverseFields<Record<string, unknown>>({\n            adapter,\n            blocks,\n            config,\n            currentTableName,\n            dataRef: groupData as Record<string, unknown>,\n            deletions,\n            fieldPrefix: groupFieldPrefix,\n            fields: field.flattenedFields,\n            joinQuery,\n            numbers,\n            parentIsLocalized: parentIsLocalized || field.localized,\n            path: `${sanitizedPath}${field.name}`,\n            relationships,\n            table,\n            tablePath: `${tablePath}${toSnakeCase(field.name)}_`,\n            texts,\n            topLevelTableName,\n            withinArrayOrBlockLocale: locale || withinArrayOrBlockLocale,\n          })\n\n          return\n        }\n\n        case 'number': {\n          if (typeof fieldData === 'string') {\n            val = Number.parseFloat(fieldData)\n          }\n\n          break\n        }\n\n        case 'point': {\n          if (typeof fieldData === 'string') {\n            val = JSON.parse(fieldData)\n          }\n\n          break\n        }\n\n        case 'relationship':\n        case 'upload': {\n          if (\n            val &&\n            typeof field.relationTo === 'string' &&\n            adapter.payload.collections[field.relationTo].customIDType === 'number'\n          ) {\n            val = Number(val)\n          }\n\n          break\n        }\n        case 'text': {\n          if (typeof fieldData === 'string') {\n            val = String(fieldData)\n          }\n\n          break\n        }\n\n        default: {\n          break\n        }\n      }\n      if (typeof locale === 'string') {\n        ref[locale] = val\n      } else {\n        result[field.name] = val\n      }\n    })\n\n    if (Object.keys(localizedFieldData).length > 0) {\n      result[field.name] = localizedFieldData\n    }\n\n    return result\n  }, dataRef)\n\n  if (Array.isArray(table._locales)) {\n    deletions.push(() => delete table._locales)\n  }\n\n  return formatted as T\n}\n"],"names":["fieldIsVirtual","fieldShouldBeLocalized","toSnakeCase","getArrayRelationName","resolveBlockTableName","transformHasManyNumber","transformHasManyText","transformRelationship","traverseFields","adapter","blocks","config","currentTableName","dataRef","deletions","fieldPrefix","fields","joinQuery","numbers","parentIsLocalized","path","relationships","table","tablePath","texts","topLevelTableName","withinArrayOrBlockLocale","sanitizedPath","localeCodes","payload","localization","formatted","reduce","result","field","fieldName","name","fieldData","localizedFieldData","valuesToTransform","push","isLocalized","type","arrayTableName","tableNameMap","get","tableName","Array","isArray","arrayResult","row","_locale","locale","data","_uuid","id","rowResult","flattenedFields","localized","_order","acc","i","blocksAsJSON","blockFieldPath","blocksByPath","forEach","Object","entries","localizedBlocks","map","block","blockType","blockReferences","find","slug","blockResult","localeIndex","length","_index","relationTo","hasMany","relationPathMatch","locales","defaultLocale","relationsByLocale","relations","ref","count","limit","defaultLimit","replaceAll","JSON","parse","fieldResult","joinResult","docs","code","hasNextPage","keys","slice","value","countPath","Number","isNaN","totalDocs","textPathMatch","fromEntries","textsByLocale","textRows","numberPathMatch","numbersByLocale","numberRows","selectResult","selectData","filter","_locales","localeRow","val","Date","toISOString","groupFieldPrefix","groupData","refKey","parseFloat","collections","customIDType","String"],"mappings":"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"}},
    {"offset": {"line": 3775, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/transform/read/index.ts"],"sourcesContent":["import type { FlattenedField, JoinQuery, SanitizedConfig, TypeWithID } from 'payload'\n\nimport type { DrizzleAdapter } from '../../types.js'\n\nimport { createBlocksMap } from '../../utilities/createBlocksMap.js'\nimport { createPathMap } from '../../utilities/createRelationshipMap.js'\nimport { traverseFields } from './traverseFields.js'\n\ntype TransformArgs = {\n  adapter: DrizzleAdapter\n  config: SanitizedConfig\n  data: Record<string, unknown>\n  fallbackLocale?: false | string\n  fields: FlattenedField[]\n  joinQuery?: JoinQuery\n  locale?: string\n  parentIsLocalized?: boolean\n  tableName: string\n}\n\n// This is the entry point to transform Drizzle output data\n// into the shape Payload expects based on field schema\nexport const transform = <T extends Record<string, unknown> | TypeWithID>({\n  adapter,\n  config,\n  data,\n  fields,\n  joinQuery,\n  parentIsLocalized,\n  tableName,\n}: TransformArgs): T => {\n  let relationships: Record<string, Record<string, unknown>[]> = {}\n  let texts: Record<string, Record<string, unknown>[]> = {}\n  let numbers: Record<string, Record<string, unknown>[]> = {}\n\n  if ('_rels' in data) {\n    relationships = createPathMap(data._rels)\n    delete data._rels\n  }\n\n  if ('_texts' in data) {\n    texts = createPathMap(data._texts)\n    delete data._texts\n  }\n\n  if ('_numbers' in data) {\n    numbers = createPathMap(data._numbers)\n    delete data._numbers\n  }\n\n  const blocks = createBlocksMap(data)\n\n  const deletions = []\n\n  const result = traverseFields<T>({\n    adapter,\n    blocks,\n    config,\n    currentTableName: tableName,\n    dataRef: {\n      id: data.id,\n    },\n    deletions,\n    fieldPrefix: '',\n    fields,\n    joinQuery,\n    numbers,\n    parentIsLocalized,\n    path: '',\n    relationships,\n    table: data,\n    tablePath: '',\n    texts,\n    topLevelTableName: tableName,\n  })\n\n  deletions.forEach((deletion) => deletion())\n\n  return result\n}\n"],"names":["createBlocksMap","createPathMap","traverseFields","transform","adapter","config","data","fields","joinQuery","parentIsLocalized","tableName","relationships","texts","numbers","_rels","_texts","_numbers","blocks","deletions","result","currentTableName","dataRef","id","fieldPrefix","path","table","tablePath","topLevelTableName","forEach","deletion"],"mappings":";;;;AAIA,SAASA,eAAe,QAAQ,qCAAoC;AACpE,SAASC,aAAa,QAAQ,2CAA0C;AACxE,SAASC,cAAc,QAAQ,sBAAqB;;;;AAgB7C,MAAMC,YAAY,CAAiD,EACxEC,OAAO,EACPC,MAAM,EACNC,IAAI,EACJC,MAAM,EACNC,SAAS,EACTC,iBAAiB,EACjBC,SAAS,EACK;IACd,IAAIC,gBAA2D,CAAC;IAChE,IAAIC,QAAmD,CAAC;IACxD,IAAIC,UAAqD,CAAC;IAE1D,IAAI,WAAWP,MAAM;QACnBK,oBAAgBV,wMAAAA,EAAcK,KAAKQ,KAAK;QACxC,OAAOR,KAAKQ,KAAK;IACnB;IAEA,IAAI,YAAYR,MAAM;QACpBM,YAAQX,wMAAAA,EAAcK,KAAKS,MAAM;QACjC,OAAOT,KAAKS,MAAM;IACpB;IAEA,IAAI,cAAcT,MAAM;QACtBO,cAAUZ,wMAAAA,EAAcK,KAAKU,QAAQ;QACrC,OAAOV,KAAKU,QAAQ;IACtB;IAEA,MAAMC,aAASjB,oMAAAA,EAAgBM;IAE/B,MAAMY,YAAY,EAAE;IAEpB,MAAMC,aAASjB,0MAAAA,EAAkB;QAC/BE;QACAa;QACAZ;QACAe,kBAAkBV;QAClBW,SAAS;YACPC,IAAIhB,KAAKgB,EAAE;QACb;QACAJ;QACAK,aAAa;QACbhB;QACAC;QACAK;QACAJ;QACAe,MAAM;QACNb;QACAc,OAAOnB;QACPoB,WAAW;QACXd;QACAe,mBAAmBjB;IACrB;IAEAQ,UAAUU,OAAO,CAAC,CAACC,WAAaA;IAEhC,OAAOV;AACT,EAAC"}},
    {"offset": {"line": 3831, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/utilities/isArrayOfRows.ts"],"sourcesContent":["export function isArrayOfRows(data: unknown): data is Record<string, unknown>[] {\n  return Array.isArray(data)\n}\n"],"names":["isArrayOfRows","data","Array","isArray"],"mappings":";;;;AAAO,SAASA,cAAcC,IAAa;IACzC,OAAOC,MAAMC,OAAO,CAACF;AACvB"}},
    {"offset": {"line": 3842, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/transform/write/array.ts"],"sourcesContent":["import type { FlattenedArrayField } from 'payload'\n\nimport { fieldShouldBeLocalized } from 'payload/shared'\n\nimport type { DrizzleAdapter } from '../../types.js'\nimport type {\n  ArrayRowToInsert,\n  BlockRowToInsert,\n  NumberToDelete,\n  RelationshipToDelete,\n  TextToDelete,\n} from './types.js'\n\nimport { isArrayOfRows } from '../../utilities/isArrayOfRows.js'\nimport { traverseFields } from './traverseFields.js'\n\ntype Args = {\n  adapter: DrizzleAdapter\n  arrayTableName: string\n  baseTableName: string\n  blocks: {\n    [blockType: string]: BlockRowToInsert[]\n  }\n  blocksToDelete: Set<string>\n  data: unknown\n  field: FlattenedArrayField\n  locale?: string\n  numbers: Record<string, unknown>[]\n  numbersToDelete: NumberToDelete[]\n  parentIsLocalized: boolean\n  path: string\n  relationships: Record<string, unknown>[]\n  relationshipsToDelete: RelationshipToDelete[]\n  selects: {\n    [tableName: string]: Record<string, unknown>[]\n  }\n  texts: Record<string, unknown>[]\n  textsToDelete: TextToDelete[]\n  /**\n   * Set to a locale code if this set of fields is traversed within a\n   * localized array or block field\n   */\n  withinArrayOrBlockLocale?: string\n}\n\nexport const transformArray = ({\n  adapter,\n  arrayTableName,\n  baseTableName,\n  blocks,\n  blocksToDelete,\n  data,\n  field,\n  locale,\n  numbers,\n  numbersToDelete,\n  parentIsLocalized,\n  path,\n  relationships,\n  relationshipsToDelete,\n  selects,\n  texts,\n  textsToDelete,\n  withinArrayOrBlockLocale,\n}: Args) => {\n  const newRows: ArrayRowToInsert[] = []\n\n  const hasUUID = adapter.tables[arrayTableName]._uuid\n\n  if (isArrayOfRows(data)) {\n    data.forEach((arrayRow, i) => {\n      const newRow: ArrayRowToInsert = {\n        arrays: {},\n        arraysToPush: {},\n        locales: {},\n        row: {\n          _order: i + 1,\n        },\n      }\n\n      // If we have declared a _uuid field on arrays,\n      // that means the ID has to be unique,\n      // and our ids within arrays are not unique.\n      // So move the ID to a uuid field for storage\n      // and allow the database to generate a serial id automatically\n      if (hasUUID) {\n        newRow.row._uuid = arrayRow.id\n        delete arrayRow.id\n      }\n\n      if (locale) {\n        newRow.locales[locale] = {\n          _locale: locale,\n        }\n      }\n\n      if (fieldShouldBeLocalized({ field, parentIsLocalized }) && locale) {\n        newRow.row._locale = locale\n      }\n\n      if (withinArrayOrBlockLocale) {\n        newRow.row._locale = withinArrayOrBlockLocale\n      }\n\n      traverseFields({\n        adapter,\n        arrays: newRow.arrays,\n        arraysToPush: newRow.arraysToPush,\n        baseTableName,\n        blocks,\n        blocksToDelete,\n        columnPrefix: '',\n        data: arrayRow,\n        fieldPrefix: '',\n        fields: field.flattenedFields,\n        insideArrayOrBlock: true,\n        locales: newRow.locales,\n        numbers,\n        numbersToDelete,\n        parentIsLocalized: parentIsLocalized || field.localized,\n        parentTableName: arrayTableName,\n        path: `${path || ''}${field.name}.${i}.`,\n        relationships,\n        relationshipsToAppend: [],\n        relationshipsToDelete,\n        row: newRow.row,\n        selects,\n        texts,\n        textsToDelete,\n        withinArrayOrBlockLocale,\n      })\n\n      newRows.push(newRow)\n    })\n  }\n\n  return newRows\n}\n"],"names":["fieldShouldBeLocalized","isArrayOfRows","traverseFields","transformArray","adapter","arrayTableName","baseTableName","blocks","blocksToDelete","data","field","locale","numbers","numbersToDelete","parentIsLocalized","path","relationships","relationshipsToDelete","selects","texts","textsToDelete","withinArrayOrBlockLocale","newRows","hasUUID","tables","_uuid","forEach","arrayRow","i","newRow","arrays","arraysToPush","locales","row","_order","id","_locale","columnPrefix","fieldPrefix","fields","flattenedFields","insideArrayOrBlock","localized","parentTableName","name","relationshipsToAppend","push"],"mappings":";;;;AAEA,SAASA,sBAAsB,QAAQ,iBAAgB;AAWvD,SAASC,aAAa,QAAQ,mCAAkC;AAChE,SAASC,cAAc,QAAQ,sBAAqB;;;;AA+B7C,MAAMC,iBAAiB,CAAC,EAC7BC,OAAO,EACPC,cAAc,EACdC,aAAa,EACbC,MAAM,EACNC,cAAc,EACdC,IAAI,EACJC,KAAK,EACLC,MAAM,EACNC,OAAO,EACPC,eAAe,EACfC,iBAAiB,EACjBC,IAAI,EACJC,aAAa,EACbC,qBAAqB,EACrBC,OAAO,EACPC,KAAK,EACLC,aAAa,EACbC,wBAAwB,EACnB;IACL,MAAMC,UAA8B,EAAE;IAEtC,MAAMC,UAAUnB,QAAQoB,MAAM,CAACnB,eAAe,CAACoB,KAAK;IAEpD,QAAIxB,gMAAAA,EAAcQ,OAAO;QACvBA,KAAKiB,OAAO,CAAC,CAACC,UAAUC;YACtB,MAAMC,SAA2B;gBAC/BC,QAAQ,CAAC;gBACTC,cAAc,CAAC;gBACfC,SAAS,CAAC;gBACVC,KAAK;oBACHC,QAAQN,IAAI;gBACd;YACF;YAEA,+CAA+C;YAC/C,sCAAsC;YACtC,4CAA4C;YAC5C,6CAA6C;YAC7C,+DAA+D;YAC/D,IAAIL,SAAS;gBACXM,OAAOI,GAAG,CAACR,KAAK,GAAGE,SAASQ,EAAE;gBAC9B,OAAOR,SAASQ,EAAE;YACpB;YAEA,IAAIxB,QAAQ;gBACVkB,OAAOG,OAAO,CAACrB,OAAO,GAAG;oBACvByB,SAASzB;gBACX;YACF;YAEA,QAAIX,wLAAAA,EAAuB;gBAAEU;gBAAOI;YAAkB,MAAMH,QAAQ;gBAClEkB,OAAOI,GAAG,CAACG,OAAO,GAAGzB;YACvB;YAEA,IAAIU,0BAA0B;gBAC5BQ,OAAOI,GAAG,CAACG,OAAO,GAAGf;YACvB;gBAEAnB,2MAAAA,EAAe;gBACbE;gBACA0B,QAAQD,OAAOC,MAAM;gBACrBC,cAAcF,OAAOE,YAAY;gBACjCzB;gBACAC;gBACAC;gBACA6B,cAAc;gBACd5B,MAAMkB;gBACNW,aAAa;gBACbC,QAAQ7B,MAAM8B,eAAe;gBAC7BC,oBAAoB;gBACpBT,SAASH,OAAOG,OAAO;gBACvBpB;gBACAC;gBACAC,mBAAmBA,qBAAqBJ,MAAMgC,SAAS;gBACvDC,iBAAiBtC;gBACjBU,MAAM,GAAGA,QAAQ,KAAKL,MAAMkC,IAAI,CAAC,CAAC,EAAEhB,EAAE,CAAC,CAAC;gBACxCZ;gBACA6B,uBAAuB,EAAE;gBACzB5B;gBACAgB,KAAKJ,OAAOI,GAAG;gBACff;gBACAC;gBACAC;gBACAC;YACF;YAEAC,QAAQwB,IAAI,CAACjB;QACf;IACF;IAEA,OAAOP;AACT,EAAC"}},
    {"offset": {"line": 3924, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/transform/write/blocks.ts"],"sourcesContent":["import type { FlattenedBlock, FlattenedBlocksField } from 'payload'\n\nimport { fieldShouldBeLocalized } from 'payload/shared'\nimport toSnakeCase from 'to-snake-case'\n\nimport type { DrizzleAdapter } from '../../types.js'\nimport type {\n  BlockRowToInsert,\n  NumberToDelete,\n  RelationshipToDelete,\n  TextToDelete,\n} from './types.js'\n\nimport { resolveBlockTableName } from '../../utilities/validateExistingBlockIsIdentical.js'\nimport { traverseFields } from './traverseFields.js'\n\ntype Args = {\n  adapter: DrizzleAdapter\n  baseTableName: string\n  blocks: {\n    [blockType: string]: BlockRowToInsert[]\n  }\n  blocksToDelete: Set<string>\n  data: Record<string, unknown>[]\n  field: FlattenedBlocksField\n  locale?: string\n  numbers: Record<string, unknown>[]\n  numbersToDelete: NumberToDelete[]\n  parentIsLocalized: boolean\n  path: string\n  relationships: Record<string, unknown>[]\n  relationshipsToDelete: RelationshipToDelete[]\n  selects: {\n    [tableName: string]: Record<string, unknown>[]\n  }\n  texts: Record<string, unknown>[]\n  textsToDelete: TextToDelete[]\n  /**\n   * Set to a locale code if this set of fields is traversed within a\n   * localized array or block field\n   */\n  withinArrayOrBlockLocale?: string\n}\nexport const transformBlocks = ({\n  adapter,\n  baseTableName,\n  blocks,\n  blocksToDelete,\n  data,\n  field,\n  locale,\n  numbers,\n  numbersToDelete,\n  parentIsLocalized,\n  path,\n  relationships,\n  relationshipsToDelete,\n  selects,\n  texts,\n  textsToDelete,\n  withinArrayOrBlockLocale,\n}: Args) => {\n  data.forEach((blockRow, i) => {\n    if (typeof blockRow.blockType !== 'string') {\n      return\n    }\n\n    const matchedBlock =\n      adapter.payload.blocks[blockRow.blockType] ??\n      ((field.blockReferences ?? field.blocks).find(\n        (block) => typeof block !== 'string' && block.slug === blockRow.blockType,\n      ) as FlattenedBlock | undefined)\n\n    if (!matchedBlock) {\n      return\n    }\n    const blockType = toSnakeCase(blockRow.blockType)\n\n    const newRow: BlockRowToInsert = {\n      arrays: {},\n      arraysToPush: {},\n      locales: {},\n      row: {\n        _order: i + 1,\n        _path: `${path}${field.name}`,\n      },\n    }\n\n    if (fieldShouldBeLocalized({ field, parentIsLocalized }) && locale) {\n      newRow.row._locale = locale\n    }\n    if (withinArrayOrBlockLocale) {\n      newRow.row._locale = withinArrayOrBlockLocale\n    }\n\n    const blockTableName = resolveBlockTableName(\n      matchedBlock,\n      adapter.tableNameMap.get(`${baseTableName}_blocks_${blockType}`),\n    )\n\n    if (!blocks[blockTableName]) {\n      blocks[blockTableName] = []\n    }\n\n    const hasUUID = adapter.tables[blockTableName]._uuid\n\n    // If we have declared a _uuid field on arrays,\n    // that means the ID has to be unique,\n    // and our ids within arrays are not unique.\n    // So move the ID to a uuid field for storage\n    // and allow the database to generate a serial id automatically\n    if (hasUUID) {\n      newRow.row._uuid = blockRow.id\n      delete blockRow.id\n    }\n\n    traverseFields({\n      adapter,\n      arrays: newRow.arrays,\n      arraysToPush: newRow.arraysToPush,\n      baseTableName,\n      blocks,\n      blocksToDelete,\n      columnPrefix: '',\n      data: blockRow,\n      fieldPrefix: '',\n      fields: matchedBlock.flattenedFields,\n      insideArrayOrBlock: true,\n      locales: newRow.locales,\n      numbers,\n      numbersToDelete,\n      parentIsLocalized: parentIsLocalized || field.localized,\n      parentTableName: blockTableName,\n      path: `${path || ''}${field.name}.${i}.`,\n      relationships,\n      relationshipsToAppend: [],\n      relationshipsToDelete,\n      row: newRow.row,\n      selects,\n      texts,\n      textsToDelete,\n      withinArrayOrBlockLocale,\n    })\n\n    blocks[blockTableName].push(newRow)\n  })\n}\n"],"names":["fieldShouldBeLocalized","toSnakeCase","resolveBlockTableName","traverseFields","transformBlocks","adapter","baseTableName","blocks","blocksToDelete","data","field","locale","numbers","numbersToDelete","parentIsLocalized","path","relationships","relationshipsToDelete","selects","texts","textsToDelete","withinArrayOrBlockLocale","forEach","blockRow","i","blockType","matchedBlock","payload","blockReferences","find","block","slug","newRow","arrays","arraysToPush","locales","row","_order","_path","name","_locale","blockTableName","tableNameMap","get","hasUUID","tables","_uuid","id","columnPrefix","fieldPrefix","fields","flattenedFields","insideArrayOrBlock","localized","parentTableName","relationshipsToAppend","push"],"mappings":";;;;AAEA,SAASA,sBAAsB,QAAQ,iBAAgB;AACvD,OAAOC,iBAAiB,gBAAe;AAUvC,SAASC,qBAAqB,QAAQ,sDAAqD;AAC3F,SAASC,cAAc,QAAQ,sBAAqB;;;;;AA6B7C,MAAMC,kBAAkB,CAAC,EAC9BC,OAAO,EACPC,aAAa,EACbC,MAAM,EACNC,cAAc,EACdC,IAAI,EACJC,KAAK,EACLC,MAAM,EACNC,OAAO,EACPC,eAAe,EACfC,iBAAiB,EACjBC,IAAI,EACJC,aAAa,EACbC,qBAAqB,EACrBC,OAAO,EACPC,KAAK,EACLC,aAAa,EACbC,wBAAwB,EACnB;IACLZ,KAAKa,OAAO,CAAC,CAACC,UAAUC;QACtB,IAAI,OAAOD,SAASE,SAAS,KAAK,UAAU;YAC1C;QACF;QAEA,MAAMC,eACJrB,QAAQsB,OAAO,CAACpB,MAAM,CAACgB,SAASE,SAAS,CAAC,IACxCf,CAAAA,MAAMkB,eAAe,IAAIlB,MAAMH,MAAK,EAAGsB,IAAI,CAC3C,CAACC,QAAU,OAAOA,UAAU,YAAYA,MAAMC,IAAI,KAAKR,SAASE,SAAS;QAG7E,IAAI,CAACC,cAAc;YACjB;QACF;QACA,MAAMD,gBAAYxB,yJAAAA,EAAYsB,SAASE,SAAS;QAEhD,MAAMO,SAA2B;YAC/BC,QAAQ,CAAC;YACTC,cAAc,CAAC;YACfC,SAAS,CAAC;YACVC,KAAK;gBACHC,QAAQb,IAAI;gBACZc,OAAO,GAAGvB,OAAOL,MAAM6B,IAAI,EAAE;YAC/B;QACF;QAEA,QAAIvC,wLAAAA,EAAuB;YAAEU;YAAOI;QAAkB,MAAMH,QAAQ;YAClEqB,OAAOI,GAAG,CAACI,OAAO,GAAG7B;QACvB;QACA,IAAIU,0BAA0B;YAC5BW,OAAOI,GAAG,CAACI,OAAO,GAAGnB;QACvB;QAEA,MAAMoB,qBAAiBvC,2NAAAA,EACrBwB,cACArB,QAAQqC,YAAY,CAACC,GAAG,CAAC,GAAGrC,cAAc,QAAQ,EAAEmB,WAAW;QAGjE,IAAI,CAAClB,MAAM,CAACkC,eAAe,EAAE;YAC3BlC,MAAM,CAACkC,eAAe,GAAG,EAAE;QAC7B;QAEA,MAAMG,UAAUvC,QAAQwC,MAAM,CAACJ,eAAe,CAACK,KAAK;QAEpD,+CAA+C;QAC/C,sCAAsC;QACtC,4CAA4C;QAC5C,6CAA6C;QAC7C,+DAA+D;QAC/D,IAAIF,SAAS;YACXZ,OAAOI,GAAG,CAACU,KAAK,GAAGvB,SAASwB,EAAE;YAC9B,OAAOxB,SAASwB,EAAE;QACpB;YAEA5C,2MAAAA,EAAe;YACbE;YACA4B,QAAQD,OAAOC,MAAM;YACrBC,cAAcF,OAAOE,YAAY;YACjC5B;YACAC;YACAC;YACAwC,cAAc;YACdvC,MAAMc;YACN0B,aAAa;YACbC,QAAQxB,aAAayB,eAAe;YACpCC,oBAAoB;YACpBjB,SAASH,OAAOG,OAAO;YACvBvB;YACAC;YACAC,mBAAmBA,qBAAqBJ,MAAM2C,SAAS;YACvDC,iBAAiBb;YACjB1B,MAAM,GAAGA,QAAQ,KAAKL,MAAM6B,IAAI,CAAC,CAAC,EAAEf,EAAE,CAAC,CAAC;YACxCR;YACAuC,uBAAuB,EAAE;YACzBtC;YACAmB,KAAKJ,OAAOI,GAAG;YACflB;YACAC;YACAC;YACAC;QACF;QAEAd,MAAM,CAACkC,eAAe,CAACe,IAAI,CAACxB;IAC9B;AACF,EAAC"}},
    {"offset": {"line": 4012, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/transform/write/numbers.ts"],"sourcesContent":["type Args = {\n  baseRow: Record<string, unknown>\n  data: unknown[]\n  numbers: Record<string, unknown>[]\n}\n\nexport const transformNumbers = ({ baseRow, data, numbers }: Args) => {\n  data.forEach((val, i) => {\n    numbers.push({\n      ...baseRow,\n      number: val,\n      order: i + 1,\n    })\n  })\n}\n"],"names":["transformNumbers","baseRow","data","numbers","forEach","val","i","push","number","order"],"mappings":";;;;AAMO,MAAMA,mBAAmB,CAAC,EAAEC,OAAO,EAAEC,IAAI,EAAEC,OAAO,EAAQ;IAC/DD,KAAKE,OAAO,CAAC,CAACC,KAAKC;QACjBH,QAAQI,IAAI,CAAC;YACX,GAAGN,OAAO;YACVO,QAAQH;YACRI,OAAOH,IAAI;QACb;IACF;AACF,EAAC"}},
    {"offset": {"line": 4029, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/transform/write/relationships.ts"],"sourcesContent":["import type { RelationshipField, UploadField } from 'payload'\n\nimport { valueIsValueWithRelation } from 'payload/shared'\n\ntype Args = {\n  baseRow: Record<string, unknown>\n  data: unknown\n  field: RelationshipField | UploadField\n  relationships: Record<string, unknown>[]\n}\n\nexport const transformRelationship = ({ baseRow, data, field, relationships }: Args) => {\n  const relations = Array.isArray(data) ? data : [data]\n\n  relations.forEach((relation, i) => {\n    if (relation) {\n      const relationRow = { ...baseRow }\n      if ('hasMany' in field && field.hasMany) {\n        relationRow.order = i + 1\n      }\n\n      if (Array.isArray(field.relationTo) && valueIsValueWithRelation(relation)) {\n        relationRow[`${relation.relationTo}ID`] = relation.value\n        relationships.push(relationRow)\n      } else if (typeof field.relationTo === 'string') {\n        relationRow[`${field.relationTo}ID`] = relation\n        if (relation) {\n          relationships.push(relationRow)\n        }\n      }\n    }\n  })\n}\n"],"names":["valueIsValueWithRelation","transformRelationship","baseRow","data","field","relationships","relations","Array","isArray","forEach","relation","i","relationRow","hasMany","order","relationTo","value","push"],"mappings":";;;;AAEA,SAASA,wBAAwB,QAAQ,iBAAgB;;AASlD,MAAMC,wBAAwB,CAAC,EAAEC,OAAO,EAAEC,IAAI,EAAEC,KAAK,EAAEC,aAAa,EAAQ;IACjF,MAAMC,YAAYC,MAAMC,OAAO,CAACL,QAAQA,OAAO;QAACA;KAAK;IAErDG,UAAUG,OAAO,CAAC,CAACC,UAAUC;QAC3B,IAAID,UAAU;YACZ,MAAME,cAAc;gBAAE,GAAGV,OAAO;YAAC;YACjC,IAAI,aAAaE,SAASA,MAAMS,OAAO,EAAE;gBACvCD,YAAYE,KAAK,GAAGH,IAAI;YAC1B;YAEA,IAAIJ,MAAMC,OAAO,CAACJ,MAAMW,UAAU,SAAKf,0LAAAA,EAAyBU,WAAW;gBACzEE,WAAW,CAAC,GAAGF,SAASK,UAAU,CAAC,EAAE,CAAC,CAAC,GAAGL,SAASM,KAAK;gBACxDX,cAAcY,IAAI,CAACL;YACrB,OAAO,IAAI,OAAOR,MAAMW,UAAU,KAAK,UAAU;gBAC/CH,WAAW,CAAC,GAAGR,MAAMW,UAAU,CAAC,EAAE,CAAC,CAAC,GAAGL;gBACvC,IAAIA,UAAU;oBACZL,cAAcY,IAAI,CAACL;gBACrB;YACF;QACF;IACF;AACF,EAAC"}},
    {"offset": {"line": 4063, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/transform/write/selects.ts"],"sourcesContent":["import { isArrayOfRows } from '../../utilities/isArrayOfRows.js'\n\ntype Args = {\n  data: unknown\n  id?: unknown\n  locale?: string\n}\n\nexport const transformSelects = ({ id, data, locale }: Args) => {\n  const newRows: Record<string, unknown>[] = []\n\n  if (isArrayOfRows(data)) {\n    data.forEach((value, i) => {\n      const newRow: Record<string, unknown> = {\n        order: i + 1,\n        parent: id,\n        value,\n      }\n\n      if (locale) {\n        newRow.locale = locale\n      }\n\n      newRows.push(newRow)\n    })\n  }\n\n  return newRows\n}\n"],"names":["isArrayOfRows","transformSelects","id","data","locale","newRows","forEach","value","i","newRow","order","parent","push"],"mappings":";;;;AAAA,SAASA,aAAa,QAAQ,mCAAkC;;AAQzD,MAAMC,mBAAmB,CAAC,EAAEC,EAAE,EAAEC,IAAI,EAAEC,MAAM,EAAQ;IACzD,MAAMC,UAAqC,EAAE;IAE7C,QAAIL,gMAAAA,EAAcG,OAAO;QACvBA,KAAKG,OAAO,CAAC,CAACC,OAAOC;YACnB,MAAMC,SAAkC;gBACtCC,OAAOF,IAAI;gBACXG,QAAQT;gBACRK;YACF;YAEA,IAAIH,QAAQ;gBACVK,OAAOL,MAAM,GAAGA;YAClB;YAEAC,QAAQO,IAAI,CAACH;QACf;IACF;IAEA,OAAOJ;AACT,EAAC"}},
    {"offset": {"line": 4090, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/transform/write/texts.ts"],"sourcesContent":["type Args = {\n  baseRow: Record<string, unknown>\n  data: unknown[]\n  texts: Record<string, unknown>[]\n}\n\nexport const transformTexts = ({ baseRow, data, texts }: Args) => {\n  data.forEach((val, i) => {\n    texts.push({\n      ...baseRow,\n      order: i + 1,\n      text: val,\n    })\n  })\n}\n"],"names":["transformTexts","baseRow","data","texts","forEach","val","i","push","order","text"],"mappings":";;;;AAMO,MAAMA,iBAAiB,CAAC,EAAEC,OAAO,EAAEC,IAAI,EAAEC,KAAK,EAAQ;IAC3DD,KAAKE,OAAO,CAAC,CAACC,KAAKC;QACjBH,MAAMI,IAAI,CAAC;YACT,GAAGN,OAAO;YACVO,OAAOF,IAAI;YACXG,MAAMJ;QACR;IACF;AACF,EAAC"}},
    {"offset": {"line": 4107, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/transform/write/traverseFields.ts"],"sourcesContent":["import { sql } from 'drizzle-orm'\nimport { APIError, type FlattenedField } from 'payload'\nimport { fieldIsVirtual, fieldShouldBeLocalized } from 'payload/shared'\nimport toSnakeCase from 'to-snake-case'\n\nimport type { DrizzleAdapter } from '../../types.js'\nimport type {\n  NumberToDelete,\n  RelationshipToAppend,\n  RelationshipToDelete,\n  RowToInsert,\n  TextToDelete,\n} from './types.js'\n\nimport { isArrayOfRows } from '../../utilities/isArrayOfRows.js'\nimport { resolveBlockTableName } from '../../utilities/validateExistingBlockIsIdentical.js'\nimport { transformArray } from './array.js'\nimport { transformBlocks } from './blocks.js'\nimport { transformNumbers } from './numbers.js'\nimport { transformRelationship } from './relationships.js'\nimport { transformSelects } from './selects.js'\nimport { transformTexts } from './texts.js'\n\ntype Args = {\n  adapter: DrizzleAdapter\n  /**\n   * This will delete the array table and then re-insert all the new array rows.\n   */\n  arrays: RowToInsert['arrays']\n  /**\n   * Array rows to push to the existing array. This will simply create\n   * a new row in the array table.\n   */\n  arraysToPush: RowToInsert['arraysToPush']\n  /**\n   * This is the name of the base table\n   */\n  baseTableName: string\n  blocks: RowToInsert['blocks']\n  blocksToDelete: Set<string>\n  /**\n   * A snake-case field prefix, representing prior fields\n   * Ex: my_group_my_named_tab_\n   */\n  columnPrefix: string\n  data: Record<string, unknown>\n  enableAtomicWrites?: boolean\n  existingLocales?: Record<string, unknown>[]\n  /**\n   * A prefix that will retain camel-case formatting, representing prior fields\n   * Ex: myGroup_myNamedTab_\n   */\n  fieldPrefix: string\n  fields: FlattenedField[]\n  forcedLocale?: string\n  /**\n   * Tracks whether the current traversion context is from array or block.\n   */\n  insideArrayOrBlock?: boolean\n  locales: {\n    [locale: string]: Record<string, unknown>\n  }\n  numbers: Record<string, unknown>[]\n  numbersToDelete: NumberToDelete[]\n  parentIsLocalized: boolean\n  /**\n   * This is the name of the parent table\n   */\n  parentTableName: string\n  path: string\n  relationships: Record<string, unknown>[]\n  relationshipsToAppend: RelationshipToAppend[]\n  relationshipsToDelete: RelationshipToDelete[]\n  row: Record<string, unknown>\n  selects: {\n    [tableName: string]: Record<string, unknown>[]\n  }\n  texts: Record<string, unknown>[]\n  textsToDelete: TextToDelete[]\n  /**\n   * Set to a locale code if this set of fields is traversed within a\n   * localized array or block field\n   */\n  withinArrayOrBlockLocale?: string\n}\n\nexport const traverseFields = ({\n  adapter,\n  arrays,\n  arraysToPush,\n  baseTableName,\n  blocks,\n  blocksToDelete,\n  columnPrefix,\n  data,\n  enableAtomicWrites,\n  existingLocales,\n  fieldPrefix,\n  fields,\n  forcedLocale,\n  insideArrayOrBlock = false,\n  locales,\n  numbers,\n  numbersToDelete,\n  parentIsLocalized,\n  parentTableName,\n  path,\n  relationships,\n  relationshipsToAppend,\n  relationshipsToDelete,\n  row,\n  selects,\n  texts,\n  textsToDelete,\n  withinArrayOrBlockLocale,\n}: Args) => {\n  let fieldsMatched = false\n\n  if (row._uuid) {\n    data._uuid = row._uuid\n  }\n\n  fields.forEach((field) => {\n    let columnName = ''\n    let fieldName = ''\n    let fieldData: unknown\n\n    if (fieldIsVirtual(field)) {\n      return\n    }\n\n    // Mark that we found a matching field\n    if (data[field.name] !== undefined) {\n      fieldsMatched = true\n    }\n\n    columnName = `${columnPrefix || ''}${toSnakeCase(field.name)}`\n    fieldName = `${fieldPrefix || ''}${field.name}`\n    fieldData = data[field.name]\n\n    const isLocalized = fieldShouldBeLocalized({ field, parentIsLocalized })\n\n    if (field.type === 'array') {\n      const arrayTableName = adapter.tableNameMap.get(`${parentTableName}_${columnName}`)\n\n      if (isLocalized) {\n        const value = data[field.name]\n\n        if (typeof value === 'object' && value !== null) {\n          Object.entries(value).forEach(([localeKey, localeValue]) => {\n            let localeData = localeValue\n            let push = false\n\n            if (localeValue && typeof localeValue === 'object' && '$push' in localeValue) {\n              localeData = localeValue.$push\n              push = true\n              if (!Array.isArray(localeData)) {\n                localeData = [localeData]\n              }\n            }\n\n            if (Array.isArray(localeData)) {\n              const newRows = transformArray({\n                adapter,\n                arrayTableName,\n                baseTableName,\n                blocks,\n                blocksToDelete,\n                data: localeData,\n                field,\n                locale: localeKey,\n                numbers,\n                numbersToDelete,\n                parentIsLocalized: parentIsLocalized || field.localized,\n                path,\n                relationships,\n                relationshipsToDelete,\n                selects,\n                texts,\n                textsToDelete,\n                withinArrayOrBlockLocale: localeKey,\n              })\n\n              if (push) {\n                if (!arraysToPush[arrayTableName]) {\n                  arraysToPush[arrayTableName] = []\n                }\n                arraysToPush[arrayTableName] = arraysToPush[arrayTableName].concat(newRows)\n              } else {\n                if (!arrays[arrayTableName]) {\n                  arrays[arrayTableName] = []\n                }\n                arrays[arrayTableName] = arrays[arrayTableName].concat(newRows)\n              }\n            }\n          })\n        }\n      } else {\n        let value = data[field.name]\n        let push = false\n        if (typeof value === 'object' && '$push' in value) {\n          value = Array.isArray(value.$push) ? value.$push : [value.$push]\n          push = true\n        }\n\n        const newRows = transformArray({\n          adapter,\n          arrayTableName,\n          baseTableName,\n          blocks,\n          blocksToDelete,\n          data: value,\n          field,\n          numbers,\n          numbersToDelete,\n          parentIsLocalized: parentIsLocalized || field.localized,\n          path,\n          relationships,\n          relationshipsToDelete,\n          selects,\n          texts,\n          textsToDelete,\n          withinArrayOrBlockLocale,\n        })\n\n        if (push) {\n          if (!arraysToPush[arrayTableName]) {\n            arraysToPush[arrayTableName] = []\n          }\n          arraysToPush[arrayTableName] = arraysToPush[arrayTableName].concat(newRows)\n        } else {\n          if (!arrays[arrayTableName]) {\n            arrays[arrayTableName] = []\n          }\n          arrays[arrayTableName] = arrays[arrayTableName].concat(newRows)\n        }\n      }\n\n      return\n    }\n\n    if (field.type === 'blocks' && !adapter.blocksAsJSON) {\n      ;(field.blockReferences ?? field.blocks).forEach((block) => {\n        const matchedBlock =\n          typeof block === 'string'\n            ? adapter.payload.config.blocks.find((each) => each.slug === block)\n            : block\n\n        blocksToDelete.add(\n          resolveBlockTableName(\n            matchedBlock,\n            adapter.tableNameMap.get(`${baseTableName}_blocks_${toSnakeCase(matchedBlock.slug)}`),\n          ),\n        )\n      })\n\n      if (isLocalized) {\n        if (typeof data[field.name] === 'object' && data[field.name] !== null) {\n          Object.entries(data[field.name]).forEach(([localeKey, localeData]) => {\n            if (Array.isArray(localeData)) {\n              transformBlocks({\n                adapter,\n                baseTableName,\n                blocks,\n                blocksToDelete,\n                data: localeData,\n                field,\n                locale: localeKey,\n                numbers,\n                numbersToDelete,\n                parentIsLocalized: parentIsLocalized || field.localized,\n                path,\n                relationships,\n                relationshipsToDelete,\n                selects,\n                texts,\n                textsToDelete,\n                withinArrayOrBlockLocale: localeKey,\n              })\n            }\n          })\n        }\n      } else if (isArrayOfRows(fieldData)) {\n        transformBlocks({\n          adapter,\n          baseTableName,\n          blocks,\n          blocksToDelete,\n          data: fieldData,\n          field,\n          numbers,\n          numbersToDelete,\n          parentIsLocalized: parentIsLocalized || field.localized,\n          path,\n          relationships,\n          relationshipsToDelete,\n          selects,\n          texts,\n          textsToDelete,\n          withinArrayOrBlockLocale,\n        })\n      }\n\n      return\n    }\n\n    if (field.type === 'group' || field.type === 'tab') {\n      if (typeof data[field.name] === 'object' && data[field.name] !== null) {\n        if (isLocalized) {\n          Object.entries(data[field.name]).forEach(([localeKey, localeData]) => {\n            // preserve array ID if there is\n            localeData._uuid = data.id || data._uuid\n\n            traverseFields({\n              adapter,\n              arrays,\n              arraysToPush,\n              baseTableName,\n              blocks,\n              blocksToDelete,\n              columnPrefix: `${columnName}_`,\n              data: localeData as Record<string, unknown>,\n              enableAtomicWrites,\n              existingLocales,\n              fieldPrefix: `${fieldName}_`,\n              fields: field.flattenedFields,\n              forcedLocale: localeKey,\n              insideArrayOrBlock,\n              locales,\n              numbers,\n              numbersToDelete,\n              parentIsLocalized: parentIsLocalized || field.localized,\n              parentTableName,\n              path: `${path || ''}${field.name}.`,\n              relationships,\n              relationshipsToAppend,\n              relationshipsToDelete,\n              row,\n              selects,\n              texts,\n              textsToDelete,\n              withinArrayOrBlockLocale: localeKey,\n            })\n          })\n        } else {\n          // preserve array ID if there is\n          const groupData = data[field.name] as Record<string, unknown>\n          groupData._uuid = data.id || data._uuid\n\n          traverseFields({\n            adapter,\n            arrays,\n            arraysToPush,\n            baseTableName,\n            blocks,\n            blocksToDelete,\n            columnPrefix: `${columnName}_`,\n            data: groupData,\n            existingLocales,\n            fieldPrefix: `${fieldName}_`,\n            fields: field.flattenedFields,\n            insideArrayOrBlock,\n            locales,\n            numbers,\n            numbersToDelete,\n            parentIsLocalized: parentIsLocalized || field.localized,\n            parentTableName,\n            path: `${path || ''}${field.name}.`,\n            relationships,\n            relationshipsToAppend,\n            relationshipsToDelete,\n            row,\n            selects,\n            texts,\n            textsToDelete,\n            withinArrayOrBlockLocale,\n          })\n        }\n      }\n\n      return\n    }\n\n    if (field.type === 'relationship' || field.type === 'upload') {\n      const relationshipPath = `${path || ''}${field.name}`\n\n      // Handle $push operation for relationship fields\n      if (\n        fieldData &&\n        typeof fieldData === 'object' &&\n        'hasMany' in field &&\n        field.hasMany &&\n        ('$push' in fieldData ||\n          (field.localized &&\n            Object.values(fieldData).some(\n              (localeValue) =>\n                localeValue &&\n                typeof localeValue === 'object' &&\n                '$push' in (localeValue as Record<string, unknown>),\n            )))\n      ) {\n        let itemsToAppend: unknown[]\n\n        if (field.localized) {\n          let hasLocaleOperations = false\n          Object.entries(fieldData).forEach(([localeKey, localeValue]) => {\n            if (localeValue && typeof localeValue === 'object' && '$push' in localeValue) {\n              hasLocaleOperations = true\n              const push = localeValue.$push\n              const localeItems = Array.isArray(push) ? push : [push]\n\n              localeItems.forEach((item) => {\n                const relationshipToAppend: RelationshipToAppend = {\n                  locale: localeKey,\n                  path: relationshipPath,\n                  value: item,\n                }\n\n                // Handle polymorphic relationships\n                if (\n                  Array.isArray(field.relationTo) &&\n                  item &&\n                  typeof item === 'object' &&\n                  'relationTo' in item\n                ) {\n                  relationshipToAppend.relationTo = item.relationTo\n                  relationshipToAppend.value = item.value\n                } else if (typeof field.relationTo === 'string') {\n                  // Simple relationship\n                  relationshipToAppend.relationTo = field.relationTo\n                  relationshipToAppend.value = item\n                }\n\n                relationshipsToAppend.push(relationshipToAppend)\n              })\n            }\n          })\n\n          if (hasLocaleOperations) {\n            return\n          }\n        } else {\n          // Handle non-localized fields: { field: { $push: data } }\n          itemsToAppend = Array.isArray((fieldData as any).$push)\n            ? (fieldData as any).$push\n            : [(fieldData as any).$push]\n\n          itemsToAppend.forEach((item) => {\n            const relationshipToAppend: RelationshipToAppend = {\n              locale: isLocalized ? withinArrayOrBlockLocale : undefined,\n              path: relationshipPath,\n              value: item,\n            }\n\n            // Handle polymorphic relationships\n            if (\n              Array.isArray(field.relationTo) &&\n              item &&\n              typeof item === 'object' &&\n              'relationTo' in item &&\n              'value' in item\n            ) {\n              relationshipToAppend.relationTo = item.relationTo as string\n              relationshipToAppend.value = item.value as number | string\n            } else if (typeof field.relationTo === 'string') {\n              // Simple relationship\n              relationshipToAppend.relationTo = field.relationTo\n              relationshipToAppend.value = item\n            }\n\n            relationshipsToAppend.push(relationshipToAppend)\n          })\n        }\n        return\n      }\n\n      // Handle $remove operation for relationship fields\n      if (\n        fieldData &&\n        typeof fieldData === 'object' &&\n        'hasMany' in field &&\n        field.hasMany &&\n        ('$remove' in fieldData ||\n          (field.localized &&\n            Object.values(fieldData).some(\n              (localeValue) =>\n                localeValue &&\n                typeof localeValue === 'object' &&\n                '$remove' in (localeValue as Record<string, unknown>),\n            )))\n      ) {\n        // Check for new locale-first syntax: { field: { locale: { $remove: data } } }\n        if (field.localized) {\n          let hasLocaleOperations = false\n          Object.entries(fieldData).forEach(([localeKey, localeValue]) => {\n            if (localeValue && typeof localeValue === 'object' && '$remove' in localeValue) {\n              hasLocaleOperations = true\n              const remove = localeValue.$remove\n              const localeItems = Array.isArray(remove) ? remove : [remove]\n\n              localeItems.forEach((item) => {\n                const relationshipToDelete: RelationshipToDelete = {\n                  itemToRemove: item,\n                  locale: localeKey,\n                  path: relationshipPath,\n                }\n\n                // Store relationTo for simple relationships\n                if (typeof field.relationTo === 'string') {\n                  relationshipToDelete.relationTo = field.relationTo\n                }\n\n                relationshipsToDelete.push(relationshipToDelete)\n              })\n            }\n          })\n\n          if (hasLocaleOperations) {\n            return\n          }\n        } else {\n          // Handle non-localized fields: { field: { $remove: data } }\n          const itemsToRemove = Array.isArray((fieldData as any).$remove)\n            ? (fieldData as any).$remove\n            : [(fieldData as any).$remove]\n\n          itemsToRemove.forEach((item) => {\n            const relationshipToDelete: RelationshipToDelete = {\n              itemToRemove: item,\n              locale: isLocalized ? withinArrayOrBlockLocale : undefined,\n              path: relationshipPath,\n            }\n\n            // Store relationTo for simple relationships\n            if (typeof field.relationTo === 'string') {\n              relationshipToDelete.relationTo = field.relationTo\n            }\n\n            relationshipsToDelete.push(relationshipToDelete)\n          })\n        }\n        return\n      }\n\n      if (\n        isLocalized &&\n        (Array.isArray(field.relationTo) || ('hasMany' in field && field.hasMany))\n      ) {\n        if (typeof fieldData === 'object') {\n          Object.entries(fieldData).forEach(([localeKey, localeData]) => {\n            if (localeData === null) {\n              relationshipsToDelete.push({\n                locale: localeKey,\n                path: relationshipPath,\n              })\n              return\n            }\n\n            transformRelationship({\n              baseRow: {\n                locale: localeKey,\n                path: relationshipPath,\n              },\n              data: localeData,\n              field,\n              relationships,\n            })\n          })\n        }\n        return\n      } else if (Array.isArray(field.relationTo) || ('hasMany' in field && field.hasMany)) {\n        if (fieldData === null || (Array.isArray(fieldData) && fieldData.length === 0)) {\n          relationshipsToDelete.push({ path: relationshipPath })\n          return\n        }\n\n        transformRelationship({\n          baseRow: {\n            locale: withinArrayOrBlockLocale,\n            path: relationshipPath,\n          },\n          data: fieldData,\n          field,\n          relationships,\n        })\n        return\n      } else {\n        if (\n          !isLocalized &&\n          fieldData &&\n          typeof fieldData === 'object' &&\n          'id' in fieldData &&\n          fieldData?.id\n        ) {\n          fieldData = fieldData.id\n        } else if (isLocalized) {\n          if (typeof fieldData === 'object') {\n            Object.entries(fieldData).forEach(([localeKey, localeData]) => {\n              if (typeof localeData === 'object') {\n                if (localeData && 'id' in localeData && localeData?.id) {\n                  fieldData[localeKey] = localeData.id\n                }\n              } else {\n                fieldData[localeKey] = localeData\n              }\n            })\n          }\n        }\n      }\n    }\n\n    if (field.type === 'text' && field.hasMany) {\n      const textPath = `${path || ''}${field.name}`\n\n      if (isLocalized) {\n        if (typeof fieldData === 'object') {\n          Object.entries(fieldData).forEach(([localeKey, localeData]) => {\n            if (Array.isArray(localeData)) {\n              if (!localeData.length) {\n                textsToDelete.push({ locale: localeKey, path: textPath })\n                return\n              }\n\n              transformTexts({\n                baseRow: {\n                  locale: localeKey,\n                  path: textPath,\n                },\n                data: localeData,\n                texts,\n              })\n            }\n          })\n        }\n      } else if (Array.isArray(fieldData)) {\n        if (!fieldData.length) {\n          textsToDelete.push({ locale: withinArrayOrBlockLocale, path: textPath })\n          return\n        }\n\n        transformTexts({\n          baseRow: {\n            locale: withinArrayOrBlockLocale,\n            path: textPath,\n          },\n          data: fieldData,\n          texts,\n        })\n      }\n\n      return\n    }\n\n    if (field.type === 'number' && field.hasMany) {\n      const numberPath = `${path || ''}${field.name}`\n\n      if (isLocalized) {\n        if (typeof fieldData === 'object') {\n          Object.entries(fieldData).forEach(([localeKey, localeData]) => {\n            if (Array.isArray(localeData)) {\n              if (!localeData.length) {\n                numbersToDelete.push({ locale: localeKey, path: numberPath })\n                return\n              }\n\n              transformNumbers({\n                baseRow: {\n                  locale: localeKey,\n                  path: numberPath,\n                },\n                data: localeData,\n                numbers,\n              })\n            }\n          })\n        }\n      } else if (Array.isArray(fieldData)) {\n        if (!fieldData.length) {\n          numbersToDelete.push({ locale: withinArrayOrBlockLocale, path: numberPath })\n          return\n        }\n\n        transformNumbers({\n          baseRow: {\n            locale: withinArrayOrBlockLocale,\n            path: numberPath,\n          },\n          data: fieldData,\n          numbers,\n        })\n      }\n\n      return\n    }\n\n    if (field.type === 'select' && field.hasMany) {\n      const selectTableName = adapter.tableNameMap.get(`${parentTableName}_${columnName}`)\n      if (!selects[selectTableName]) {\n        selects[selectTableName] = []\n      }\n\n      if (isLocalized) {\n        if (typeof data[field.name] === 'object' && data[field.name] !== null) {\n          Object.entries(data[field.name]).forEach(([localeKey, localeData]) => {\n            if (Array.isArray(localeData)) {\n              const newRows = transformSelects({\n                id: insideArrayOrBlock ? data._uuid || data.id : undefined,\n                data: localeData,\n                locale: localeKey,\n              })\n\n              selects[selectTableName] = selects[selectTableName].concat(newRows)\n            }\n          })\n        }\n      } else if (Array.isArray(data[field.name])) {\n        const newRows = transformSelects({\n          id: insideArrayOrBlock ? data._uuid || data.id : undefined,\n          data: data[field.name],\n          locale: withinArrayOrBlockLocale,\n        })\n\n        selects[selectTableName] = selects[selectTableName].concat(newRows)\n      }\n\n      return\n    }\n\n    const valuesToTransform: { localeKey?: string; ref: unknown; value: unknown }[] = []\n\n    if (isLocalized) {\n      if (typeof fieldData === 'object' && fieldData !== null) {\n        Object.entries(fieldData).forEach(([localeKey, localeData]) => {\n          if (!locales[localeKey]) {\n            locales[localeKey] = {}\n          }\n\n          valuesToTransform.push({\n            localeKey,\n            ref: locales,\n            value: localeData,\n          })\n        })\n      }\n    } else {\n      let ref = row\n\n      if (forcedLocale) {\n        if (!locales[forcedLocale]) {\n          locales[forcedLocale] = {}\n        }\n        ref = locales[forcedLocale]\n      }\n\n      valuesToTransform.push({ ref, value: fieldData })\n    }\n\n    valuesToTransform.forEach(({ localeKey, ref, value }) => {\n      let formattedValue = value\n\n      if (field.type === 'date') {\n        if (fieldName === 'updatedAt' && formattedValue === null) {\n          // If updatedAt is explicitly set to null, skip it entirely - don't add to row\n          // This prevents the timestamp from being updated for session-only operations\n          return // Skip this iteration\n        } else if (fieldName === 'updatedAt' && typeof formattedValue === 'undefined') {\n          // If updatedAt is undefined, set it to current time (normal behavior)\n          formattedValue = new Date().toISOString()\n        } else {\n          if (typeof value === 'number' && !Number.isNaN(value)) {\n            formattedValue = new Date(value).toISOString()\n          } else if (value instanceof Date) {\n            formattedValue = value.toISOString()\n          }\n        }\n      }\n\n      if (typeof value !== 'undefined') {\n        if (value && field.type === 'point' && adapter.name !== 'sqlite') {\n          formattedValue = sql`ST_GeomFromGeoJSON(${JSON.stringify(value)})`\n        }\n\n        if (field.type === 'text' && value && typeof value !== 'string') {\n          formattedValue = JSON.stringify(value)\n        }\n\n        if (\n          field.type === 'number' &&\n          value &&\n          typeof value === 'object' &&\n          '$inc' in value &&\n          typeof value.$inc === 'number'\n        ) {\n          if (!enableAtomicWrites) {\n            throw new APIError(\n              'The passed data must not contain any nested fields for atomic writes',\n            )\n          }\n\n          formattedValue = sql.raw(`${columnName} + ${value.$inc}`)\n        }\n      }\n\n      if (typeof formattedValue !== 'undefined') {\n        if (localeKey) {\n          ref[localeKey][fieldName] = formattedValue\n        } else {\n          ref[fieldName] = formattedValue\n        }\n      }\n    })\n  })\n\n  // Handle dot-notation paths when no fields matched\n  if (!fieldsMatched) {\n    Object.keys(data).forEach((key) => {\n      if (key.includes('.')) {\n        // Split on first dot only\n        const firstDotIndex = key.indexOf('.')\n        const fieldName = key.substring(0, firstDotIndex)\n        const remainingPath = key.substring(firstDotIndex + 1)\n\n        // Create nested structure for this field\n        if (!data[fieldName]) {\n          data[fieldName] = {}\n        }\n\n        const nestedData = data[fieldName] as Record<string, unknown>\n\n        // Move the value to the nested structure\n        nestedData[remainingPath] = data[key]\n        delete data[key]\n\n        // Recursively process the newly created nested structure\n        // The field traversal will naturally handle it if the field exists in the schema\n        traverseFields({\n          adapter,\n          arrays,\n          arraysToPush,\n          baseTableName,\n          blocks,\n          blocksToDelete,\n          columnPrefix,\n          data,\n          enableAtomicWrites,\n          existingLocales,\n          fieldPrefix,\n          fields,\n          forcedLocale,\n          insideArrayOrBlock,\n          locales,\n          numbers,\n          numbersToDelete,\n          parentIsLocalized,\n          parentTableName,\n          path,\n          relationships,\n          relationshipsToAppend,\n          relationshipsToDelete,\n          row,\n          selects,\n          texts,\n          textsToDelete,\n          withinArrayOrBlockLocale,\n        })\n      }\n    })\n  }\n}\n"],"names":["sql","APIError","fieldIsVirtual","fieldShouldBeLocalized","toSnakeCase","isArrayOfRows","resolveBlockTableName","transformArray","transformBlocks","transformNumbers","transformRelationship","transformSelects","transformTexts","traverseFields","adapter","arrays","arraysToPush","baseTableName","blocks","blocksToDelete","columnPrefix","data","enableAtomicWrites","existingLocales","fieldPrefix","fields","forcedLocale","insideArrayOrBlock","locales","numbers","numbersToDelete","parentIsLocalized","parentTableName","path","relationships","relationshipsToAppend","relationshipsToDelete","row","selects","texts","textsToDelete","withinArrayOrBlockLocale","fieldsMatched","_uuid","forEach","field","columnName","fieldName","fieldData","name","undefined","isLocalized","type","arrayTableName","tableNameMap","get","value","Object","entries","localeKey","localeValue","localeData","push","$push","Array","isArray","newRows","locale","localized","concat","blocksAsJSON","blockReferences","block","matchedBlock","payload","config","find","each","slug","add","id","flattenedFields","groupData","relationshipPath","hasMany","values","some","itemsToAppend","hasLocaleOperations","localeItems","item","relationshipToAppend","relationTo","remove","$remove","relationshipToDelete","itemToRemove","itemsToRemove","baseRow","length","textPath","numberPath","selectTableName","valuesToTransform","ref","formattedValue","Date","toISOString","Number","isNaN","JSON","stringify","$inc","raw","keys","key","includes","firstDotIndex","indexOf","substring","remainingPath","nestedData"],"mappings":"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"}},
    {"offset": {"line": 4784, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/transform/write/index.ts"],"sourcesContent":["import type { FlattenedField } from 'payload'\n\nimport type { DrizzleAdapter } from '../../types.js'\nimport type { RowToInsert } from './types.js'\n\nimport { traverseFields } from './traverseFields.js'\n\ntype Args = {\n  adapter: DrizzleAdapter\n  data: Record<string, unknown>\n  enableAtomicWrites?: boolean\n  fields: FlattenedField[]\n  parentIsLocalized?: boolean\n  path?: string\n  tableName: string\n}\n\nexport const transformForWrite = ({\n  adapter,\n  data,\n  enableAtomicWrites,\n  fields,\n  parentIsLocalized,\n  path = '',\n  tableName,\n}: Args): RowToInsert => {\n  // Split out the incoming data into rows to insert / delete\n  const rowToInsert: RowToInsert = {\n    arrays: {},\n    arraysToPush: {},\n    blocks: {},\n    blocksToDelete: new Set(),\n    locales: {},\n    numbers: [],\n    numbersToDelete: [],\n    relationships: [],\n    relationshipsToAppend: [],\n    relationshipsToDelete: [],\n    row: {},\n    selects: {},\n    texts: [],\n    textsToDelete: [],\n  }\n\n  // This function is responsible for building up the\n  // above rowToInsert\n  traverseFields({\n    adapter,\n    arrays: rowToInsert.arrays,\n    arraysToPush: rowToInsert.arraysToPush,\n    baseTableName: tableName,\n    blocks: rowToInsert.blocks,\n    blocksToDelete: rowToInsert.blocksToDelete,\n    columnPrefix: '',\n    data,\n    enableAtomicWrites,\n    fieldPrefix: '',\n    fields,\n    locales: rowToInsert.locales,\n    numbers: rowToInsert.numbers,\n    numbersToDelete: rowToInsert.numbersToDelete,\n    parentIsLocalized,\n    parentTableName: tableName,\n    path,\n    relationships: rowToInsert.relationships,\n    relationshipsToAppend: rowToInsert.relationshipsToAppend,\n    relationshipsToDelete: rowToInsert.relationshipsToDelete,\n    row: rowToInsert.row,\n    selects: rowToInsert.selects,\n    texts: rowToInsert.texts,\n    textsToDelete: rowToInsert.textsToDelete,\n  })\n\n  return rowToInsert\n}\n"],"names":["traverseFields","transformForWrite","adapter","data","enableAtomicWrites","fields","parentIsLocalized","path","tableName","rowToInsert","arrays","arraysToPush","blocks","blocksToDelete","Set","locales","numbers","numbersToDelete","relationships","relationshipsToAppend","relationshipsToDelete","row","selects","texts","textsToDelete","baseTableName","columnPrefix","fieldPrefix","parentTableName"],"mappings":";;;;AAKA,SAASA,cAAc,QAAQ,sBAAqB;;AAY7C,MAAMC,oBAAoB,CAAC,EAChCC,OAAO,EACPC,IAAI,EACJC,kBAAkB,EAClBC,MAAM,EACNC,iBAAiB,EACjBC,OAAO,EAAE,EACTC,SAAS,EACJ;IACL,2DAA2D;IAC3D,MAAMC,cAA2B;QAC/BC,QAAQ,CAAC;QACTC,cAAc,CAAC;QACfC,QAAQ,CAAC;QACTC,gBAAgB,IAAIC;QACpBC,SAAS,CAAC;QACVC,SAAS,EAAE;QACXC,iBAAiB,EAAE;QACnBC,eAAe,EAAE;QACjBC,uBAAuB,EAAE;QACzBC,uBAAuB,EAAE;QACzBC,KAAK,CAAC;QACNC,SAAS,CAAC;QACVC,OAAO,EAAE;QACTC,eAAe,EAAE;IACnB;IAEA,mDAAmD;IACnD,oBAAoB;QACpBxB,2MAAAA,EAAe;QACbE;QACAQ,QAAQD,YAAYC,MAAM;QAC1BC,cAAcF,YAAYE,YAAY;QACtCc,eAAejB;QACfI,QAAQH,YAAYG,MAAM;QAC1BC,gBAAgBJ,YAAYI,cAAc;QAC1Ca,cAAc;QACdvB;QACAC;QACAuB,aAAa;QACbtB;QACAU,SAASN,YAAYM,OAAO;QAC5BC,SAASP,YAAYO,OAAO;QAC5BC,iBAAiBR,YAAYQ,eAAe;QAC5CX;QACAsB,iBAAiBpB;QACjBD;QACAW,eAAeT,YAAYS,aAAa;QACxCC,uBAAuBV,YAAYU,qBAAqB;QACxDC,uBAAuBX,YAAYW,qBAAqB;QACxDC,KAAKZ,YAAYY,GAAG;QACpBC,SAASb,YAAYa,OAAO;QAC5BC,OAAOd,YAAYc,KAAK;QACxBC,eAAef,YAAYe,aAAa;IAC1C;IAEA,OAAOf;AACT,EAAC"}},
    {"offset": {"line": 4842, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/upsertRow/deleteExistingArrayRows.ts"],"sourcesContent":["import { and, eq } from 'drizzle-orm'\n\nimport type { DrizzleAdapter, DrizzleTransaction } from '../types.js'\n\ntype Args = {\n  adapter: DrizzleAdapter\n  db: DrizzleAdapter['drizzle'] | DrizzleTransaction\n  parentID: unknown\n  tableName: string\n}\n\nexport const deleteExistingArrayRows = async ({\n  adapter,\n  db,\n  parentID,\n  tableName,\n}: Args): Promise<void> => {\n  const table = adapter.tables[tableName]\n\n  const whereConstraints = [eq(table._parentID, parentID)]\n\n  await adapter.deleteWhere({\n    db,\n    tableName,\n    where: and(...whereConstraints),\n  })\n}\n"],"names":["and","eq","deleteExistingArrayRows","adapter","db","parentID","tableName","table","tables","whereConstraints","_parentID","deleteWhere","where"],"mappings":";;;;AAAA,SAASA,GAAG,EAAEC,EAAE,QAAQ,cAAa;;AAW9B,MAAMC,0BAA0B,OAAO,EAC5CC,OAAO,EACPC,EAAE,EACFC,QAAQ,EACRC,SAAS,EACJ;IACL,MAAMC,QAAQJ,QAAQK,MAAM,CAACF,UAAU;IAEvC,MAAMG,mBAAmB;YAACR,0KAAAA,EAAGM,MAAMG,SAAS,EAAEL;KAAU;IAExD,MAAMF,QAAQQ,WAAW,CAAC;QACxBP;QACAE;QACAM,WAAOZ,2KAAAA,KAAOS;IAChB;AACF,EAAC"}},
    {"offset": {"line": 4863, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/upsertRow/deleteExistingRowsByPath.ts"],"sourcesContent":["import { and, eq, inArray } from 'drizzle-orm'\n\nimport type { DrizzleAdapter, DrizzleTransaction } from '../types.js'\n\ntype Args = {\n  adapter: DrizzleAdapter\n  db: DrizzleAdapter['drizzle'] | DrizzleTransaction\n  localeColumnName?: string\n  parentColumnName?: string\n  parentID: unknown\n  pathColumnName?: string\n  rows: Record<string, unknown>[]\n  tableName: string\n}\n\nexport const deleteExistingRowsByPath = async ({\n  adapter,\n  db,\n  localeColumnName = '_locale',\n  parentColumnName = '_parentID',\n  parentID,\n  pathColumnName = '_path',\n  rows,\n  tableName,\n}: Args): Promise<void> => {\n  const localizedPathsToDelete = new Set<string>()\n  const pathsToDelete = new Set<string>()\n  const table = adapter.tables[tableName]\n\n  rows.forEach((row) => {\n    const path = row[pathColumnName]\n    const localeData = row[localeColumnName]\n    if (typeof path === 'string') {\n      if (typeof localeData === 'string') {\n        localizedPathsToDelete.add(path)\n      } else {\n        pathsToDelete.add(path)\n      }\n    }\n  })\n\n  if (localizedPathsToDelete.size > 0) {\n    const whereConstraints = [eq(table[parentColumnName], parentID)]\n\n    if (pathColumnName) {\n      whereConstraints.push(inArray(table[pathColumnName], Array.from(localizedPathsToDelete)))\n    }\n\n    await adapter.deleteWhere({\n      db,\n      tableName,\n      where: and(...whereConstraints),\n    })\n  }\n\n  if (pathsToDelete.size > 0) {\n    const whereConstraints = [eq(table[parentColumnName], parentID)]\n\n    if (pathColumnName) {\n      whereConstraints.push(inArray(table[pathColumnName], Array.from(pathsToDelete)))\n    }\n\n    await adapter.deleteWhere({\n      db,\n      tableName,\n      where: and(...whereConstraints),\n    })\n  }\n}\n"],"names":["and","eq","inArray","deleteExistingRowsByPath","adapter","db","localeColumnName","parentColumnName","parentID","pathColumnName","rows","tableName","localizedPathsToDelete","Set","pathsToDelete","table","tables","forEach","row","path","localeData","add","size","whereConstraints","push","Array","from","deleteWhere","where"],"mappings":";;;;AAAA,SAASA,GAAG,EAAEC,EAAE,EAAEC,OAAO,QAAQ,cAAa;;AAevC,MAAMC,2BAA2B,OAAO,EAC7CC,OAAO,EACPC,EAAE,EACFC,mBAAmB,SAAS,EAC5BC,mBAAmB,WAAW,EAC9BC,QAAQ,EACRC,iBAAiB,OAAO,EACxBC,IAAI,EACJC,SAAS,EACJ;IACL,MAAMC,yBAAyB,IAAIC;IACnC,MAAMC,gBAAgB,IAAID;IAC1B,MAAME,QAAQX,QAAQY,MAAM,CAACL,UAAU;IAEvCD,KAAKO,OAAO,CAAC,CAACC;QACZ,MAAMC,OAAOD,GAAG,CAACT,eAAe;QAChC,MAAMW,aAAaF,GAAG,CAACZ,iBAAiB;QACxC,IAAI,OAAOa,SAAS,UAAU;YAC5B,IAAI,OAAOC,eAAe,UAAU;gBAClCR,uBAAuBS,GAAG,CAACF;YAC7B,OAAO;gBACLL,cAAcO,GAAG,CAACF;YACpB;QACF;IACF;IAEA,IAAIP,uBAAuBU,IAAI,GAAG,GAAG;QACnC,MAAMC,mBAAmB;gBAACtB,0KAAAA,EAAGc,KAAK,CAACR,iBAAiB,EAAEC;SAAU;QAEhE,IAAIC,gBAAgB;YAClBc,iBAAiBC,IAAI,KAACtB,+KAAAA,EAAQa,KAAK,CAACN,eAAe,EAAEgB,MAAMC,IAAI,CAACd;QAClE;QAEA,MAAMR,QAAQuB,WAAW,CAAC;YACxBtB;YACAM;YACAiB,WAAO5B,2KAAAA,KAAOuB;QAChB;IACF;IAEA,IAAIT,cAAcQ,IAAI,GAAG,GAAG;QAC1B,MAAMC,mBAAmB;gBAACtB,0KAAAA,EAAGc,KAAK,CAACR,iBAAiB,EAAEC;SAAU;QAEhE,IAAIC,gBAAgB;YAClBc,iBAAiBC,IAAI,KAACtB,+KAAAA,EAAQa,KAAK,CAACN,eAAe,EAAEgB,MAAMC,IAAI,CAACZ;QAClE;QAEA,MAAMV,QAAQuB,WAAW,CAAC;YACxBtB;YACAM;YACAiB,WAAO5B,2KAAAA,KAAOuB;QAChB;IACF;AACF,EAAC"}},
    {"offset": {"line": 4915, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/upsertRow/handleUpsertError.ts"],"sourcesContent":["import type { PayloadRequest } from 'payload'\n\nimport { ValidationError } from 'payload'\n\nimport type { DrizzleAdapter } from '../types.js'\n\ntype HandleUpsertErrorArgs = {\n  adapter: DrizzleAdapter\n  collectionSlug?: string\n  error: unknown\n  globalSlug?: string\n  id?: number | string\n  req?: Partial<PayloadRequest>\n  tableName: string\n}\n\n/**\n * Handles unique constraint violation errors from PostgreSQL and SQLite,\n * converting them to Payload ValidationErrors.\n * Re-throws non-constraint errors unchanged.\n */\nexport const handleUpsertError = ({\n  id,\n  adapter,\n  collectionSlug,\n  error: caughtError,\n  globalSlug,\n  req,\n  tableName,\n}: HandleUpsertErrorArgs): never => {\n  let error: any = caughtError\n  if (typeof caughtError === 'object' && caughtError !== null && 'cause' in caughtError) {\n    error = caughtError.cause\n  }\n\n  // PostgreSQL: 23505, SQLite: SQLITE_CONSTRAINT_UNIQUE\n  if (error?.code === '23505' || error?.code === 'SQLITE_CONSTRAINT_UNIQUE') {\n    let fieldName: null | string = null\n\n    if (error.code === '23505') {\n      // PostgreSQL - extract field name from constraint\n      if (adapter.fieldConstraints?.[tableName]?.[error.constraint]) {\n        fieldName = adapter.fieldConstraints[tableName][error.constraint]\n      } else {\n        const replacement = `${tableName}_`\n        if (error.constraint?.includes(replacement)) {\n          const replacedConstraint = error.constraint.replace(replacement, '')\n          if (replacedConstraint && adapter.fieldConstraints[tableName]?.[replacedConstraint]) {\n            fieldName = adapter.fieldConstraints[tableName][replacedConstraint]\n          }\n        }\n      }\n\n      if (!fieldName && error.detail) {\n        // Extract from detail: \"Key (field)=(value) already exists.\"\n        const regex = /Key \\(([^)]+)\\)=\\(([^)]+)\\)/\n        const match: string[] = error.detail.match(regex)\n        if (match && match[1]) {\n          fieldName = match[1]\n        }\n      }\n    } else if (error.code === 'SQLITE_CONSTRAINT_UNIQUE') {\n      // SQLite - extract from message: \"UNIQUE constraint failed: table.field\"\n      const regex = /UNIQUE constraint failed: ([^.]+)\\.([^.]+)/\n      const match: string[] = error.message?.match(regex)\n      if (match && match[2]) {\n        if (adapter.fieldConstraints[tableName]) {\n          fieldName = adapter.fieldConstraints[tableName][`${match[2]}_idx`]\n        }\n        if (!fieldName) {\n          fieldName = match[2]\n        }\n      }\n    }\n\n    throw new ValidationError(\n      {\n        id,\n        collection: collectionSlug,\n        errors: [\n          {\n            message: req?.t ? req.t('error:valueMustBeUnique') : 'Value must be unique',\n            path: fieldName,\n          },\n        ],\n        global: globalSlug,\n        req,\n      },\n      req?.t,\n    )\n  }\n\n  // Re-throw non-constraint errors\n  throw caughtError\n}\n"],"names":["ValidationError","handleUpsertError","id","adapter","collectionSlug","error","caughtError","globalSlug","req","tableName","cause","code","fieldName","fieldConstraints","constraint","replacement","includes","replacedConstraint","replace","detail","regex","match","message","collection","errors","t","path","global"],"mappings":";;;;AAEA,SAASA,eAAe,QAAQ,UAAS;;AAmBlC,MAAMC,oBAAoB,CAAC,EAChCC,EAAE,EACFC,OAAO,EACPC,cAAc,EACdC,OAAOC,WAAW,EAClBC,UAAU,EACVC,GAAG,EACHC,SAAS,EACa;IACtB,IAAIJ,QAAaC;IACjB,IAAI,OAAOA,gBAAgB,YAAYA,gBAAgB,QAAQ,WAAWA,aAAa;QACrFD,QAAQC,YAAYI,KAAK;IAC3B;IAEA,sDAAsD;IACtD,IAAIL,OAAOM,SAAS,WAAWN,OAAOM,SAAS,4BAA4B;QACzE,IAAIC,YAA2B;QAE/B,IAAIP,MAAMM,IAAI,KAAK,SAAS;YAC1B,kDAAkD;YAClD,IAAIR,QAAQU,gBAAgB,EAAE,CAACJ,UAAU,EAAE,CAACJ,MAAMS,UAAU,CAAC,EAAE;gBAC7DF,YAAYT,QAAQU,gBAAgB,CAACJ,UAAU,CAACJ,MAAMS,UAAU,CAAC;YACnE,OAAO;gBACL,MAAMC,cAAc,GAAGN,UAAU,CAAC,CAAC;gBACnC,IAAIJ,MAAMS,UAAU,EAAEE,SAASD,cAAc;oBAC3C,MAAME,qBAAqBZ,MAAMS,UAAU,CAACI,OAAO,CAACH,aAAa;oBACjE,IAAIE,sBAAsBd,QAAQU,gBAAgB,CAACJ,UAAU,EAAE,CAACQ,mBAAmB,EAAE;wBACnFL,YAAYT,QAAQU,gBAAgB,CAACJ,UAAU,CAACQ,mBAAmB;oBACrE;gBACF;YACF;YAEA,IAAI,CAACL,aAAaP,MAAMc,MAAM,EAAE;gBAC9B,6DAA6D;gBAC7D,MAAMC,QAAQ;gBACd,MAAMC,QAAkBhB,MAAMc,MAAM,CAACE,KAAK,CAACD;gBAC3C,IAAIC,SAASA,KAAK,CAAC,EAAE,EAAE;oBACrBT,YAAYS,KAAK,CAAC,EAAE;gBACtB;YACF;QACF,OAAO,IAAIhB,MAAMM,IAAI,KAAK,4BAA4B;YACpD,yEAAyE;YACzE,MAAMS,QAAQ;YACd,MAAMC,QAAkBhB,MAAMiB,OAAO,EAAED,MAAMD;YAC7C,IAAIC,SAASA,KAAK,CAAC,EAAE,EAAE;gBACrB,IAAIlB,QAAQU,gBAAgB,CAACJ,UAAU,EAAE;oBACvCG,YAAYT,QAAQU,gBAAgB,CAACJ,UAAU,CAAC,GAAGY,KAAK,CAAC,EAAE,CAAC,IAAI,CAAC,CAAC;gBACpE;gBACA,IAAI,CAACT,WAAW;oBACdA,YAAYS,KAAK,CAAC,EAAE;gBACtB;YACF;QACF;QAEA,MAAM,IAAIrB,iLAAAA,CACR;YACEE;YACAqB,YAAYnB;YACZoB,QAAQ;gBACN;oBACEF,SAASd,KAAKiB,IAAIjB,IAAIiB,CAAC,CAAC,6BAA6B;oBACrDC,MAAMd;gBACR;aACD;YACDe,QAAQpB;YACRC;QACF,GACAA,KAAKiB;IAET;IAEA,iCAAiC;IACjC,MAAMnB;AACR,EAAC"}},
    {"offset": {"line": 4983, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/upsertRow/insertArrays.ts"],"sourcesContent":["import type { ArrayRowToInsert } from '../transform/write/types.js'\nimport type { DrizzleAdapter, DrizzleTransaction } from '../types.js'\n\ntype Args = {\n  adapter: DrizzleAdapter\n  arrays: {\n    [tableName: string]: ArrayRowToInsert[]\n  }[]\n  db: DrizzleAdapter['drizzle'] | DrizzleTransaction\n  parentRows: Record<string, unknown>[]\n  uuidMap?: Record<string, number | string>\n}\n\ntype RowsByTable = {\n  [tableName: string]: {\n    arrays: {\n      [tableName: string]: ArrayRowToInsert[]\n    }[]\n    locales: Record<string, unknown>[]\n    rows: Record<string, unknown>[]\n  }\n}\n\nexport const insertArrays = async ({\n  adapter,\n  arrays,\n  db,\n  parentRows,\n  uuidMap = {},\n}: Args): Promise<void> => {\n  // Maintain a map of flattened rows by table\n  const rowsByTable: RowsByTable = {}\n\n  arrays.forEach((arraysByTable, parentRowIndex) => {\n    if (!arraysByTable || Object.keys(arraysByTable).length === 0) {\n      return\n    }\n    Object.entries(arraysByTable).forEach(([tableName, arrayRows]) => {\n      // If the table doesn't exist in map, initialize it\n      if (!rowsByTable[tableName]) {\n        rowsByTable[tableName] = {\n          arrays: [],\n          locales: [],\n          rows: [],\n        }\n      }\n\n      const parentID = parentRows[parentRowIndex].id\n\n      // Add any sub arrays that need to be created\n      // We will call this recursively below\n      arrayRows.forEach((arrayRow) => {\n        if (Object.keys(arrayRow.arrays).length > 0) {\n          rowsByTable[tableName].arrays.push(arrayRow.arrays)\n        }\n\n        // Set up parent IDs for both row and locale row\n        arrayRow.row._parentID = parentID\n        rowsByTable[tableName].rows.push(arrayRow.row)\n\n        Object.entries(arrayRow.locales).forEach(([arrayRowLocale, arrayRowLocaleData]) => {\n          arrayRowLocaleData._parentID = arrayRow.row.id\n          arrayRowLocaleData._locale = arrayRowLocale\n          rowsByTable[tableName].locales.push(arrayRowLocaleData)\n          if (!arrayRow.row.id) {\n            arrayRowLocaleData._getParentID = (rows: { _uuid: string; id: number }[]) => {\n              const { id } = rows.find((each) => each._uuid === arrayRow.row._uuid)\n              return id\n            }\n          }\n        })\n      })\n    })\n  })\n\n  // Insert all corresponding arrays\n  // (one insert per array table)\n  for (const [tableName, row] of Object.entries(rowsByTable)) {\n    // the nested arrays need the ID for the parentID foreign key\n    let insertedRows: Args['parentRows']\n    if (row.rows.length > 0) {\n      insertedRows = await adapter.insert({\n        db,\n        tableName,\n        values: row.rows,\n      })\n\n      insertedRows.forEach((row) => {\n        if (\n          typeof row._uuid === 'string' &&\n          (typeof row.id === 'string' || typeof row.id === 'number')\n        ) {\n          uuidMap[row._uuid] = row.id\n        }\n      })\n    }\n\n    // Insert locale rows\n    if (adapter.tables[`${tableName}${adapter.localesSuffix}`] && row.locales.length > 0) {\n      if (!row.locales[0]._parentID) {\n        row.locales = row.locales.map((localeRow) => {\n          if (typeof localeRow._getParentID === 'function') {\n            localeRow._parentID = localeRow._getParentID(insertedRows)\n            delete localeRow._getParentID\n          }\n          return localeRow\n        })\n      }\n      await adapter.insert({\n        db,\n        tableName: `${tableName}${adapter.localesSuffix}`,\n        values: row.locales,\n      })\n    }\n\n    // If there are sub arrays, call this function recursively\n    if (row.arrays.length > 0) {\n      await insertArrays({\n        adapter,\n        arrays: row.arrays,\n        db,\n        parentRows: insertedRows,\n      })\n    }\n  }\n}\n"],"names":["insertArrays","adapter","arrays","db","parentRows","uuidMap","rowsByTable","forEach","arraysByTable","parentRowIndex","Object","keys","length","entries","tableName","arrayRows","locales","rows","parentID","id","arrayRow","push","row","_parentID","arrayRowLocale","arrayRowLocaleData","_locale","_getParentID","find","each","_uuid","insertedRows","insert","values","tables","localesSuffix","map","localeRow"],"mappings":"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"}},
    {"offset": {"line": 5076, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/upsertRow/shouldUseOptimizedUpsertRow.ts"],"sourcesContent":["import type { FlattenedField } from 'payload'\n\n/**\n * Checks whether we should use the upsertRow function for the passed data and otherwise use a simple SQL SET call.\n * We need to use upsertRow only when the data has arrays, blocks, hasMany select/text/number, localized fields, complex relationships.\n */\nexport const shouldUseOptimizedUpsertRow = ({\n  data,\n  fields,\n}: {\n  data: Record<string, unknown>\n  fields: FlattenedField[]\n}) => {\n  let fieldsMatched = false\n\n  for (const key in data) {\n    const value = data[key]\n    const field = fields.find((each) => each.name === key)\n\n    if (!field) {\n      continue\n    }\n\n    fieldsMatched = true\n\n    if (\n      field.type === 'blocks' ||\n      ((field.type === 'text' ||\n        field.type === 'relationship' ||\n        field.type === 'upload' ||\n        field.type === 'select' ||\n        field.type === 'number') &&\n        field.hasMany) ||\n      ((field.type === 'relationship' || field.type === 'upload') &&\n        Array.isArray(field.relationTo)) ||\n      field.localized\n    ) {\n      return false\n    }\n\n    if (field.type === 'array') {\n      if (typeof value === 'object' && '$push' in value && value.$push) {\n        return shouldUseOptimizedUpsertRow({\n          // Only check first row - this function cares about field definitions. Each array row will have the same field definitions.\n          data: Array.isArray(value.$push) ? value.$push?.[0] : value.$push,\n          fields: field.flattenedFields,\n        })\n      }\n      return false\n    }\n\n    // Handle relationship $push and $remove operations\n    if ((field.type === 'relationship' || field.type === 'upload') && field.hasMany) {\n      if (typeof value === 'object' && ('$push' in value || '$remove' in value)) {\n        return false // Use full upsertRow for relationship operations\n      }\n    }\n\n    if (\n      (field.type === 'group' || field.type === 'tab') &&\n      value &&\n      typeof value === 'object' &&\n      !shouldUseOptimizedUpsertRow({\n        data: value as Record<string, unknown>,\n        fields: field.flattenedFields,\n      })\n    ) {\n      return false\n    }\n  }\n\n  // Handle dot-notation paths when no fields matched\n  if (!fieldsMatched) {\n    for (const key in data) {\n      if (key.includes('.')) {\n        // Split on first dot only\n        const firstDotIndex = key.indexOf('.')\n        const fieldName = key.substring(0, firstDotIndex)\n        const remainingPath = key.substring(firstDotIndex + 1)\n\n        const nestedData = { [fieldName]: { [remainingPath]: data[key] } }\n        return shouldUseOptimizedUpsertRow({\n          data: nestedData,\n          fields,\n        })\n      }\n    }\n  }\n\n  return true\n}\n"],"names":["shouldUseOptimizedUpsertRow","data","fields","fieldsMatched","key","value","field","find","each","name","type","hasMany","Array","isArray","relationTo","localized","$push","flattenedFields","includes","firstDotIndex","indexOf","fieldName","substring","remainingPath","nestedData"],"mappings":"AAEA;;;CAGC,GACD;;;;AAAO,MAAMA,8BAA8B,CAAC,EAC1CC,IAAI,EACJC,MAAM,EAIP;IACC,IAAIC,gBAAgB;IAEpB,IAAK,MAAMC,OAAOH,KAAM;QACtB,MAAMI,QAAQJ,IAAI,CAACG,IAAI;QACvB,MAAME,QAAQJ,OAAOK,IAAI,CAAC,CAACC,OAASA,KAAKC,IAAI,KAAKL;QAElD,IAAI,CAACE,OAAO;YACV;QACF;QAEAH,gBAAgB;QAEhB,IACEG,MAAMI,IAAI,KAAK,YACbJ,CAAAA,MAAMI,IAAI,KAAK,UACfJ,MAAMI,IAAI,KAAK,kBACfJ,MAAMI,IAAI,KAAK,YACfJ,MAAMI,IAAI,KAAK,YACfJ,MAAMI,IAAI,KAAK,QAAO,KACtBJ,MAAMK,OAAO,IACbL,CAAAA,MAAMI,IAAI,KAAK,kBAAkBJ,MAAMI,IAAI,KAAK,QAAO,KACvDE,MAAMC,OAAO,CAACP,MAAMQ,UAAU,KAChCR,MAAMS,SAAS,EACf;YACA,OAAO;QACT;QAEA,IAAIT,MAAMI,IAAI,KAAK,SAAS;YAC1B,IAAI,OAAOL,UAAU,YAAY,WAAWA,SAASA,MAAMW,KAAK,EAAE;gBAChE,OAAOhB,4BAA4B;oBACjC,2HAA2H;oBAC3HC,MAAMW,MAAMC,OAAO,CAACR,MAAMW,KAAK,IAAIX,MAAMW,KAAK,EAAE,CAAC,EAAE,GAAGX,MAAMW,KAAK;oBACjEd,QAAQI,MAAMW,eAAe;gBAC/B;YACF;YACA,OAAO;QACT;QAEA,mDAAmD;QACnD,IAAKX,CAAAA,MAAMI,IAAI,KAAK,kBAAkBJ,MAAMI,IAAI,KAAK,QAAO,KAAMJ,MAAMK,OAAO,EAAE;YAC/E,IAAI,OAAON,UAAU,YAAa,CAAA,WAAWA,SAAS,aAAaA,KAAI,GAAI;gBACzE,OAAO,MAAM,iDAAiD;;YAChE;QACF;QAEA,IACGC,CAAAA,MAAMI,IAAI,KAAK,WAAWJ,MAAMI,IAAI,KAAK,KAAI,KAC9CL,SACA,OAAOA,UAAU,YACjB,CAACL,4BAA4B;YAC3BC,MAAMI;YACNH,QAAQI,MAAMW,eAAe;QAC/B,IACA;YACA,OAAO;QACT;IACF;IAEA,mDAAmD;IACnD,IAAI,CAACd,eAAe;QAClB,IAAK,MAAMC,OAAOH,KAAM;YACtB,IAAIG,IAAIc,QAAQ,CAAC,MAAM;gBACrB,0BAA0B;gBAC1B,MAAMC,gBAAgBf,IAAIgB,OAAO,CAAC;gBAClC,MAAMC,YAAYjB,IAAIkB,SAAS,CAAC,GAAGH;gBACnC,MAAMI,gBAAgBnB,IAAIkB,SAAS,CAACH,gBAAgB;gBAEpD,MAAMK,aAAa;oBAAE,CAACH,UAAU,EAAE;wBAAE,CAACE,cAAc,EAAEtB,IAAI,CAACG,IAAI;oBAAC;gBAAE;gBACjE,OAAOJ,4BAA4B;oBACjCC,MAAMuB;oBACNtB;gBACF;YACF;QACF;IACF;IAEA,OAAO;AACT,EAAC"}},
    {"offset": {"line": 5145, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/upsertRow/index.ts"],"sourcesContent":["import type { LibSQLDatabase } from 'drizzle-orm/libsql'\nimport type { SelectedFields } from 'drizzle-orm/sqlite-core'\nimport type { TypeWithID } from 'payload'\n\nimport { and, desc, eq, isNull, or } from 'drizzle-orm'\n\nimport type { BlockRowToInsert } from '../transform/write/types.js'\nimport type { Args } from './types.js'\n\ntype RelationshipRow = {\n  [key: string]: number | string | undefined // For relationship ID columns like categoriesID, moviesID, etc.\n  id?: number | string\n  locale?: string\n  order: number\n  parent: number | string // Drizzle table uses 'parent' key\n  path: string\n}\n\nimport { buildFindManyArgs } from '../find/buildFindManyArgs.js'\nimport { transform } from '../transform/read/index.js'\nimport { transformForWrite } from '../transform/write/index.js'\nimport { deleteExistingArrayRows } from './deleteExistingArrayRows.js'\nimport { deleteExistingRowsByPath } from './deleteExistingRowsByPath.js'\nimport { handleUpsertError } from './handleUpsertError.js'\nimport { insertArrays } from './insertArrays.js'\nimport { shouldUseOptimizedUpsertRow } from './shouldUseOptimizedUpsertRow.js'\n\n/**\n * If `id` is provided, it will update the row with that ID.\n * If `where` is provided, it will update the row that matches the `where`\n * If neither `id` nor `where` is provided, it will create a new row.\n *\n * adapter function replaces the entire row and does not support partial updates.\n */\nexport const upsertRow = async <T extends Record<string, unknown> | TypeWithID>({\n  id,\n  adapter,\n  collectionSlug,\n  data,\n  db,\n  fields,\n  globalSlug,\n  ignoreResult,\n  // TODO:\n  // When we support joins for write operations (create/update) - pass collectionSlug to the buildFindManyArgs\n  // Make a new argument in upsertRow.ts and pass the slug from every operation.\n  joinQuery: _joinQuery,\n  operation,\n  path = '',\n  req,\n  select,\n  tableName,\n  upsertTarget,\n  where,\n}: Args): Promise<T> => {\n  if (operation === 'create' && !data.createdAt) {\n    data.createdAt = new Date().toISOString()\n  }\n\n  let insertedRow: Record<string, unknown> = { id }\n  if (id && shouldUseOptimizedUpsertRow({ data, fields })) {\n    try {\n      const transformedForWrite = transformForWrite({\n        adapter,\n        data,\n        enableAtomicWrites: true,\n        fields,\n        tableName,\n      })\n      const { row } = transformedForWrite\n      const { arraysToPush } = transformedForWrite\n\n      const drizzle = db as LibSQLDatabase\n\n      // First, handle $push arrays\n\n      if (arraysToPush && Object.keys(arraysToPush)?.length) {\n        await insertArrays({\n          adapter,\n          arrays: [arraysToPush],\n          db,\n          parentRows: [insertedRow],\n          uuidMap: {},\n        })\n      }\n\n      // If row.updatedAt is not set, delete it to avoid triggering hasDataToUpdate. `updatedAt` may be explicitly set to null to\n      // disable triggering hasDataToUpdate.\n      if (typeof row.updatedAt === 'undefined' || row.updatedAt === null) {\n        delete row.updatedAt\n      }\n\n      const hasDataToUpdate = row && Object.keys(row)?.length\n\n      // Then, handle regular row update\n      if (ignoreResult) {\n        if (hasDataToUpdate) {\n          // Only update row if there is something to update.\n          // Example: if the data only consists of a single $push, calling insertArrays is enough - we don't need to update the row.\n          await drizzle\n            .update(adapter.tables[tableName])\n            .set(row)\n            .where(eq(adapter.tables[tableName].id, id))\n        }\n        return ignoreResult === 'idOnly' ? ({ id } as T) : null\n      }\n\n      const findManyArgs = buildFindManyArgs({\n        adapter,\n        depth: 0,\n        fields,\n        joinQuery: false,\n        select,\n        tableName,\n      })\n\n      const findManyKeysLength = Object.keys(findManyArgs).length\n      const hasOnlyColumns = Object.keys(findManyArgs.columns || {}).length > 0\n\n      if (!hasDataToUpdate) {\n        // Nothing to update => just fetch current row and return\n        findManyArgs.where = eq(adapter.tables[tableName].id, insertedRow.id)\n\n        const doc = await db.query[tableName].findFirst(findManyArgs)\n\n        return transform<T>({\n          adapter,\n          config: adapter.payload.config,\n          data: doc,\n          fields,\n          joinQuery: false,\n          tableName,\n        })\n      }\n\n      if (findManyKeysLength === 0 || hasOnlyColumns) {\n        // Optimization - No need for joins => can simply use returning(). This is optimal for very simple collections\n        // without complex fields that live in separate tables like blocks, arrays, relationships, etc.\n\n        const selectedFields: SelectedFields = {}\n        if (hasOnlyColumns) {\n          for (const [column, enabled] of Object.entries(findManyArgs.columns)) {\n            if (enabled) {\n              selectedFields[column] = adapter.tables[tableName][column]\n            }\n          }\n        }\n\n        const docs = await drizzle\n          .update(adapter.tables[tableName])\n          .set(row)\n          .where(eq(adapter.tables[tableName].id, id))\n          .returning(Object.keys(selectedFields).length ? selectedFields : undefined)\n\n        return transform<T>({\n          adapter,\n          config: adapter.payload.config,\n          data: docs[0],\n          fields,\n          joinQuery: false,\n          tableName,\n        })\n      }\n\n      // DB Update that needs the result, potentially with joins => need to update first, then find. returning() does not work with joins.\n\n      await drizzle\n        .update(adapter.tables[tableName])\n        .set(row)\n        .where(eq(adapter.tables[tableName].id, id))\n\n      findManyArgs.where = eq(adapter.tables[tableName].id, insertedRow.id)\n\n      const doc = await db.query[tableName].findFirst(findManyArgs)\n\n      return transform<T>({\n        adapter,\n        config: adapter.payload.config,\n        data: doc,\n        fields,\n        joinQuery: false,\n        tableName,\n      })\n    } catch (error) {\n      handleUpsertError({ id, adapter, collectionSlug, error, globalSlug, req, tableName })\n    }\n  }\n  // Split out the incoming data into the corresponding:\n  // base row, locales, relationships, blocks, and arrays\n  const rowToInsert = transformForWrite({\n    adapter,\n    data,\n    enableAtomicWrites: false,\n    fields,\n    path,\n    tableName,\n  })\n\n  // First, we insert the main row\n  try {\n    if (operation === 'update') {\n      const target = upsertTarget || adapter.tables[tableName].id\n\n      // Check if we only have relationship operations and no main row data to update\n      // Exclude timestamp-only updates when we only have relationship operations\n      const rowKeys = Object.keys(rowToInsert.row)\n      const hasMainRowData =\n        rowKeys.length > 0 && !rowKeys.every((key) => key === 'updatedAt' || key === 'createdAt')\n\n      if (hasMainRowData) {\n        if (id) {\n          rowToInsert.row.id = id\n          ;[insertedRow] = await adapter.insert({\n            db,\n            onConflictDoUpdate: { set: rowToInsert.row, target },\n            tableName,\n            values: rowToInsert.row,\n          })\n        } else {\n          ;[insertedRow] = await adapter.insert({\n            db,\n            onConflictDoUpdate: { set: rowToInsert.row, target, where },\n            tableName,\n            values: rowToInsert.row,\n          })\n        }\n      } else {\n        // No main row data to update, just use the existing ID\n        insertedRow = { id }\n      }\n    } else {\n      if (adapter.allowIDOnCreate && data.id) {\n        rowToInsert.row.id = data.id\n      }\n      ;[insertedRow] = await adapter.insert({\n        db,\n        tableName,\n        values: rowToInsert.row,\n      })\n    }\n\n    const localesToInsert: Record<string, unknown>[] = []\n    const relationsToInsert: Record<string, unknown>[] = []\n    const textsToInsert: Record<string, unknown>[] = []\n    const numbersToInsert: Record<string, unknown>[] = []\n    const blocksToInsert: { [blockType: string]: BlockRowToInsert[] } = {}\n    const selectsToInsert: { [selectTableName: string]: Record<string, unknown>[] } = {}\n\n    // If there are locale rows with data, add the parent and locale to each\n    if (Object.keys(rowToInsert.locales).length > 0) {\n      Object.entries(rowToInsert.locales).forEach(([locale, localeRow]) => {\n        localeRow._parentID = insertedRow.id\n        localeRow._locale = locale\n        localesToInsert.push(localeRow)\n      })\n    }\n\n    // If there are relationships, add parent to each\n    if (rowToInsert.relationships.length > 0) {\n      rowToInsert.relationships.forEach((relation) => {\n        relation.parent = insertedRow.id\n        relationsToInsert.push(relation)\n      })\n    }\n\n    // If there are texts, add parent to each\n    if (rowToInsert.texts.length > 0) {\n      rowToInsert.texts.forEach((textRow) => {\n        textRow.parent = insertedRow.id\n        textsToInsert.push(textRow)\n      })\n    }\n\n    // If there are numbers, add parent to each\n    if (rowToInsert.numbers.length > 0) {\n      rowToInsert.numbers.forEach((numberRow) => {\n        numberRow.parent = insertedRow.id\n        numbersToInsert.push(numberRow)\n      })\n    }\n\n    // If there are selects, add parent to each, and then\n    // store by table name and rows\n    if (Object.keys(rowToInsert.selects).length > 0) {\n      Object.entries(rowToInsert.selects).forEach(([selectTableName, selectRows]) => {\n        selectsToInsert[selectTableName] = []\n\n        selectRows.forEach((row) => {\n          if (typeof row.parent === 'undefined') {\n            row.parent = insertedRow.id\n          }\n\n          selectsToInsert[selectTableName].push(row)\n        })\n      })\n    }\n\n    // If there are blocks, add parent to each, and then\n    // store by table name and rows\n    Object.keys(rowToInsert.blocks).forEach((tableName) => {\n      rowToInsert.blocks[tableName].forEach((blockRow) => {\n        blockRow.row._parentID = insertedRow.id\n        if (!blocksToInsert[tableName]) {\n          blocksToInsert[tableName] = []\n        }\n        if (blockRow.row.uuid) {\n          delete blockRow.row.uuid\n        }\n        blocksToInsert[tableName].push(blockRow)\n      })\n    })\n\n    // //////////////////////////////////\n    // INSERT LOCALES\n    // //////////////////////////////////\n\n    if (localesToInsert.length > 0) {\n      const localeTableName = `${tableName}${adapter.localesSuffix}`\n      const localeTable = adapter.tables[`${tableName}${adapter.localesSuffix}`]\n\n      if (operation === 'update') {\n        await adapter.deleteWhere({\n          db,\n          tableName: localeTableName,\n          where: eq(localeTable._parentID, insertedRow.id),\n        })\n      }\n\n      await adapter.insert({\n        db,\n        tableName: localeTableName,\n        values: localesToInsert,\n      })\n    }\n\n    // //////////////////////////////////\n    // INSERT RELATIONSHIPS\n    // //////////////////////////////////\n\n    const relationshipsTableName = `${tableName}${adapter.relationshipsSuffix}`\n\n    if (operation === 'update') {\n      // Filter out specific item deletions (those with itemToRemove) from general path deletions\n      const generalRelationshipDeletes = rowToInsert.relationshipsToDelete.filter(\n        (rel) => !('itemToRemove' in rel),\n      )\n\n      await deleteExistingRowsByPath({\n        adapter,\n        db,\n        localeColumnName: 'locale',\n        parentColumnName: 'parent',\n        parentID: insertedRow.id,\n        pathColumnName: 'path',\n        rows: [...relationsToInsert, ...generalRelationshipDeletes],\n        tableName: relationshipsTableName,\n      })\n    }\n\n    if (relationsToInsert.length > 0) {\n      await adapter.insert({\n        db,\n        tableName: relationshipsTableName,\n        values: relationsToInsert,\n      })\n    }\n\n    // //////////////////////////////////\n    // HANDLE RELATIONSHIP $push OPERATIONS\n    // //////////////////////////////////\n\n    if (rowToInsert.relationshipsToAppend.length > 0) {\n      // Prepare all relationships for batch insert (order will be set after max query)\n      const relationshipsToInsert = rowToInsert.relationshipsToAppend.map((rel) => {\n        const parentId = id || insertedRow.id\n        const row: Record<string, unknown> = {\n          parent: parentId as number | string, // Use 'parent' key for Drizzle table\n          path: rel.path,\n        }\n\n        // Only add locale if this relationship table has a locale column\n        const relationshipTable = adapter.rawTables[relationshipsTableName]\n        if (rel.locale && relationshipTable && relationshipTable.columns.locale) {\n          row.locale = rel.locale\n        }\n\n        if (rel.relationTo) {\n          // Use camelCase key for Drizzle table (e.g., categoriesID not categories_id)\n          row[`${rel.relationTo}ID`] = rel.value\n        }\n\n        return row\n      })\n\n      if (relationshipsToInsert.length > 0) {\n        // Check for potential duplicates\n        const relationshipTable = adapter.tables[relationshipsTableName]\n\n        if (relationshipTable) {\n          // Build conditions only if we have relationships to check\n          if (relationshipsToInsert.length === 0) {\n            return // No relationships to insert\n          }\n\n          const conditions = relationshipsToInsert.map((row: RelationshipRow) => {\n            const parts = [\n              eq(relationshipTable.parent, row.parent),\n              eq(relationshipTable.path, row.path),\n            ]\n\n            // Add locale condition\n            if (row.locale !== undefined && relationshipTable.locale) {\n              parts.push(eq(relationshipTable.locale, row.locale))\n            } else if (relationshipTable.locale) {\n              parts.push(isNull(relationshipTable.locale))\n            }\n\n            // Add all relationship ID matches using schema fields\n            for (const [key, value] of Object.entries(row)) {\n              if (key.endsWith('ID') && value != null) {\n                const column = relationshipTable[key]\n                if (column && typeof column === 'object') {\n                  parts.push(eq(column, value))\n                }\n              }\n            }\n\n            return and(...parts)\n          })\n\n          // Get both existing relationships AND max order in a single query\n          let existingRels: Record<string, unknown>[] = []\n          let maxOrder = 0\n\n          if (conditions.length > 0) {\n            // Query for existing relationships\n            existingRels = await (db as any)\n              .select()\n              .from(relationshipTable)\n              .where(or(...conditions))\n          }\n\n          // Get max order for this parent across all paths in a single query\n          const parentId = id || insertedRow.id\n          const maxOrderResult = await (db as any)\n            .select({ maxOrder: relationshipTable.order })\n            .from(relationshipTable)\n            .where(eq(relationshipTable.parent, parentId))\n            .orderBy(desc(relationshipTable.order))\n            .limit(1)\n\n          if (maxOrderResult.length > 0 && maxOrderResult[0].maxOrder) {\n            maxOrder = maxOrderResult[0].maxOrder\n          }\n\n          // Set order values for all relationships based on max order\n          relationshipsToInsert.forEach((row, index) => {\n            row.order = maxOrder + index + 1\n          })\n\n          // Filter out relationships that already exist\n          const relationshipsToActuallyInsert = relationshipsToInsert.filter((newRow) => {\n            return !existingRels.some((existingRow: Record<string, unknown>) => {\n              // Check if this relationship already exists\n              let matches = existingRow.parent === newRow.parent && existingRow.path === newRow.path\n\n              if (newRow.locale !== undefined) {\n                matches = matches && existingRow.locale === newRow.locale\n              }\n\n              // Check relationship value matches - convert to camelCase for comparison\n              for (const key of Object.keys(newRow)) {\n                if (key.endsWith('ID')) {\n                  // Now using camelCase keys\n                  matches = matches && existingRow[key] === newRow[key]\n                }\n              }\n\n              return matches\n            })\n          })\n\n          // Insert only non-duplicate relationships\n          if (relationshipsToActuallyInsert.length > 0) {\n            await adapter.insert({\n              db,\n              tableName: relationshipsTableName,\n              values: relationshipsToActuallyInsert,\n            })\n          }\n        }\n      }\n    }\n\n    // //////////////////////////////////\n    // HANDLE RELATIONSHIP $remove OPERATIONS\n    // //////////////////////////////////\n\n    if (rowToInsert.relationshipsToDelete.some((rel) => 'itemToRemove' in rel)) {\n      const relationshipTable = adapter.tables[relationshipsTableName]\n\n      if (relationshipTable) {\n        for (const relToDelete of rowToInsert.relationshipsToDelete) {\n          if ('itemToRemove' in relToDelete && relToDelete.itemToRemove) {\n            const item = relToDelete.itemToRemove\n            const parentId = (id || insertedRow.id) as number | string\n\n            const conditions = [\n              eq(relationshipTable.parent, parentId),\n              eq(relationshipTable.path, relToDelete.path),\n            ]\n\n            // Add locale condition if this relationship table has a locale column\n            if (adapter.rawTables[relationshipsTableName]?.columns.locale) {\n              if (relToDelete.locale) {\n                conditions.push(eq(relationshipTable.locale, relToDelete.locale))\n              } else {\n                conditions.push(isNull(relationshipTable.locale))\n              }\n            }\n\n            // Handle polymorphic vs simple relationships\n            if (typeof item === 'object' && 'relationTo' in item) {\n              // Polymorphic relationship - convert to camelCase key\n              const camelKey = `${item.relationTo}ID`\n              if (relationshipTable[camelKey]) {\n                conditions.push(eq(relationshipTable[camelKey], item.value))\n              }\n            } else if (relToDelete.relationTo) {\n              // Simple relationship - convert to camelCase key\n              const camelKey = `${relToDelete.relationTo}ID`\n              if (relationshipTable[camelKey]) {\n                conditions.push(eq(relationshipTable[camelKey], item))\n              }\n            }\n\n            // Execute DELETE using Drizzle query builder\n            await adapter.deleteWhere({\n              db,\n              tableName: relationshipsTableName,\n              where: and(...conditions),\n            })\n          }\n        }\n      }\n    }\n\n    // //////////////////////////////////\n    // INSERT hasMany TEXTS\n    // //////////////////////////////////\n\n    const textsTableName = `${tableName}_texts`\n\n    if (operation === 'update') {\n      await deleteExistingRowsByPath({\n        adapter,\n        db,\n        localeColumnName: 'locale',\n        parentColumnName: 'parent',\n        parentID: insertedRow.id,\n        pathColumnName: 'path',\n        rows: [...textsToInsert, ...rowToInsert.textsToDelete],\n        tableName: textsTableName,\n      })\n    }\n\n    if (textsToInsert.length > 0) {\n      await adapter.insert({\n        db,\n        tableName: textsTableName,\n        values: textsToInsert,\n      })\n    }\n\n    // //////////////////////////////////\n    // INSERT hasMany NUMBERS\n    // //////////////////////////////////\n\n    const numbersTableName = `${tableName}_numbers`\n\n    if (operation === 'update') {\n      await deleteExistingRowsByPath({\n        adapter,\n        db,\n        localeColumnName: 'locale',\n        parentColumnName: 'parent',\n        parentID: insertedRow.id,\n        pathColumnName: 'path',\n        rows: [...numbersToInsert, ...rowToInsert.numbersToDelete],\n        tableName: numbersTableName,\n      })\n    }\n\n    if (numbersToInsert.length > 0) {\n      await adapter.insert({\n        db,\n        tableName: numbersTableName,\n        values: numbersToInsert,\n      })\n    }\n\n    // //////////////////////////////////\n    // INSERT BLOCKS\n    // //////////////////////////////////\n\n    const insertedBlockRows: Record<string, Record<string, unknown>[]> = {}\n\n    if (operation === 'update') {\n      for (const tableName of rowToInsert.blocksToDelete) {\n        const blockTable = adapter.tables[tableName]\n        await adapter.deleteWhere({\n          db,\n          tableName,\n          where: eq(blockTable._parentID, insertedRow.id),\n        })\n      }\n    }\n\n    // When versions are enabled, adapter is used to track mapping between blocks/arrays ObjectID to their numeric generated representation, then we use it for nested to arrays/blocks select hasMany in versions.\n    const arraysBlocksUUIDMap: Record<string, number | string> = {}\n\n    for (const [tableName, blockRows] of Object.entries(blocksToInsert)) {\n      insertedBlockRows[tableName] = await adapter.insert({\n        db,\n        tableName,\n        values: blockRows.map(({ row }) => row),\n      })\n\n      insertedBlockRows[tableName].forEach((row, i) => {\n        blockRows[i].row = row\n        if (\n          typeof row._uuid === 'string' &&\n          (typeof row.id === 'string' || typeof row.id === 'number')\n        ) {\n          arraysBlocksUUIDMap[row._uuid] = row.id\n        }\n      })\n\n      const blockLocaleIndexMap: number[] = []\n\n      const blockLocaleRowsToInsert = blockRows.reduce((acc, blockRow, i) => {\n        if (Object.entries(blockRow.locales).length > 0) {\n          Object.entries(blockRow.locales).forEach(([blockLocale, blockLocaleData]) => {\n            if (Object.keys(blockLocaleData).length > 0) {\n              blockLocaleData._parentID = blockRow.row.id\n              blockLocaleData._locale = blockLocale\n              acc.push(blockLocaleData)\n              blockLocaleIndexMap.push(i)\n            }\n          })\n        }\n\n        return acc\n      }, [])\n\n      if (blockLocaleRowsToInsert.length > 0) {\n        await adapter.insert({\n          db,\n          tableName: `${tableName}${adapter.localesSuffix}`,\n          values: blockLocaleRowsToInsert,\n        })\n      }\n\n      await insertArrays({\n        adapter,\n        arrays: blockRows.map(({ arrays }) => arrays),\n        db,\n        parentRows: insertedBlockRows[tableName],\n        uuidMap: arraysBlocksUUIDMap,\n      })\n    }\n\n    // //////////////////////////////////\n    // INSERT ARRAYS RECURSIVELY\n    // //////////////////////////////////\n\n    if (operation === 'update') {\n      for (const arrayTableName of Object.keys(rowToInsert.arrays)) {\n        await deleteExistingArrayRows({\n          adapter,\n          db,\n          parentID: insertedRow.id,\n          tableName: arrayTableName,\n        })\n      }\n    }\n\n    await insertArrays({\n      adapter,\n      arrays: [rowToInsert.arrays, rowToInsert.arraysToPush],\n      db,\n      parentRows: [insertedRow, insertedRow],\n      uuidMap: arraysBlocksUUIDMap,\n    })\n\n    // //////////////////////////////////\n    // INSERT hasMany SELECTS\n    // //////////////////////////////////\n\n    for (const [selectTableName, tableRows] of Object.entries(selectsToInsert)) {\n      const selectTable = adapter.tables[selectTableName]\n      if (operation === 'update') {\n        await adapter.deleteWhere({\n          db,\n          tableName: selectTableName,\n          where: eq(selectTable.parent, insertedRow.id),\n        })\n      }\n\n      if (Object.keys(arraysBlocksUUIDMap).length > 0) {\n        tableRows.forEach((row: RelationshipRow) => {\n          if (row.parent in arraysBlocksUUIDMap) {\n            row.parent = arraysBlocksUUIDMap[row.parent]\n          }\n        })\n      }\n\n      if (tableRows.length) {\n        await adapter.insert({\n          db,\n          tableName: selectTableName,\n          values: tableRows,\n        })\n      }\n    }\n  } catch (error) {\n    handleUpsertError({ id, adapter, collectionSlug, error, globalSlug, req, tableName })\n  }\n\n  if (ignoreResult === 'idOnly') {\n    return { id: insertedRow.id } as T\n  }\n\n  if (ignoreResult) {\n    return data as T\n  }\n\n  // //////////////////////////////////\n  // RETRIEVE NEWLY UPDATED ROW\n  // //////////////////////////////////\n\n  const findManyArgs = buildFindManyArgs({\n    adapter,\n    depth: 0,\n    fields,\n    joinQuery: false,\n    select,\n    tableName,\n  })\n\n  findManyArgs.where = eq(adapter.tables[tableName].id, insertedRow.id)\n\n  const doc = await db.query[tableName].findFirst(findManyArgs)\n\n  // //////////////////////////////////\n  // TRANSFORM DATA\n  // //////////////////////////////////\n\n  const result = transform<T>({\n    adapter,\n    config: adapter.payload.config,\n    data: doc,\n    fields,\n    joinQuery: false,\n    tableName,\n  })\n\n  return result\n}\n"],"names":["and","desc","eq","isNull","or","buildFindManyArgs","transform","transformForWrite","deleteExistingArrayRows","deleteExistingRowsByPath","handleUpsertError","insertArrays","shouldUseOptimizedUpsertRow","upsertRow","id","adapter","collectionSlug","data","db","fields","globalSlug","ignoreResult","joinQuery","_joinQuery","operation","path","req","select","tableName","upsertTarget","where","createdAt","Date","toISOString","insertedRow","transformedForWrite","enableAtomicWrites","row","arraysToPush","drizzle","Object","keys","length","arrays","parentRows","uuidMap","updatedAt","hasDataToUpdate","update","tables","set","findManyArgs","depth","findManyKeysLength","hasOnlyColumns","columns","doc","query","findFirst","config","payload","selectedFields","column","enabled","entries","docs","returning","undefined","error","rowToInsert","target","rowKeys","hasMainRowData","every","key","insert","onConflictDoUpdate","values","allowIDOnCreate","localesToInsert","relationsToInsert","textsToInsert","numbersToInsert","blocksToInsert","selectsToInsert","locales","forEach","locale","localeRow","_parentID","_locale","push","relationships","relation","parent","texts","textRow","numbers","numberRow","selects","selectTableName","selectRows","blocks","blockRow","uuid","localeTableName","localesSuffix","localeTable","deleteWhere","relationshipsTableName","relationshipsSuffix","generalRelationshipDeletes","relationshipsToDelete","filter","rel","localeColumnName","parentColumnName","parentID","pathColumnName","rows","relationshipsToAppend","relationshipsToInsert","map","parentId","relationshipTable","rawTables","relationTo","value","conditions","parts","endsWith","existingRels","maxOrder","from","maxOrderResult","order","orderBy","limit","index","relationshipsToActuallyInsert","newRow","some","existingRow","matches","relToDelete","itemToRemove","item","camelKey","textsTableName","textsToDelete","numbersTableName","numbersToDelete","insertedBlockRows","blocksToDelete","blockTable","arraysBlocksUUIDMap","blockRows","i","_uuid","blockLocaleIndexMap","blockLocaleRowsToInsert","reduce","acc","blockLocale","blockLocaleData","arrayTableName","tableRows","selectTable","result"],"mappings":";;;;;AAIA,SAASA,GAAG,EAAEC,IAAI,EAAEC,EAAE,EAAEC,MAAM,EAAEC,EAAE,QAAQ,cAAa;AAcvD,SAASC,iBAAiB,QAAQ,+BAA8B;AAChE,SAASC,SAAS,QAAQ,6BAA4B;AACtD,SAASC,iBAAiB,QAAQ,8BAA6B;AAC/D,SAASC,uBAAuB,QAAQ,+BAA8B;AACtE,SAASC,wBAAwB,QAAQ,gCAA+B;AACxE,SAASC,iBAAiB,QAAQ,yBAAwB;AAC1D,SAASC,YAAY,QAAQ,oBAAmB;AAChD,SAASC,2BAA2B,QAAQ,mCAAkC;;;;;;;;;;AASvE,MAAMC,YAAY,OAAuD,EAC9EC,EAAE,EACFC,OAAO,EACPC,cAAc,EACdC,IAAI,EACJC,EAAE,EACFC,MAAM,EACNC,UAAU,EACVC,YAAY,EACZ,AACA,QADQ,oGACoG;AAC5G,8EAA8E;AAC9EC,WAAWC,UAAU,EACrBC,SAAS,EACTC,OAAO,EAAE,EACTC,GAAG,EACHC,MAAM,EACNC,SAAS,EACTC,YAAY,EACZC,KAAK,EACA;IACL,IAAIN,cAAc,YAAY,CAACP,KAAKc,SAAS,EAAE;QAC7Cd,KAAKc,SAAS,GAAG,IAAIC,OAAOC,WAAW;IACzC;IAEA,IAAIC,cAAuC;QAAEpB;IAAG;IAChD,IAAIA,UAAMF,4NAAAA,EAA4B;QAAEK;QAAME;IAAO,IAAI;QACvD,IAAI;YACF,MAAMgB,0BAAsB5B,qMAAAA,EAAkB;gBAC5CQ;gBACAE;gBACAmB,oBAAoB;gBACpBjB;gBACAS;YACF;YACA,MAAM,EAAES,GAAG,EAAE,GAAGF;YAChB,MAAM,EAAEG,YAAY,EAAE,GAAGH;YAEzB,MAAMI,UAAUrB;YAEhB,6BAA6B;YAE7B,IAAIoB,gBAAgBE,OAAOC,IAAI,CAACH,eAAeI,QAAQ;gBACrD,UAAM/B,8LAAAA,EAAa;oBACjBI;oBACA4B,QAAQ;wBAACL;qBAAa;oBACtBpB;oBACA0B,YAAY;wBAACV;qBAAY;oBACzBW,SAAS,CAAC;gBACZ;YACF;YAEA,2HAA2H;YAC3H,sCAAsC;YACtC,IAAI,OAAOR,IAAIS,SAAS,KAAK,eAAeT,IAAIS,SAAS,KAAK,MAAM;gBAClE,OAAOT,IAAIS,SAAS;YACtB;YAEA,MAAMC,kBAAkBV,OAAOG,OAAOC,IAAI,CAACJ,MAAMK;YAEjD,kCAAkC;YAClC,IAAIrB,cAAc;gBAChB,IAAI0B,iBAAiB;oBACnB,mDAAmD;oBACnD,0HAA0H;oBAC1H,MAAMR,QACHS,MAAM,CAACjC,QAAQkC,MAAM,CAACrB,UAAU,EAChCsB,GAAG,CAACb,KACJP,KAAK,KAAC5B,0KAAAA,EAAGa,QAAQkC,MAAM,CAACrB,UAAU,CAACd,EAAE,EAAEA;gBAC5C;gBACA,OAAOO,iBAAiB,WAAY;oBAAEP;gBAAG,IAAU;YACrD;YAEA,MAAMqC,mBAAe9C,mMAAAA,EAAkB;gBACrCU;gBACAqC,OAAO;gBACPjC;gBACAG,WAAW;gBACXK;gBACAC;YACF;YAEA,MAAMyB,qBAAqBb,OAAOC,IAAI,CAACU,cAAcT,MAAM;YAC3D,MAAMY,iBAAiBd,OAAOC,IAAI,CAACU,aAAaI,OAAO,IAAI,CAAC,GAAGb,MAAM,GAAG;YAExE,IAAI,CAACK,iBAAiB;gBACpB,yDAAyD;gBACzDI,aAAarB,KAAK,OAAG5B,0KAAAA,EAAGa,QAAQkC,MAAM,CAACrB,UAAU,CAACd,EAAE,EAAEoB,YAAYpB,EAAE;gBAEpE,MAAM0C,MAAM,MAAMtC,GAAGuC,KAAK,CAAC7B,UAAU,CAAC8B,SAAS,CAACP;gBAEhD,WAAO7C,4LAAAA,EAAa;oBAClBS;oBACA4C,QAAQ5C,QAAQ6C,OAAO,CAACD,MAAM;oBAC9B1C,MAAMuC;oBACNrC;oBACAG,WAAW;oBACXM;gBACF;YACF;YAEA,IAAIyB,uBAAuB,KAAKC,gBAAgB;gBAC9C,8GAA8G;gBAC9G,+FAA+F;gBAE/F,MAAMO,iBAAiC,CAAC;gBACxC,IAAIP,gBAAgB;oBAClB,KAAK,MAAM,CAACQ,QAAQC,QAAQ,IAAIvB,OAAOwB,OAAO,CAACb,aAAaI,OAAO,EAAG;wBACpE,IAAIQ,SAAS;4BACXF,cAAc,CAACC,OAAO,GAAG/C,QAAQkC,MAAM,CAACrB,UAAU,CAACkC,OAAO;wBAC5D;oBACF;gBACF;gBAEA,MAAMG,OAAO,MAAM1B,QAChBS,MAAM,CAACjC,QAAQkC,MAAM,CAACrB,UAAU,EAChCsB,GAAG,CAACb,KACJP,KAAK,KAAC5B,0KAAAA,EAAGa,QAAQkC,MAAM,CAACrB,UAAU,CAACd,EAAE,EAAEA,KACvCoD,SAAS,CAAC1B,OAAOC,IAAI,CAACoB,gBAAgBnB,MAAM,GAAGmB,iBAAiBM;gBAEnE,WAAO7D,4LAAAA,EAAa;oBAClBS;oBACA4C,QAAQ5C,QAAQ6C,OAAO,CAACD,MAAM;oBAC9B1C,MAAMgD,IAAI,CAAC,EAAE;oBACb9C;oBACAG,WAAW;oBACXM;gBACF;YACF;YAEA,oIAAoI;YAEpI,MAAMW,QACHS,MAAM,CAACjC,QAAQkC,MAAM,CAACrB,UAAU,EAChCsB,GAAG,CAACb,KACJP,KAAK,KAAC5B,0KAAAA,EAAGa,QAAQkC,MAAM,CAACrB,UAAU,CAACd,EAAE,EAAEA;YAE1CqC,aAAarB,KAAK,OAAG5B,0KAAAA,EAAGa,QAAQkC,MAAM,CAACrB,UAAU,CAACd,EAAE,EAAEoB,YAAYpB,EAAE;YAEpE,MAAM0C,MAAM,MAAMtC,GAAGuC,KAAK,CAAC7B,UAAU,CAAC8B,SAAS,CAACP;YAEhD,WAAO7C,4LAAAA,EAAa;gBAClBS;gBACA4C,QAAQ5C,QAAQ6C,OAAO,CAACD,MAAM;gBAC9B1C,MAAMuC;gBACNrC;gBACAG,WAAW;gBACXM;YACF;QACF,EAAE,OAAOwC,OAAO;gBACd1D,wMAAAA,EAAkB;gBAAEI;gBAAIC;gBAASC;gBAAgBoD;gBAAOhD;gBAAYM;gBAAKE;YAAU;QACrF;IACF;IACA,sDAAsD;IACtD,uDAAuD;IACvD,MAAMyC,kBAAc9D,qMAAAA,EAAkB;QACpCQ;QACAE;QACAmB,oBAAoB;QACpBjB;QACAM;QACAG;IACF;IAEA,gCAAgC;IAChC,IAAI;QACF,IAAIJ,cAAc,UAAU;YAC1B,MAAM8C,SAASzC,gBAAgBd,QAAQkC,MAAM,CAACrB,UAAU,CAACd,EAAE;YAE3D,+EAA+E;YAC/E,2EAA2E;YAC3E,MAAMyD,UAAU/B,OAAOC,IAAI,CAAC4B,YAAYhC,GAAG;YAC3C,MAAMmC,iBACJD,QAAQ7B,MAAM,GAAG,KAAK,CAAC6B,QAAQE,KAAK,CAAC,CAACC,MAAQA,QAAQ,eAAeA,QAAQ;YAE/E,IAAIF,gBAAgB;gBAClB,IAAI1D,IAAI;oBACNuD,YAAYhC,GAAG,CAACvB,EAAE,GAAGA;oBACpB,CAACoB,YAAY,GAAG,MAAMnB,QAAQ4D,MAAM,CAAC;wBACpCzD;wBACA0D,oBAAoB;4BAAE1B,KAAKmB,YAAYhC,GAAG;4BAAEiC;wBAAO;wBACnD1C;wBACAiD,QAAQR,YAAYhC,GAAG;oBACzB;gBACF,OAAO;;oBACJ,CAACH,YAAY,GAAG,MAAMnB,QAAQ4D,MAAM,CAAC;wBACpCzD;wBACA0D,oBAAoB;4BAAE1B,KAAKmB,YAAYhC,GAAG;4BAAEiC;4BAAQxC;wBAAM;wBAC1DF;wBACAiD,QAAQR,YAAYhC,GAAG;oBACzB;gBACF;YACF,OAAO;gBACL,uDAAuD;gBACvDH,cAAc;oBAAEpB;gBAAG;YACrB;QACF,OAAO;YACL,IAAIC,QAAQ+D,eAAe,IAAI7D,KAAKH,EAAE,EAAE;gBACtCuD,YAAYhC,GAAG,CAACvB,EAAE,GAAGG,KAAKH,EAAE;YAC9B;;YACC,CAACoB,YAAY,GAAG,MAAMnB,QAAQ4D,MAAM,CAAC;gBACpCzD;gBACAU;gBACAiD,QAAQR,YAAYhC,GAAG;YACzB;QACF;QAEA,MAAM0C,kBAA6C,EAAE;QACrD,MAAMC,oBAA+C,EAAE;QACvD,MAAMC,gBAA2C,EAAE;QACnD,MAAMC,kBAA6C,EAAE;QACrD,MAAMC,iBAA8D,CAAC;QACrE,MAAMC,kBAA4E,CAAC;QAEnF,wEAAwE;QACxE,IAAI5C,OAAOC,IAAI,CAAC4B,YAAYgB,OAAO,EAAE3C,MAAM,GAAG,GAAG;YAC/CF,OAAOwB,OAAO,CAACK,YAAYgB,OAAO,EAAEC,OAAO,CAAC,CAAC,CAACC,QAAQC,UAAU;gBAC9DA,UAAUC,SAAS,GAAGvD,YAAYpB,EAAE;gBACpC0E,UAAUE,OAAO,GAAGH;gBACpBR,gBAAgBY,IAAI,CAACH;YACvB;QACF;QAEA,iDAAiD;QACjD,IAAInB,YAAYuB,aAAa,CAAClD,MAAM,GAAG,GAAG;YACxC2B,YAAYuB,aAAa,CAACN,OAAO,CAAC,CAACO;gBACjCA,SAASC,MAAM,GAAG5D,YAAYpB,EAAE;gBAChCkE,kBAAkBW,IAAI,CAACE;YACzB;QACF;QAEA,yCAAyC;QACzC,IAAIxB,YAAY0B,KAAK,CAACrD,MAAM,GAAG,GAAG;YAChC2B,YAAY0B,KAAK,CAACT,OAAO,CAAC,CAACU;gBACzBA,QAAQF,MAAM,GAAG5D,YAAYpB,EAAE;gBAC/BmE,cAAcU,IAAI,CAACK;YACrB;QACF;QAEA,2CAA2C;QAC3C,IAAI3B,YAAY4B,OAAO,CAACvD,MAAM,GAAG,GAAG;YAClC2B,YAAY4B,OAAO,CAACX,OAAO,CAAC,CAACY;gBAC3BA,UAAUJ,MAAM,GAAG5D,YAAYpB,EAAE;gBACjCoE,gBAAgBS,IAAI,CAACO;YACvB;QACF;QAEA,qDAAqD;QACrD,+BAA+B;QAC/B,IAAI1D,OAAOC,IAAI,CAAC4B,YAAY8B,OAAO,EAAEzD,MAAM,GAAG,GAAG;YAC/CF,OAAOwB,OAAO,CAACK,YAAY8B,OAAO,EAAEb,OAAO,CAAC,CAAC,CAACc,iBAAiBC,WAAW;gBACxEjB,eAAe,CAACgB,gBAAgB,GAAG,EAAE;gBAErCC,WAAWf,OAAO,CAAC,CAACjD;oBAClB,IAAI,OAAOA,IAAIyD,MAAM,KAAK,aAAa;wBACrCzD,IAAIyD,MAAM,GAAG5D,YAAYpB,EAAE;oBAC7B;oBAEAsE,eAAe,CAACgB,gBAAgB,CAACT,IAAI,CAACtD;gBACxC;YACF;QACF;QAEA,oDAAoD;QACpD,+BAA+B;QAC/BG,OAAOC,IAAI,CAAC4B,YAAYiC,MAAM,EAAEhB,OAAO,CAAC,CAAC1D;YACvCyC,YAAYiC,MAAM,CAAC1E,UAAU,CAAC0D,OAAO,CAAC,CAACiB;gBACrCA,SAASlE,GAAG,CAACoD,SAAS,GAAGvD,YAAYpB,EAAE;gBACvC,IAAI,CAACqE,cAAc,CAACvD,UAAU,EAAE;oBAC9BuD,cAAc,CAACvD,UAAU,GAAG,EAAE;gBAChC;gBACA,IAAI2E,SAASlE,GAAG,CAACmE,IAAI,EAAE;oBACrB,OAAOD,SAASlE,GAAG,CAACmE,IAAI;gBAC1B;gBACArB,cAAc,CAACvD,UAAU,CAAC+D,IAAI,CAACY;YACjC;QACF;QAEA,qCAAqC;QACrC,iBAAiB;QACjB,qCAAqC;QAErC,IAAIxB,gBAAgBrC,MAAM,GAAG,GAAG;YAC9B,MAAM+D,kBAAkB,GAAG7E,YAAYb,QAAQ2F,aAAa,EAAE;YAC9D,MAAMC,cAAc5F,QAAQkC,MAAM,CAAC,GAAGrB,YAAYb,QAAQ2F,aAAa,EAAE,CAAC;YAE1E,IAAIlF,cAAc,UAAU;gBAC1B,MAAMT,QAAQ6F,WAAW,CAAC;oBACxB1F;oBACAU,WAAW6E;oBACX3E,WAAO5B,0KAAAA,EAAGyG,YAAYlB,SAAS,EAAEvD,YAAYpB,EAAE;gBACjD;YACF;YAEA,MAAMC,QAAQ4D,MAAM,CAAC;gBACnBzD;gBACAU,WAAW6E;gBACX5B,QAAQE;YACV;QACF;QAEA,qCAAqC;QACrC,uBAAuB;QACvB,qCAAqC;QAErC,MAAM8B,yBAAyB,GAAGjF,YAAYb,QAAQ+F,mBAAmB,EAAE;QAE3E,IAAItF,cAAc,UAAU;YAC1B,2FAA2F;YAC3F,MAAMuF,6BAA6B1C,YAAY2C,qBAAqB,CAACC,MAAM,CACzE,CAACC,MAAQ,CAAE,CAAA,kBAAkBA,GAAE;YAGjC,UAAMzG,sNAAAA,EAAyB;gBAC7BM;gBACAG;gBACAiG,kBAAkB;gBAClBC,kBAAkB;gBAClBC,UAAUnF,YAAYpB,EAAE;gBACxBwG,gBAAgB;gBAChBC,MAAM;uBAAIvC;uBAAsB+B;iBAA2B;gBAC3DnF,WAAWiF;YACb;QACF;QAEA,IAAI7B,kBAAkBtC,MAAM,GAAG,GAAG;YAChC,MAAM3B,QAAQ4D,MAAM,CAAC;gBACnBzD;gBACAU,WAAWiF;gBACXhC,QAAQG;YACV;QACF;QAEA,qCAAqC;QACrC,uCAAuC;QACvC,qCAAqC;QAErC,IAAIX,YAAYmD,qBAAqB,CAAC9E,MAAM,GAAG,GAAG;YAChD,iFAAiF;YACjF,MAAM+E,wBAAwBpD,YAAYmD,qBAAqB,CAACE,GAAG,CAAC,CAACR;gBACnE,MAAMS,WAAW7G,MAAMoB,YAAYpB,EAAE;gBACrC,MAAMuB,MAA+B;oBACnCyD,QAAQ6B;oBACRlG,MAAMyF,IAAIzF,IAAI;gBAChB;gBAEA,iEAAiE;gBACjE,MAAMmG,oBAAoB7G,QAAQ8G,SAAS,CAAChB,uBAAuB;gBACnE,IAAIK,IAAI3B,MAAM,IAAIqC,qBAAqBA,kBAAkBrE,OAAO,CAACgC,MAAM,EAAE;oBACvElD,IAAIkD,MAAM,GAAG2B,IAAI3B,MAAM;gBACzB;gBAEA,IAAI2B,IAAIY,UAAU,EAAE;oBAClB,6EAA6E;oBAC7EzF,GAAG,CAAC,GAAG6E,IAAIY,UAAU,CAAC,EAAE,CAAC,CAAC,GAAGZ,IAAIa,KAAK;gBACxC;gBAEA,OAAO1F;YACT;YAEA,IAAIoF,sBAAsB/E,MAAM,GAAG,GAAG;gBACpC,iCAAiC;gBACjC,MAAMkF,oBAAoB7G,QAAQkC,MAAM,CAAC4D,uBAAuB;gBAEhE,IAAIe,mBAAmB;oBACrB,0DAA0D;oBAC1D,IAAIH,sBAAsB/E,MAAM,KAAK,GAAG;wBACtC,QAAO,6BAA6B;oBACtC;oBAEA,MAAMsF,aAAaP,sBAAsBC,GAAG,CAAC,CAACrF;wBAC5C,MAAM4F,QAAQ;gCACZ/H,0KAAAA,EAAG0H,kBAAkB9B,MAAM,EAAEzD,IAAIyD,MAAM;gCACvC5F,0KAAAA,EAAG0H,kBAAkBnG,IAAI,EAAEY,IAAIZ,IAAI;yBACpC;wBAED,uBAAuB;wBACvB,IAAIY,IAAIkD,MAAM,KAAKpB,aAAayD,kBAAkBrC,MAAM,EAAE;4BACxD0C,MAAMtC,IAAI,KAACzF,0KAAAA,EAAG0H,kBAAkBrC,MAAM,EAAElD,IAAIkD,MAAM;wBACpD,OAAO,IAAIqC,kBAAkBrC,MAAM,EAAE;4BACnC0C,MAAMtC,IAAI,KAACxF,8KAAAA,EAAOyH,kBAAkBrC,MAAM;wBAC5C;wBAEA,sDAAsD;wBACtD,KAAK,MAAM,CAACb,KAAKqD,MAAM,IAAIvF,OAAOwB,OAAO,CAAC3B,KAAM;4BAC9C,IAAIqC,IAAIwD,QAAQ,CAAC,SAASH,SAAS,MAAM;gCACvC,MAAMjE,SAAS8D,iBAAiB,CAAClD,IAAI;gCACrC,IAAIZ,UAAU,OAAOA,WAAW,UAAU;oCACxCmE,MAAMtC,IAAI,KAACzF,0KAAAA,EAAG4D,QAAQiE;gCACxB;4BACF;wBACF;wBAEA,WAAO/H,2KAAAA,KAAOiI;oBAChB;oBAEA,kEAAkE;oBAClE,IAAIE,eAA0C,EAAE;oBAChD,IAAIC,WAAW;oBAEf,IAAIJ,WAAWtF,MAAM,GAAG,GAAG;wBACzB,mCAAmC;wBACnCyF,eAAe,MAAOjH,GACnBS,MAAM,GACN0G,IAAI,CAACT,mBACL9F,KAAK,KAAC1B,0KAAAA,KAAM4H;oBACjB;oBAEA,mEAAmE;oBACnE,MAAML,WAAW7G,MAAMoB,YAAYpB,EAAE;oBACrC,MAAMwH,iBAAiB,MAAOpH,GAC3BS,MAAM,CAAC;wBAAEyG,UAAUR,kBAAkBW,KAAK;oBAAC,GAC3CF,IAAI,CAACT,mBACL9F,KAAK,KAAC5B,0KAAAA,EAAG0H,kBAAkB9B,MAAM,EAAE6B,WACnCa,OAAO,KAACvI,wKAAAA,EAAK2H,kBAAkBW,KAAK,GACpCE,KAAK,CAAC;oBAET,IAAIH,eAAe5F,MAAM,GAAG,KAAK4F,cAAc,CAAC,EAAE,CAACF,QAAQ,EAAE;wBAC3DA,WAAWE,cAAc,CAAC,EAAE,CAACF,QAAQ;oBACvC;oBAEA,4DAA4D;oBAC5DX,sBAAsBnC,OAAO,CAAC,CAACjD,KAAKqG;wBAClCrG,IAAIkG,KAAK,GAAGH,WAAWM,QAAQ;oBACjC;oBAEA,8CAA8C;oBAC9C,MAAMC,gCAAgClB,sBAAsBR,MAAM,CAAC,CAAC2B;wBAClE,OAAO,CAACT,aAAaU,IAAI,CAAC,CAACC;4BACzB,4CAA4C;4BAC5C,IAAIC,UAAUD,YAAYhD,MAAM,KAAK8C,OAAO9C,MAAM,IAAIgD,YAAYrH,IAAI,KAAKmH,OAAOnH,IAAI;4BAEtF,IAAImH,OAAOrD,MAAM,KAAKpB,WAAW;gCAC/B4E,UAAUA,WAAWD,YAAYvD,MAAM,KAAKqD,OAAOrD,MAAM;4BAC3D;4BAEA,yEAAyE;4BACzE,KAAK,MAAMb,OAAOlC,OAAOC,IAAI,CAACmG,QAAS;gCACrC,IAAIlE,IAAIwD,QAAQ,CAAC,OAAO;oCACtB,2BAA2B;oCAC3Ba,UAAUA,WAAWD,WAAW,CAACpE,IAAI,KAAKkE,MAAM,CAAClE,IAAI;gCACvD;4BACF;4BAEA,OAAOqE;wBACT;oBACF;oBAEA,0CAA0C;oBAC1C,IAAIJ,8BAA8BjG,MAAM,GAAG,GAAG;wBAC5C,MAAM3B,QAAQ4D,MAAM,CAAC;4BACnBzD;4BACAU,WAAWiF;4BACXhC,QAAQ8D;wBACV;oBACF;gBACF;YACF;QACF;QAEA,qCAAqC;QACrC,yCAAyC;QACzC,qCAAqC;QAErC,IAAItE,YAAY2C,qBAAqB,CAAC6B,IAAI,CAAC,CAAC3B,MAAQ,kBAAkBA,MAAM;YAC1E,MAAMU,oBAAoB7G,QAAQkC,MAAM,CAAC4D,uBAAuB;YAEhE,IAAIe,mBAAmB;gBACrB,KAAK,MAAMoB,eAAe3E,YAAY2C,qBAAqB,CAAE;oBAC3D,IAAI,kBAAkBgC,eAAeA,YAAYC,YAAY,EAAE;wBAC7D,MAAMC,OAAOF,YAAYC,YAAY;wBACrC,MAAMtB,WAAY7G,MAAMoB,YAAYpB,EAAE;wBAEtC,MAAMkH,aAAa;gCACjB9H,0KAAAA,EAAG0H,kBAAkB9B,MAAM,EAAE6B;gCAC7BzH,0KAAAA,EAAG0H,kBAAkBnG,IAAI,EAAEuH,YAAYvH,IAAI;yBAC5C;wBAED,sEAAsE;wBACtE,IAAIV,QAAQ8G,SAAS,CAAChB,uBAAuB,EAAEtD,QAAQgC,QAAQ;4BAC7D,IAAIyD,YAAYzD,MAAM,EAAE;gCACtByC,WAAWrC,IAAI,KAACzF,0KAAAA,EAAG0H,kBAAkBrC,MAAM,EAAEyD,YAAYzD,MAAM;4BACjE,OAAO;gCACLyC,WAAWrC,IAAI,KAACxF,8KAAAA,EAAOyH,kBAAkBrC,MAAM;4BACjD;wBACF;wBAEA,6CAA6C;wBAC7C,IAAI,OAAO2D,SAAS,YAAY,gBAAgBA,MAAM;4BACpD,sDAAsD;4BACtD,MAAMC,WAAW,GAAGD,KAAKpB,UAAU,CAAC,EAAE,CAAC;4BACvC,IAAIF,iBAAiB,CAACuB,SAAS,EAAE;gCAC/BnB,WAAWrC,IAAI,KAACzF,0KAAAA,EAAG0H,iBAAiB,CAACuB,SAAS,EAAED,KAAKnB,KAAK;4BAC5D;wBACF,OAAO,IAAIiB,YAAYlB,UAAU,EAAE;4BACjC,iDAAiD;4BACjD,MAAMqB,WAAW,GAAGH,YAAYlB,UAAU,CAAC,EAAE,CAAC;4BAC9C,IAAIF,iBAAiB,CAACuB,SAAS,EAAE;gCAC/BnB,WAAWrC,IAAI,KAACzF,0KAAAA,EAAG0H,iBAAiB,CAACuB,SAAS,EAAED;4BAClD;wBACF;wBAEA,6CAA6C;wBAC7C,MAAMnI,QAAQ6F,WAAW,CAAC;4BACxB1F;4BACAU,WAAWiF;4BACX/E,WAAO9B,2KAAAA,KAAOgI;wBAChB;oBACF;gBACF;YACF;QACF;QAEA,qCAAqC;QACrC,uBAAuB;QACvB,qCAAqC;QAErC,MAAMoB,iBAAiB,GAAGxH,UAAU,MAAM,CAAC;QAE3C,IAAIJ,cAAc,UAAU;YAC1B,UAAMf,sNAAAA,EAAyB;gBAC7BM;gBACAG;gBACAiG,kBAAkB;gBAClBC,kBAAkB;gBAClBC,UAAUnF,YAAYpB,EAAE;gBACxBwG,gBAAgB;gBAChBC,MAAM;uBAAItC;uBAAkBZ,YAAYgF,aAAa;iBAAC;gBACtDzH,WAAWwH;YACb;QACF;QAEA,IAAInE,cAAcvC,MAAM,GAAG,GAAG;YAC5B,MAAM3B,QAAQ4D,MAAM,CAAC;gBACnBzD;gBACAU,WAAWwH;gBACXvE,QAAQI;YACV;QACF;QAEA,qCAAqC;QACrC,yBAAyB;QACzB,qCAAqC;QAErC,MAAMqE,mBAAmB,GAAG1H,UAAU,QAAQ,CAAC;QAE/C,IAAIJ,cAAc,UAAU;YAC1B,UAAMf,sNAAAA,EAAyB;gBAC7BM;gBACAG;gBACAiG,kBAAkB;gBAClBC,kBAAkB;gBAClBC,UAAUnF,YAAYpB,EAAE;gBACxBwG,gBAAgB;gBAChBC,MAAM;uBAAIrC;uBAAoBb,YAAYkF,eAAe;iBAAC;gBAC1D3H,WAAW0H;YACb;QACF;QAEA,IAAIpE,gBAAgBxC,MAAM,GAAG,GAAG;YAC9B,MAAM3B,QAAQ4D,MAAM,CAAC;gBACnBzD;gBACAU,WAAW0H;gBACXzE,QAAQK;YACV;QACF;QAEA,qCAAqC;QACrC,gBAAgB;QAChB,qCAAqC;QAErC,MAAMsE,oBAA+D,CAAC;QAEtE,IAAIhI,cAAc,UAAU;YAC1B,KAAK,MAAMI,aAAayC,YAAYoF,cAAc,CAAE;gBAClD,MAAMC,aAAa3I,QAAQkC,MAAM,CAACrB,UAAU;gBAC5C,MAAMb,QAAQ6F,WAAW,CAAC;oBACxB1F;oBACAU;oBACAE,WAAO5B,0KAAAA,EAAGwJ,WAAWjE,SAAS,EAAEvD,YAAYpB,EAAE;gBAChD;YACF;QACF;QAEA,+MAA+M;QAC/M,MAAM6I,sBAAuD,CAAC;QAE9D,KAAK,MAAM,CAAC/H,WAAWgI,UAAU,IAAIpH,OAAOwB,OAAO,CAACmB,gBAAiB;YACnEqE,iBAAiB,CAAC5H,UAAU,GAAG,MAAMb,QAAQ4D,MAAM,CAAC;gBAClDzD;gBACAU;gBACAiD,QAAQ+E,UAAUlC,GAAG,CAAC,CAAC,EAAErF,GAAG,EAAE,GAAKA;YACrC;YAEAmH,iBAAiB,CAAC5H,UAAU,CAAC0D,OAAO,CAAC,CAACjD,KAAKwH;gBACzCD,SAAS,CAACC,EAAE,CAACxH,GAAG,GAAGA;gBACnB,IACE,OAAOA,IAAIyH,KAAK,KAAK,YACpB,CAAA,OAAOzH,IAAIvB,EAAE,KAAK,YAAY,OAAOuB,IAAIvB,EAAE,KAAK,QAAO,GACxD;oBACA6I,mBAAmB,CAACtH,IAAIyH,KAAK,CAAC,GAAGzH,IAAIvB,EAAE;gBACzC;YACF;YAEA,MAAMiJ,sBAAgC,EAAE;YAExC,MAAMC,0BAA0BJ,UAAUK,MAAM,CAAC,CAACC,KAAK3D,UAAUsD;gBAC/D,IAAIrH,OAAOwB,OAAO,CAACuC,SAASlB,OAAO,EAAE3C,MAAM,GAAG,GAAG;oBAC/CF,OAAOwB,OAAO,CAACuC,SAASlB,OAAO,EAAEC,OAAO,CAAC,CAAC,CAAC6E,aAAaC,gBAAgB;wBACtE,IAAI5H,OAAOC,IAAI,CAAC2H,iBAAiB1H,MAAM,GAAG,GAAG;4BAC3C0H,gBAAgB3E,SAAS,GAAGc,SAASlE,GAAG,CAACvB,EAAE;4BAC3CsJ,gBAAgB1E,OAAO,GAAGyE;4BAC1BD,IAAIvE,IAAI,CAACyE;4BACTL,oBAAoBpE,IAAI,CAACkE;wBAC3B;oBACF;gBACF;gBAEA,OAAOK;YACT,GAAG,EAAE;YAEL,IAAIF,wBAAwBtH,MAAM,GAAG,GAAG;gBACtC,MAAM3B,QAAQ4D,MAAM,CAAC;oBACnBzD;oBACAU,WAAW,GAAGA,YAAYb,QAAQ2F,aAAa,EAAE;oBACjD7B,QAAQmF;gBACV;YACF;YAEA,UAAMrJ,8LAAAA,EAAa;gBACjBI;gBACA4B,QAAQiH,UAAUlC,GAAG,CAAC,CAAC,EAAE/E,MAAM,EAAE,GAAKA;gBACtCzB;gBACA0B,YAAY4G,iBAAiB,CAAC5H,UAAU;gBACxCiB,SAAS8G;YACX;QACF;QAEA,qCAAqC;QACrC,4BAA4B;QAC5B,qCAAqC;QAErC,IAAInI,cAAc,UAAU;YAC1B,KAAK,MAAM6I,kBAAkB7H,OAAOC,IAAI,CAAC4B,YAAY1B,MAAM,EAAG;gBAC5D,UAAMnC,oNAAAA,EAAwB;oBAC5BO;oBACAG;oBACAmG,UAAUnF,YAAYpB,EAAE;oBACxBc,WAAWyI;gBACb;YACF;QACF;QAEA,UAAM1J,8LAAAA,EAAa;YACjBI;YACA4B,QAAQ;gBAAC0B,YAAY1B,MAAM;gBAAE0B,YAAY/B,YAAY;aAAC;YACtDpB;YACA0B,YAAY;gBAACV;gBAAaA;aAAY;YACtCW,SAAS8G;QACX;QAEA,qCAAqC;QACrC,yBAAyB;QACzB,qCAAqC;QAErC,KAAK,MAAM,CAACvD,iBAAiBkE,UAAU,IAAI9H,OAAOwB,OAAO,CAACoB,iBAAkB;YAC1E,MAAMmF,cAAcxJ,QAAQkC,MAAM,CAACmD,gBAAgB;YACnD,IAAI5E,cAAc,UAAU;gBAC1B,MAAMT,QAAQ6F,WAAW,CAAC;oBACxB1F;oBACAU,WAAWwE;oBACXtE,WAAO5B,0KAAAA,EAAGqK,YAAYzE,MAAM,EAAE5D,YAAYpB,EAAE;gBAC9C;YACF;YAEA,IAAI0B,OAAOC,IAAI,CAACkH,qBAAqBjH,MAAM,GAAG,GAAG;gBAC/C4H,UAAUhF,OAAO,CAAC,CAACjD;oBACjB,IAAIA,IAAIyD,MAAM,IAAI6D,qBAAqB;wBACrCtH,IAAIyD,MAAM,GAAG6D,mBAAmB,CAACtH,IAAIyD,MAAM,CAAC;oBAC9C;gBACF;YACF;YAEA,IAAIwE,UAAU5H,MAAM,EAAE;gBACpB,MAAM3B,QAAQ4D,MAAM,CAAC;oBACnBzD;oBACAU,WAAWwE;oBACXvB,QAAQyF;gBACV;YACF;QACF;IACF,EAAE,OAAOlG,OAAO;YACd1D,wMAAAA,EAAkB;YAAEI;YAAIC;YAASC;YAAgBoD;YAAOhD;YAAYM;YAAKE;QAAU;IACrF;IAEA,IAAIP,iBAAiB,UAAU;QAC7B,OAAO;YAAEP,IAAIoB,YAAYpB,EAAE;QAAC;IAC9B;IAEA,IAAIO,cAAc;QAChB,OAAOJ;IACT;IAEA,qCAAqC;IACrC,6BAA6B;IAC7B,qCAAqC;IAErC,MAAMkC,mBAAe9C,mMAAAA,EAAkB;QACrCU;QACAqC,OAAO;QACPjC;QACAG,WAAW;QACXK;QACAC;IACF;IAEAuB,aAAarB,KAAK,OAAG5B,0KAAAA,EAAGa,QAAQkC,MAAM,CAACrB,UAAU,CAACd,EAAE,EAAEoB,YAAYpB,EAAE;IAEpE,MAAM0C,MAAM,MAAMtC,GAAGuC,KAAK,CAAC7B,UAAU,CAAC8B,SAAS,CAACP;IAEhD,qCAAqC;IACrC,iBAAiB;IACjB,qCAAqC;IAErC,MAAMqH,aAASlK,4LAAAA,EAAa;QAC1BS;QACA4C,QAAQ5C,QAAQ6C,OAAO,CAACD,MAAM;QAC9B1C,MAAMuC;QACNrC;QACAG,WAAW;QACXM;IACF;IAEA,OAAO4I;AACT,EAAC"}},
    {"offset": {"line": 5817, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/create.ts"],"sourcesContent":["import type { Create } from 'payload'\n\nimport toSnakeCase from 'to-snake-case'\n\nimport type { DrizzleAdapter } from './types.js'\n\nimport { upsertRow } from './upsertRow/index.js'\nimport { getTransaction } from './utilities/getTransaction.js'\n\nexport const create: Create = async function create(\n  this: DrizzleAdapter,\n  { collection: collectionSlug, data, req, returning, select },\n) {\n  const collection = this.payload.collections[collectionSlug].config\n\n  const tableName = this.tableNameMap.get(toSnakeCase(collection.slug))\n\n  const db = await getTransaction(this, req)\n\n  const result = await upsertRow({\n    adapter: this,\n    collectionSlug,\n    data,\n    db,\n    fields: collection.flattenedFields,\n    ignoreResult: returning === false,\n    operation: 'create',\n    req,\n    select,\n    tableName,\n  })\n\n  if (returning === false) {\n    return null\n  }\n\n  return result\n}\n"],"names":["toSnakeCase","upsertRow","getTransaction","create","collection","collectionSlug","data","req","returning","select","payload","collections","config","tableName","tableNameMap","get","slug","db","result","adapter","fields","flattenedFields","ignoreResult","operation"],"mappings":";;;;AAEA,OAAOA,iBAAiB,gBAAe;AAIvC,SAASC,SAAS,QAAQ,uBAAsB;AAChD,SAASC,cAAc,QAAQ,gCAA+B;;;;AAEvD,MAAMC,SAAiB,eAAeA,OAE3C,EAAEC,YAAYC,cAAc,EAAEC,IAAI,EAAEC,GAAG,EAAEC,SAAS,EAAEC,MAAM,EAAE;IAE5D,MAAML,aAAa,IAAI,CAACM,OAAO,CAACC,WAAW,CAACN,eAAe,CAACO,MAAM;IAElE,MAAMC,YAAY,IAAI,CAACC,YAAY,CAACC,GAAG,KAACf,yJAAAA,EAAYI,WAAWY,IAAI;IAEnE,MAAMC,KAAK,UAAMf,kMAAAA,EAAe,IAAI,EAAEK;IAEtC,MAAMW,SAAS,UAAMjB,oLAAAA,EAAU;QAC7BkB,SAAS,IAAI;QACbd;QACAC;QACAW;QACAG,QAAQhB,WAAWiB,eAAe;QAClCC,cAAcd,cAAc;QAC5Be,WAAW;QACXhB;QACAE;QACAI;IACF;IAEA,IAAIL,cAAc,OAAO;QACvB,OAAO;IACT;IAEA,OAAOU;AACT,EAAC"}},
    {"offset": {"line": 5852, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/utilities/blocksToJsonMigrator.ts"],"sourcesContent":["import type {\n  DynamicMigrationTemplate,\n  FlattenedField,\n  Payload,\n  PayloadRequest,\n  SanitizedConfig,\n} from 'payload'\n\nimport { existsSync, mkdirSync, readdirSync, readFileSync, rmSync, writeFileSync } from 'fs'\nimport path from 'path'\nimport {\n  APIError,\n  buildVersionCollectionFields,\n  buildVersionGlobalFields,\n  dynamicImport,\n} from 'payload'\nimport { findConfig } from 'payload/node'\nimport { fieldShouldBeLocalized } from 'payload/shared'\nimport * as ts from 'typescript'\n\nimport type {\n  BlocksToJsonBlockToMigrate,\n  BlocksToJsonEntityToMigrate,\n  BlocksToJsonMigrator,\n  DrizzleAdapter,\n} from '../types.js'\n\nimport { getTransaction } from './getTransaction.js'\n\nconst DEFAULT_BATCH_SIZE = 100\nconst TEMP_FOLDER_NAME = '.payload-blocks-migration'\n\nconst writeEntitiesToTempFile = (\n  entities: BlocksToJsonEntityToMigrate[],\n  tempFolderPath: string,\n  batchIndex: number,\n): void => {\n  const filePath = path.join(tempFolderPath, `entities-batch-${batchIndex}.json`)\n  writeFileSync(filePath, JSON.stringify(entities, null, 2), 'utf-8')\n}\n\nconst acceptDrizzlePrompts = async <T>(\n  callPrompt: () => Promise<T> | T,\n  {\n    silenceLogs = false,\n  }: {\n    silenceLogs?: boolean\n  } = {},\n): Promise<T> => {\n  // eslint-disable-next-line @typescript-eslint/unbound-method\n  const write = process.stdout.write\n\n  if (silenceLogs) {\n    process.stdout.write = () => true\n  }\n\n  const promise = callPrompt()\n\n  const interval = setInterval(\n    () =>\n      process.stdin.emit('keypress', '\\n', {\n        name: 'return',\n        ctrl: false,\n      }),\n    25,\n  )\n\n  const res = await promise\n\n  if (silenceLogs) {\n    process.stdout.write = write\n  }\n\n  clearInterval(interval)\n\n  return res\n}\n\nconst entityHasBlocksField = (entity: { flattenedFields: FlattenedField[] }): boolean => {\n  for (const field of entity.flattenedFields) {\n    if (field.type === 'blocks') {\n      return true\n    }\n\n    if (\n      'flattenedFields' in field &&\n      entityHasBlocksField({ flattenedFields: field.flattenedFields })\n    ) {\n      return true\n    }\n  }\n\n  return false\n}\n\nconst collectBlocksToMigrate = ({\n  config,\n  data,\n  fields,\n  parentAccessor,\n  parentIsLocalized,\n}: {\n  config: SanitizedConfig\n  data: any\n  fields: FlattenedField[]\n  parentAccessor: (number | string)[]\n  parentIsLocalized: boolean\n}): BlocksToJsonBlockToMigrate[] => {\n  const result: BlocksToJsonBlockToMigrate[] = []\n\n  for (const field of fields) {\n    switch (field.type) {\n      case 'array': {\n        const arrayData = data[field.name]\n\n        if (!Array.isArray(arrayData)) {\n          continue\n        }\n\n        if (config.localization && fieldShouldBeLocalized({ field, parentIsLocalized })) {\n          result.push(\n            ...collectBlocksToMigrate({\n              config,\n              data: arrayData,\n              fields: config.localization.localeCodes.map((code) => ({\n                ...field,\n                name: code,\n                localized: false,\n              })),\n              parentAccessor: [...parentAccessor, field.name],\n              parentIsLocalized: true,\n            }),\n          )\n\n          continue\n        }\n\n        for (const [index, row] of arrayData.entries()) {\n          result.push(\n            ...collectBlocksToMigrate({\n              config,\n              data: row,\n              fields: field.flattenedFields,\n              parentAccessor: [...parentAccessor, field.name, index],\n              parentIsLocalized,\n            }),\n          )\n        }\n        break\n      }\n      case 'blocks': {\n        result.push({\n          data: data[field.name],\n          fieldAccessor: [...parentAccessor, field.name],\n        })\n        break\n      }\n      case 'group':\n      case 'tab': {\n        if (config.localization && fieldShouldBeLocalized({ field, parentIsLocalized })) {\n          result.push(\n            ...collectBlocksToMigrate({\n              config,\n              data: data[field.name],\n              fields: config.localization.localeCodes.map((code) => ({\n                ...field,\n                name: code,\n                localized: false,\n              })),\n              parentAccessor: [...parentAccessor, field.name],\n              parentIsLocalized: true,\n            }),\n          )\n\n          continue\n        }\n\n        result.push(\n          ...collectBlocksToMigrate({\n            config,\n            data: data[field.name],\n            fields: field.flattenedFields,\n            parentAccessor: [...parentAccessor, field.name],\n            parentIsLocalized,\n          }),\n        )\n        break\n      }\n      default: {\n        continue\n      }\n    }\n  }\n\n  return result\n}\n\nclass BlocksToJsonMigratorImpl implements BlocksToJsonMigrator {\n  private readonly batchSize: number\n  private tempFolderPath: string\n\n  constructor(\n    private readonly adapter: DrizzleAdapter,\n    private readonly sanitizeStatements: (args: {\n      sqlExecute: string\n      statements: string[]\n    }) => string,\n    private readonly executeMethod: string,\n    batchSize?: number,\n  ) {\n    this.batchSize = batchSize || DEFAULT_BATCH_SIZE\n    this.tempFolderPath = path.resolve(this.adapter.migrationDir, TEMP_FOLDER_NAME)\n  }\n\n  private ensureTempFolder(): void {\n    if (!existsSync(this.tempFolderPath)) {\n      mkdirSync(this.tempFolderPath, { recursive: true })\n    }\n  }\n\n  private *fetchEntitiesFromJsonBatches(): IterableIterator<BlocksToJsonEntityToMigrate[]> {\n    if (!existsSync(this.tempFolderPath)) {\n      return\n    }\n\n    const files = readdirSync(this.tempFolderPath)\n      .filter((file) => file.startsWith('entities-batch-') && file.endsWith('.json'))\n      .sort((a, b) => {\n        const aNum = parseInt(a.match(/\\d+/)?.[0] || '0', 10)\n        const bNum = parseInt(b.match(/\\d+/)?.[0] || '0', 10)\n        return aNum - bNum\n      })\n\n    for (const file of files) {\n      const filePath = path.join(this.tempFolderPath, file)\n      const fileContent = readFileSync(filePath, 'utf-8')\n      const batchEntities = JSON.parse(fileContent) as BlocksToJsonEntityToMigrate[]\n      yield batchEntities\n    }\n  }\n\n  private async migrateEntities(\n    entities: BlocksToJsonEntityToMigrate[],\n    req: PayloadRequest,\n  ): Promise<void> {\n    this.adapter.blocksAsJSON = true\n    this.resetSchema()\n    await this.adapter.init()\n    await this.adapter.connect()\n\n    await this.syncTransactionDrizzleInstance(req)\n\n    const totalEntities = entities.length\n    let processed = 0\n\n    for (const entity of entities) {\n      switch (entity.type) {\n        case 'collection': {\n          await this.adapter.updateOne({\n            collection: entity.slug,\n            data: entity.originalData,\n            joins: false,\n            req,\n            where: {\n              id: {\n                equals: entity.id,\n              },\n            },\n          })\n          break\n        }\n        case 'collectionVersion': {\n          await this.adapter.updateVersion({\n            id: entity.id,\n            collection: entity.slug,\n            req,\n            versionData: entity.originalData as any,\n          })\n\n          break\n        }\n        case 'global': {\n          await this.adapter.updateGlobal({\n            slug: entity.slug,\n            data: entity.originalData,\n            req,\n          })\n          break\n        }\n        case 'globalVersion': {\n          await this.adapter.updateGlobalVersion({\n            id: entity.id,\n            global: entity.slug,\n            req,\n            versionData: entity.originalData as any,\n          })\n          break\n        }\n      }\n\n      processed++\n      if (processed % this.batchSize === 0 || processed === totalEntities) {\n        this.adapter.payload.logger.info(\n          `Migrated ${processed}/${totalEntities} entities (${Math.round((processed / totalEntities) * 100)}%)`,\n        )\n      }\n    }\n  }\n\n  private resetSchema() {\n    this.adapter.schema = {}\n    this.adapter.tables = {}\n    this.adapter.indexes = new Set()\n    this.adapter.foreignKeys = new Set()\n    this.adapter.relations = {}\n    this.adapter.rawTables = {}\n    this.adapter.rawRelations = {}\n    this.adapter.tableNameMap = new Map()\n    this.adapter.enums = {}\n  }\n\n  private async syncTransactionDrizzleInstance(req: PayloadRequest) {\n    const tsx = (await getTransaction(this.adapter, req)) as any\n\n    tsx._ = this.adapter.drizzle._\n    tsx.schema = this.adapter.drizzle._\n    tsx.session.schema = (this.adapter.drizzle as any).session.schema\n  }\n\n  cleanupTempFolder(): void {\n    rmSync(this.tempFolderPath, { force: true, recursive: true })\n\n    this.adapter.payload.logger.info(`Cleaned up temp folder at ${this.tempFolderPath}`)\n  }\n\n  async collectAndSaveEntitiesToBatches(\n    req: PayloadRequest,\n    options?: {\n      batchSize?: number\n    },\n  ): Promise<void> {\n    const batchSize = options?.batchSize ?? this.batchSize\n\n    this.cleanupTempFolder()\n    this.ensureTempFolder()\n\n    this.adapter.blocksAsJSON = false\n    this.resetSchema()\n    await this.adapter.init()\n    await this.adapter.connect()\n\n    // Count total entities to migrate\n    let totalExpected = 0\n    for (const collection of this.adapter.payload.config.collections.filter(entityHasBlocksField)) {\n      const { totalDocs } = await this.adapter.count({ collection: collection.slug })\n      totalExpected += totalDocs\n\n      if (collection.versions) {\n        const { totalDocs: totalVersions } = await this.adapter.countVersions({\n          collection: collection.slug,\n        })\n        totalExpected += totalVersions\n      }\n    }\n\n    for (const globalConfig of this.adapter.payload.config.globals.filter(entityHasBlocksField)) {\n      totalExpected += 1 // Global itself\n\n      if (globalConfig.versions) {\n        const { totalDocs: totalGlobalVersions } = await this.adapter.countGlobalVersions({\n          global: globalConfig.slug,\n        })\n        totalExpected += totalGlobalVersions\n      }\n    }\n\n    this.adapter.payload.logger.info(\n      `Found ${totalExpected} total entities to collect and save to batches`,\n    )\n\n    let batchIndex = 0\n    let currentBatch: BlocksToJsonEntityToMigrate[] = []\n    let totalCollected = 0\n\n    const flushBatch = () => {\n      if (currentBatch.length > 0) {\n        writeEntitiesToTempFile(currentBatch, this.tempFolderPath, batchIndex)\n        const percentage =\n          totalExpected > 0 ? Math.round((totalCollected / totalExpected) * 100) : 0\n        this.adapter.payload.logger.info(\n          `Saved batch ${batchIndex} with ${currentBatch.length} entities (${totalCollected}/${totalExpected} - ${percentage}%)`,\n        )\n        batchIndex++\n        currentBatch = []\n      }\n    }\n\n    const addEntity = (entity: BlocksToJsonEntityToMigrate) => {\n      currentBatch.push(entity)\n      totalCollected++\n      if (currentBatch.length >= batchSize) {\n        flushBatch()\n      }\n    }\n\n    for (const collection of this.adapter.payload.config.collections.filter(entityHasBlocksField)) {\n      let page = 1\n      let hasMore = true\n\n      while (hasMore) {\n        const { docs, hasNextPage } = await this.adapter.find({\n          collection: collection.slug,\n          limit: batchSize,\n          page,\n        })\n\n        for (const doc of docs) {\n          const entity: BlocksToJsonEntityToMigrate = {\n            id: doc.id,\n            slug: collection.slug,\n            type: 'collection',\n            blocks: collectBlocksToMigrate({\n              config: this.adapter.payload.config,\n              data: doc,\n              fields: collection.flattenedFields,\n              parentAccessor: [],\n              parentIsLocalized: false,\n            }),\n            originalData: doc,\n          }\n\n          addEntity(entity)\n        }\n\n        this.adapter.payload.logger.info(\n          `Collected ${docs.length} entries from ${collection.slug} (page ${page})`,\n        )\n\n        hasMore = hasNextPage\n        page++\n      }\n\n      if (collection.versions) {\n        let versionPage = 1\n        let hasMoreVersions = true\n\n        while (hasMoreVersions) {\n          const { docs: versionDocs, hasNextPage: hasNextVersionPage } =\n            await this.adapter.findVersions({\n              collection: collection.slug,\n              limit: batchSize,\n              page: versionPage,\n            })\n\n          for (const versionDoc of versionDocs) {\n            const entity: BlocksToJsonEntityToMigrate = {\n              id: versionDoc.id,\n              slug: collection.slug,\n              type: 'collectionVersion',\n              blocks: collectBlocksToMigrate({\n                config: this.adapter.payload.config,\n                data: versionDoc,\n                fields: buildVersionCollectionFields(this.adapter.payload.config, collection, true),\n                parentAccessor: [],\n                parentIsLocalized: false,\n              }),\n              originalData: versionDoc,\n            }\n\n            addEntity(entity)\n          }\n\n          this.adapter.payload.logger.info(\n            `Collected ${versionDocs.length} versions from ${collection.slug} (page ${versionPage})`,\n          )\n\n          hasMoreVersions = hasNextVersionPage\n          versionPage++\n        }\n      }\n    }\n\n    for (const globalConfig of this.adapter.payload.config.globals.filter(entityHasBlocksField)) {\n      const globalDoc = await this.adapter.findGlobal({ slug: globalConfig.slug })\n\n      const entity: BlocksToJsonEntityToMigrate = {\n        slug: globalConfig.slug,\n        type: 'global',\n        blocks: collectBlocksToMigrate({\n          config: this.adapter.payload.config,\n          data: globalDoc,\n          fields: globalConfig.flattenedFields,\n          parentAccessor: [],\n          parentIsLocalized: false,\n        }),\n        originalData: globalDoc,\n      }\n\n      addEntity(entity)\n      this.adapter.payload.logger.info(`Collected global ${globalConfig.slug}`)\n\n      if (globalConfig.versions) {\n        let globalVersionPage = 1\n        let hasMoreGlobalVersions = true\n\n        while (hasMoreGlobalVersions) {\n          const { docs: globalVersionDocs, hasNextPage: hasNextGlobalVersionPage } =\n            await this.adapter.findGlobalVersions({\n              global: globalConfig.slug,\n              limit: batchSize,\n              page: globalVersionPage,\n            })\n\n          for (const globalVersionDoc of globalVersionDocs) {\n            const entity: BlocksToJsonEntityToMigrate = {\n              id: globalVersionDoc.id,\n              slug: globalConfig.slug,\n              type: 'globalVersion',\n              blocks: collectBlocksToMigrate({\n                config: this.adapter.payload.config,\n                data: globalVersionDoc,\n                fields: buildVersionGlobalFields(this.adapter.payload.config, globalConfig, true),\n                parentAccessor: [],\n                parentIsLocalized: false,\n              }),\n              originalData: globalVersionDoc,\n            }\n\n            addEntity(entity)\n          }\n\n          this.adapter.payload.logger.info(\n            `Collected ${globalVersionDocs.length} versions from global ${globalConfig.slug} (page ${globalVersionPage})`,\n          )\n\n          hasMoreGlobalVersions = hasNextGlobalVersionPage\n          globalVersionPage++\n        }\n      }\n    }\n\n    flushBatch()\n\n    this.adapter.payload.logger.info(\n      `Collected total of ${totalCollected} entities across ${batchIndex} batches`,\n    )\n  }\n\n  async getMigrationStatements(): Promise<{\n    statements: string\n    writeDrizzleSnapshot(filePath: string): void\n  }> {\n    const { generateDrizzleJson, generateMigration } = this.adapter.requireDrizzleKit()\n\n    const drizzleJsonBefore = await generateDrizzleJson(this.adapter.schema)\n    this.adapter.blocksAsJSON = true\n    this.resetSchema()\n\n    await this.adapter.init()\n    const drizzleJsonAfter = await generateDrizzleJson(this.adapter.schema)\n    this.adapter.blocksAsJSON = false\n    this.resetSchema()\n    await this.adapter.init()\n\n    const statements = await acceptDrizzlePrompts(\n      () => generateMigration(drizzleJsonBefore, drizzleJsonAfter),\n      {\n        silenceLogs: true,\n      },\n    )\n\n    const sqlExecute = `await db.${this.executeMethod}(` + 'sql`'\n\n    return {\n      statements: this.sanitizeStatements({\n        sqlExecute,\n        statements,\n      }),\n      writeDrizzleSnapshot(filePath) {\n        writeFileSync(`${filePath}.json`, JSON.stringify(drizzleJsonAfter, null, 2))\n      },\n    }\n  }\n\n  async migrateEntitiesFromTempFolder(\n    req: PayloadRequest,\n    options?: {\n      clearBatches?: boolean\n    },\n  ): Promise<void> {\n    const clearBatches = options?.clearBatches ?? true\n\n    let totalEntities = 0\n    let hasEntities = false\n\n    for (const entities of this.fetchEntitiesFromJsonBatches()) {\n      hasEntities = true\n      totalEntities += entities.length\n\n      this.adapter.payload.logger.info(\n        `Migrating batch with ${entities.length} entities (total: ${totalEntities})`,\n      )\n\n      await this.migrateEntities(entities, req)\n    }\n\n    if (!hasEntities) {\n      this.adapter.payload.logger.warn('No entities found in temp folder to migrate')\n      return\n    }\n\n    this.adapter.payload.logger.info(\n      `Completed migration of ${totalEntities} entities from temp folder`,\n    )\n\n    if (clearBatches) {\n      this.cleanupTempFolder()\n    } else {\n      this.adapter.payload.logger.info(\n        `Temp folder preserved at ${this.tempFolderPath} (clearBatches: false)`,\n      )\n    }\n  }\n\n  setTempFolder(tempFolderPath: string): void {\n    this.tempFolderPath = tempFolderPath\n  }\n\n  async updatePayloadConfigFile(): Promise<void> {\n    let configPath: string\n\n    try {\n      configPath = findConfig()\n    } catch {\n      this.adapter.payload.logger.info(\n        'updatePayloadConfigFile failed - could not find the payload config. Please set the blocksAsJSON DB adapter property manually to \"true\"',\n      )\n      return\n    }\n\n    const configFile = readFileSync(configPath, 'utf-8')\n\n    const source = ts.createSourceFile(configPath, configFile, ts.ScriptTarget.ESNext)\n\n    let hadChanges = false\n\n    const result = ts.transform(source, [\n      (ctx) => (sourceFile) => {\n        const factory = ctx.factory\n\n        const visit: ts.Visitor = (node) => {\n          if (\n            ts.isPropertyAssignment(node) &&\n            ts.isIdentifier(node.name) &&\n            node.name.text === 'db' &&\n            ts.isCallExpression(node.initializer) &&\n            node.initializer.arguments.length > 0 &&\n            ts.isObjectLiteralExpression(node.initializer.arguments[0])\n          ) {\n            const call = node.initializer\n            const obj = node.initializer.arguments[0]\n\n            const filteredProps = obj.properties.filter((prop) => {\n              if (!ts.isPropertyAssignment(prop)) {\n                return true\n              }\n\n              return !(ts.isIdentifier(prop.name) && prop.name.text === 'blocksAsJSON')\n            })\n\n            const newProperty = factory.createPropertyAssignment(\n              'blocksAsJSON',\n              factory.createTrue(),\n            )\n            hadChanges = true\n            const newObject = factory.updateObjectLiteralExpression(obj, [\n              ...filteredProps,\n              newProperty,\n            ])\n\n            const newCall = factory.updateCallExpression(\n              call,\n              call.expression,\n              call.typeArguments,\n              [newObject],\n            )\n\n            return factory.updatePropertyAssignment(node, node.name, newCall)\n          }\n\n          return ts.visitEachChild(node, visit, ctx)\n        }\n\n        return ts.visitNode(sourceFile, visit) as ts.SourceFile\n      },\n    ])\n\n    if (!hadChanges) {\n      this.adapter.payload.logger.info(\n        'No changes made to payload config. Set blocksAsJSON to true manually.',\n      )\n      return\n    }\n\n    const printer = ts.createPrinter({ newLine: ts.NewLineKind.LineFeed })\n    let output = printer.printFile(result.transformed[0])\n\n    try {\n      // eslint-disable-next-line @typescript-eslint/consistent-type-imports\n      const prettier = await dynamicImport<typeof import('prettier')>('prettier')\n      const configPath = await prettier.resolveConfigFile()\n      const config = configPath ? await prettier.resolveConfig(configPath) : {}\n      output = await prettier.format(output, { ...config, parser: 'typescript' })\n    } catch (err) {\n      this.adapter.payload.logger.error({\n        err,\n        msg: 'Could not format payload config with Prettier',\n      })\n    }\n\n    writeFileSync(configPath, output, 'utf-8')\n    this.adapter.payload.logger.info(`Updated ${configPath} with blocksAsJSON: true`)\n  }\n}\n\nexport const createBlocksToJsonMigrator = ({\n  adapter,\n  executeMethod,\n  sanitizeStatements,\n}: {\n  adapter: DrizzleAdapter\n  executeMethod: string\n  sanitizeStatements: (args: { sqlExecute: string; statements: string[] }) => string\n}): BlocksToJsonMigrator => {\n  return new BlocksToJsonMigratorImpl(adapter, sanitizeStatements, executeMethod)\n}\n\nexport const getBlocksToJsonMigrator = (payload: Payload): BlocksToJsonMigrator => {\n  const migrator = (payload.db as DrizzleAdapter).blocksToJsonMigrator\n\n  if (!migrator) {\n    throw new APIError(`blocksToJsonMigrator is not defined for ${payload.db.packageName}`)\n  }\n\n  return migrator\n}\n\nexport const buildDynamicPredefinedBlocksToJsonMigration = ({\n  packageName,\n}: {\n  packageName: string\n}): DynamicMigrationTemplate => {\n  return async ({ filePath, payload }) => {\n    const migrator = getBlocksToJsonMigrator(payload)\n\n    const migrationStatements = await migrator.getMigrationStatements()\n\n    migrationStatements.writeDrizzleSnapshot(filePath)\n\n    await migrator.updatePayloadConfigFile()\n    const upSQL = `\nconst migrator = getBlocksToJsonMigrator(payload)\nmigrator.setTempFolder(TEMP_FOLDER)\nawait migrator.collectAndSaveEntitiesToBatches(req, { batchSize: BATCH_SIZE })\n\n${migrationStatements.statements}\npayload.logger.info(\"Executed blocks to JSON migration statements.\")\n\nawait migrator.migrateEntitiesFromTempFolder(req, { clearBatches: true })\n  `\n\n    return {\n      imports: `\nimport { getBlocksToJsonMigrator } from '${packageName}/migration-utils'\nimport { fileURLToPath } from 'url'\nimport path from 'path'\n\nconst filename = fileURLToPath(import.meta.url)\nconst dirname = path.dirname(filename)\n\n// Configure migration options (optional)\nconst BATCH_SIZE = 100 // Number of entities to process per batch\nconst TEMP_FOLDER = path.resolve(dirname, '${TEMP_FOLDER_NAME}') // Folder path to store migration batch\n`,\n      upSQL,\n    }\n  }\n}\n"],"names":["existsSync","mkdirSync","readdirSync","readFileSync","rmSync","writeFileSync","path","APIError","buildVersionCollectionFields","buildVersionGlobalFields","dynamicImport","findConfig","fieldShouldBeLocalized","ts","getTransaction","DEFAULT_BATCH_SIZE","TEMP_FOLDER_NAME","writeEntitiesToTempFile","entities","tempFolderPath","batchIndex","filePath","join","JSON","stringify","acceptDrizzlePrompts","callPrompt","silenceLogs","write","process","stdout","promise","interval","setInterval","stdin","emit","name","ctrl","res","clearInterval","entityHasBlocksField","entity","field","flattenedFields","type","collectBlocksToMigrate","config","data","fields","parentAccessor","parentIsLocalized","result","arrayData","Array","isArray","localization","push","localeCodes","map","code","localized","index","row","entries","fieldAccessor","BlocksToJsonMigratorImpl","batchSize","adapter","sanitizeStatements","executeMethod","resolve","migrationDir","ensureTempFolder","recursive","fetchEntitiesFromJsonBatches","files","filter","file","startsWith","endsWith","sort","a","b","aNum","parseInt","match","bNum","fileContent","batchEntities","parse","migrateEntities","req","blocksAsJSON","resetSchema","init","connect","syncTransactionDrizzleInstance","totalEntities","length","processed","updateOne","collection","slug","originalData","joins","where","id","equals","updateVersion","versionData","updateGlobal","updateGlobalVersion","global","payload","logger","info","Math","round","schema","tables","indexes","Set","foreignKeys","relations","rawTables","rawRelations","tableNameMap","Map","enums","tsx","_","drizzle","session","cleanupTempFolder","force","collectAndSaveEntitiesToBatches","options","totalExpected","collections","totalDocs","count","versions","totalVersions","countVersions","globalConfig","globals","totalGlobalVersions","countGlobalVersions","currentBatch","totalCollected","flushBatch","percentage","addEntity","page","hasMore","docs","hasNextPage","find","limit","doc","blocks","versionPage","hasMoreVersions","versionDocs","hasNextVersionPage","findVersions","versionDoc","globalDoc","findGlobal","globalVersionPage","hasMoreGlobalVersions","globalVersionDocs","hasNextGlobalVersionPage","findGlobalVersions","globalVersionDoc","getMigrationStatements","generateDrizzleJson","generateMigration","requireDrizzleKit","drizzleJsonBefore","drizzleJsonAfter","statements","sqlExecute","writeDrizzleSnapshot","migrateEntitiesFromTempFolder","clearBatches","hasEntities","warn","setTempFolder","updatePayloadConfigFile","configPath","configFile","source","createSourceFile","ScriptTarget","ESNext","hadChanges","transform","ctx","sourceFile","factory","visit","node","isPropertyAssignment","isIdentifier","text","isCallExpression","initializer","arguments","isObjectLiteralExpression","call","obj","filteredProps","properties","prop","newProperty","createPropertyAssignment","createTrue","newObject","updateObjectLiteralExpression","newCall","updateCallExpression","expression","typeArguments","updatePropertyAssignment","visitEachChild","visitNode","printer","createPrinter","newLine","NewLineKind","LineFeed","output","printFile","transformed","prettier","resolveConfigFile","resolveConfig","format","parser","err","error","msg","createBlocksToJsonMigrator","getBlocksToJsonMigrator","migrator","db","blocksToJsonMigrator","packageName","buildDynamicPredefinedBlocksToJsonMigration","migrationStatements","upSQL","imports"],"mappings":"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"}},
    {"offset": {"line": 6459, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/createGlobal.ts"],"sourcesContent":["import type { CreateGlobalArgs } from 'payload'\n\nimport toSnakeCase from 'to-snake-case'\n\nimport type { DrizzleAdapter } from './types.js'\n\nimport { upsertRow } from './upsertRow/index.js'\nimport { getTransaction } from './utilities/getTransaction.js'\n\nexport async function createGlobal<T extends Record<string, unknown>>(\n  this: DrizzleAdapter,\n  { slug, data, req, returning }: CreateGlobalArgs,\n): Promise<T> {\n  const globalConfig = this.payload.globals.config.find((config) => config.slug === slug)\n\n  const tableName = this.tableNameMap.get(toSnakeCase(globalConfig.slug))\n\n  data.createdAt = new Date().toISOString()\n\n  const db = await getTransaction(this, req)\n\n  const result = await upsertRow<{ globalType: string } & T>({\n    adapter: this,\n    data,\n    db,\n    fields: globalConfig.flattenedFields,\n    globalSlug: slug,\n    ignoreResult: returning === false,\n    operation: 'create',\n    req,\n    tableName,\n  })\n\n  if (returning === false) {\n    return null\n  }\n\n  result.globalType = slug\n\n  return result\n}\n"],"names":["toSnakeCase","upsertRow","getTransaction","createGlobal","slug","data","req","returning","globalConfig","payload","globals","config","find","tableName","tableNameMap","get","createdAt","Date","toISOString","db","result","adapter","fields","flattenedFields","globalSlug","ignoreResult","operation","globalType"],"mappings":";;;;AAEA,OAAOA,iBAAiB,gBAAe;AAIvC,SAASC,SAAS,QAAQ,uBAAsB;AAChD,SAASC,cAAc,QAAQ,gCAA+B;;;;AAEvD,eAAeC,aAEpB,EAAEC,IAAI,EAAEC,IAAI,EAAEC,GAAG,EAAEC,SAAS,EAAoB;IAEhD,MAAMC,eAAe,IAAI,CAACC,OAAO,CAACC,OAAO,CAACC,MAAM,CAACC,IAAI,CAAC,CAACD,SAAWA,OAAOP,IAAI,KAAKA;IAElF,MAAMS,YAAY,IAAI,CAACC,YAAY,CAACC,GAAG,KAACf,yJAAAA,EAAYQ,aAAaJ,IAAI;IAErEC,KAAKW,SAAS,GAAG,IAAIC,OAAOC,WAAW;IAEvC,MAAMC,KAAK,UAAMjB,kMAAAA,EAAe,IAAI,EAAEI;IAEtC,MAAMc,SAAS,UAAMnB,oLAAAA,EAAsC;QACzDoB,SAAS,IAAI;QACbhB;QACAc;QACAG,QAAQd,aAAae,eAAe;QACpCC,YAAYpB;QACZqB,cAAclB,cAAc;QAC5BmB,WAAW;QACXpB;QACAO;IACF;IAEA,IAAIN,cAAc,OAAO;QACvB,OAAO;IACT;IAEAa,OAAOO,UAAU,GAAGvB;IAEpB,OAAOgB;AACT"}},
    {"offset": {"line": 6495, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/createGlobalVersion.ts"],"sourcesContent":["import type { CreateGlobalVersionArgs, JsonObject, TypeWithVersion } from 'payload'\n\nimport { sql } from 'drizzle-orm'\nimport { buildVersionGlobalFields } from 'payload'\nimport { hasDraftsEnabled } from 'payload/shared'\nimport toSnakeCase from 'to-snake-case'\n\nimport type { DrizzleAdapter } from './types.js'\n\nimport { upsertRow } from './upsertRow/index.js'\nimport { getTransaction } from './utilities/getTransaction.js'\n\nexport async function createGlobalVersion<T extends JsonObject = JsonObject>(\n  this: DrizzleAdapter,\n  {\n    autosave,\n    createdAt,\n    globalSlug,\n    publishedLocale,\n    req,\n    returning,\n    select,\n    snapshot,\n    updatedAt,\n    versionData,\n  }: CreateGlobalVersionArgs,\n): Promise<TypeWithVersion<T>> {\n  const global = this.payload.globals.config.find(({ slug }) => slug === globalSlug)\n\n  const tableName = this.tableNameMap.get(`_${toSnakeCase(global.slug)}${this.versionsSuffix}`)\n\n  const db = await getTransaction(this, req)\n\n  const result = await upsertRow<TypeWithVersion<T>>({\n    adapter: this,\n    data: {\n      autosave,\n      createdAt,\n      latest: true,\n      publishedLocale,\n      snapshot,\n      updatedAt,\n      version: versionData,\n    },\n    db,\n    fields: buildVersionGlobalFields(this.payload.config, global, true),\n    globalSlug,\n    ignoreResult: returning === false ? 'idOnly' : false,\n    operation: 'create',\n    req,\n    select,\n    tableName,\n  })\n\n  const table = this.tables[tableName]\n  if (hasDraftsEnabled(global)) {\n    await this.execute({\n      db,\n      sql: sql`\n          UPDATE ${table}\n          SET latest = false\n          WHERE ${table.id} != ${result.id};\n        `,\n    })\n  }\n\n  if (returning === false) {\n    return null\n  }\n\n  return result\n}\n"],"names":["sql","buildVersionGlobalFields","hasDraftsEnabled","toSnakeCase","upsertRow","getTransaction","createGlobalVersion","autosave","createdAt","globalSlug","publishedLocale","req","returning","select","snapshot","updatedAt","versionData","global","payload","globals","config","find","slug","tableName","tableNameMap","get","versionsSuffix","db","result","adapter","data","latest","version","fields","ignoreResult","operation","table","tables","execute","id"],"mappings":";;;;AAEA,SAASA,GAAG,QAAQ,cAAa;AACjC,SAASC,wBAAwB,QAAQ,UAAS;AAClD,SAASC,gBAAgB,QAAQ,iBAAgB;AACjD,OAAOC,iBAAiB,gBAAe;AAIvC,SAASC,SAAS,QAAQ,uBAAsB;AAChD,SAASC,cAAc,QAAQ,gCAA+B;;;;;;;AAEvD,eAAeC,oBAEpB,EACEC,QAAQ,EACRC,SAAS,EACTC,UAAU,EACVC,eAAe,EACfC,GAAG,EACHC,SAAS,EACTC,MAAM,EACNC,QAAQ,EACRC,SAAS,EACTC,WAAW,EACa;IAE1B,MAAMC,SAAS,IAAI,CAACC,OAAO,CAACC,OAAO,CAACC,MAAM,CAACC,IAAI,CAAC,CAAC,EAAEC,IAAI,EAAE,GAAKA,SAASb;IAEvE,MAAMc,YAAY,IAAI,CAACC,YAAY,CAACC,GAAG,CAAC,CAAC,CAAC,MAAEtB,yJAAAA,EAAYc,OAAOK,IAAI,IAAI,IAAI,CAACI,cAAc,EAAE;IAE5F,MAAMC,KAAK,UAAMtB,kMAAAA,EAAe,IAAI,EAAEM;IAEtC,MAAMiB,SAAS,UAAMxB,oLAAAA,EAA8B;QACjDyB,SAAS,IAAI;QACbC,MAAM;YACJvB;YACAC;YACAuB,QAAQ;YACRrB;YACAI;YACAC;YACAiB,SAAShB;QACX;QACAW;QACAM,YAAQhC,8LAAAA,EAAyB,IAAI,CAACiB,OAAO,CAACE,MAAM,EAAEH,QAAQ;QAC9DR;QACAyB,cAActB,cAAc,QAAQ,WAAW;QAC/CuB,WAAW;QACXxB;QACAE;QACAU;IACF;IAEA,MAAMa,QAAQ,IAAI,CAACC,MAAM,CAACd,UAAU;IACpC,QAAIrB,uLAAAA,EAAiBe,SAAS;QAC5B,MAAM,IAAI,CAACqB,OAAO,CAAC;YACjBX;YACA3B,KAAKA,qJAAG,CAAC;iBACE,EAAEoC,MAAM;;gBAET,EAAEA,MAAMG,EAAE,CAAC,IAAI,EAAEX,OAAOW,EAAE,CAAC;QACnC,CAAC;QACL;IACF;IAEA,IAAI3B,cAAc,OAAO;QACvB,OAAO;IACT;IAEA,OAAOgB;AACT"}},
    {"offset": {"line": 6555, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/utilities/createSchemaGenerator.ts"],"sourcesContent":["import type { GenerateSchema } from 'payload'\n\nimport { existsSync } from 'fs'\nimport { writeFile } from 'fs/promises'\nimport path from 'path'\n\nimport type { ColumnToCodeConverter, DrizzleAdapter } from '../types.js'\n\n/**\n * @example\n * console.log(sanitizeObjectKey(\"oneTwo\"));   // oneTwo\n * console.log(sanitizeObjectKey(\"one-two\"));  // 'one-two'\n * console.log(sanitizeObjectKey(\"_one$Two3\")); // _one$Two3\n * console.log(sanitizeObjectKey(\"3invalid\")); // '3invalid'\n */\nconst sanitizeObjectKey = (key: string) => {\n  // Regular expression for a valid identifier\n  const identifierRegex = /^[a-z_$][\\w$]*$/i\n  if (identifierRegex.test(key)) {\n    return key\n  }\n\n  return `'${key}'`\n}\n\n/**\n * @example\n * (columns default-valuesID) -> columns['default-valuesID']\n * (columns defaultValues) -> columns.defaultValues\n */\nconst accessProperty = (objName: string, key: string) => {\n  const sanitized = sanitizeObjectKey(key)\n\n  if (sanitized.startsWith(\"'\")) {\n    return `${objName}[${sanitized}]`\n  }\n\n  return `${objName}.${key}`\n}\n\nexport const createSchemaGenerator = ({\n  columnToCodeConverter,\n  corePackageSuffix,\n  defaultOutputFile,\n  enumImport,\n  schemaImport,\n  tableImport,\n}: {\n  columnToCodeConverter: ColumnToCodeConverter\n  corePackageSuffix: string\n  defaultOutputFile?: string\n  enumImport?: string\n  schemaImport?: string\n  tableImport: string\n}): GenerateSchema => {\n  return async function generateSchema(\n    this: DrizzleAdapter,\n    { log = true, outputFile = defaultOutputFile, prettify = true } = {},\n  ) {\n    const importDeclarations: Record<string, Set<string>> = {}\n\n    const tableDeclarations: string[] = []\n    const enumDeclarations: string[] = []\n    const relationsDeclarations: string[] = []\n\n    const addImport = (from: string, name: string) => {\n      if (!importDeclarations[from]) {\n        importDeclarations[from] = new Set()\n      }\n\n      importDeclarations[from].add(name)\n    }\n\n    const corePackage = `${this.packageName}/drizzle/${corePackageSuffix}`\n\n    let schemaDeclaration: null | string = null\n\n    if (this.schemaName) {\n      addImport(corePackage, schemaImport)\n      schemaDeclaration = `export const db_schema = ${schemaImport}('${this.schemaName}')`\n    }\n\n    const enumFn = this.schemaName ? `db_schema.enum` : enumImport\n\n    const enumsList: string[] = []\n    const addEnum = (name: string, options: string[]) => {\n      if (enumsList.some((each) => each === name)) {\n        return\n      }\n      enumsList.push(name)\n      enumDeclarations.push(\n        `export const ${name} = ${enumFn}('${name}', [${options.map((option) => `'${option}'`).join(', ')}])`,\n      )\n    }\n\n    if (this.payload.config.localization && enumImport) {\n      addEnum('enum__locales', this.payload.config.localization.localeCodes)\n    }\n\n    const tableFn = this.schemaName ? `db_schema.table` : tableImport\n\n    if (!this.schemaName) {\n      addImport(corePackage, tableImport)\n    }\n\n    addImport(corePackage, 'index')\n    addImport(corePackage, 'uniqueIndex')\n    addImport(corePackage, 'foreignKey')\n\n    addImport(`${this.packageName}/drizzle`, 'sql')\n    addImport(`${this.packageName}/drizzle`, 'relations')\n\n    for (const tableName in this.rawTables) {\n      const table = this.rawTables[tableName]\n\n      const extrasDeclarations: string[] = []\n\n      if (table.indexes) {\n        for (const key in table.indexes) {\n          const index = table.indexes[key]\n          let indexDeclaration = `${index.unique ? 'uniqueIndex' : 'index'}('${index.name}')`\n          indexDeclaration += `.on(${typeof index.on === 'string' ? `${accessProperty('columns', index.on)}` : `${index.on.map((on) => `${accessProperty('columns', on)}`).join(', ')}`}),`\n          extrasDeclarations.push(indexDeclaration)\n        }\n      }\n\n      if (table.foreignKeys) {\n        for (const key in table.foreignKeys) {\n          const foreignKey = table.foreignKeys[key]\n\n          let foreignKeyDeclaration = `foreignKey({\n      columns: [${foreignKey.columns.map((col) => `columns['${col}']`).join(', ')}],\n      foreignColumns: [${foreignKey.foreignColumns.map((col) => `${accessProperty(col.table, col.name)}`).join(', ')}],\n      name: '${foreignKey.name}'\n    })`\n\n          if (foreignKey.onDelete) {\n            foreignKeyDeclaration += `.onDelete('${foreignKey.onDelete}')`\n          }\n          if (foreignKey.onUpdate) {\n            foreignKeyDeclaration += `.onUpdate('${foreignKey.onDelete}')`\n          }\n\n          foreignKeyDeclaration += ','\n\n          extrasDeclarations.push(foreignKeyDeclaration)\n        }\n      }\n\n      const tableCode = `\nexport const ${tableName} = ${tableFn}('${tableName}', {\n${Object.entries(table.columns)\n  .map(\n    ([key, column]) =>\n      `  ${sanitizeObjectKey(key)}: ${columnToCodeConverter({\n        adapter: this,\n        addEnum,\n        addImport,\n        column,\n        locales: this.payload.config.localization\n          ? this.payload.config.localization.localeCodes\n          : undefined,\n        tableKey: tableName,\n      })},`,\n  )\n  .join('\\n')}\n}${\n        extrasDeclarations.length\n          ? `, (columns) => [\n    ${extrasDeclarations.join(' ')}\n]`\n          : ''\n      }\n)\n`\n\n      tableDeclarations.push(tableCode)\n    }\n\n    for (const tableName in this.rawRelations) {\n      const relations = this.rawRelations[tableName]\n      const properties: string[] = []\n\n      for (const key in relations) {\n        const relation = relations[key]\n        let declaration: string\n\n        if (relation.type === 'one') {\n          declaration = `${sanitizeObjectKey(key)}: one(${relation.to}, {\n    ${relation.fields.some((field) => field.table !== tableName) ? '// @ts-expect-error Drizzle TypeScript bug for ONE relationships with a field in different table' : ''}\n    fields: [${relation.fields.map((field) => `${accessProperty(field.table, field.name)}`).join(', ')}],\n    references: [${relation.references.map((col) => `${accessProperty(relation.to, col)}`).join(', ')}],\n    ${relation.relationName ? `relationName: '${relation.relationName}',` : ''}\n    }),`\n        } else {\n          declaration = `${sanitizeObjectKey(key)}: many(${relation.to}, {\n            ${relation.relationName ? `relationName: '${relation.relationName}',` : ''}\n    }),`\n        }\n\n        properties.push(declaration)\n      }\n\n      // beautify / lintify relations callback output, when no many for example, don't add it\n      const args = []\n\n      if (Object.values(relations).some((rel) => rel.type === 'one')) {\n        args.push('one')\n      }\n\n      if (Object.values(relations).some((rel) => rel.type === 'many')) {\n        args.push('many')\n      }\n\n      const arg = args.length ? `{ ${args.join(', ')} }` : ''\n\n      const declaration = `export const relations_${tableName} = relations(${tableName}, (${arg}) => ({\n  ${properties.join('\\n    ')}\n      }))`\n\n      relationsDeclarations.push(declaration)\n    }\n\n    if (enumDeclarations.length && !this.schemaName) {\n      addImport(corePackage, enumImport)\n    }\n\n    const importDeclarationsSanitized: string[] = []\n\n    for (const moduleName in importDeclarations) {\n      const moduleImports = importDeclarations[moduleName]\n\n      importDeclarationsSanitized.push(\n        `import { ${Array.from(moduleImports).join(', ')} } from '${moduleName}'`,\n      )\n    }\n\n    const schemaType = `\ntype DatabaseSchema = {\n  ${[\n    this.schemaName ? 'db_schema' : null,\n    ...enumsList,\n    ...Object.keys(this.rawTables),\n    ...Object.keys(this.rawRelations).map((table) => `relations_${table}`),\n  ]\n    .filter(Boolean)\n    .map((name) => `${name}: typeof ${name}`)\n    .join('\\n  ')}\n}\n    `\n\n    const finalDeclaration = `\ndeclare module '${this.packageName}' {\n  export interface GeneratedDatabaseSchema {\n    schema: DatabaseSchema\n  }\n}\n    `\n\n    const warning = `\n/* tslint:disable */\n/* eslint-disable */\n/**\n * This file was automatically generated by Payload.\n * DO NOT MODIFY IT BY HAND. Instead, modify your source Payload config,\n * and re-run \\`payload generate:db-schema\\` to regenerate this file.\n */\n`\n\n    const importTypes = `import type {} from '${this.packageName}'`\n\n    let code = [\n      warning,\n      importTypes,\n      ...importDeclarationsSanitized,\n      schemaDeclaration,\n      ...enumDeclarations,\n      ...tableDeclarations,\n      ...relationsDeclarations,\n      schemaType,\n      finalDeclaration,\n    ]\n      .filter(Boolean)\n      .join('\\n')\n\n    if (!outputFile) {\n      const cwd = process.cwd()\n      const srcDir = path.resolve(cwd, 'src')\n\n      if (existsSync(srcDir)) {\n        outputFile = path.resolve(srcDir, 'payload-generated-schema.ts')\n      } else {\n        outputFile = path.resolve(cwd, 'payload-generated-schema.ts')\n      }\n    }\n\n    if (prettify) {\n      try {\n        const prettier = await eval('import(\"prettier\")')\n        const configPath = await prettier.resolveConfigFile()\n        const config = configPath ? await prettier.resolveConfig(configPath) : {}\n        code = await prettier.format(code, { ...config, parser: 'typescript' })\n      } catch {\n        /* empty */\n      }\n    }\n\n    await writeFile(outputFile, code, 'utf-8')\n\n    if (log) {\n      this.payload.logger.info(`Written ${outputFile}`)\n    }\n  }\n}\n"],"names":["existsSync","writeFile","path","sanitizeObjectKey","key","identifierRegex","test","accessProperty","objName","sanitized","startsWith","createSchemaGenerator","columnToCodeConverter","corePackageSuffix","defaultOutputFile","enumImport","schemaImport","tableImport","generateSchema","log","outputFile","prettify","importDeclarations","tableDeclarations","enumDeclarations","relationsDeclarations","addImport","from","name","Set","add","corePackage","packageName","schemaDeclaration","schemaName","enumFn","enumsList","addEnum","options","some","each","push","map","option","join","payload","config","localization","localeCodes","tableFn","tableName","rawTables","table","extrasDeclarations","indexes","index","indexDeclaration","unique","on","foreignKeys","foreignKey","foreignKeyDeclaration","columns","col","foreignColumns","onDelete","onUpdate","tableCode","Object","entries","column","adapter","locales","undefined","tableKey","length","rawRelations","relations","properties","relation","declaration","type","to","fields","field","references","relationName","args","values","rel","arg","importDeclarationsSanitized","moduleName","moduleImports","Array","schemaType","keys","filter","Boolean","finalDeclaration","warning","importTypes","code","cwd","process","srcDir","resolve","prettier","eval","configPath","resolveConfigFile","resolveConfig","format","parser","logger","info"],"mappings":"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"}},
    {"offset": {"line": 6786, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/createVersion.ts"],"sourcesContent":["import type { CreateVersionArgs, JsonObject, TypeWithVersion } from 'payload'\n\nimport { sql } from 'drizzle-orm'\nimport { buildVersionCollectionFields } from 'payload'\nimport { hasDraftsEnabled } from 'payload/shared'\nimport toSnakeCase from 'to-snake-case'\n\nimport type { DrizzleAdapter } from './types.js'\n\nimport { upsertRow } from './upsertRow/index.js'\nimport { getTransaction } from './utilities/getTransaction.js'\n\nexport async function createVersion<T extends JsonObject = JsonObject>(\n  this: DrizzleAdapter,\n  {\n    autosave,\n    collectionSlug,\n    createdAt,\n    parent,\n    publishedLocale,\n    req,\n    returning,\n    select,\n    snapshot,\n    updatedAt,\n    versionData,\n  }: CreateVersionArgs<T>,\n): Promise<TypeWithVersion<T>> {\n  const collection = this.payload.collections[collectionSlug].config\n  if (collection.versions.drafts) {\n    if (typeof select === 'object') {\n      select.updatedAt = true\n    }\n  }\n\n  const defaultTableName = toSnakeCase(collection.slug)\n  const tableName = this.tableNameMap.get(`_${defaultTableName}${this.versionsSuffix}`)\n\n  const version = { ...versionData }\n  if (version.id) {\n    delete version.id\n  }\n\n  const data: Record<string, unknown> = {\n    autosave,\n    createdAt,\n    latest: true,\n    parent,\n    publishedLocale,\n    snapshot,\n    updatedAt,\n    version,\n  }\n\n  const db = await getTransaction(this, req)\n\n  const result = await upsertRow<TypeWithVersion<T>>({\n    adapter: this,\n    collectionSlug,\n    data,\n    db,\n    fields: buildVersionCollectionFields(this.payload.config, collection, true),\n    ignoreResult: returning === false ? 'idOnly' : undefined,\n    operation: 'create',\n    req,\n    select,\n    tableName,\n  })\n\n  const table = this.tables[tableName]\n\n  if (hasDraftsEnabled(collection)) {\n    await this.execute({\n      db,\n      sql: sql`\n        UPDATE ${table}\n        SET latest = false\n        WHERE ${table.id} != ${result.id}\n          AND ${table.parent} = ${parent}\n          AND ${table.updatedAt} < ${result.updatedAt || updatedAt}\n      `,\n    })\n  }\n\n  if (returning === false) {\n    return null\n  }\n\n  return result\n}\n"],"names":["sql","buildVersionCollectionFields","hasDraftsEnabled","toSnakeCase","upsertRow","getTransaction","createVersion","autosave","collectionSlug","createdAt","parent","publishedLocale","req","returning","select","snapshot","updatedAt","versionData","collection","payload","collections","config","versions","drafts","defaultTableName","slug","tableName","tableNameMap","get","versionsSuffix","version","id","data","latest","db","result","adapter","fields","ignoreResult","undefined","operation","table","tables","execute"],"mappings":";;;;AAEA,SAASA,GAAG,QAAQ,cAAa;AACjC,SAASC,4BAA4B,QAAQ,UAAS;AACtD,SAASC,gBAAgB,QAAQ,iBAAgB;AACjD,OAAOC,iBAAiB,gBAAe;AAIvC,SAASC,SAAS,QAAQ,uBAAsB;AAChD,SAASC,cAAc,QAAQ,gCAA+B;;;;;;;AAEvD,eAAeC,cAEpB,EACEC,QAAQ,EACRC,cAAc,EACdC,SAAS,EACTC,MAAM,EACNC,eAAe,EACfC,GAAG,EACHC,SAAS,EACTC,MAAM,EACNC,QAAQ,EACRC,SAAS,EACTC,WAAW,EACU;IAEvB,MAAMC,aAAa,IAAI,CAACC,OAAO,CAACC,WAAW,CAACZ,eAAe,CAACa,MAAM;IAClE,IAAIH,WAAWI,QAAQ,CAACC,MAAM,EAAE;QAC9B,IAAI,OAAOT,WAAW,UAAU;YAC9BA,OAAOE,SAAS,GAAG;QACrB;IACF;IAEA,MAAMQ,uBAAmBrB,yJAAAA,EAAYe,WAAWO,IAAI;IACpD,MAAMC,YAAY,IAAI,CAACC,YAAY,CAACC,GAAG,CAAC,CAAC,CAAC,EAAEJ,mBAAmB,IAAI,CAACK,cAAc,EAAE;IAEpF,MAAMC,UAAU;QAAE,GAAGb,WAAW;IAAC;IACjC,IAAIa,QAAQC,EAAE,EAAE;QACd,OAAOD,QAAQC,EAAE;IACnB;IAEA,MAAMC,OAAgC;QACpCzB;QACAE;QACAwB,QAAQ;QACRvB;QACAC;QACAI;QACAC;QACAc;IACF;IAEA,MAAMI,KAAK,UAAM7B,kMAAAA,EAAe,IAAI,EAAEO;IAEtC,MAAMuB,SAAS,UAAM/B,oLAAAA,EAA8B;QACjDgC,SAAS,IAAI;QACb5B;QACAwB;QACAE;QACAG,YAAQpC,sMAAAA,EAA6B,IAAI,CAACkB,OAAO,CAACE,MAAM,EAAEH,YAAY;QACtEoB,cAAczB,cAAc,QAAQ,WAAW0B;QAC/CC,WAAW;QACX5B;QACAE;QACAY;IACF;IAEA,MAAMe,QAAQ,IAAI,CAACC,MAAM,CAAChB,UAAU;IAEpC,QAAIxB,uLAAAA,EAAiBgB,aAAa;QAChC,MAAM,IAAI,CAACyB,OAAO,CAAC;YACjBT;YACAlC,KAAKA,qJAAG,CAAC;eACA,EAAEyC,MAAM;;cAET,EAAEA,MAAMV,EAAE,CAAC,IAAI,EAAEI,OAAOJ,EAAE,CAAC;cAC3B,EAAEU,MAAM/B,MAAM,CAAC,GAAG,EAAEA,OAAO;cAC3B,EAAE+B,MAAMzB,SAAS,CAAC,GAAG,EAAEmB,OAAOnB,SAAS,IAAIA,UAAU;MAC7D,CAAC;QACH;IACF;IAEA,IAAIH,cAAc,OAAO;QACvB,OAAO;IACT;IAEA,OAAOsB;AACT"}},
    {"offset": {"line": 6862, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/queries/selectDistinct.ts"],"sourcesContent":["import type { QueryPromise, SQL } from 'drizzle-orm'\nimport type { SQLiteColumn, SQLiteSelect } from 'drizzle-orm/sqlite-core'\n\nimport type {\n  DrizzleAdapter,\n  DrizzleTransaction,\n  GenericColumn,\n  TransactionSQLite,\n} from '../types.js'\nimport type { BuildQueryJoinAliases } from './buildQuery.js'\n\ntype Args = {\n  adapter: DrizzleAdapter\n  db: DrizzleAdapter['drizzle'] | DrizzleTransaction\n  forceRun?: boolean\n  hasAggregates?: boolean\n  joins: BuildQueryJoinAliases\n  query?: (args: { query: SQLiteSelect }) => SQLiteSelect\n  selectFields: Record<string, GenericColumn>\n  tableName: string\n  where: SQL\n}\n\n/**\n * Selects distinct records from a table only if there are joins that need to be used, otherwise return null\n */\nexport const selectDistinct = ({\n  adapter,\n  db,\n  forceRun,\n  hasAggregates,\n  joins,\n  query: queryModifier = ({ query }) => query,\n  selectFields,\n  tableName,\n  where,\n}: Args): QueryPromise<{ id: number | string }[] & Record<string, GenericColumn>> => {\n  if (forceRun || Object.keys(joins).length > 0) {\n    let query: SQLiteSelect\n    const table = adapter.tables[tableName]\n\n    // With hasAggregate we use groupBy so we don't need to use selectDistinct in that case\n    // @ts-expect-error - Drizzle types are not accurate here\n    let selectFunc: TransactionSQLite['selectDistinct'] = hasAggregates\n      ? db.select\n      : db.selectDistinct\n\n    // bind this otherwise we get TypeError: Cannot read properties of undefined (reading 'session')\n    selectFunc = selectFunc.bind(db)\n\n    query = selectFunc(selectFields as Record<string, SQLiteColumn>)\n      .from(table)\n      .$dynamic()\n\n    if (where) {\n      query = query.where(where)\n    }\n\n    joins.forEach(({ type, condition, table }) => {\n      query = query[type ?? 'leftJoin'](table, condition)\n    })\n\n    if (hasAggregates && '_selected' in selectFields) {\n      // @ts-expect-error - Drizzle types are not accurate here\n      query = query.groupBy(selectFields['_selected'])\n    }\n\n    return queryModifier({\n      query,\n    }) as unknown as QueryPromise<{ id: number | string }[] & Record<string, GenericColumn>>\n  }\n}\n"],"names":["selectDistinct","adapter","db","forceRun","hasAggregates","joins","query","queryModifier","selectFields","tableName","where","Object","keys","length","table","tables","selectFunc","select","bind","from","$dynamic","forEach","type","condition","groupBy"],"mappings":"AAuBA;;CAEC,GACD;;;;AAAO,MAAMA,iBAAiB,CAAC,EAC7BC,OAAO,EACPC,EAAE,EACFC,QAAQ,EACRC,aAAa,EACbC,KAAK,EACLC,OAAOC,gBAAgB,CAAC,EAAED,KAAK,EAAE,GAAKA,KAAK,EAC3CE,YAAY,EACZC,SAAS,EACTC,KAAK,EACA;IACL,IAAIP,YAAYQ,OAAOC,IAAI,CAACP,OAAOQ,MAAM,GAAG,GAAG;QAC7C,IAAIP;QACJ,MAAMQ,QAAQb,QAAQc,MAAM,CAACN,UAAU;QAEvC,uFAAuF;QACvF,yDAAyD;QACzD,IAAIO,aAAkDZ,gBAClDF,GAAGe,MAAM,GACTf,GAAGF,cAAc;QAErB,gGAAgG;QAChGgB,aAAaA,WAAWE,IAAI,CAAChB;QAE7BI,QAAQU,WAAWR,cAChBW,IAAI,CAACL,OACLM,QAAQ;QAEX,IAAIV,OAAO;YACTJ,QAAQA,MAAMI,KAAK,CAACA;QACtB;QAEAL,MAAMgB,OAAO,CAAC,CAAC,EAAEC,IAAI,EAAEC,SAAS,EAAET,KAAK,EAAE;YACvCR,QAAQA,KAAK,CAACgB,QAAQ,WAAW,CAACR,OAAOS;QAC3C;QAEA,IAAInB,iBAAiB,eAAeI,cAAc;YAChD,yDAAyD;YACzDF,QAAQA,MAAMkB,OAAO,CAAChB,YAAY,CAAC,YAAY;QACjD;QAEA,OAAOD,cAAc;YACnBD;QACF;IACF;AACF,EAAC"}},
    {"offset": {"line": 6897, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/find/findMany.ts"],"sourcesContent":["import type { FindArgs, FlattenedField, TypeWithID } from 'payload'\n\nimport { inArray } from 'drizzle-orm'\n\nimport type { DrizzleAdapter } from '../types.js'\n\nimport { buildQuery } from '../queries/buildQuery.js'\nimport { selectDistinct } from '../queries/selectDistinct.js'\nimport { transform } from '../transform/read/index.js'\nimport { getNameFromDrizzleTable } from '../utilities/getNameFromDrizzleTable.js'\nimport { getTransaction } from '../utilities/getTransaction.js'\nimport { buildFindManyArgs } from './buildFindManyArgs.js'\n\ntype Args = {\n  adapter: DrizzleAdapter\n  collectionSlug?: string\n  fields: FlattenedField[]\n  tableName: string\n  versions?: boolean\n} & Omit<FindArgs, 'collection'>\n\nexport const findMany = async function find({\n  adapter,\n  collectionSlug,\n  draftsEnabled,\n  fields,\n  joins: joinQuery,\n  limit: limitArg,\n  locale,\n  page = 1,\n  pagination,\n  req,\n  select,\n  sort,\n  tableName,\n  versions,\n  where: whereArg,\n}: Args) {\n  let limit = limitArg\n  let totalDocs: number\n  let totalPages: number\n  let hasPrevPage: boolean\n  let hasNextPage: boolean\n  let pagingCounter: number\n  const offset = (page - 1) * limit\n\n  if (limit === 0) {\n    pagination = false\n    limit = undefined\n  }\n\n  const { joins, orderBy, selectFields, where } = buildQuery({\n    adapter,\n    fields,\n    locale,\n    sort,\n    tableName,\n    where: whereArg,\n  })\n\n  const orderedIDMap: Record<number | string, number> = {}\n  let orderedIDs: (number | string)[]\n\n  const findManyArgs = buildFindManyArgs({\n    adapter,\n    collectionSlug,\n    depth: 0,\n    draftsEnabled,\n    fields,\n    joinQuery,\n    joins,\n    locale,\n    select,\n    tableName,\n    versions,\n  })\n\n  if (orderBy) {\n    for (const key in selectFields) {\n      const column = selectFields[key]\n      if (!column || column.primary) {\n        continue\n      }\n\n      if (\n        !orderBy.some(\n          (col) =>\n            col.column.name === column.name &&\n            getNameFromDrizzleTable(col.column.table) === getNameFromDrizzleTable(column.table),\n        )\n      ) {\n        delete selectFields[key]\n      }\n    }\n  }\n\n  const db = await getTransaction(adapter, req)\n\n  const selectDistinctResult = await selectDistinct({\n    adapter,\n    db,\n    joins,\n    query: ({ query }) => {\n      if (orderBy) {\n        query = query.orderBy(() => orderBy.map(({ column, order }) => order(column)))\n      }\n      return query.offset(offset).limit(limit)\n    },\n    selectFields,\n    tableName,\n    where,\n  })\n\n  if (selectDistinctResult) {\n    if (selectDistinctResult.length === 0) {\n      return {\n        docs: [],\n        hasNextPage: false,\n        hasPrevPage: false,\n        limit,\n        nextPage: null,\n        page: 1,\n        pagingCounter: 0,\n        prevPage: null,\n        totalDocs: 0,\n        totalPages: 0,\n      }\n    } else {\n      // set the id in an object for sorting later\n      selectDistinctResult.forEach(({ id }, i) => {\n        orderedIDMap[id] = i\n      })\n      orderedIDs = Object.keys(orderedIDMap)\n      findManyArgs.where = inArray(adapter.tables[tableName].id, orderedIDs)\n    }\n  } else {\n    findManyArgs.limit = limit\n    findManyArgs.offset = offset\n    findManyArgs.orderBy = () => orderBy.map(({ column, order }) => order(column))\n\n    if (where) {\n      findManyArgs.where = where\n    }\n  }\n\n  const findPromise = db.query[tableName].findMany(findManyArgs)\n\n  if (pagination !== false && (orderedIDs ? orderedIDs?.length <= limit : true)) {\n    totalDocs = await adapter.countDistinct({\n      db,\n      joins,\n      tableName,\n      where,\n    })\n\n    totalPages = typeof limit === 'number' && limit !== 0 ? Math.ceil(totalDocs / limit) : 1\n    hasPrevPage = page > 1\n    hasNextPage = totalPages > page\n    pagingCounter = (page - 1) * limit + 1\n  }\n\n  const rawDocs = await findPromise\n  // sort rawDocs from selectQuery\n  if (Object.keys(orderedIDMap).length > 0) {\n    rawDocs.sort((a, b) => orderedIDMap[a.id] - orderedIDMap[b.id])\n  }\n\n  if (pagination === false || !totalDocs) {\n    totalDocs = rawDocs.length\n    totalPages = 1\n    pagingCounter = 1\n    hasPrevPage = false\n    hasNextPage = false\n  }\n\n  const docs = rawDocs.map((data: TypeWithID) => {\n    return transform({\n      adapter,\n      config: adapter.payload.config,\n      data,\n      fields,\n      joinQuery,\n      tableName,\n    })\n  })\n\n  return {\n    docs,\n    hasNextPage,\n    hasPrevPage,\n    limit: limitArg,\n    nextPage: hasNextPage ? page + 1 : null,\n    page,\n    pagingCounter,\n    prevPage: hasPrevPage ? page - 1 : null,\n    totalDocs,\n    totalPages,\n  }\n}\n"],"names":["inArray","buildQuery","selectDistinct","transform","getNameFromDrizzleTable","getTransaction","buildFindManyArgs","findMany","find","adapter","collectionSlug","draftsEnabled","fields","joins","joinQuery","limit","limitArg","locale","page","pagination","req","select","sort","tableName","versions","where","whereArg","totalDocs","totalPages","hasPrevPage","hasNextPage","pagingCounter","offset","undefined","orderBy","selectFields","orderedIDMap","orderedIDs","findManyArgs","depth","key","column","primary","some","col","name","table","db","selectDistinctResult","query","map","order","length","docs","nextPage","prevPage","forEach","id","i","Object","keys","tables","findPromise","countDistinct","Math","ceil","rawDocs","a","b","data","config","payload"],"mappings":"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"}},
    {"offset": {"line": 7058, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/deleteMany.ts"],"sourcesContent":["import type { DeleteMany } from 'payload'\n\nimport { inArray } from 'drizzle-orm'\nimport toSnakeCase from 'to-snake-case'\n\nimport type { DrizzleAdapter } from './types.js'\n\nimport { findMany } from './find/findMany.js'\nimport { buildQuery } from './queries/buildQuery.js'\nimport { getTransaction } from './utilities/getTransaction.js'\n\nexport const deleteMany: DeleteMany = async function deleteMany(\n  this: DrizzleAdapter,\n  { collection, req, where: whereArg },\n) {\n  const collectionConfig = this.payload.collections[collection].config\n\n  const tableName = this.tableNameMap.get(toSnakeCase(collectionConfig.slug))\n\n  const table = this.tables[tableName]\n\n  const { joins, where } = buildQuery({\n    adapter: this,\n    fields: collectionConfig.flattenedFields,\n    locale: req?.locale,\n    tableName,\n    where: whereArg,\n  })\n\n  let whereToUse = where\n\n  if (joins?.length) {\n    // Difficult to support joins (through where referencing other tables) in deleteMany. => 2 separate queries.\n    // We can look into supporting this using one single query (through a subquery) in the future, though that's difficult to do in a generic way.\n    const result = await findMany({\n      adapter: this,\n      fields: collectionConfig.flattenedFields,\n      joins: false,\n      limit: 0,\n      locale: req?.locale,\n      page: 1,\n      pagination: false,\n      req,\n      select: {\n        id: true,\n      },\n      tableName,\n      where: whereArg,\n    })\n\n    whereToUse = inArray(\n      table.id,\n      result.docs.map((doc) => doc.id),\n    )\n  }\n\n  const db = await getTransaction(this, req)\n\n  await this.deleteWhere({\n    db,\n    tableName,\n    where: whereToUse,\n  })\n}\n"],"names":["inArray","toSnakeCase","findMany","buildQuery","getTransaction","deleteMany","collection","req","where","whereArg","collectionConfig","payload","collections","config","tableName","tableNameMap","get","slug","table","tables","joins","adapter","fields","flattenedFields","locale","whereToUse","length","result","limit","page","pagination","select","id","docs","map","doc","db","deleteWhere"],"mappings":";;;;AAEA,SAASA,OAAO,QAAQ,cAAa;AACrC,OAAOC,iBAAiB,gBAAe;AAIvC,SAASC,QAAQ,QAAQ,qBAAoB;AAC7C,SAASC,UAAU,QAAQ,0BAAyB;AACpD,SAASC,cAAc,QAAQ,gCAA+B;;;;;;AAEvD,MAAMC,aAAyB,eAAeA,WAEnD,EAAEC,UAAU,EAAEC,GAAG,EAAEC,OAAOC,QAAQ,EAAE;IAEpC,MAAMC,mBAAmB,IAAI,CAACC,OAAO,CAACC,WAAW,CAACN,WAAW,CAACO,MAAM;IAEpE,MAAMC,YAAY,IAAI,CAACC,YAAY,CAACC,GAAG,KAACf,yJAAAA,EAAYS,iBAAiBO,IAAI;IAEzE,MAAMC,QAAQ,IAAI,CAACC,MAAM,CAACL,UAAU;IAEpC,MAAM,EAAEM,KAAK,EAAEZ,KAAK,EAAE,OAAGL,wLAAAA,EAAW;QAClCkB,SAAS,IAAI;QACbC,QAAQZ,iBAAiBa,eAAe;QACxCC,QAAQjB,KAAKiB;QACbV;QACAN,OAAOC;IACT;IAEA,IAAIgB,aAAajB;IAEjB,IAAIY,OAAOM,QAAQ;QACjB,4GAA4G;QAC5G,8IAA8I;QAC9I,MAAMC,SAAS,UAAMzB,iLAAAA,EAAS;YAC5BmB,SAAS,IAAI;YACbC,QAAQZ,iBAAiBa,eAAe;YACxCH,OAAO;YACPQ,OAAO;YACPJ,QAAQjB,KAAKiB;YACbK,MAAM;YACNC,YAAY;YACZvB;YACAwB,QAAQ;gBACNC,IAAI;YACN;YACAlB;YACAN,OAAOC;QACT;QAEAgB,iBAAazB,+KAAAA,EACXkB,MAAMc,EAAE,EACRL,OAAOM,IAAI,CAACC,GAAG,CAAC,CAACC,MAAQA,IAAIH,EAAE;IAEnC;IAEA,MAAMI,KAAK,UAAMhC,kMAAAA,EAAe,IAAI,EAAEG;IAEtC,MAAM,IAAI,CAAC8B,WAAW,CAAC;QACrBD;QACAtB;QACAN,OAAOiB;IACT;AACF,EAAC"}},
    {"offset": {"line": 7115, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/deleteOne.ts"],"sourcesContent":["import type { DeleteOne } from 'payload'\n\nimport { eq } from 'drizzle-orm'\nimport toSnakeCase from 'to-snake-case'\n\nimport type { DrizzleAdapter } from './types.js'\n\nimport { buildFindManyArgs } from './find/buildFindManyArgs.js'\nimport { buildQuery } from './queries/buildQuery.js'\nimport { selectDistinct } from './queries/selectDistinct.js'\nimport { transform } from './transform/read/index.js'\nimport { getTransaction } from './utilities/getTransaction.js'\n\nexport const deleteOne: DeleteOne = async function deleteOne(\n  this: DrizzleAdapter,\n  { collection: collectionSlug, req, returning, select, where: whereArg },\n) {\n  const collection = this.payload.collections[collectionSlug].config\n\n  const tableName = this.tableNameMap.get(toSnakeCase(collection.slug))\n\n  let docToDelete: Record<string, unknown>\n\n  const { joins, selectFields, where } = buildQuery({\n    adapter: this,\n    fields: collection.flattenedFields,\n    locale: req?.locale,\n    tableName,\n    where: whereArg,\n  })\n\n  const db = await getTransaction(this, req)\n\n  const selectDistinctResult = await selectDistinct({\n    adapter: this,\n    db,\n    joins,\n    query: ({ query }) => query.limit(1),\n    selectFields,\n    tableName,\n    where,\n  })\n\n  if (selectDistinctResult?.[0]?.id) {\n    docToDelete = await db.query[tableName].findFirst({\n      where: eq(this.tables[tableName].id, selectDistinctResult[0].id),\n    })\n  } else {\n    const findManyArgs = buildFindManyArgs({\n      adapter: this,\n      depth: 0,\n      fields: collection.flattenedFields,\n      joinQuery: false,\n      select,\n      tableName,\n    })\n\n    findManyArgs.where = where\n\n    docToDelete = await db.query[tableName].findFirst(findManyArgs)\n  }\n\n  if (!docToDelete) {\n    return null\n  }\n\n  const result =\n    returning === false\n      ? null\n      : transform({\n          adapter: this,\n          config: this.payload.config,\n          data: docToDelete,\n          fields: collection.flattenedFields,\n          joinQuery: false,\n          tableName,\n        })\n\n  await this.deleteWhere({\n    db,\n    tableName,\n    where: eq(this.tables[tableName].id, docToDelete.id),\n  })\n\n  return result\n}\n"],"names":["eq","toSnakeCase","buildFindManyArgs","buildQuery","selectDistinct","transform","getTransaction","deleteOne","collection","collectionSlug","req","returning","select","where","whereArg","payload","collections","config","tableName","tableNameMap","get","slug","docToDelete","joins","selectFields","adapter","fields","flattenedFields","locale","db","selectDistinctResult","query","limit","id","findFirst","tables","findManyArgs","depth","joinQuery","result","data","deleteWhere"],"mappings":";;;;AAEA,SAASA,EAAE,QAAQ,cAAa;AAChC,OAAOC,iBAAiB,gBAAe;AAIvC,SAASC,iBAAiB,QAAQ,8BAA6B;AAC/D,SAASC,UAAU,QAAQ,0BAAyB;AACpD,SAASC,cAAc,QAAQ,8BAA6B;AAC5D,SAASC,SAAS,QAAQ,4BAA2B;AACrD,SAASC,cAAc,QAAQ,gCAA+B;;;;;;;;AAEvD,MAAMC,YAAuB,eAAeA,UAEjD,EAAEC,YAAYC,cAAc,EAAEC,GAAG,EAAEC,SAAS,EAAEC,MAAM,EAAEC,OAAOC,QAAQ,EAAE;IAEvE,MAAMN,aAAa,IAAI,CAACO,OAAO,CAACC,WAAW,CAACP,eAAe,CAACQ,MAAM;IAElE,MAAMC,YAAY,IAAI,CAACC,YAAY,CAACC,GAAG,KAACnB,yJAAAA,EAAYO,WAAWa,IAAI;IAEnE,IAAIC;IAEJ,MAAM,EAAEC,KAAK,EAAEC,YAAY,EAAEX,KAAK,EAAE,OAAGV,wLAAAA,EAAW;QAChDsB,SAAS,IAAI;QACbC,QAAQlB,WAAWmB,eAAe;QAClCC,QAAQlB,KAAKkB;QACbV;QACAL,OAAOC;IACT;IAEA,MAAMe,KAAK,UAAMvB,kMAAAA,EAAe,IAAI,EAAEI;IAEtC,MAAMoB,uBAAuB,UAAM1B,gMAAAA,EAAe;QAChDqB,SAAS,IAAI;QACbI;QACAN;QACAQ,OAAO,CAAC,EAAEA,KAAK,EAAE,GAAKA,MAAMC,KAAK,CAAC;QAClCR;QACAN;QACAL;IACF;IAEA,IAAIiB,sBAAsB,CAAC,EAAE,EAAEG,IAAI;QACjCX,cAAc,MAAMO,GAAGE,KAAK,CAACb,UAAU,CAACgB,SAAS,CAAC;YAChDrB,WAAOb,0KAAAA,EAAG,IAAI,CAACmC,MAAM,CAACjB,UAAU,CAACe,EAAE,EAAEH,oBAAoB,CAAC,EAAE,CAACG,EAAE;QACjE;IACF,OAAO;QACL,MAAMG,mBAAelC,mMAAAA,EAAkB;YACrCuB,SAAS,IAAI;YACbY,OAAO;YACPX,QAAQlB,WAAWmB,eAAe;YAClCW,WAAW;YACX1B;YACAM;QACF;QAEAkB,aAAavB,KAAK,GAAGA;QAErBS,cAAc,MAAMO,GAAGE,KAAK,CAACb,UAAU,CAACgB,SAAS,CAACE;IACpD;IAEA,IAAI,CAACd,aAAa;QAChB,OAAO;IACT;IAEA,MAAMiB,SACJ5B,cAAc,QACV,WACAN,4LAAAA,EAAU;QACRoB,SAAS,IAAI;QACbR,QAAQ,IAAI,CAACF,OAAO,CAACE,MAAM;QAC3BuB,MAAMlB;QACNI,QAAQlB,WAAWmB,eAAe;QAClCW,WAAW;QACXpB;IACF;IAEN,MAAM,IAAI,CAACuB,WAAW,CAAC;QACrBZ;QACAX;QACAL,WAAOb,0KAAAA,EAAG,IAAI,CAACmC,MAAM,CAACjB,UAAU,CAACe,EAAE,EAAEX,YAAYW,EAAE;IACrD;IAEA,OAAOM;AACT,EAAC"}},
    {"offset": {"line": 7192, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/deleteVersions.ts"],"sourcesContent":["import type { DeleteVersions, FlattenedField, SanitizedCollectionConfig } from 'payload'\n\nimport { inArray } from 'drizzle-orm'\nimport { APIError, buildVersionCollectionFields, buildVersionGlobalFields } from 'payload'\nimport toSnakeCase from 'to-snake-case'\n\nimport type { DrizzleAdapter } from './types.js'\n\nimport { findMany } from './find/findMany.js'\nimport { getTransaction } from './utilities/getTransaction.js'\n\nexport const deleteVersions: DeleteVersions = async function deleteVersion(\n  this: DrizzleAdapter,\n  { collection: collectionSlug, globalSlug, locale, req, where: where },\n) {\n  let tableName: string\n  let fields: FlattenedField[]\n\n  if (globalSlug) {\n    const globalConfig = this.payload.globals.config.find(({ slug }) => slug === globalSlug)\n    tableName = this.tableNameMap.get(`_${toSnakeCase(globalSlug)}${this.versionsSuffix}`)\n    fields = buildVersionGlobalFields(this.payload.config, globalConfig, true)\n  } else if (collectionSlug) {\n    const collectionConfig: SanitizedCollectionConfig =\n      this.payload.collections[collectionSlug].config\n    tableName = this.tableNameMap.get(\n      `_${toSnakeCase(collectionConfig.slug)}${this.versionsSuffix}`,\n    )\n    fields = buildVersionCollectionFields(this.payload.config, collectionConfig, true)\n  } else {\n    throw new APIError('Either collection or globalSlug must be passed.')\n  }\n\n  const { docs } = await findMany({\n    adapter: this,\n    fields,\n    joins: false,\n    limit: 0,\n    locale,\n    page: 1,\n    pagination: false,\n    req,\n    tableName,\n    where,\n  })\n\n  const ids = []\n\n  docs.forEach((doc) => {\n    ids.push(doc.id)\n  })\n\n  if (ids.length > 0) {\n    const db = await getTransaction(this, req)\n\n    await this.deleteWhere({\n      db,\n      tableName,\n      where: inArray(this.tables[tableName].id, ids),\n    })\n  }\n\n  return docs\n}\n"],"names":["inArray","APIError","buildVersionCollectionFields","buildVersionGlobalFields","toSnakeCase","findMany","getTransaction","deleteVersions","deleteVersion","collection","collectionSlug","globalSlug","locale","req","where","tableName","fields","globalConfig","payload","globals","config","find","slug","tableNameMap","get","versionsSuffix","collectionConfig","collections","docs","adapter","joins","limit","page","pagination","ids","forEach","doc","push","id","length","db","deleteWhere","tables"],"mappings":";;;;AAEA,SAASA,OAAO,QAAQ,cAAa;;;AACrC,SAASC,QAAQ,EAAEC,4BAA4B,EAAEC,wBAAwB,QAAQ,UAAS;AAC1F,OAAOC,iBAAiB,gBAAe;AAIvC,SAASC,QAAQ,QAAQ,qBAAoB;AAC7C,SAASC,cAAc,QAAQ,gCAA+B;;;;;;AAEvD,MAAMC,iBAAiC,eAAeC,cAE3D,EAAEC,YAAYC,cAAc,EAAEC,UAAU,EAAEC,MAAM,EAAEC,GAAG,EAAEC,OAAOA,KAAK,EAAE;IAErE,IAAIC;IACJ,IAAIC;IAEJ,IAAIL,YAAY;QACd,MAAMM,eAAe,IAAI,CAACC,OAAO,CAACC,OAAO,CAACC,MAAM,CAACC,IAAI,CAAC,CAAC,EAAEC,IAAI,EAAE,GAAKA,SAASX;QAC7EI,YAAY,IAAI,CAACQ,YAAY,CAACC,GAAG,CAAC,CAAC,CAAC,MAAEpB,yJAAAA,EAAYO,cAAc,IAAI,CAACc,cAAc,EAAE;QACrFT,aAASb,8LAAAA,EAAyB,IAAI,CAACe,OAAO,CAACE,MAAM,EAAEH,cAAc;IACvE,OAAO,IAAIP,gBAAgB;QACzB,MAAMgB,mBACJ,IAAI,CAACR,OAAO,CAACS,WAAW,CAACjB,eAAe,CAACU,MAAM;QACjDL,YAAY,IAAI,CAACQ,YAAY,CAACC,GAAG,CAC/B,CAAC,CAAC,MAAEpB,yJAAAA,EAAYsB,iBAAiBJ,IAAI,IAAI,IAAI,CAACG,cAAc,EAAE;QAEhET,aAASd,sMAAAA,EAA6B,IAAI,CAACgB,OAAO,CAACE,MAAM,EAAEM,kBAAkB;IAC/E,OAAO;QACL,MAAM,IAAIzB,mKAAAA,CAAS;IACrB;IAEA,MAAM,EAAE2B,IAAI,EAAE,GAAG,UAAMvB,iLAAAA,EAAS;QAC9BwB,SAAS,IAAI;QACbb;QACAc,OAAO;QACPC,OAAO;QACPnB;QACAoB,MAAM;QACNC,YAAY;QACZpB;QACAE;QACAD;IACF;IAEA,MAAMoB,MAAM,EAAE;IAEdN,KAAKO,OAAO,CAAC,CAACC;QACZF,IAAIG,IAAI,CAACD,IAAIE,EAAE;IACjB;IAEA,IAAIJ,IAAIK,MAAM,GAAG,GAAG;QAClB,MAAMC,KAAK,UAAMlC,kMAAAA,EAAe,IAAI,EAAEO;QAEtC,MAAM,IAAI,CAAC4B,WAAW,CAAC;YACrBD;YACAzB;YACAD,WAAOd,+KAAAA,EAAQ,IAAI,CAAC0C,MAAM,CAAC3B,UAAU,CAACuB,EAAE,EAAEJ;QAC5C;IACF;IAEA,OAAON;AACT,EAAC"}},
    {"offset": {"line": 7252, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/destroy.ts"],"sourcesContent":["import type { Destroy } from 'payload'\n\nimport type { DrizzleAdapter } from './types.js'\n\n// eslint-disable-next-line @typescript-eslint/require-await\nexport const destroy: Destroy = async function destroy(this: DrizzleAdapter) {\n  if (this.enums) {\n    this.enums = {}\n  }\n  this.schema = {}\n  this.tables = {}\n  this.relations = {}\n  this.fieldConstraints = {}\n  this.drizzle = undefined\n  this.initializing = new Promise((res, rej) => {\n    this.resolveInitializing = res\n    this.rejectInitializing = rej\n  })\n}\n"],"names":["destroy","enums","schema","tables","relations","fieldConstraints","drizzle","undefined","initializing","Promise","res","rej","resolveInitializing","rejectInitializing"],"mappings":"AAIA,4DAA4D;;;;;AACrD,MAAMA,UAAmB,eAAeA;IAC7C,IAAI,IAAI,CAACC,KAAK,EAAE;QACd,IAAI,CAACA,KAAK,GAAG,CAAC;IAChB;IACA,IAAI,CAACC,MAAM,GAAG,CAAC;IACf,IAAI,CAACC,MAAM,GAAG,CAAC;IACf,IAAI,CAACC,SAAS,GAAG,CAAC;IAClB,IAAI,CAACC,gBAAgB,GAAG,CAAC;IACzB,IAAI,CAACC,OAAO,GAAGC;IACf,IAAI,CAACC,YAAY,GAAG,IAAIC,QAAQ,CAACC,KAAKC;QACpC,IAAI,CAACC,mBAAmB,GAAGF;QAC3B,IAAI,CAACG,kBAAkB,GAAGF;IAC5B;AACF,EAAC"}},
    {"offset": {"line": 7275, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/find.ts"],"sourcesContent":["import type { Find, SanitizedCollectionConfig } from 'payload'\n\nimport toSnakeCase from 'to-snake-case'\n\nimport type { DrizzleAdapter } from './types.js'\n\nimport { findMany } from './find/findMany.js'\n\nexport const find: Find = async function find(\n  this: DrizzleAdapter,\n  {\n    collection,\n    draftsEnabled,\n    joins,\n    limit,\n    locale,\n    page = 1,\n    pagination,\n    req,\n    select,\n    sort: sortArg,\n    where,\n  },\n) {\n  const collectionConfig: SanitizedCollectionConfig = this.payload.collections[collection].config\n  const sort = sortArg !== undefined && sortArg !== null ? sortArg : collectionConfig.defaultSort\n\n  const tableName = this.tableNameMap.get(toSnakeCase(collectionConfig.slug))\n\n  return findMany({\n    adapter: this,\n    collectionSlug: collectionConfig.slug,\n    draftsEnabled,\n    fields: collectionConfig.flattenedFields,\n    joins,\n    limit,\n    locale,\n    page,\n    pagination,\n    req,\n    select,\n    sort,\n    tableName,\n    where,\n  })\n}\n"],"names":["toSnakeCase","findMany","find","collection","draftsEnabled","joins","limit","locale","page","pagination","req","select","sort","sortArg","where","collectionConfig","payload","collections","config","undefined","defaultSort","tableName","tableNameMap","get","slug","adapter","collectionSlug","fields","flattenedFields"],"mappings":";;;;AAEA,OAAOA,iBAAiB,gBAAe;AAIvC,SAASC,QAAQ,QAAQ,qBAAoB;;;AAEtC,MAAMC,OAAa,eAAeA,KAEvC,EACEC,UAAU,EACVC,aAAa,EACbC,KAAK,EACLC,KAAK,EACLC,MAAM,EACNC,OAAO,CAAC,EACRC,UAAU,EACVC,GAAG,EACHC,MAAM,EACNC,MAAMC,OAAO,EACbC,KAAK,EACN;IAED,MAAMC,mBAA8C,IAAI,CAACC,OAAO,CAACC,WAAW,CAACd,WAAW,CAACe,MAAM;IAC/F,MAAMN,OAAOC,YAAYM,aAAaN,YAAY,OAAOA,UAAUE,iBAAiBK,WAAW;IAE/F,MAAMC,YAAY,IAAI,CAACC,YAAY,CAACC,GAAG,KAACvB,yJAAAA,EAAYe,iBAAiBS,IAAI;IAEzE,WAAOvB,iLAAAA,EAAS;QACdwB,SAAS,IAAI;QACbC,gBAAgBX,iBAAiBS,IAAI;QACrCpB;QACAuB,QAAQZ,iBAAiBa,eAAe;QACxCvB;QACAC;QACAC;QACAC;QACAC;QACAC;QACAC;QACAC;QACAS;QACAP;IACF;AACF,EAAC"}},
    {"offset": {"line": 7308, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/findDistinct.ts"],"sourcesContent":["import type { asc, desc, SQL } from 'drizzle-orm'\n\nimport { max, sql } from 'drizzle-orm'\nimport { type FindDistinct, getFieldByPath, type SanitizedCollectionConfig } from 'payload'\nimport toSnakeCase from 'to-snake-case'\n\nimport type { BuildQueryJoinAliases, DrizzleAdapter, GenericColumn } from './types.js'\n\nimport { buildQuery } from './queries/buildQuery.js'\nimport { selectDistinct } from './queries/selectDistinct.js'\nimport { getTransaction } from './utilities/getTransaction.js'\nimport { DistinctSymbol } from './utilities/rawConstraint.js'\n\nconst getOrderColumn = (\n  orderBy: { column: GenericColumn; order: typeof asc | typeof desc }[],\n  selectFields: Record<string, GenericColumn>,\n  joins: BuildQueryJoinAliases,\n): GenericColumn | null | SQL.Aliased => {\n  if (orderBy.length === 0) {\n    return null\n  }\n\n  if (orderBy[0].column === selectFields['_selected']) {\n    return null\n  }\n\n  if (joins.length > 0) {\n    return orderBy[0].column\n  }\n\n  return max(orderBy[0]?.column).as('_order')\n}\n\nexport const findDistinct: FindDistinct = async function (this: DrizzleAdapter, args) {\n  const collectionConfig: SanitizedCollectionConfig =\n    this.payload.collections[args.collection].config\n  const page = args.page || 1\n  const offset = args.limit ? (page - 1) * args.limit : undefined\n  const tableName = this.tableNameMap.get(toSnakeCase(collectionConfig.slug))\n\n  const { joins, orderBy, selectFields, where } = buildQuery({\n    adapter: this,\n    fields: collectionConfig.flattenedFields,\n    locale: args.locale,\n    sort: args.sort ?? args.field,\n    tableName,\n    where: {\n      and: [\n        args.where ?? {},\n        {\n          [args.field]: {\n            equals: DistinctSymbol,\n          },\n        },\n      ],\n    },\n  })\n\n  orderBy.pop()\n\n  const db = await getTransaction(this, args.req)\n\n  const _order = getOrderColumn(orderBy, selectFields, joins)\n\n  const selectDistinctResult = await selectDistinct({\n    adapter: this,\n    db,\n    forceRun: true,\n    hasAggregates: Boolean(_order) && !joins.length,\n    joins,\n    query: ({ query }) => {\n      if (_order && orderBy.length > 0 && !joins.length) {\n        query = query.orderBy(orderBy[0].order(sql`_order`))\n      } else {\n        query = query.orderBy(() => orderBy.map(({ column, order }) => order(column)))\n      }\n\n      if (args.limit) {\n        if (offset) {\n          query = query.offset(offset)\n        }\n\n        query = query.limit(args.limit)\n      }\n\n      return query\n    },\n    selectFields: {\n      _selected: selectFields['_selected'],\n      ...(_order ? { _order } : {}),\n    } as Record<string, any>,\n    tableName,\n    where,\n  })\n\n  const field = getFieldByPath({\n    config: this.payload.config,\n    fields: collectionConfig.flattenedFields,\n    includeRelationships: true,\n    path: args.field,\n  })?.field\n\n  if (field && 'relationTo' in field && Array.isArray(field.relationTo)) {\n    for (const row of selectDistinctResult as any) {\n      const json = JSON.parse(row._selected)\n      const relationTo = Object.keys(json).find((each) => Boolean(json[each]))\n      const value = json[relationTo]\n\n      if (!value) {\n        row._selected = null\n      } else {\n        row._selected = { relationTo, value }\n      }\n    }\n  }\n\n  const values = selectDistinctResult.map((each) => ({\n    [args.field]: (each as Record<string, any>)._selected,\n  }))\n\n  if (args.limit) {\n    const totalDocs = await this.countDistinct({\n      column: selectFields['_selected'],\n      db,\n      joins,\n      tableName,\n      where,\n    })\n\n    const totalPages = Math.ceil(totalDocs / args.limit)\n    const hasPrevPage = page > 1\n    const hasNextPage = totalPages > page\n    const pagingCounter = (page - 1) * args.limit + 1\n\n    return {\n      hasNextPage,\n      hasPrevPage,\n      limit: args.limit,\n      nextPage: hasNextPage ? page + 1 : null,\n      page,\n      pagingCounter,\n      prevPage: hasPrevPage ? page - 1 : null,\n      totalDocs,\n      totalPages,\n      values,\n    }\n  }\n\n  return {\n    hasNextPage: false,\n    hasPrevPage: false,\n    limit: 0,\n    page: 1,\n    pagingCounter: 1,\n    totalDocs: values.length,\n    totalPages: 1,\n    values,\n  }\n}\n"],"names":["max","sql","getFieldByPath","toSnakeCase","buildQuery","selectDistinct","getTransaction","DistinctSymbol","getOrderColumn","orderBy","selectFields","joins","length","column","as","findDistinct","args","collectionConfig","payload","collections","collection","config","page","offset","limit","undefined","tableName","tableNameMap","get","slug","where","adapter","fields","flattenedFields","locale","sort","field","and","equals","pop","db","req","_order","selectDistinctResult","forceRun","hasAggregates","Boolean","query","order","map","_selected","includeRelationships","path","Array","isArray","relationTo","row","json","JSON","parse","Object","keys","find","each","value","values","totalDocs","countDistinct","totalPages","Math","ceil","hasPrevPage","hasNextPage","pagingCounter","nextPage","prevPage"],"mappings":"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"}},
    {"offset": {"line": 7457, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/findGlobal.ts"],"sourcesContent":["import type { FindGlobal } from 'payload'\n\nimport toSnakeCase from 'to-snake-case'\n\nimport type { DrizzleAdapter } from './types.js'\n\nimport { findMany } from './find/findMany.js'\n\nexport const findGlobal: FindGlobal = async function findGlobal(\n  this: DrizzleAdapter,\n  { slug, locale, req, select, where },\n) {\n  const globalConfig = this.payload.globals.config.find((config) => config.slug === slug)\n\n  const tableName = this.tableNameMap.get(toSnakeCase(globalConfig.slug))\n\n  const {\n    docs: [doc],\n  } = await findMany({\n    adapter: this,\n    fields: globalConfig.flattenedFields,\n    limit: 1,\n    locale,\n    pagination: false,\n    req,\n    select,\n    tableName,\n    where,\n  })\n\n  if (doc) {\n    doc.globalType = slug\n    return doc\n  }\n\n  return {}\n}\n"],"names":["toSnakeCase","findMany","findGlobal","slug","locale","req","select","where","globalConfig","payload","globals","config","find","tableName","tableNameMap","get","docs","doc","adapter","fields","flattenedFields","limit","pagination","globalType"],"mappings":";;;;AAEA,OAAOA,iBAAiB,gBAAe;AAIvC,SAASC,QAAQ,QAAQ,qBAAoB;;;AAEtC,MAAMC,aAAyB,eAAeA,WAEnD,EAAEC,IAAI,EAAEC,MAAM,EAAEC,GAAG,EAAEC,MAAM,EAAEC,KAAK,EAAE;IAEpC,MAAMC,eAAe,IAAI,CAACC,OAAO,CAACC,OAAO,CAACC,MAAM,CAACC,IAAI,CAAC,CAACD,SAAWA,OAAOR,IAAI,KAAKA;IAElF,MAAMU,YAAY,IAAI,CAACC,YAAY,CAACC,GAAG,KAACf,yJAAAA,EAAYQ,aAAaL,IAAI;IAErE,MAAM,EACJa,MAAM,CAACC,IAAI,EACZ,GAAG,UAAMhB,iLAAAA,EAAS;QACjBiB,SAAS,IAAI;QACbC,QAAQX,aAAaY,eAAe;QACpCC,OAAO;QACPjB;QACAkB,YAAY;QACZjB;QACAC;QACAO;QACAN;IACF;IAEA,IAAIU,KAAK;QACPA,IAAIM,UAAU,GAAGpB;QACjB,OAAOc;IACT;IAEA,OAAO,CAAC;AACV,EAAC"}},
    {"offset": {"line": 7489, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/findGlobalVersions.ts"],"sourcesContent":["import type { FindGlobalVersions, SanitizedGlobalConfig } from 'payload'\n\nimport { buildVersionGlobalFields } from 'payload'\nimport toSnakeCase from 'to-snake-case'\n\nimport type { DrizzleAdapter } from './types.js'\n\nimport { findMany } from './find/findMany.js'\n\nexport const findGlobalVersions: FindGlobalVersions = async function findGlobalVersions(\n  this: DrizzleAdapter,\n  { global, limit, locale, page, pagination, req, select, sort: sortArg, where },\n) {\n  const globalConfig: SanitizedGlobalConfig = this.payload.globals.config.find(\n    ({ slug }) => slug === global,\n  )\n  const sort = sortArg !== undefined && sortArg !== null ? sortArg : '-createdAt'\n\n  const tableName = this.tableNameMap.get(\n    `_${toSnakeCase(globalConfig.slug)}${this.versionsSuffix}`,\n  )\n\n  const fields = buildVersionGlobalFields(this.payload.config, globalConfig, true)\n\n  return findMany({\n    adapter: this,\n    fields,\n    limit,\n    locale,\n    page,\n    pagination,\n    req,\n    select,\n    sort,\n    tableName,\n    where,\n  })\n}\n"],"names":["buildVersionGlobalFields","toSnakeCase","findMany","findGlobalVersions","global","limit","locale","page","pagination","req","select","sort","sortArg","where","globalConfig","payload","globals","config","find","slug","undefined","tableName","tableNameMap","get","versionsSuffix","fields","adapter"],"mappings":";;;;AAEA,SAASA,wBAAwB,QAAQ,UAAS;AAClD,OAAOC,iBAAiB,gBAAe;AAIvC,SAASC,QAAQ,QAAQ,qBAAoB;;;;AAEtC,MAAMC,qBAAyC,eAAeA,mBAEnE,EAAEC,MAAM,EAAEC,KAAK,EAAEC,MAAM,EAAEC,IAAI,EAAEC,UAAU,EAAEC,GAAG,EAAEC,MAAM,EAAEC,MAAMC,OAAO,EAAEC,KAAK,EAAE;IAE9E,MAAMC,eAAsC,IAAI,CAACC,OAAO,CAACC,OAAO,CAACC,MAAM,CAACC,IAAI,CAC1E,CAAC,EAAEC,IAAI,EAAE,GAAKA,SAASf;IAEzB,MAAMO,OAAOC,YAAYQ,aAAaR,YAAY,OAAOA,UAAU;IAEnE,MAAMS,YAAY,IAAI,CAACC,YAAY,CAACC,GAAG,CACrC,CAAC,CAAC,MAAEtB,yJAAAA,EAAYa,aAAaK,IAAI,IAAI,IAAI,CAACK,cAAc,EAAE;IAG5D,MAAMC,aAASzB,8LAAAA,EAAyB,IAAI,CAACe,OAAO,CAACE,MAAM,EAAEH,cAAc;IAE3E,WAAOZ,iLAAAA,EAAS;QACdwB,SAAS,IAAI;QACbD;QACApB;QACAC;QACAC;QACAC;QACAC;QACAC;QACAC;QACAU;QACAR;IACF;AACF,EAAC"}},
    {"offset": {"line": 7522, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/findOne.ts"],"sourcesContent":["import type { FindOneArgs, SanitizedCollectionConfig, TypeWithID } from 'payload'\n\nimport toSnakeCase from 'to-snake-case'\n\nimport type { DrizzleAdapter } from './types.js'\n\nimport { findMany } from './find/findMany.js'\n\nexport async function findOne<T extends TypeWithID>(\n  this: DrizzleAdapter,\n  { collection, draftsEnabled, joins, locale, req, select, where }: FindOneArgs,\n): Promise<null | T> {\n  const collectionConfig: SanitizedCollectionConfig = this.payload.collections[collection].config\n\n  const tableName = this.tableNameMap.get(toSnakeCase(collectionConfig.slug))\n\n  const { docs } = await findMany({\n    adapter: this,\n    collectionSlug: collection,\n    draftsEnabled,\n    fields: collectionConfig.flattenedFields,\n    joins,\n    limit: 1,\n    locale,\n    page: 1,\n    pagination: false,\n    req,\n    select,\n    sort: undefined,\n    tableName,\n    where,\n  })\n\n  return docs?.[0] || null\n}\n"],"names":["toSnakeCase","findMany","findOne","collection","draftsEnabled","joins","locale","req","select","where","collectionConfig","payload","collections","config","tableName","tableNameMap","get","slug","docs","adapter","collectionSlug","fields","flattenedFields","limit","page","pagination","sort","undefined"],"mappings":";;;;AAEA,OAAOA,iBAAiB,gBAAe;AAIvC,SAASC,QAAQ,QAAQ,qBAAoB;;;AAEtC,eAAeC,QAEpB,EAAEC,UAAU,EAAEC,aAAa,EAAEC,KAAK,EAAEC,MAAM,EAAEC,GAAG,EAAEC,MAAM,EAAEC,KAAK,EAAe;IAE7E,MAAMC,mBAA8C,IAAI,CAACC,OAAO,CAACC,WAAW,CAACT,WAAW,CAACU,MAAM;IAE/F,MAAMC,YAAY,IAAI,CAACC,YAAY,CAACC,GAAG,KAAChB,yJAAAA,EAAYU,iBAAiBO,IAAI;IAEzE,MAAM,EAAEC,IAAI,EAAE,GAAG,UAAMjB,iLAAAA,EAAS;QAC9BkB,SAAS,IAAI;QACbC,gBAAgBjB;QAChBC;QACAiB,QAAQX,iBAAiBY,eAAe;QACxCjB;QACAkB,OAAO;QACPjB;QACAkB,MAAM;QACNC,YAAY;QACZlB;QACAC;QACAkB,MAAMC;QACNb;QACAL;IACF;IAEA,OAAOS,MAAM,CAAC,EAAE,IAAI;AACtB"}},
    {"offset": {"line": 7555, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/findVersions.ts"],"sourcesContent":["import type { FindVersions, SanitizedCollectionConfig } from 'payload'\n\nimport { buildVersionCollectionFields } from 'payload'\nimport toSnakeCase from 'to-snake-case'\n\nimport type { DrizzleAdapter } from './types.js'\n\nimport { findMany } from './find/findMany.js'\n\nexport const findVersions: FindVersions = async function findVersions(\n  this: DrizzleAdapter,\n  { collection, limit, locale, page, pagination, req, select, sort: sortArg, where },\n) {\n  const collectionConfig: SanitizedCollectionConfig = this.payload.collections[collection].config\n  const sort = sortArg !== undefined && sortArg !== null ? sortArg : collectionConfig.defaultSort\n\n  const tableName = this.tableNameMap.get(\n    `_${toSnakeCase(collectionConfig.slug)}${this.versionsSuffix}`,\n  )\n\n  const fields = buildVersionCollectionFields(this.payload.config, collectionConfig, true)\n\n  return findMany({\n    adapter: this,\n    fields,\n    joins: false,\n    limit,\n    locale,\n    page,\n    pagination,\n    req,\n    select,\n    sort,\n    tableName,\n    where,\n  })\n}\n"],"names":["buildVersionCollectionFields","toSnakeCase","findMany","findVersions","collection","limit","locale","page","pagination","req","select","sort","sortArg","where","collectionConfig","payload","collections","config","undefined","defaultSort","tableName","tableNameMap","get","slug","versionsSuffix","fields","adapter","joins"],"mappings":";;;;AAEA,SAASA,4BAA4B,QAAQ,UAAS;AACtD,OAAOC,iBAAiB,gBAAe;AAIvC,SAASC,QAAQ,QAAQ,qBAAoB;;;;AAEtC,MAAMC,eAA6B,eAAeA,aAEvD,EAAEC,UAAU,EAAEC,KAAK,EAAEC,MAAM,EAAEC,IAAI,EAAEC,UAAU,EAAEC,GAAG,EAAEC,MAAM,EAAEC,MAAMC,OAAO,EAAEC,KAAK,EAAE;IAElF,MAAMC,mBAA8C,IAAI,CAACC,OAAO,CAACC,WAAW,CAACZ,WAAW,CAACa,MAAM;IAC/F,MAAMN,OAAOC,YAAYM,aAAaN,YAAY,OAAOA,UAAUE,iBAAiBK,WAAW;IAE/F,MAAMC,YAAY,IAAI,CAACC,YAAY,CAACC,GAAG,CACrC,CAAC,CAAC,MAAErB,yJAAAA,EAAYa,iBAAiBS,IAAI,IAAI,IAAI,CAACC,cAAc,EAAE;IAGhE,MAAMC,aAASzB,sMAAAA,EAA6B,IAAI,CAACe,OAAO,CAACE,MAAM,EAAEH,kBAAkB;IAEnF,WAAOZ,iLAAAA,EAAS;QACdwB,SAAS,IAAI;QACbD;QACAE,OAAO;QACPtB;QACAC;QACAC;QACAC;QACAC;QACAC;QACAC;QACAS;QACAP;IACF;AACF,EAAC"}},
    {"offset": {"line": 7589, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/utilities/migrationTableExists.ts"],"sourcesContent":["import type { LibSQLDatabase } from 'drizzle-orm/libsql'\n\nimport type { DrizzleAdapter, PostgresDB } from '../types.js'\n\nexport const migrationTableExists = async (\n  adapter: DrizzleAdapter,\n  db?: LibSQLDatabase | PostgresDB,\n): Promise<boolean> => {\n  let statement\n\n  if (adapter.name === 'postgres') {\n    const prependSchema = adapter.schemaName ? `\"${adapter.schemaName}\".` : ''\n    statement = `SELECT to_regclass('${prependSchema}\"payload_migrations\"') AS exists;`\n  }\n\n  if (adapter.name === 'sqlite') {\n    statement = `\n      SELECT CASE\n               WHEN COUNT(*) > 0 THEN 1\n               ELSE 0\n               END AS 'exists'\n      FROM sqlite_master\n      WHERE type = 'table'\n        AND name = 'payload_migrations';`\n  }\n\n  const result = await adapter.execute({\n    drizzle: db ?? adapter.drizzle,\n    raw: statement,\n  })\n\n  const [row] = result.rows\n\n  return row && typeof row === 'object' && 'exists' in row && !!row.exists\n}\n"],"names":["migrationTableExists","adapter","db","statement","name","prependSchema","schemaName","result","execute","drizzle","raw","row","rows","exists"],"mappings":";;;;AAIO,MAAMA,uBAAuB,OAClCC,SACAC;IAEA,IAAIC;IAEJ,IAAIF,QAAQG,IAAI,KAAK,YAAY;QAC/B,MAAMC,gBAAgBJ,QAAQK,UAAU,GAAG,CAAC,CAAC,EAAEL,QAAQK,UAAU,CAAC,EAAE,CAAC,GAAG;QACxEH,YAAY,CAAC,oBAAoB,EAAEE,cAAc,iCAAiC,CAAC;IACrF;IAEA,IAAIJ,QAAQG,IAAI,KAAK,UAAU;QAC7BD,YAAY,CAAC;;;;;;;wCAOuB,CAAC;IACvC;IAEA,MAAMI,SAAS,MAAMN,QAAQO,OAAO,CAAC;QACnCC,SAASP,MAAMD,QAAQQ,OAAO;QAC9BC,KAAKP;IACP;IAEA,MAAM,CAACQ,IAAI,GAAGJ,OAAOK,IAAI;IAEzB,OAAOD,OAAO,OAAOA,QAAQ,YAAY,YAAYA,OAAO,CAAC,CAACA,IAAIE,MAAM;AAC1E,EAAC"}},
    {"offset": {"line": 7620, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/utilities/parseError.ts"],"sourcesContent":["/**\n * Format error message with hint if available\n */\nexport const parseError = (err: unknown, msg: string): string => {\n  let formattedMsg = `${msg}`\n  if (err instanceof Error) {\n    formattedMsg += ` ${err.message}.`\n    // Check if the error has a hint property\n    if ('hint' in err && typeof err.hint === 'string') {\n      formattedMsg += ` ${err.hint}.`\n    }\n  }\n  return formattedMsg\n}\n"],"names":["parseError","err","msg","formattedMsg","Error","message","hint"],"mappings":"AAAA;;CAEC,GACD;;;;AAAO,MAAMA,aAAa,CAACC,KAAcC;IACvC,IAAIC,eAAe,GAAGD,KAAK;IAC3B,IAAID,eAAeG,OAAO;QACxBD,gBAAgB,CAAC,CAAC,EAAEF,IAAII,OAAO,CAAC,CAAC,CAAC;QAClC,yCAAyC;QACzC,IAAI,UAAUJ,OAAO,OAAOA,IAAIK,IAAI,KAAK,UAAU;YACjDH,gBAAgB,CAAC,CAAC,EAAEF,IAAIK,IAAI,CAAC,CAAC,CAAC;QACjC;IACF;IACA,OAAOH;AACT,EAAC"}},
    {"offset": {"line": 7641, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/migrate.ts"],"sourcesContent":["import type { Payload } from 'payload'\n\nimport {\n  commitTransaction,\n  createLocalReq,\n  initTransaction,\n  killTransaction,\n  readMigrationFiles,\n} from 'payload'\nimport prompts from 'prompts'\n\nimport type { DrizzleAdapter, Migration } from './types.js'\n\nimport { getTransaction } from './utilities/getTransaction.js'\nimport { migrationTableExists } from './utilities/migrationTableExists.js'\nimport { parseError } from './utilities/parseError.js'\n\nexport const migrate: DrizzleAdapter['migrate'] = async function migrate(\n  this: DrizzleAdapter,\n  args,\n): Promise<void> {\n  const { payload } = this\n  const migrationFiles = args?.migrations || (await readMigrationFiles({ payload }))\n\n  if (!migrationFiles.length) {\n    payload.logger.info({ msg: 'No migrations to run.' })\n    return\n  }\n\n  if ('createExtensions' in this && typeof this.createExtensions === 'function') {\n    await this.createExtensions()\n  }\n\n  let latestBatch = 0\n  let migrationsInDB = []\n\n  const hasMigrationTable = await migrationTableExists(this)\n\n  if (hasMigrationTable) {\n    ;({ docs: migrationsInDB } = await payload.find({\n      collection: 'payload-migrations',\n      limit: 0,\n      sort: '-name',\n    }))\n\n    if (migrationsInDB.find((m) => m.batch === -1)) {\n      const { confirm: runMigrations } = await prompts(\n        {\n          name: 'confirm',\n          type: 'confirm',\n          initial: false,\n          message:\n            \"It looks like you've run Payload in dev mode, meaning you've dynamically pushed changes to your database.\\n\\n\" +\n            \"If you'd like to run migrations, data loss will occur. Would you like to proceed?\",\n        },\n        {\n          onCancel: () => {\n            process.exit(0)\n          },\n        },\n      )\n\n      if (!runMigrations) {\n        process.exit(0)\n      }\n      // ignore the dev migration so that the latest batch number increments correctly\n      migrationsInDB = migrationsInDB.filter((m) => m.batch !== -1)\n    }\n\n    if (Number(migrationsInDB?.[0]?.batch) > 0) {\n      latestBatch = Number(migrationsInDB[0]?.batch)\n    }\n  }\n\n  const newBatch = latestBatch + 1\n\n  // Execute 'up' function for each migration sequentially\n  for (const migration of migrationFiles) {\n    const alreadyRan = migrationsInDB.find((existing) => existing.name === migration.name)\n\n    // If already ran, skip\n    if (alreadyRan) {\n      continue\n    }\n\n    await runMigrationFile(payload, migration, newBatch)\n  }\n}\n\nasync function runMigrationFile(payload: Payload, migration: Migration, batch: number) {\n  const start = Date.now()\n  const req = await createLocalReq({}, payload)\n\n  payload.logger.info({ msg: `Migrating: ${migration.name}` })\n\n  try {\n    await initTransaction(req)\n    const db = await getTransaction(payload.db as DrizzleAdapter, req)\n    await migration.up({ db, payload, req })\n    payload.logger.info({ msg: `Migrated:  ${migration.name} (${Date.now() - start}ms)` })\n    await payload.create({\n      collection: 'payload-migrations',\n      data: {\n        name: migration.name,\n        batch,\n      },\n      req,\n    })\n    await commitTransaction(req)\n  } catch (err: unknown) {\n    await killTransaction(req)\n    payload.logger.error({\n      err,\n      msg: parseError(err, `Error running migration ${migration.name}`),\n    })\n    process.exit(1)\n  }\n}\n"],"names":["commitTransaction","createLocalReq","initTransaction","killTransaction","readMigrationFiles","prompts","getTransaction","migrationTableExists","parseError","migrate","args","payload","migrationFiles","migrations","length","logger","info","msg","createExtensions","latestBatch","migrationsInDB","hasMigrationTable","docs","find","collection","limit","sort","m","batch","confirm","runMigrations","name","type","initial","message","onCancel","process","exit","filter","Number","newBatch","migration","alreadyRan","existing","runMigrationFile","start","Date","now","req","db","up","create","data","err","error"],"mappings":"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"}},
    {"offset": {"line": 7754, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/migrateDown.ts"],"sourcesContent":["import {\n  commitTransaction,\n  createLocalReq,\n  getMigrations,\n  initTransaction,\n  killTransaction,\n  readMigrationFiles,\n} from 'payload'\n\nimport type { DrizzleAdapter } from './types.js'\n\nimport { getTransaction } from './utilities/getTransaction.js'\nimport { migrationTableExists } from './utilities/migrationTableExists.js'\nimport { parseError } from './utilities/parseError.js'\n\nexport async function migrateDown(this: DrizzleAdapter): Promise<void> {\n  const { payload } = this\n  const migrationFiles = await readMigrationFiles({ payload })\n\n  const { existingMigrations, latestBatch } = await getMigrations({\n    payload,\n  })\n\n  if (!existingMigrations?.length) {\n    payload.logger.info({ msg: 'No migrations to rollback.' })\n    return\n  }\n\n  payload.logger.info({\n    msg: `Rolling back batch ${latestBatch} consisting of ${existingMigrations.length} migration(s).`,\n  })\n\n  const latestBatchMigrations = existingMigrations.filter(({ batch }) => batch === latestBatch)\n\n  for (const migration of latestBatchMigrations) {\n    const migrationFile = migrationFiles.find((m) => m.name === migration.name)\n    if (!migrationFile) {\n      throw new Error(`Migration ${migration.name} not found locally.`)\n    }\n\n    const start = Date.now()\n    const req = await createLocalReq({}, payload)\n\n    try {\n      payload.logger.info({ msg: `Migrating down: ${migrationFile.name}` })\n      await initTransaction(req)\n      const db = await getTransaction(this, req)\n      await migrationFile.down({ db, payload, req })\n      payload.logger.info({\n        msg: `Migrated down:  ${migrationFile.name} (${Date.now() - start}ms)`,\n      })\n\n      const tableExists = await migrationTableExists(this, db)\n\n      if (tableExists) {\n        await payload.delete({\n          id: migration.id,\n          collection: 'payload-migrations',\n          req,\n        })\n      }\n\n      await commitTransaction(req)\n    } catch (err: unknown) {\n      await killTransaction(req)\n\n      payload.logger.error({\n        err,\n        msg: parseError(err, `Error migrating down ${migrationFile.name}. Rolling back.`),\n      })\n      process.exit(1)\n    }\n  }\n}\n"],"names":["commitTransaction","createLocalReq","getMigrations","initTransaction","killTransaction","readMigrationFiles","getTransaction","migrationTableExists","parseError","migrateDown","payload","migrationFiles","existingMigrations","latestBatch","length","logger","info","msg","latestBatchMigrations","filter","batch","migration","migrationFile","find","m","name","Error","start","Date","now","req","db","down","tableExists","delete","id","collection","err","error","process","exit"],"mappings":";;;;;;;;;AAAA,SACEA,iBAAiB,EACjBC,cAAc,EACdC,aAAa,EACbC,eAAe,EACfC,eAAe,EACfC,kBAAkB,QACb,UAAS;AAIhB,SAASC,cAAc,QAAQ,gCAA+B;AAC9D,SAASC,oBAAoB,QAAQ,sCAAqC;AAC1E,SAASC,UAAU,QAAQ,4BAA2B;;;;;AAE/C,eAAeC;IACpB,MAAM,EAAEC,OAAO,EAAE,GAAG,IAAI;IACxB,MAAMC,iBAAiB,UAAMN,uMAAAA,EAAmB;QAAEK;IAAQ;IAE1D,MAAM,EAAEE,kBAAkB,EAAEC,WAAW,EAAE,GAAG,UAAMX,6LAAAA,EAAc;QAC9DQ;IACF;IAEA,IAAI,CAACE,oBAAoBE,QAAQ;QAC/BJ,QAAQK,MAAM,CAACC,IAAI,CAAC;YAAEC,KAAK;QAA6B;QACxD;IACF;IAEAP,QAAQK,MAAM,CAACC,IAAI,CAAC;QAClBC,KAAK,CAAC,mBAAmB,EAAEJ,YAAY,eAAe,EAAED,mBAAmBE,MAAM,CAAC,cAAc,CAAC;IACnG;IAEA,MAAMI,wBAAwBN,mBAAmBO,MAAM,CAAC,CAAC,EAAEC,KAAK,EAAE,GAAKA,UAAUP;IAEjF,KAAK,MAAMQ,aAAaH,sBAAuB;QAC7C,MAAMI,gBAAgBX,eAAeY,IAAI,CAAC,CAACC,IAAMA,EAAEC,IAAI,KAAKJ,UAAUI,IAAI;QAC1E,IAAI,CAACH,eAAe;YAClB,MAAM,IAAII,MAAM,CAAC,UAAU,EAAEL,UAAUI,IAAI,CAAC,mBAAmB,CAAC;QAClE;QAEA,MAAME,QAAQC,KAAKC,GAAG;QACtB,MAAMC,MAAM,UAAM7B,kLAAAA,EAAe,CAAC,GAAGS;QAErC,IAAI;YACFA,QAAQK,MAAM,CAACC,IAAI,CAAC;gBAAEC,KAAK,CAAC,gBAAgB,EAAEK,cAAcG,IAAI,EAAE;YAAC;YACnE,UAAMtB,oLAAAA,EAAgB2B;YACtB,MAAMC,KAAK,UAAMzB,kMAAAA,EAAe,IAAI,EAAEwB;YACtC,MAAMR,cAAcU,IAAI,CAAC;gBAAED;gBAAIrB;gBAASoB;YAAI;YAC5CpB,QAAQK,MAAM,CAACC,IAAI,CAAC;gBAClBC,KAAK,CAAC,gBAAgB,EAAEK,cAAcG,IAAI,CAAC,EAAE,EAAEG,KAAKC,GAAG,KAAKF,MAAM,GAAG,CAAC;YACxE;YAEA,MAAMM,cAAc,UAAM1B,8MAAAA,EAAqB,IAAI,EAAEwB;YAErD,IAAIE,aAAa;gBACf,MAAMvB,QAAQwB,MAAM,CAAC;oBACnBC,IAAId,UAAUc,EAAE;oBAChBC,YAAY;oBACZN;gBACF;YACF;YAEA,UAAM9B,wLAAAA,EAAkB8B;QAC1B,EAAE,OAAOO,KAAc;YACrB,UAAMjC,oLAAAA,EAAgB0B;YAEtBpB,QAAQK,MAAM,CAACuB,KAAK,CAAC;gBACnBD;gBACApB,SAAKT,0LAAAA,EAAW6B,KAAK,CAAC,qBAAqB,EAAEf,cAAcG,IAAI,CAAC,eAAe,CAAC;YAClF;YACAc,QAAQC,IAAI,CAAC;QACf;IACF;AACF"}},
    {"offset": {"line": 7833, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/migrateFresh.ts"],"sourcesContent":["import {\n  commitTransaction,\n  createLocalReq,\n  initTransaction,\n  killTransaction,\n  readMigrationFiles,\n} from 'payload'\nimport prompts from 'prompts'\n\nimport type { DrizzleAdapter } from './types.js'\n\nimport { getTransaction } from './utilities/getTransaction.js'\nimport { parseError } from './utilities/parseError.js'\n\n/**\n * Drop the current database and run all migrate up functions\n */\nexport async function migrateFresh(\n  this: DrizzleAdapter,\n  { forceAcceptWarning = false },\n): Promise<void> {\n  const { payload } = this\n\n  if (forceAcceptWarning === false) {\n    const { confirm: acceptWarning } = await prompts(\n      {\n        name: 'confirm',\n        type: 'confirm',\n        initial: false,\n        message: `WARNING: This will drop your database and run all migrations. Are you sure you want to proceed?`,\n      },\n      {\n        onCancel: () => {\n          process.exit(0)\n        },\n      },\n    )\n\n    if (!acceptWarning) {\n      process.exit(0)\n    }\n  }\n\n  payload.logger.info({\n    msg: `Dropping database.`,\n  })\n\n  await this.dropDatabase({ adapter: this })\n\n  const migrationFiles = await readMigrationFiles({ payload })\n  payload.logger.debug({\n    msg: `Found ${migrationFiles.length} migration files.`,\n  })\n\n  const req = await createLocalReq({}, payload)\n\n  if ('createExtensions' in this && typeof this.createExtensions === 'function') {\n    await this.createExtensions()\n  }\n\n  // Run all migrate up\n  for (const migration of migrationFiles) {\n    payload.logger.info({ msg: `Migrating: ${migration.name}` })\n    try {\n      const start = Date.now()\n      await initTransaction(req)\n      const db = await getTransaction(this, req)\n      await migration.up({ db, payload, req })\n      await payload.create({\n        collection: 'payload-migrations',\n        data: {\n          name: migration.name,\n          batch: 1,\n        },\n        req,\n      })\n      await commitTransaction(req)\n\n      payload.logger.info({ msg: `Migrated:  ${migration.name} (${Date.now() - start}ms)` })\n    } catch (err: unknown) {\n      await killTransaction(req)\n      payload.logger.error({\n        err,\n        msg: parseError(err, `Error running migration ${migration.name}. Rolling back`),\n      })\n      process.exit(1)\n    }\n  }\n}\n"],"names":["commitTransaction","createLocalReq","initTransaction","killTransaction","readMigrationFiles","prompts","getTransaction","parseError","migrateFresh","forceAcceptWarning","payload","confirm","acceptWarning","name","type","initial","message","onCancel","process","exit","logger","info","msg","dropDatabase","adapter","migrationFiles","debug","length","req","createExtensions","migration","start","Date","now","db","up","create","collection","data","batch","err","error"],"mappings":";;;;;;;;AAAA,SACEA,iBAAiB,EACjBC,cAAc,EACdC,eAAe,EACfC,eAAe,EACfC,kBAAkB,QACb,UAAS;AAChB,OAAOC,aAAa,UAAS;AAI7B,SAASC,cAAc,QAAQ,gCAA+B;AAC9D,SAASC,UAAU,QAAQ,4BAA2B;;;;;AAK/C,eAAeC,aAEpB,EAAEC,qBAAqB,KAAK,EAAE;IAE9B,MAAM,EAAEC,OAAO,EAAE,GAAG,IAAI;IAExB,IAAID,uBAAuB,OAAO;QAChC,MAAM,EAAEE,SAASC,aAAa,EAAE,GAAG,UAAMP,6IAAAA,EACvC;YACEQ,MAAM;YACNC,MAAM;YACNC,SAAS;YACTC,SAAS,CAAC,+FAA+F,CAAC;QAC5G,GACA;YACEC,UAAU;gBACRC,QAAQC,IAAI,CAAC;YACf;QACF;QAGF,IAAI,CAACP,eAAe;YAClBM,QAAQC,IAAI,CAAC;QACf;IACF;IAEAT,QAAQU,MAAM,CAACC,IAAI,CAAC;QAClBC,KAAK,CAAC,kBAAkB,CAAC;IAC3B;IAEA,MAAM,IAAI,CAACC,YAAY,CAAC;QAAEC,SAAS,IAAI;IAAC;IAExC,MAAMC,iBAAiB,UAAMrB,uMAAAA,EAAmB;QAAEM;IAAQ;IAC1DA,QAAQU,MAAM,CAACM,KAAK,CAAC;QACnBJ,KAAK,CAAC,MAAM,EAAEG,eAAeE,MAAM,CAAC,iBAAiB,CAAC;IACxD;IAEA,MAAMC,MAAM,UAAM3B,kLAAAA,EAAe,CAAC,GAAGS;IAErC,IAAI,sBAAsB,IAAI,IAAI,OAAO,IAAI,CAACmB,gBAAgB,KAAK,YAAY;QAC7E,MAAM,IAAI,CAACA,gBAAgB;IAC7B;IAEA,qBAAqB;IACrB,KAAK,MAAMC,aAAaL,eAAgB;QACtCf,QAAQU,MAAM,CAACC,IAAI,CAAC;YAAEC,KAAK,CAAC,WAAW,EAAEQ,UAAUjB,IAAI,EAAE;QAAC;QAC1D,IAAI;YACF,MAAMkB,QAAQC,KAAKC,GAAG;YACtB,UAAM/B,oLAAAA,EAAgB0B;YACtB,MAAMM,KAAK,UAAM5B,kMAAAA,EAAe,IAAI,EAAEsB;YACtC,MAAME,UAAUK,EAAE,CAAC;gBAAED;gBAAIxB;gBAASkB;YAAI;YACtC,MAAMlB,QAAQ0B,MAAM,CAAC;gBACnBC,YAAY;gBACZC,MAAM;oBACJzB,MAAMiB,UAAUjB,IAAI;oBACpB0B,OAAO;gBACT;gBACAX;YACF;YACA,UAAM5B,wLAAAA,EAAkB4B;YAExBlB,QAAQU,MAAM,CAACC,IAAI,CAAC;gBAAEC,KAAK,CAAC,WAAW,EAAEQ,UAAUjB,IAAI,CAAC,EAAE,EAAEmB,KAAKC,GAAG,KAAKF,MAAM,GAAG,CAAC;YAAC;QACtF,EAAE,OAAOS,KAAc;YACrB,UAAMrC,oLAAAA,EAAgByB;YACtBlB,QAAQU,MAAM,CAACqB,KAAK,CAAC;gBACnBD;gBACAlB,SAAKf,0LAAAA,EAAWiC,KAAK,CAAC,wBAAwB,EAAEV,UAAUjB,IAAI,CAAC,cAAc,CAAC;YAChF;YACAK,QAAQC,IAAI,CAAC;QACf;IACF;AACF"}},
    {"offset": {"line": 7922, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/migrateRefresh.ts"],"sourcesContent":["import {\n  commitTransaction,\n  createLocalReq,\n  getMigrations,\n  initTransaction,\n  killTransaction,\n  readMigrationFiles,\n} from 'payload'\n\nimport type { DrizzleAdapter } from './types.js'\n\nimport { getTransaction } from './utilities/getTransaction.js'\nimport { migrationTableExists } from './utilities/migrationTableExists.js'\nimport { parseError } from './utilities/parseError.js'\n\n/**\n * Run all migration down functions before running up\n */\nexport async function migrateRefresh(this: DrizzleAdapter) {\n  const { payload } = this\n  const migrationFiles = await readMigrationFiles({ payload })\n\n  const { existingMigrations, latestBatch } = await getMigrations({\n    payload,\n  })\n\n  if (!existingMigrations?.length) {\n    payload.logger.info({ msg: 'No migrations to rollback.' })\n    return\n  }\n\n  payload.logger.info({\n    msg: `Rolling back batch ${latestBatch} consisting of ${existingMigrations.length} migration(s).`,\n  })\n\n  const req = await createLocalReq({}, payload)\n\n  // Reverse order of migrations to rollback\n  existingMigrations.reverse()\n\n  for (const migration of existingMigrations) {\n    try {\n      const migrationFile = migrationFiles.find((m) => m.name === migration.name)\n      if (!migrationFile) {\n        throw new Error(`Migration ${migration.name} not found locally.`)\n      }\n\n      payload.logger.info({ msg: `Migrating down: ${migration.name}` })\n      const start = Date.now()\n      await initTransaction(req)\n      const db = await getTransaction(this, req)\n      await migrationFile.down({ db, payload, req })\n      payload.logger.info({\n        msg: `Migrated down:  ${migration.name} (${Date.now() - start}ms)`,\n      })\n\n      const tableExists = await migrationTableExists(this, db)\n      if (tableExists) {\n        await payload.delete({\n          collection: 'payload-migrations',\n          req,\n          where: {\n            name: {\n              equals: migration.name,\n            },\n          },\n        })\n      }\n      await commitTransaction(req)\n    } catch (err: unknown) {\n      await killTransaction(req)\n      payload.logger.error({\n        err,\n        msg: parseError(err, `Error running migration ${migration.name}. Rolling back.`),\n      })\n      process.exit(1)\n    }\n  }\n\n  // Run all migrate up\n  for (const migration of migrationFiles) {\n    payload.logger.info({ msg: `Migrating: ${migration.name}` })\n    try {\n      const start = Date.now()\n      await initTransaction(req)\n      await migration.up({ payload, req })\n      await payload.create({\n        collection: 'payload-migrations',\n        data: {\n          name: migration.name,\n          executed: true,\n        },\n        req,\n      })\n      await commitTransaction(req)\n\n      payload.logger.info({ msg: `Migrated:  ${migration.name} (${Date.now() - start}ms)` })\n    } catch (err: unknown) {\n      await killTransaction(req)\n      payload.logger.error({\n        err,\n        msg: parseError(err, `Error running migration ${migration.name}. Rolling back.`),\n      })\n      process.exit(1)\n    }\n  }\n}\n"],"names":["commitTransaction","createLocalReq","getMigrations","initTransaction","killTransaction","readMigrationFiles","getTransaction","migrationTableExists","parseError","migrateRefresh","payload","migrationFiles","existingMigrations","latestBatch","length","logger","info","msg","req","reverse","migration","migrationFile","find","m","name","Error","start","Date","now","db","down","tableExists","delete","collection","where","equals","err","error","process","exit","up","create","data","executed"],"mappings":"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"}},
    {"offset": {"line": 8039, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/migrateReset.ts"],"sourcesContent":["import {\n  commitTransaction,\n  createLocalReq,\n  getMigrations,\n  initTransaction,\n  killTransaction,\n  readMigrationFiles,\n} from 'payload'\n\nimport type { DrizzleAdapter } from './types.js'\n\nimport { getTransaction } from './utilities/getTransaction.js'\nimport { migrationTableExists } from './utilities/migrationTableExists.js'\n\n/**\n * Run all migrate down functions\n */\nexport async function migrateReset(this: DrizzleAdapter): Promise<void> {\n  const { payload } = this\n  const migrationFiles = await readMigrationFiles({ payload })\n\n  const { existingMigrations } = await getMigrations({ payload })\n\n  if (!existingMigrations?.length) {\n    payload.logger.info({ msg: 'No migrations to reset.' })\n    return\n  }\n\n  const req = await createLocalReq({}, payload)\n\n  existingMigrations.reverse()\n\n  // Rollback all migrations in order\n  for (const migration of existingMigrations) {\n    const migrationFile = migrationFiles.find((m) => m.name === migration.name)\n    try {\n      if (!migrationFile) {\n        throw new Error(`Migration ${migration.name} not found locally.`)\n      }\n\n      const start = Date.now()\n      payload.logger.info({ msg: `Migrating down: ${migrationFile.name}` })\n      await initTransaction(req)\n      const db = await getTransaction(this, req)\n      await migrationFile.down({ db, payload, req })\n      payload.logger.info({\n        msg: `Migrated down:  ${migrationFile.name} (${Date.now() - start}ms)`,\n      })\n\n      const tableExists = await migrationTableExists(this, db)\n      if (tableExists) {\n        await payload.delete({\n          id: migration.id,\n          collection: 'payload-migrations',\n          req,\n        })\n      }\n\n      await commitTransaction(req)\n    } catch (err: unknown) {\n      let msg = `Error running migration ${migrationFile.name}.`\n\n      if (err instanceof Error) {\n        msg += ` ${err.message}`\n      }\n\n      await killTransaction(req)\n      payload.logger.error({\n        err,\n        msg,\n      })\n      process.exit(1)\n    }\n  }\n\n  // Delete dev migration\n\n  const tableExists = await migrationTableExists(this)\n  if (tableExists) {\n    try {\n      await payload.delete({\n        collection: 'payload-migrations',\n        where: {\n          batch: {\n            equals: -1,\n          },\n        },\n      })\n    } catch (err: unknown) {\n      payload.logger.error({ err, msg: 'Error deleting dev migration' })\n    }\n  }\n}\n"],"names":["commitTransaction","createLocalReq","getMigrations","initTransaction","killTransaction","readMigrationFiles","getTransaction","migrationTableExists","migrateReset","payload","migrationFiles","existingMigrations","length","logger","info","msg","req","reverse","migration","migrationFile","find","m","name","Error","start","Date","now","db","down","tableExists","delete","id","collection","err","message","error","process","exit","where","batch","equals"],"mappings":";;;;;;;;;AAAA,SACEA,iBAAiB,EACjBC,cAAc,EACdC,aAAa,EACbC,eAAe,EACfC,eAAe,EACfC,kBAAkB,QACb,UAAS;AAIhB,SAASC,cAAc,QAAQ,gCAA+B;AAC9D,SAASC,oBAAoB,QAAQ,sCAAqC;;;;AAKnE,eAAeC;IACpB,MAAM,EAAEC,OAAO,EAAE,GAAG,IAAI;IACxB,MAAMC,iBAAiB,UAAML,uMAAAA,EAAmB;QAAEI;IAAQ;IAE1D,MAAM,EAAEE,kBAAkB,EAAE,GAAG,UAAMT,6LAAAA,EAAc;QAAEO;IAAQ;IAE7D,IAAI,CAACE,oBAAoBC,QAAQ;QAC/BH,QAAQI,MAAM,CAACC,IAAI,CAAC;YAAEC,KAAK;QAA0B;QACrD;IACF;IAEA,MAAMC,MAAM,UAAMf,kLAAAA,EAAe,CAAC,GAAGQ;IAErCE,mBAAmBM,OAAO;IAE1B,mCAAmC;IACnC,KAAK,MAAMC,aAAaP,mBAAoB;QAC1C,MAAMQ,gBAAgBT,eAAeU,IAAI,CAAC,CAACC,IAAMA,EAAEC,IAAI,KAAKJ,UAAUI,IAAI;QAC1E,IAAI;YACF,IAAI,CAACH,eAAe;gBAClB,MAAM,IAAII,MAAM,CAAC,UAAU,EAAEL,UAAUI,IAAI,CAAC,mBAAmB,CAAC;YAClE;YAEA,MAAME,QAAQC,KAAKC,GAAG;YACtBjB,QAAQI,MAAM,CAACC,IAAI,CAAC;gBAAEC,KAAK,CAAC,gBAAgB,EAAEI,cAAcG,IAAI,EAAE;YAAC;YACnE,UAAMnB,oLAAAA,EAAgBa;YACtB,MAAMW,KAAK,UAAMrB,kMAAAA,EAAe,IAAI,EAAEU;YACtC,MAAMG,cAAcS,IAAI,CAAC;gBAAED;gBAAIlB;gBAASO;YAAI;YAC5CP,QAAQI,MAAM,CAACC,IAAI,CAAC;gBAClBC,KAAK,CAAC,gBAAgB,EAAEI,cAAcG,IAAI,CAAC,EAAE,EAAEG,KAAKC,GAAG,KAAKF,MAAM,GAAG,CAAC;YACxE;YAEA,MAAMK,cAAc,UAAMtB,8MAAAA,EAAqB,IAAI,EAAEoB;YACrD,IAAIE,aAAa;gBACf,MAAMpB,QAAQqB,MAAM,CAAC;oBACnBC,IAAIb,UAAUa,EAAE;oBAChBC,YAAY;oBACZhB;gBACF;YACF;YAEA,UAAMhB,wLAAAA,EAAkBgB;QAC1B,EAAE,OAAOiB,KAAc;YACrB,IAAIlB,MAAM,CAAC,wBAAwB,EAAEI,cAAcG,IAAI,CAAC,CAAC,CAAC;YAE1D,IAAIW,eAAeV,OAAO;gBACxBR,OAAO,CAAC,CAAC,EAAEkB,IAAIC,OAAO,EAAE;YAC1B;YAEA,UAAM9B,oLAAAA,EAAgBY;YACtBP,QAAQI,MAAM,CAACsB,KAAK,CAAC;gBACnBF;gBACAlB;YACF;YACAqB,QAAQC,IAAI,CAAC;QACf;IACF;IAEA,uBAAuB;IAEvB,MAAMR,cAAc,UAAMtB,8MAAAA,EAAqB,IAAI;IACnD,IAAIsB,aAAa;QACf,IAAI;YACF,MAAMpB,QAAQqB,MAAM,CAAC;gBACnBE,YAAY;gBACZM,OAAO;oBACLC,OAAO;wBACLC,QAAQ,CAAC;oBACX;gBACF;YACF;QACF,EAAE,OAAOP,KAAc;YACrBxB,QAAQI,MAAM,CAACsB,KAAK,CAAC;gBAAEF;gBAAKlB,KAAK;YAA+B;QAClE;IACF;AACF"}},
    {"offset": {"line": 8137, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/migrateStatus.ts"],"sourcesContent":["import { Table } from 'console-table-printer'\nimport { getMigrations, readMigrationFiles } from 'payload'\n\nimport type { DrizzleAdapter } from './types.js'\n\nimport { migrationTableExists } from './utilities/migrationTableExists.js'\n\nexport async function migrateStatus(this: DrizzleAdapter): Promise<void> {\n  const { payload } = this\n  const migrationFiles = await readMigrationFiles({ payload })\n\n  payload.logger.debug({\n    msg: `Found ${migrationFiles.length} migration files.`,\n  })\n\n  let existingMigrations = []\n  const hasMigrationTable = await migrationTableExists(this)\n\n  if (hasMigrationTable) {\n    ;({ existingMigrations } = await getMigrations({ payload }))\n  }\n\n  if (!migrationFiles.length) {\n    payload.logger.info({ msg: 'No migrations found.' })\n    return\n  }\n\n  // Compare migration files to existing migrations\n  const statuses = migrationFiles.map((migration) => {\n    const existingMigration = existingMigrations.find((m) => m.name === migration.name)\n    return {\n      Name: migration.name,\n\n      Batch: existingMigration?.batch,\n      Ran: existingMigration ? 'Yes' : 'No',\n    }\n  })\n\n  const p = new Table()\n\n  statuses.forEach((s) => {\n    p.addRow(s, {\n      color: s.Ran === 'Yes' ? 'green' : 'red',\n    })\n  })\n  p.printTable()\n}\n"],"names":["Table","getMigrations","readMigrationFiles","migrationTableExists","migrateStatus","payload","migrationFiles","logger","debug","msg","length","existingMigrations","hasMigrationTable","info","statuses","map","migration","existingMigration","find","m","name","Name","Batch","batch","Ran","p","forEach","s","addRow","color","printTable"],"mappings":";;;;AAAA,SAASA,KAAK,QAAQ,wBAAuB;;AAC7C,SAASC,aAAa,EAAEC,kBAAkB,QAAQ,UAAS;AAI3D,SAASC,oBAAoB,QAAQ,sCAAqC;;;;AAEnE,eAAeC;IACpB,MAAM,EAAEC,OAAO,EAAE,GAAG,IAAI;IACxB,MAAMC,iBAAiB,UAAMJ,uMAAAA,EAAmB;QAAEG;IAAQ;IAE1DA,QAAQE,MAAM,CAACC,KAAK,CAAC;QACnBC,KAAK,CAAC,MAAM,EAAEH,eAAeI,MAAM,CAAC,iBAAiB,CAAC;IACxD;IAEA,IAAIC,qBAAqB,EAAE;IAC3B,MAAMC,oBAAoB,UAAMT,8MAAAA,EAAqB,IAAI;IAEzD,IAAIS,mBAAmB;;QACnB,CAAA,EAAED,kBAAkB,EAAE,GAAG,UAAMV,6LAAAA,EAAc;YAAEI;QAAQ,EAAC;IAC5D;IAEA,IAAI,CAACC,eAAeI,MAAM,EAAE;QAC1BL,QAAQE,MAAM,CAACM,IAAI,CAAC;YAAEJ,KAAK;QAAuB;QAClD;IACF;IAEA,iDAAiD;IACjD,MAAMK,WAAWR,eAAeS,GAAG,CAAC,CAACC;QACnC,MAAMC,oBAAoBN,mBAAmBO,IAAI,CAAC,CAACC,IAAMA,EAAEC,IAAI,KAAKJ,UAAUI,IAAI;QAClF,OAAO;YACLC,MAAML,UAAUI,IAAI;YAEpBE,OAAOL,mBAAmBM;YAC1BC,KAAKP,oBAAoB,QAAQ;QACnC;IACF;IAEA,MAAMQ,IAAI,IAAIzB,uKAAAA;IAEdc,SAASY,OAAO,CAAC,CAACC;QAChBF,EAAEG,MAAM,CAACD,GAAG;YACVE,OAAOF,EAAEH,GAAG,KAAK,QAAQ,UAAU;QACrC;IACF;IACAC,EAAEK,UAAU;AACd"}},
    {"offset": {"line": 8191, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/queryDrafts.ts"],"sourcesContent":["import type { QueryDrafts, SanitizedCollectionConfig } from 'payload'\n\nimport { buildVersionCollectionFields, combineQueries } from 'payload'\nimport toSnakeCase from 'to-snake-case'\n\nimport type { DrizzleAdapter } from './types.js'\n\nimport { findMany } from './find/findMany.js'\n\nexport const queryDrafts: QueryDrafts = async function queryDrafts(\n  this: DrizzleAdapter,\n  { collection, joins, limit, locale, page = 1, pagination, req, select, sort, where },\n) {\n  const collectionConfig: SanitizedCollectionConfig = this.payload.collections[collection].config\n  const tableName = this.tableNameMap.get(\n    `_${toSnakeCase(collectionConfig.slug)}${this.versionsSuffix}`,\n  )\n  const fields = buildVersionCollectionFields(this.payload.config, collectionConfig, true)\n\n  const combinedWhere = combineQueries({ latest: { equals: true } }, where)\n\n  const result = await findMany({\n    adapter: this,\n    collectionSlug: collection,\n    fields,\n    joins,\n    limit,\n    locale,\n    page,\n    pagination,\n    req,\n    select,\n    sort,\n    tableName,\n    versions: true,\n    where: combinedWhere,\n  })\n\n  return {\n    ...result,\n    docs: result.docs.map((doc) => {\n      doc = {\n        id: doc.parent,\n        ...doc.version,\n      }\n\n      return doc\n    }),\n  }\n}\n"],"names":["buildVersionCollectionFields","combineQueries","toSnakeCase","findMany","queryDrafts","collection","joins","limit","locale","page","pagination","req","select","sort","where","collectionConfig","payload","collections","config","tableName","tableNameMap","get","slug","versionsSuffix","fields","combinedWhere","latest","equals","result","adapter","collectionSlug","versions","docs","map","doc","id","parent","version"],"mappings":";;;;;AAEA,SAASA,4BAA4B,EAAEC,cAAc,QAAQ,UAAS;AACtE,OAAOC,iBAAiB,gBAAe;AAIvC,SAASC,QAAQ,QAAQ,qBAAoB;;;;AAEtC,MAAMC,cAA2B,eAAeA,YAErD,EAAEC,UAAU,EAAEC,KAAK,EAAEC,KAAK,EAAEC,MAAM,EAAEC,OAAO,CAAC,EAAEC,UAAU,EAAEC,GAAG,EAAEC,MAAM,EAAEC,IAAI,EAAEC,KAAK,EAAE;IAEpF,MAAMC,mBAA8C,IAAI,CAACC,OAAO,CAACC,WAAW,CAACZ,WAAW,CAACa,MAAM;IAC/F,MAAMC,YAAY,IAAI,CAACC,YAAY,CAACC,GAAG,CACrC,CAAC,CAAC,MAAEnB,yJAAAA,EAAYa,iBAAiBO,IAAI,IAAI,IAAI,CAACC,cAAc,EAAE;IAEhE,MAAMC,aAASxB,sMAAAA,EAA6B,IAAI,CAACgB,OAAO,CAACE,MAAM,EAAEH,kBAAkB;IAEnF,MAAMU,oBAAgBxB,iLAAAA,EAAe;QAAEyB,QAAQ;YAAEC,QAAQ;QAAK;IAAE,GAAGb;IAEnE,MAAMc,SAAS,UAAMzB,iLAAAA,EAAS;QAC5B0B,SAAS,IAAI;QACbC,gBAAgBzB;QAChBmB;QACAlB;QACAC;QACAC;QACAC;QACAC;QACAC;QACAC;QACAC;QACAM;QACAY,UAAU;QACVjB,OAAOW;IACT;IAEA,OAAO;QACL,GAAGG,MAAM;QACTI,MAAMJ,OAAOI,IAAI,CAACC,GAAG,CAAC,CAACC;YACrBA,MAAM;gBACJC,IAAID,IAAIE,MAAM;gBACd,GAAGF,IAAIG,OAAO;YAChB;YAEA,OAAOH;QACT;IACF;AACF,EAAC"}},
    {"offset": {"line": 8242, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/transactions/rollbackTransaction.ts"],"sourcesContent":["import type { RollbackTransaction } from 'payload'\n\nexport const rollbackTransaction: RollbackTransaction = async function rollbackTransaction(\n  incomingID = '',\n) {\n  const transactionID = incomingID instanceof Promise ? await incomingID : incomingID\n\n  // if multiple operations are using the same transaction, the first will flow through and delete the session.\n  // subsequent calls should be ignored.\n  if (!this.sessions[transactionID]) {\n    return\n  }\n\n  const session = this.sessions[transactionID]\n\n  // Delete from registry FIRST to prevent race conditions\n  // This ensures other operations can't retrieve this session while we're ending it\n  delete this.sessions[transactionID]\n\n  // end the session promise in failure by calling reject\n  await session.reject()\n}\n"],"names":["rollbackTransaction","incomingID","transactionID","Promise","sessions","session","reject"],"mappings":";;;;AAEO,MAAMA,sBAA2C,eAAeA,oBACrEC,aAAa,EAAE;IAEf,MAAMC,gBAAgBD,sBAAsBE,UAAU,MAAMF,aAAaA;IAEzE,6GAA6G;IAC7G,sCAAsC;IACtC,IAAI,CAAC,IAAI,CAACG,QAAQ,CAACF,cAAc,EAAE;QACjC;IACF;IAEA,MAAMG,UAAU,IAAI,CAACD,QAAQ,CAACF,cAAc;IAE5C,wDAAwD;IACxD,kFAAkF;IAClF,OAAO,IAAI,CAACE,QAAQ,CAACF,cAAc;IAEnC,uDAAuD;IACvD,MAAMG,QAAQC,MAAM;AACtB,EAAC"}},
    {"offset": {"line": 8264, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/updateGlobal.ts"],"sourcesContent":["import type { UpdateGlobalArgs } from 'payload'\n\nimport toSnakeCase from 'to-snake-case'\n\nimport type { DrizzleAdapter } from './types.js'\n\nimport { upsertRow } from './upsertRow/index.js'\nimport { getTransaction } from './utilities/getTransaction.js'\n\nexport async function updateGlobal<T extends Record<string, unknown>>(\n  this: DrizzleAdapter,\n  { slug, data, req, returning, select }: UpdateGlobalArgs,\n): Promise<T> {\n  const globalConfig = this.payload.globals.config.find((config) => config.slug === slug)\n  const tableName = this.tableNameMap.get(toSnakeCase(globalConfig.slug))\n\n  const db = await getTransaction(this, req)\n  const existingGlobal = await db.query[tableName].findFirst({})\n\n  const result = await upsertRow<{ globalType: string } & T>({\n    ...(existingGlobal ? { id: existingGlobal.id, operation: 'update' } : { operation: 'create' }),\n    adapter: this,\n    data,\n    db,\n    fields: globalConfig.flattenedFields,\n    globalSlug: slug,\n    ignoreResult: returning === false,\n    req,\n    select,\n    tableName,\n  })\n\n  if (returning === false) {\n    return null\n  }\n\n  result.globalType = slug\n\n  return result\n}\n"],"names":["toSnakeCase","upsertRow","getTransaction","updateGlobal","slug","data","req","returning","select","globalConfig","payload","globals","config","find","tableName","tableNameMap","get","db","existingGlobal","query","findFirst","result","id","operation","adapter","fields","flattenedFields","globalSlug","ignoreResult","globalType"],"mappings":";;;;AAEA,OAAOA,iBAAiB,gBAAe;AAIvC,SAASC,SAAS,QAAQ,uBAAsB;AAChD,SAASC,cAAc,QAAQ,gCAA+B;;;;AAEvD,eAAeC,aAEpB,EAAEC,IAAI,EAAEC,IAAI,EAAEC,GAAG,EAAEC,SAAS,EAAEC,MAAM,EAAoB;IAExD,MAAMC,eAAe,IAAI,CAACC,OAAO,CAACC,OAAO,CAACC,MAAM,CAACC,IAAI,CAAC,CAACD,SAAWA,OAAOR,IAAI,KAAKA;IAClF,MAAMU,YAAY,IAAI,CAACC,YAAY,CAACC,GAAG,KAAChB,yJAAAA,EAAYS,aAAaL,IAAI;IAErE,MAAMa,KAAK,UAAMf,kMAAAA,EAAe,IAAI,EAAEI;IACtC,MAAMY,iBAAiB,MAAMD,GAAGE,KAAK,CAACL,UAAU,CAACM,SAAS,CAAC,CAAC;IAE5D,MAAMC,SAAS,UAAMpB,oLAAAA,EAAsC;QACzD,GAAIiB,iBAAiB;YAAEI,IAAIJ,eAAeI,EAAE;YAAEC,WAAW;QAAS,IAAI;YAAEA,WAAW;QAAS,CAAC;QAC7FC,SAAS,IAAI;QACbnB;QACAY;QACAQ,QAAQhB,aAAaiB,eAAe;QACpCC,YAAYvB;QACZwB,cAAcrB,cAAc;QAC5BD;QACAE;QACAM;IACF;IAEA,IAAIP,cAAc,OAAO;QACvB,OAAO;IACT;IAEAc,OAAOQ,UAAU,GAAGzB;IAEpB,OAAOiB;AACT"}},
    {"offset": {"line": 8306, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/updateGlobalVersion.ts"],"sourcesContent":["import type {\n  JsonObject,\n  SanitizedGlobalConfig,\n  TypeWithVersion,\n  UpdateGlobalVersionArgs,\n} from 'payload'\n\nimport { buildVersionGlobalFields } from 'payload'\nimport toSnakeCase from 'to-snake-case'\n\nimport type { DrizzleAdapter } from './types.js'\n\nimport { buildQuery } from './queries/buildQuery.js'\nimport { upsertRow } from './upsertRow/index.js'\nimport { getTransaction } from './utilities/getTransaction.js'\n\nexport async function updateGlobalVersion<T extends JsonObject = JsonObject>(\n  this: DrizzleAdapter,\n  {\n    id,\n    global,\n    locale,\n    req,\n    returning,\n    select,\n    versionData,\n    where: whereArg,\n  }: UpdateGlobalVersionArgs<T>,\n): Promise<TypeWithVersion<T>> {\n  const globalConfig: SanitizedGlobalConfig = this.payload.globals.config.find(\n    ({ slug }) => slug === global,\n  )\n  const whereToUse = whereArg || { id: { equals: id } }\n\n  const tableName = this.tableNameMap.get(\n    `_${toSnakeCase(globalConfig.slug)}${this.versionsSuffix}`,\n  )\n\n  const fields = buildVersionGlobalFields(this.payload.config, globalConfig, true)\n\n  const { where } = buildQuery({\n    adapter: this,\n    fields,\n    locale,\n    tableName,\n    where: whereToUse,\n  })\n\n  const db = await getTransaction(this, req)\n\n  const result = await upsertRow<TypeWithVersion<T>>({\n    id,\n    adapter: this,\n    data: versionData,\n    db,\n    fields,\n    globalSlug: global,\n    ignoreResult: returning === false,\n    operation: 'update',\n    req,\n    select,\n    tableName,\n    where,\n  })\n\n  if (returning === false) {\n    return null\n  }\n\n  return result\n}\n"],"names":["buildVersionGlobalFields","toSnakeCase","buildQuery","upsertRow","getTransaction","updateGlobalVersion","id","global","locale","req","returning","select","versionData","where","whereArg","globalConfig","payload","globals","config","find","slug","whereToUse","equals","tableName","tableNameMap","get","versionsSuffix","fields","adapter","db","result","data","globalSlug","ignoreResult","operation"],"mappings":";;;;AAOA,SAASA,wBAAwB,QAAQ,UAAS;AAClD,OAAOC,iBAAiB,gBAAe;AAIvC,SAASC,UAAU,QAAQ,0BAAyB;AACpD,SAASC,SAAS,QAAQ,uBAAsB;AAChD,SAASC,cAAc,QAAQ,gCAA+B;;;;;;AAEvD,eAAeC,oBAEpB,EACEC,EAAE,EACFC,MAAM,EACNC,MAAM,EACNC,GAAG,EACHC,SAAS,EACTC,MAAM,EACNC,WAAW,EACXC,OAAOC,QAAQ,EACY;IAE7B,MAAMC,eAAsC,IAAI,CAACC,OAAO,CAACC,OAAO,CAACC,MAAM,CAACC,IAAI,CAC1E,CAAC,EAAEC,IAAI,EAAE,GAAKA,SAASb;IAEzB,MAAMc,aAAaP,YAAY;QAAER,IAAI;YAAEgB,QAAQhB;QAAG;IAAE;IAEpD,MAAMiB,YAAY,IAAI,CAACC,YAAY,CAACC,GAAG,CACrC,CAAC,CAAC,MAAExB,yJAAAA,EAAYc,aAAaK,IAAI,IAAI,IAAI,CAACM,cAAc,EAAE;IAG5D,MAAMC,aAAS3B,8LAAAA,EAAyB,IAAI,CAACgB,OAAO,CAACE,MAAM,EAAEH,cAAc;IAE3E,MAAM,EAAEF,KAAK,EAAE,OAAGX,wLAAAA,EAAW;QAC3B0B,SAAS,IAAI;QACbD;QACAnB;QACAe;QACAV,OAAOQ;IACT;IAEA,MAAMQ,KAAK,UAAMzB,kMAAAA,EAAe,IAAI,EAAEK;IAEtC,MAAMqB,SAAS,UAAM3B,oLAAAA,EAA8B;QACjDG;QACAsB,SAAS,IAAI;QACbG,MAAMnB;QACNiB;QACAF;QACAK,YAAYzB;QACZ0B,cAAcvB,cAAc;QAC5BwB,WAAW;QACXzB;QACAE;QACAY;QACAV;IACF;IAEA,IAAIH,cAAc,OAAO;QACvB,OAAO;IACT;IAEA,OAAOoB;AACT"}},
    {"offset": {"line": 8360, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/updateJobs.ts"],"sourcesContent":["import type { UpdateJobs, Where } from 'payload'\n\nimport toSnakeCase from 'to-snake-case'\n\nimport type { DrizzleAdapter } from './types.js'\n\nimport { findMany } from './find/findMany.js'\nimport { upsertRow } from './upsertRow/index.js'\nimport { shouldUseOptimizedUpsertRow } from './upsertRow/shouldUseOptimizedUpsertRow.js'\nimport { getTransaction } from './utilities/getTransaction.js'\n\nexport const updateJobs: UpdateJobs = async function updateMany(\n  this: DrizzleAdapter,\n  { id, data, limit: limitArg, req, returning, sort: sortArg, where: whereArg },\n) {\n  if (\n    !(data?.log as object[])?.length &&\n    !(data.log && typeof data.log === 'object' && '$push' in data.log)\n  ) {\n    delete data.log\n  }\n\n  const whereToUse: Where = id ? { id: { equals: id } } : whereArg\n  const limit = id ? 1 : limitArg\n\n  const collection = this.payload.collections['payload-jobs'].config\n  const tableName = this.tableNameMap.get(toSnakeCase(collection.slug))\n  const sort = sortArg !== undefined && sortArg !== null ? sortArg : collection.defaultSort\n\n  const useOptimizedUpsertRow = shouldUseOptimizedUpsertRow({\n    data,\n    fields: collection.flattenedFields,\n  })\n\n  if (useOptimizedUpsertRow && id) {\n    const db = await getTransaction(this, req)\n\n    const result = await upsertRow({\n      id,\n      adapter: this,\n      collectionSlug: 'payload-jobs',\n      data,\n      db,\n      fields: collection.flattenedFields,\n      ignoreResult: returning === false,\n      operation: 'update',\n      req,\n      tableName,\n    })\n\n    return returning === false ? null : [result]\n  }\n\n  const jobs = await findMany({\n    adapter: this,\n    collectionSlug: 'payload-jobs',\n    fields: collection.flattenedFields,\n    limit: id ? 1 : limit,\n    pagination: false,\n    req,\n    sort,\n    tableName,\n    where: whereToUse,\n  })\n  if (!jobs.docs.length) {\n    return []\n  }\n\n  const db = await getTransaction(this, req)\n\n  const results = []\n\n  // TODO: We need to batch this to reduce the amount of db calls. This can get very slow if we are updating a lot of rows.\n  for (const job of jobs.docs) {\n    const updateData = useOptimizedUpsertRow\n      ? data\n      : {\n          ...job,\n          ...data,\n        }\n\n    const result = await upsertRow({\n      id: job.id,\n      adapter: this,\n      collectionSlug: 'payload-jobs',\n      data: updateData,\n      db,\n      fields: collection.flattenedFields,\n      ignoreResult: returning === false,\n      operation: 'update',\n      req,\n      tableName,\n    })\n\n    results.push(result)\n  }\n\n  if (returning === false) {\n    return null\n  }\n\n  return results\n}\n"],"names":["toSnakeCase","findMany","upsertRow","shouldUseOptimizedUpsertRow","getTransaction","updateJobs","updateMany","id","data","limit","limitArg","req","returning","sort","sortArg","where","whereArg","log","length","whereToUse","equals","collection","payload","collections","config","tableName","tableNameMap","get","slug","undefined","defaultSort","useOptimizedUpsertRow","fields","flattenedFields","db","result","adapter","collectionSlug","ignoreResult","operation","jobs","pagination","docs","results","job","updateData","push"],"mappings":";;;;AAEA,OAAOA,iBAAiB,gBAAe;AAIvC,SAASC,QAAQ,QAAQ,qBAAoB;AAC7C,SAASC,SAAS,QAAQ,uBAAsB;AAChD,SAASC,2BAA2B,QAAQ,6CAA4C;AACxF,SAASC,cAAc,QAAQ,gCAA+B;;;;;;AAEvD,MAAMC,aAAyB,eAAeC,WAEnD,EAAEC,EAAE,EAAEC,IAAI,EAAEC,OAAOC,QAAQ,EAAEC,GAAG,EAAEC,SAAS,EAAEC,MAAMC,OAAO,EAAEC,OAAOC,QAAQ,EAAE;IAE7E,IACE,CAAER,MAAMS,KAAkBC,UAC1B,CAAEV,CAAAA,KAAKS,GAAG,IAAI,OAAOT,KAAKS,GAAG,KAAK,YAAY,WAAWT,KAAKS,GAAE,GAChE;QACA,OAAOT,KAAKS,GAAG;IACjB;IAEA,MAAME,aAAoBZ,KAAK;QAAEA,IAAI;YAAEa,QAAQb;QAAG;IAAE,IAAIS;IACxD,MAAMP,QAAQF,KAAK,IAAIG;IAEvB,MAAMW,aAAa,IAAI,CAACC,OAAO,CAACC,WAAW,CAAC,eAAe,CAACC,MAAM;IAClE,MAAMC,YAAY,IAAI,CAACC,YAAY,CAACC,GAAG,KAAC3B,yJAAAA,EAAYqB,WAAWO,IAAI;IACnE,MAAMf,OAAOC,YAAYe,aAAaf,YAAY,OAAOA,UAAUO,WAAWS,WAAW;IAEzF,MAAMC,4BAAwB5B,4NAAAA,EAA4B;QACxDK;QACAwB,QAAQX,WAAWY,eAAe;IACpC;IAEA,IAAIF,yBAAyBxB,IAAI;QAC/B,MAAM2B,KAAK,UAAM9B,kMAAAA,EAAe,IAAI,EAAEO;QAEtC,MAAMwB,SAAS,UAAMjC,oLAAAA,EAAU;YAC7BK;YACA6B,SAAS,IAAI;YACbC,gBAAgB;YAChB7B;YACA0B;YACAF,QAAQX,WAAWY,eAAe;YAClCK,cAAc1B,cAAc;YAC5B2B,WAAW;YACX5B;YACAc;QACF;QAEA,OAAOb,cAAc,QAAQ,OAAO;YAACuB;SAAO;IAC9C;IAEA,MAAMK,OAAO,UAAMvC,iLAAAA,EAAS;QAC1BmC,SAAS,IAAI;QACbC,gBAAgB;QAChBL,QAAQX,WAAWY,eAAe;QAClCxB,OAAOF,KAAK,IAAIE;QAChBgC,YAAY;QACZ9B;QACAE;QACAY;QACAV,OAAOI;IACT;IACA,IAAI,CAACqB,KAAKE,IAAI,CAACxB,MAAM,EAAE;QACrB,OAAO,EAAE;IACX;IAEA,MAAMgB,KAAK,UAAM9B,kMAAAA,EAAe,IAAI,EAAEO;IAEtC,MAAMgC,UAAU,EAAE;IAElB,yHAAyH;IACzH,KAAK,MAAMC,OAAOJ,KAAKE,IAAI,CAAE;QAC3B,MAAMG,aAAad,wBACfvB,OACA;YACE,GAAGoC,GAAG;YACN,GAAGpC,IAAI;QACT;QAEJ,MAAM2B,SAAS,UAAMjC,oLAAAA,EAAU;YAC7BK,IAAIqC,IAAIrC,EAAE;YACV6B,SAAS,IAAI;YACbC,gBAAgB;YAChB7B,MAAMqC;YACNX;YACAF,QAAQX,WAAWY,eAAe;YAClCK,cAAc1B,cAAc;YAC5B2B,WAAW;YACX5B;YACAc;QACF;QAEAkB,QAAQG,IAAI,CAACX;IACf;IAEA,IAAIvB,cAAc,OAAO;QACvB,OAAO;IACT;IAEA,OAAO+B;AACT,EAAC"}},
    {"offset": {"line": 8454, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/updateMany.ts"],"sourcesContent":["import type { LibSQLDatabase } from 'drizzle-orm/libsql'\nimport type { UpdateMany } from 'payload'\n\nimport toSnakeCase from 'to-snake-case'\n\nimport type { DrizzleAdapter } from './types.js'\n\nimport { buildQuery } from './queries/buildQuery.js'\nimport { selectDistinct } from './queries/selectDistinct.js'\nimport { upsertRow } from './upsertRow/index.js'\nimport { getTransaction } from './utilities/getTransaction.js'\n\nexport const updateMany: UpdateMany = async function updateMany(\n  this: DrizzleAdapter,\n  {\n    collection: collectionSlug,\n    data,\n    joins: joinQuery,\n    limit,\n    locale,\n    req,\n    returning,\n    select,\n    sort: sortArg,\n    where: whereToUse,\n  },\n) {\n  const collection = this.payload.collections[collectionSlug].config\n  const tableName = this.tableNameMap.get(toSnakeCase(collection.slug))\n\n  const sort = sortArg !== undefined && sortArg !== null ? sortArg : collection.defaultSort\n\n  const { joins, orderBy, selectFields, where } = buildQuery({\n    adapter: this,\n    fields: collection.flattenedFields,\n    locale,\n    sort,\n    tableName,\n    where: whereToUse,\n  })\n\n  const db = await getTransaction(this, req)\n\n  let idsToUpdate: (number | string)[] = []\n\n  const selectDistinctResult = await selectDistinct({\n    adapter: this,\n    db,\n    joins,\n    query: ({ query }) =>\n      orderBy ? query.orderBy(() => orderBy.map(({ column, order }) => order(column))) : query,\n    selectFields,\n    tableName,\n    where,\n  })\n\n  if (selectDistinctResult?.[0]?.id) {\n    idsToUpdate = selectDistinctResult?.map((doc) => doc.id)\n  } else if (whereToUse && !joins.length) {\n    // If id wasn't passed but `where` without any joins, retrieve it with findFirst\n\n    const _db = db as LibSQLDatabase\n\n    const table = this.tables[tableName]\n\n    let query = _db.select({ id: table.id }).from(table).where(where).$dynamic()\n\n    if (typeof limit === 'number' && limit > 0) {\n      query = query.limit(limit)\n    }\n\n    if (orderBy) {\n      query = query.orderBy(() => orderBy.map(({ column, order }) => order(column)))\n    }\n\n    const docsToUpdate = await query\n\n    idsToUpdate = docsToUpdate?.map((doc) => doc.id)\n  }\n\n  if (!idsToUpdate.length) {\n    return []\n  }\n\n  const results = []\n\n  // TODO: We need to batch this to reduce the amount of db calls. This can get very slow if we are updating a lot of rows.\n  for (const idToUpdate of idsToUpdate) {\n    const result = await upsertRow({\n      id: idToUpdate,\n      adapter: this,\n      collectionSlug,\n      data,\n      db,\n      fields: collection.flattenedFields,\n      ignoreResult: returning === false,\n      joinQuery,\n      operation: 'update',\n      req,\n      select,\n      tableName,\n    })\n    results.push(result)\n  }\n\n  if (returning === false) {\n    return null\n  }\n\n  return results\n}\n"],"names":["toSnakeCase","buildQuery","selectDistinct","upsertRow","getTransaction","updateMany","collection","collectionSlug","data","joins","joinQuery","limit","locale","req","returning","select","sort","sortArg","where","whereToUse","payload","collections","config","tableName","tableNameMap","get","slug","undefined","defaultSort","orderBy","selectFields","adapter","fields","flattenedFields","db","idsToUpdate","selectDistinctResult","query","map","column","order","id","doc","length","_db","table","tables","from","$dynamic","docsToUpdate","results","idToUpdate","result","ignoreResult","operation","push"],"mappings":";;;;AAGA,OAAOA,iBAAiB,gBAAe;AAIvC,SAASC,UAAU,QAAQ,0BAAyB;AACpD,SAASC,cAAc,QAAQ,8BAA6B;AAC5D,SAASC,SAAS,QAAQ,uBAAsB;AAChD,SAASC,cAAc,QAAQ,gCAA+B;;;;;;AAEvD,MAAMC,aAAyB,eAAeA,WAEnD,EACEC,YAAYC,cAAc,EAC1BC,IAAI,EACJC,OAAOC,SAAS,EAChBC,KAAK,EACLC,MAAM,EACNC,GAAG,EACHC,SAAS,EACTC,MAAM,EACNC,MAAMC,OAAO,EACbC,OAAOC,UAAU,EAClB;IAED,MAAMb,aAAa,IAAI,CAACc,OAAO,CAACC,WAAW,CAACd,eAAe,CAACe,MAAM;IAClE,MAAMC,YAAY,IAAI,CAACC,YAAY,CAACC,GAAG,KAACzB,yJAAAA,EAAYM,WAAWoB,IAAI;IAEnE,MAAMV,OAAOC,YAAYU,aAAaV,YAAY,OAAOA,UAAUX,WAAWsB,WAAW;IAEzF,MAAM,EAAEnB,KAAK,EAAEoB,OAAO,EAAEC,YAAY,EAAEZ,KAAK,EAAE,OAAGjB,wLAAAA,EAAW;QACzD8B,SAAS,IAAI;QACbC,QAAQ1B,WAAW2B,eAAe;QAClCrB;QACAI;QACAO;QACAL,OAAOC;IACT;IAEA,MAAMe,KAAK,UAAM9B,kMAAAA,EAAe,IAAI,EAAES;IAEtC,IAAIsB,cAAmC,EAAE;IAEzC,MAAMC,uBAAuB,UAAMlC,gMAAAA,EAAe;QAChD6B,SAAS,IAAI;QACbG;QACAzB;QACA4B,OAAO,CAAC,EAAEA,KAAK,EAAE,GACfR,UAAUQ,MAAMR,OAAO,CAAC,IAAMA,QAAQS,GAAG,CAAC,CAAC,EAAEC,MAAM,EAAEC,KAAK,EAAE,GAAKA,MAAMD,YAAYF;QACrFP;QACAP;QACAL;IACF;IAEA,IAAIkB,sBAAsB,CAAC,EAAE,EAAEK,IAAI;QACjCN,cAAcC,sBAAsBE,IAAI,CAACI,MAAQA,IAAID,EAAE;IACzD,OAAO,IAAItB,cAAc,CAACV,MAAMkC,MAAM,EAAE;QACtC,gFAAgF;QAEhF,MAAMC,MAAMV;QAEZ,MAAMW,QAAQ,IAAI,CAACC,MAAM,CAACvB,UAAU;QAEpC,IAAIc,QAAQO,IAAI7B,MAAM,CAAC;YAAE0B,IAAII,MAAMJ,EAAE;QAAC,GAAGM,IAAI,CAACF,OAAO3B,KAAK,CAACA,OAAO8B,QAAQ;QAE1E,IAAI,OAAOrC,UAAU,YAAYA,QAAQ,GAAG;YAC1C0B,QAAQA,MAAM1B,KAAK,CAACA;QACtB;QAEA,IAAIkB,SAAS;YACXQ,QAAQA,MAAMR,OAAO,CAAC,IAAMA,QAAQS,GAAG,CAAC,CAAC,EAAEC,MAAM,EAAEC,KAAK,EAAE,GAAKA,MAAMD;QACvE;QAEA,MAAMU,eAAe,MAAMZ;QAE3BF,cAAcc,cAAcX,IAAI,CAACI,MAAQA,IAAID,EAAE;IACjD;IAEA,IAAI,CAACN,YAAYQ,MAAM,EAAE;QACvB,OAAO,EAAE;IACX;IAEA,MAAMO,UAAU,EAAE;IAElB,yHAAyH;IACzH,KAAK,MAAMC,cAAchB,YAAa;QACpC,MAAMiB,SAAS,UAAMjD,oLAAAA,EAAU;YAC7BsC,IAAIU;YACJpB,SAAS,IAAI;YACbxB;YACAC;YACA0B;YACAF,QAAQ1B,WAAW2B,eAAe;YAClCoB,cAAcvC,cAAc;YAC5BJ;YACA4C,WAAW;YACXzC;YACAE;YACAQ;QACF;QACA2B,QAAQK,IAAI,CAACH;IACf;IAEA,IAAItC,cAAc,OAAO;QACvB,OAAO;IACT;IAEA,OAAOoC;AACT,EAAC"}},
    {"offset": {"line": 8540, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/updateOne.ts"],"sourcesContent":["import type { LibSQLDatabase } from 'drizzle-orm/libsql'\nimport type { UpdateOne } from 'payload'\n\nimport toSnakeCase from 'to-snake-case'\n\nimport type { DrizzleAdapter } from './types.js'\n\nimport { buildQuery } from './queries/buildQuery.js'\nimport { selectDistinct } from './queries/selectDistinct.js'\nimport { upsertRow } from './upsertRow/index.js'\nimport { getTransaction } from './utilities/getTransaction.js'\n\nexport const updateOne: UpdateOne = async function updateOne(\n  this: DrizzleAdapter,\n  {\n    id,\n    collection: collectionSlug,\n    data,\n    joins: joinQuery,\n    locale,\n    options = { upsert: false },\n    req,\n    returning,\n    select,\n    where: whereArg,\n  },\n) {\n  const collection = this.payload.collections[collectionSlug].config\n  const tableName = this.tableNameMap.get(toSnakeCase(collection.slug))\n  let idToUpdate = id\n\n  const db = await getTransaction(this, req)\n\n  if (!idToUpdate) {\n    const { joins, selectFields, where } = buildQuery({\n      adapter: this,\n      fields: collection.flattenedFields,\n      locale,\n      tableName,\n      where: whereArg,\n    })\n\n    // selectDistinct will only return if there are joins\n    const selectDistinctResult = await selectDistinct({\n      adapter: this,\n      db,\n      joins,\n      query: ({ query }) => query.limit(1),\n      selectFields,\n      tableName,\n      where,\n    })\n\n    if (selectDistinctResult?.[0]?.id) {\n      idToUpdate = selectDistinctResult?.[0]?.id\n      // If id wasn't passed but `where` without any joins, retrieve it with findFirst\n    } else if (whereArg && !joins.length) {\n      const table = this.tables[tableName]\n\n      const docsToUpdate = await (db as LibSQLDatabase)\n        .select({\n          id: table.id,\n        })\n        .from(table)\n        .where(where)\n        .limit(1)\n      idToUpdate = docsToUpdate?.[0]?.id\n    }\n  }\n\n  if (!idToUpdate && !options.upsert) {\n    // TODO: In 4.0, if returning === false, we should differentiate between:\n    // - No document found to update\n    // - Document found, but returning === false\n    return null\n  }\n\n  const result = await upsertRow({\n    id: idToUpdate,\n    adapter: this,\n    collectionSlug,\n    data,\n    db,\n    fields: collection.flattenedFields,\n    ignoreResult: returning === false,\n    joinQuery,\n    operation: 'update',\n    req,\n    select,\n    tableName,\n  })\n\n  if (returning === false) {\n    return null\n  }\n\n  return result\n}\n"],"names":["toSnakeCase","buildQuery","selectDistinct","upsertRow","getTransaction","updateOne","id","collection","collectionSlug","data","joins","joinQuery","locale","options","upsert","req","returning","select","where","whereArg","payload","collections","config","tableName","tableNameMap","get","slug","idToUpdate","db","selectFields","adapter","fields","flattenedFields","selectDistinctResult","query","limit","length","table","tables","docsToUpdate","from","result","ignoreResult","operation"],"mappings":";;;;AAGA,OAAOA,iBAAiB,gBAAe;AAIvC,SAASC,UAAU,QAAQ,0BAAyB;AACpD,SAASC,cAAc,QAAQ,8BAA6B;AAC5D,SAASC,SAAS,QAAQ,uBAAsB;AAChD,SAASC,cAAc,QAAQ,gCAA+B;;;;;;AAEvD,MAAMC,YAAuB,eAAeA,UAEjD,EACEC,EAAE,EACFC,YAAYC,cAAc,EAC1BC,IAAI,EACJC,OAAOC,SAAS,EAChBC,MAAM,EACNC,UAAU;IAAEC,QAAQ;AAAM,CAAC,EAC3BC,GAAG,EACHC,SAAS,EACTC,MAAM,EACNC,OAAOC,QAAQ,EAChB;IAED,MAAMZ,aAAa,IAAI,CAACa,OAAO,CAACC,WAAW,CAACb,eAAe,CAACc,MAAM;IAClE,MAAMC,YAAY,IAAI,CAACC,YAAY,CAACC,GAAG,KAACzB,yJAAAA,EAAYO,WAAWmB,IAAI;IACnE,IAAIC,aAAarB;IAEjB,MAAMsB,KAAK,UAAMxB,kMAAAA,EAAe,IAAI,EAAEW;IAEtC,IAAI,CAACY,YAAY;QACf,MAAM,EAAEjB,KAAK,EAAEmB,YAAY,EAAEX,KAAK,EAAE,OAAGjB,wLAAAA,EAAW;YAChD6B,SAAS,IAAI;YACbC,QAAQxB,WAAWyB,eAAe;YAClCpB;YACAW;YACAL,OAAOC;QACT;QAEA,qDAAqD;QACrD,MAAMc,uBAAuB,UAAM/B,gMAAAA,EAAe;YAChD4B,SAAS,IAAI;YACbF;YACAlB;YACAwB,OAAO,CAAC,EAAEA,KAAK,EAAE,GAAKA,MAAMC,KAAK,CAAC;YAClCN;YACAN;YACAL;QACF;QAEA,IAAIe,sBAAsB,CAAC,EAAE,EAAE3B,IAAI;YACjCqB,aAAaM,sBAAsB,CAAC,EAAE,EAAE3B;QACxC,gFAAgF;QAClF,OAAO,IAAIa,YAAY,CAACT,MAAM0B,MAAM,EAAE;YACpC,MAAMC,QAAQ,IAAI,CAACC,MAAM,CAACf,UAAU;YAEpC,MAAMgB,eAAe,MAAOX,GACzBX,MAAM,CAAC;gBACNX,IAAI+B,MAAM/B,EAAE;YACd,GACCkC,IAAI,CAACH,OACLnB,KAAK,CAACA,OACNiB,KAAK,CAAC;YACTR,aAAaY,cAAc,CAAC,EAAE,EAAEjC;QAClC;IACF;IAEA,IAAI,CAACqB,cAAc,CAACd,QAAQC,MAAM,EAAE;QAClC,yEAAyE;QACzE,gCAAgC;QAChC,4CAA4C;QAC5C,OAAO;IACT;IAEA,MAAM2B,SAAS,UAAMtC,oLAAAA,EAAU;QAC7BG,IAAIqB;QACJG,SAAS,IAAI;QACbtB;QACAC;QACAmB;QACAG,QAAQxB,WAAWyB,eAAe;QAClCU,cAAc1B,cAAc;QAC5BL;QACAgC,WAAW;QACX5B;QACAE;QACAM;IACF;IAEA,IAAIP,cAAc,OAAO;QACvB,OAAO;IACT;IAEA,OAAOyB;AACT,EAAC"}},
    {"offset": {"line": 8619, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/updateVersion.ts"],"sourcesContent":["import type {\n  JsonObject,\n  SanitizedCollectionConfig,\n  TypeWithVersion,\n  UpdateVersionArgs,\n} from 'payload'\n\nimport { buildVersionCollectionFields } from 'payload'\nimport toSnakeCase from 'to-snake-case'\n\nimport type { DrizzleAdapter } from './types.js'\n\nimport { buildQuery } from './queries/buildQuery.js'\nimport { upsertRow } from './upsertRow/index.js'\nimport { getTransaction } from './utilities/getTransaction.js'\n\nexport async function updateVersion<T extends JsonObject = JsonObject>(\n  this: DrizzleAdapter,\n  {\n    id,\n    collection,\n    locale,\n    req,\n    returning,\n    select,\n    versionData,\n    where: whereArg,\n  }: UpdateVersionArgs<T>,\n): Promise<TypeWithVersion<T>> {\n  const collectionConfig: SanitizedCollectionConfig = this.payload.collections[collection].config\n  const whereToUse = whereArg || { id: { equals: id } }\n  const tableName = this.tableNameMap.get(\n    `_${toSnakeCase(collectionConfig.slug)}${this.versionsSuffix}`,\n  )\n\n  const fields = buildVersionCollectionFields(this.payload.config, collectionConfig, true)\n\n  const { where } = buildQuery({\n    adapter: this,\n    fields,\n    locale,\n    tableName,\n    where: whereToUse,\n  })\n\n  const db = await getTransaction(this, req)\n\n  const result = await upsertRow<TypeWithVersion<T>>({\n    id,\n    adapter: this,\n    collectionSlug: collection,\n    data: versionData,\n    db,\n    fields,\n    ignoreResult: returning === false,\n    joinQuery: false,\n    operation: 'update',\n    req,\n    select,\n    tableName,\n    where,\n  })\n\n  if (returning === false) {\n    return null\n  }\n\n  return result\n}\n"],"names":["buildVersionCollectionFields","toSnakeCase","buildQuery","upsertRow","getTransaction","updateVersion","id","collection","locale","req","returning","select","versionData","where","whereArg","collectionConfig","payload","collections","config","whereToUse","equals","tableName","tableNameMap","get","slug","versionsSuffix","fields","adapter","db","result","collectionSlug","data","ignoreResult","joinQuery","operation"],"mappings":";;;;AAOA,SAASA,4BAA4B,QAAQ,UAAS;AACtD,OAAOC,iBAAiB,gBAAe;AAIvC,SAASC,UAAU,QAAQ,0BAAyB;AACpD,SAASC,SAAS,QAAQ,uBAAsB;AAChD,SAASC,cAAc,QAAQ,gCAA+B;;;;;;AAEvD,eAAeC,cAEpB,EACEC,EAAE,EACFC,UAAU,EACVC,MAAM,EACNC,GAAG,EACHC,SAAS,EACTC,MAAM,EACNC,WAAW,EACXC,OAAOC,QAAQ,EACM;IAEvB,MAAMC,mBAA8C,IAAI,CAACC,OAAO,CAACC,WAAW,CAACV,WAAW,CAACW,MAAM;IAC/F,MAAMC,aAAaL,YAAY;QAAER,IAAI;YAAEc,QAAQd;QAAG;IAAE;IACpD,MAAMe,YAAY,IAAI,CAACC,YAAY,CAACC,GAAG,CACrC,CAAC,CAAC,MAAEtB,yJAAAA,EAAYc,iBAAiBS,IAAI,IAAI,IAAI,CAACC,cAAc,EAAE;IAGhE,MAAMC,aAAS1B,sMAAAA,EAA6B,IAAI,CAACgB,OAAO,CAACE,MAAM,EAAEH,kBAAkB;IAEnF,MAAM,EAAEF,KAAK,EAAE,OAAGX,wLAAAA,EAAW;QAC3ByB,SAAS,IAAI;QACbD;QACAlB;QACAa;QACAR,OAAOM;IACT;IAEA,MAAMS,KAAK,UAAMxB,kMAAAA,EAAe,IAAI,EAAEK;IAEtC,MAAMoB,SAAS,UAAM1B,oLAAAA,EAA8B;QACjDG;QACAqB,SAAS,IAAI;QACbG,gBAAgBvB;QAChBwB,MAAMnB;QACNgB;QACAF;QACAM,cAActB,cAAc;QAC5BuB,WAAW;QACXC,WAAW;QACXzB;QACAE;QACAU;QACAR;IACF;IAEA,IAAIH,cAAc,OAAO;QACvB,OAAO;IACT;IAEA,OAAOmB;AACT"}},
    {"offset": {"line": 8674, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/upsert.ts"],"sourcesContent":["import type { Upsert } from 'payload'\n\nimport type { DrizzleAdapter } from './types.js'\n\nexport const upsert: Upsert = async function upsert(\n  this: DrizzleAdapter,\n  { collection, data, joins, locale, req, returning, select, where },\n) {\n  return this.updateOne({\n    collection,\n    data,\n    joins,\n    locale,\n    options: { upsert: true },\n    req,\n    returning,\n    select,\n    where,\n  })\n}\n"],"names":["upsert","collection","data","joins","locale","req","returning","select","where","updateOne","options"],"mappings":";;;;AAIO,MAAMA,SAAiB,eAAeA,OAE3C,EAAEC,UAAU,EAAEC,IAAI,EAAEC,KAAK,EAAEC,MAAM,EAAEC,GAAG,EAAEC,SAAS,EAAEC,MAAM,EAAEC,KAAK,EAAE;IAElE,OAAO,IAAI,CAACC,SAAS,CAAC;QACpBR;QACAC;QACAC;QACAC;QACAM,SAAS;YAAEV,QAAQ;QAAK;QACxBK;QACAC;QACAC;QACAC;IACF;AACF,EAAC"}},
    {"offset": {"line": 8697, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/postgres/columnToCodeConverter.ts"],"sourcesContent":["import type { ColumnToCodeConverter } from '../types.js'\nexport const columnToCodeConverter: ColumnToCodeConverter = ({\n  adapter,\n  addEnum,\n  addImport,\n  column,\n  tableKey,\n}) => {\n  let columnBuilderFn: string = column.type\n\n  if (column.type === 'geometry') {\n    columnBuilderFn = 'geometryColumn'\n    addImport(adapter.packageName, columnBuilderFn)\n  } else if (column.type === 'enum') {\n    if ('locale' in column) {\n      columnBuilderFn = `enum__locales`\n    } else {\n      addEnum(column.enumName, column.options)\n      columnBuilderFn = column.enumName\n    }\n  } else {\n    addImport(`${adapter.packageName}/drizzle/pg-core`, columnBuilderFn)\n  }\n\n  const columnBuilderArgsArray: string[] = []\n\n  switch (column.type) {\n    case 'bit':\n    case 'halfvec':\n    case 'sparsevec':\n    case 'vector': {\n      if (column.dimensions) {\n        columnBuilderArgsArray.push(`dimensions: ${column.dimensions}`)\n      }\n      break\n    }\n    case 'numeric': {\n      columnBuilderArgsArray.push(\"mode: 'number'\")\n      break\n    }\n    case 'timestamp': {\n      columnBuilderArgsArray.push(`mode: '${column.mode}'`)\n      if (column.withTimezone) {\n        columnBuilderArgsArray.push('withTimezone: true')\n      }\n\n      if (typeof column.precision === 'number') {\n        columnBuilderArgsArray.push(`precision: ${column.precision}`)\n      }\n      break\n    }\n  }\n\n  let columnBuilderArgs = ''\n\n  if (columnBuilderArgsArray.length) {\n    columnBuilderArgs = `, {${columnBuilderArgsArray.join(',')}}`\n  }\n\n  let code = `${columnBuilderFn}('${column.name}'${columnBuilderArgs})`\n\n  if (column.type === 'timestamp' && column.defaultNow) {\n    code = `${code}.defaultNow()`\n  }\n\n  if (column.type === 'uuid' && column.defaultRandom) {\n    code = `${code}.defaultRandom()`\n  }\n\n  if (column.notNull) {\n    code = `${code}.notNull()`\n  }\n\n  if (column.primaryKey) {\n    code = `${code}.primaryKey()`\n  }\n\n  if (typeof column.default !== 'undefined') {\n    let sanitizedDefault = column.default\n\n    if (column.type === 'geometry') {\n      sanitizedDefault = `sql\\`${column.default}\\``\n    } else if (column.type === 'jsonb') {\n      sanitizedDefault = `sql\\`'${JSON.stringify(column.default)}'::jsonb\\``\n    } else if (column.type === 'numeric') {\n      sanitizedDefault = `${column.default}`\n    } else if (typeof column.default === 'string') {\n      sanitizedDefault = `${JSON.stringify(column.default)}`\n    }\n\n    code = `${code}.default(${sanitizedDefault})`\n  }\n\n  if (column.reference) {\n    let callback = `()`\n\n    if (column.reference.table === tableKey) {\n      addImport(`${adapter.packageName}/drizzle/pg-core`, 'type AnyPgColumn')\n      callback = `${callback}: AnyPgColumn`\n    }\n\n    callback = `${callback} => ${column.reference.table}.${column.reference.name}`\n\n    code = `${code}.references(${callback}, {\n      ${column.reference.onDelete ? `onDelete: '${column.reference.onDelete}'` : ''}\n  })`\n  }\n\n  return code\n}\n"],"names":["columnToCodeConverter","adapter","addEnum","addImport","column","tableKey","columnBuilderFn","type","packageName","enumName","options","columnBuilderArgsArray","dimensions","push","mode","withTimezone","precision","columnBuilderArgs","length","join","code","name","defaultNow","defaultRandom","notNull","primaryKey","default","sanitizedDefault","JSON","stringify","reference","callback","table","onDelete"],"mappings":"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"}},
    {"offset": {"line": 8792, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/postgres/countDistinct.ts"],"sourcesContent":["import type { PgTableWithColumns } from 'drizzle-orm/pg-core'\n\nimport { count, sql } from 'drizzle-orm'\n\nimport type { BasePostgresAdapter, CountDistinct } from './types.js'\n\nexport const countDistinct: CountDistinct = async function countDistinct(\n  this: BasePostgresAdapter,\n  { column, db, joins, tableName, where },\n) {\n  // When we don't have any joins - use a simple COUNT(*) query.\n  if (joins.length === 0) {\n    const countResult = await db\n      .select({\n        count: column ? count(sql`DISTINCT ${column}`) : count(),\n      })\n      .from(this.tables[tableName])\n      .where(where)\n\n    return Number(countResult?.[0]?.count ?? 0)\n  }\n\n  let query = db\n    .select({\n      count: sql`COUNT(1) OVER()`,\n    })\n    .from(this.tables[tableName])\n    .where(where)\n    .groupBy(column || this.tables[tableName].id)\n    .limit(1)\n    .$dynamic()\n\n  joins.forEach(({ type, condition, table }) => {\n    query = query[type ?? 'leftJoin'](table as PgTableWithColumns<any>, condition)\n  })\n\n  // When we have any joins, we need to count each individual ID only once.\n  // COUNT(*) doesn't work for this well in this case, as it also counts joined tables.\n  // SELECT (COUNT DISTINCT id) has a very slow performance on large tables.\n  // Instead, COUNT (GROUP BY id) can be used which is still slower than COUNT(*) but acceptable.\n  const countResult = await query\n\n  return Number(countResult?.[0]?.count ?? 0)\n}\n"],"names":["count","sql","countDistinct","column","db","joins","tableName","where","length","countResult","select","from","tables","Number","query","groupBy","id","limit","$dynamic","forEach","type","condition","table"],"mappings":";;;;;AAEA,SAASA,KAAK,EAAEC,GAAG,QAAQ,cAAa;;AAIjC,MAAMC,gBAA+B,eAAeA,cAEzD,EAAEC,MAAM,EAAEC,EAAE,EAAEC,KAAK,EAAEC,SAAS,EAAEC,KAAK,EAAE;IAEvC,8DAA8D;IAC9D,IAAIF,MAAMG,MAAM,KAAK,GAAG;QACtB,MAAMC,cAAc,MAAML,GACvBM,MAAM,CAAC;YACNV,OAAOG,aAASH,0KAAAA,EAAMC,qJAAG,CAAC,SAAS,EAAEE,OAAO,CAAC,QAAIH,0KAAAA;QACnD,GACCW,IAAI,CAAC,IAAI,CAACC,MAAM,CAACN,UAAU,EAC3BC,KAAK,CAACA;QAET,OAAOM,OAAOJ,aAAa,CAAC,EAAE,EAAET,SAAS;IAC3C;IAEA,IAAIc,QAAQV,GACTM,MAAM,CAAC;QACNV,OAAOC,qJAAG,CAAC,eAAe,CAAC;IAC7B,GACCU,IAAI,CAAC,IAAI,CAACC,MAAM,CAACN,UAAU,EAC3BC,KAAK,CAACA,OACNQ,OAAO,CAACZ,UAAU,IAAI,CAACS,MAAM,CAACN,UAAU,CAACU,EAAE,EAC3CC,KAAK,CAAC,GACNC,QAAQ;IAEXb,MAAMc,OAAO,CAAC,CAAC,EAAEC,IAAI,EAAEC,SAAS,EAAEC,KAAK,EAAE;QACvCR,QAAQA,KAAK,CAACM,QAAQ,WAAW,CAACE,OAAkCD;IACtE;IAEA,yEAAyE;IACzE,qFAAqF;IACrF,0EAA0E;IAC1E,+FAA+F;IAC/F,MAAMZ,cAAc,MAAMK;IAE1B,OAAOD,OAAOJ,aAAa,CAAC,EAAE,EAAET,SAAS;AAC3C,EAAC"}},
    {"offset": {"line": 8824, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/postgres/createDatabase.ts"],"sourcesContent":["import type { ClientConfig } from 'pg'\n\nimport type { BasePostgresAdapter } from './types.js'\n\nconst setConnectionStringDatabase = ({\n  connectionString,\n  database,\n}: {\n  connectionString: string\n  database: string\n}): string => {\n  const connectionURL = new URL(connectionString)\n  const newConnectionURL = new URL(connectionURL)\n  newConnectionURL.pathname = `/${database}`\n\n  return newConnectionURL.toString()\n}\n\ntype Args = {\n  /**\n   * Name of a database, defaults to the current one\n   */\n  name?: string\n  /**\n   * Schema to create in addition to 'public'. Defaults to adapter.schemaName if exists.\n   */\n  schemaName?: string\n}\nexport const createDatabase = async function (this: BasePostgresAdapter, args: Args = {}) {\n  // POSTGRES_URL - default Vercel env\n  const connectionString =\n    this.poolOptions?.connectionString ?? process.env.POSTGRES_URL ?? process.env.DATABASE_URL\n  let managementClientConfig: ClientConfig = {}\n  let dbName = args.name\n  const schemaName = this.schemaName || 'public'\n\n  if (connectionString) {\n    if (!dbName) {\n      dbName = new URL(connectionString).pathname.slice(1)\n    }\n\n    managementClientConfig.connectionString = setConnectionStringDatabase({\n      connectionString,\n      database: 'postgres',\n    })\n  } else {\n    if (!dbName) {\n      dbName = this.poolOptions.database\n    }\n\n    managementClientConfig = {\n      ...this.poolOptions,\n      database: 'postgres',\n    }\n  }\n\n  // import pg only when createDatabase is used\n  const pg = await import('pg').then((mod) => mod.default)\n\n  const managementClient = new pg.Client(managementClientConfig)\n\n  try {\n    await managementClient.connect()\n    await managementClient.query(`CREATE DATABASE \"${dbName}\"`)\n\n    this.payload.logger.info(`Created database \"${dbName}\"`)\n\n    if (schemaName !== 'public') {\n      let createdDatabaseConfig: ClientConfig = {}\n\n      if (connectionString) {\n        createdDatabaseConfig.connectionString = setConnectionStringDatabase({\n          connectionString,\n          database: dbName,\n        })\n      } else {\n        createdDatabaseConfig = {\n          ...this.poolOptions,\n          database: dbName,\n        }\n      }\n\n      const createdDatabaseClient = new pg.Client(createdDatabaseConfig)\n\n      try {\n        await createdDatabaseClient.connect()\n\n        await createdDatabaseClient.query(`CREATE SCHEMA ${schemaName}`)\n        this.payload.logger.info(`Created schema \"${dbName}.${schemaName}\"`)\n      } catch (err) {\n        this.payload.logger.error({\n          err,\n          msg: `Error: failed to create schema \"${dbName}.${schemaName}\". Details: ${err.message}`,\n        })\n      } finally {\n        await createdDatabaseClient.end()\n      }\n    }\n\n    return true\n  } catch (err) {\n    this.payload.logger.error({\n      err,\n      msg: `Error: failed to create database ${dbName}. Details: ${err.message}`,\n    })\n\n    return false\n  } finally {\n    await managementClient.end()\n  }\n}\n"],"names":["setConnectionStringDatabase","connectionString","database","connectionURL","URL","newConnectionURL","pathname","toString","createDatabase","args","poolOptions","process","env","POSTGRES_URL","DATABASE_URL","managementClientConfig","dbName","name","schemaName","slice","pg","then","mod","default","managementClient","Client","connect","query","payload","logger","info","createdDatabaseConfig","createdDatabaseClient","err","error","msg","message","end"],"mappings":";;;;AAIA,MAAMA,8BAA8B,CAAC,EACnCC,gBAAgB,EAChBC,QAAQ,EAIT;IACC,MAAMC,gBAAgB,IAAIC,IAAIH;IAC9B,MAAMI,mBAAmB,IAAID,IAAID;IACjCE,iBAAiBC,QAAQ,GAAG,CAAC,CAAC,EAAEJ,UAAU;IAE1C,OAAOG,iBAAiBE,QAAQ;AAClC;AAYO,MAAMC,iBAAiB,eAA2CC,OAAa,CAAC,CAAC;IACtF,oCAAoC;IACpC,MAAMR,mBACJ,IAAI,CAACS,WAAW,EAAET,oBAAoBU,QAAQC,GAAG,CAACC,YAAY,IAAIF,QAAQC,GAAG,CAACE,YAAY;IAC5F,IAAIC,yBAAuC,CAAC;IAC5C,IAAIC,SAASP,KAAKQ,IAAI;IACtB,MAAMC,aAAa,IAAI,CAACA,UAAU,IAAI;IAEtC,IAAIjB,kBAAkB;QACpB,IAAI,CAACe,QAAQ;YACXA,SAAS,IAAIZ,IAAIH,kBAAkBK,QAAQ,CAACa,KAAK,CAAC;QACpD;QAEAJ,uBAAuBd,gBAAgB,GAAGD,4BAA4B;YACpEC;YACAC,UAAU;QACZ;IACF,OAAO;QACL,IAAI,CAACc,QAAQ;YACXA,SAAS,IAAI,CAACN,WAAW,CAACR,QAAQ;QACpC;QAEAa,yBAAyB;YACvB,GAAG,IAAI,CAACL,WAAW;YACnBR,UAAU;QACZ;IACF;IAEA,6CAA6C;IAC7C,MAAMkB,KAAK,MAAM,MAAM,CAAC,wGAAMC,IAAI,CAAC,CAACC,MAAQA,IAAIC,OAAO;IAEvD,MAAMC,mBAAmB,IAAIJ,GAAGK,MAAM,CAACV;IAEvC,IAAI;QACF,MAAMS,iBAAiBE,OAAO;QAC9B,MAAMF,iBAAiBG,KAAK,CAAC,CAAC,iBAAiB,EAAEX,OAAO,CAAC,CAAC;QAE1D,IAAI,CAACY,OAAO,CAACC,MAAM,CAACC,IAAI,CAAC,CAAC,kBAAkB,EAAEd,OAAO,CAAC,CAAC;QAEvD,IAAIE,eAAe,UAAU;YAC3B,IAAIa,wBAAsC,CAAC;YAE3C,IAAI9B,kBAAkB;gBACpB8B,sBAAsB9B,gBAAgB,GAAGD,4BAA4B;oBACnEC;oBACAC,UAAUc;gBACZ;YACF,OAAO;gBACLe,wBAAwB;oBACtB,GAAG,IAAI,CAACrB,WAAW;oBACnBR,UAAUc;gBACZ;YACF;YAEA,MAAMgB,wBAAwB,IAAIZ,GAAGK,MAAM,CAACM;YAE5C,IAAI;gBACF,MAAMC,sBAAsBN,OAAO;gBAEnC,MAAMM,sBAAsBL,KAAK,CAAC,CAAC,cAAc,EAAET,YAAY;gBAC/D,IAAI,CAACU,OAAO,CAACC,MAAM,CAACC,IAAI,CAAC,CAAC,gBAAgB,EAAEd,OAAO,CAAC,EAAEE,WAAW,CAAC,CAAC;YACrE,EAAE,OAAOe,KAAK;gBACZ,IAAI,CAACL,OAAO,CAACC,MAAM,CAACK,KAAK,CAAC;oBACxBD;oBACAE,KAAK,CAAC,gCAAgC,EAAEnB,OAAO,CAAC,EAAEE,WAAW,YAAY,EAAEe,IAAIG,OAAO,EAAE;gBAC1F;YACF,SAAU;gBACR,MAAMJ,sBAAsBK,GAAG;YACjC;QACF;QAEA,OAAO;IACT,EAAE,OAAOJ,KAAK;QACZ,IAAI,CAACL,OAAO,CAACC,MAAM,CAACK,KAAK,CAAC;YACxBD;YACAE,KAAK,CAAC,iCAAiC,EAAEnB,OAAO,WAAW,EAAEiB,IAAIG,OAAO,EAAE;QAC5E;QAEA,OAAO;IACT,SAAU;QACR,MAAMZ,iBAAiBa,GAAG;IAC5B;AACF,EAAC"}},
    {"offset": {"line": 8906, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/postgres/createExtensions.ts"],"sourcesContent":["import type { BasePostgresAdapter } from './types.js'\n\nexport const createExtensions = async function (this: BasePostgresAdapter): Promise<void> {\n  for (const extension in this.extensions) {\n    if (this.extensions[extension]) {\n      try {\n        await this.drizzle.execute(`CREATE EXTENSION IF NOT EXISTS \"${extension}\"`)\n      } catch (err) {\n        this.payload.logger.error({ err, msg: `Failed to create extension ${extension}` })\n      }\n    }\n  }\n}\n"],"names":["createExtensions","extension","extensions","drizzle","execute","err","payload","logger","error","msg"],"mappings":";;;;AAEO,MAAMA,mBAAmB;IAC9B,IAAK,MAAMC,aAAa,IAAI,CAACC,UAAU,CAAE;QACvC,IAAI,IAAI,CAACA,UAAU,CAACD,UAAU,EAAE;YAC9B,IAAI;gBACF,MAAM,IAAI,CAACE,OAAO,CAACC,OAAO,CAAC,CAAC,gCAAgC,EAAEH,UAAU,CAAC,CAAC;YAC5E,EAAE,OAAOI,KAAK;gBACZ,IAAI,CAACC,OAAO,CAACC,MAAM,CAACC,KAAK,CAAC;oBAAEH;oBAAKI,KAAK,CAAC,2BAA2B,EAAER,WAAW;gBAAC;YAClF;QACF;IACF;AACF,EAAC"}},
    {"offset": {"line": 8928, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/postgres/createJSONQuery/index.ts"],"sourcesContent":["import { APIError } from 'payload'\n\nimport type { CreateJSONQueryArgs } from '../../types.js'\n\nimport { SAFE_STRING_REGEX } from '../../utilities/escapeSQLValue.js'\n\nconst operatorMap: Record<string, string> = {\n  contains: '~',\n  equals: '==',\n  in: 'in',\n  like: 'like_regex',\n  not_equals: '!=',\n  not_in: 'in',\n  not_like: '!like_regex',\n}\n\nconst sanitizeValue = (value: unknown, operator?: string): string => {\n  if (value === null) {\n    return `NULL`\n  }\n\n  if (typeof value === 'number' || typeof value === 'boolean') {\n    return `${value}`\n  }\n\n  if (typeof value !== 'string') {\n    throw new Error('Invalid value type')\n  }\n\n  if (!SAFE_STRING_REGEX.test(value)) {\n    throw new APIError(`${value} is not allowed as a JSON query value`, 400)\n  }\n\n  const escaped = value.replace(/\\\\/g, '\\\\\\\\').replace(/\"/g, '\\\\\"')\n\n  const prefix = ['like', 'not_like'].includes(operator ?? '') ? '(?i)' : ''\n\n  return `\"${prefix}${escaped}\"`\n}\n\nexport const createJSONQuery = ({ column, operator, pathSegments, value }: CreateJSONQueryArgs) => {\n  const columnName = typeof column === 'object' ? column.name : column\n  const jsonPaths = pathSegments\n    .slice(1)\n    .map((key) => {\n      return `${key}[*]`\n    })\n    .join('.')\n\n  const fullPath = pathSegments.length === 1 ? '$[*]' : `$.${jsonPaths}`\n\n  let sql = ''\n\n  if (['in', 'not_in'].includes(operator) && Array.isArray(value)) {\n    sql = '('\n    value.forEach((item, i) => {\n      sql = `${sql}${createJSONQuery({ column, operator: operator === 'in' ? 'equals' : 'not_equals', pathSegments, value: item })}${i === value.length - 1 ? '' : ` ${operator === 'in' ? 'OR' : 'AND'} `}`\n    })\n    sql = `${sql})`\n  } else if (operator === 'exists') {\n    sql = `${value === false ? 'NOT ' : ''}jsonb_path_exists(${columnName}, '${fullPath}')`\n  } else if (['not_like'].includes(operator)) {\n    const mappedOperator = operatorMap[operator]\n\n    sql = `NOT jsonb_path_exists(${columnName}, '${fullPath} ? (@ ${mappedOperator.substring(1)} ${sanitizeValue(value, operator)})')`\n  } else {\n    sql = `jsonb_path_exists(${columnName}, '${fullPath} ? (@ ${operatorMap[operator]} ${sanitizeValue(value, operator)})')`\n  }\n\n  return sql\n}\n"],"names":["APIError","SAFE_STRING_REGEX","operatorMap","contains","equals","in","like","not_equals","not_in","not_like","sanitizeValue","value","operator","Error","test","escaped","replace","prefix","includes","createJSONQuery","column","pathSegments","columnName","name","jsonPaths","slice","map","key","join","fullPath","length","sql","Array","isArray","forEach","item","i","mappedOperator","substring"],"mappings":";;;;AAAA,SAASA,QAAQ,QAAQ,UAAS;AAIlC,SAASC,iBAAiB,QAAQ,oCAAmC;;;AAErE,MAAMC,cAAsC;IAC1CC,UAAU;IACVC,QAAQ;IACRC,IAAI;IACJC,MAAM;IACNC,YAAY;IACZC,QAAQ;IACRC,UAAU;AACZ;AAEA,MAAMC,gBAAgB,CAACC,OAAgBC;IACrC,IAAID,UAAU,MAAM;QAClB,OAAO,CAAC,IAAI,CAAC;IACf;IAEA,IAAI,OAAOA,UAAU,YAAY,OAAOA,UAAU,WAAW;QAC3D,OAAO,GAAGA,OAAO;IACnB;IAEA,IAAI,OAAOA,UAAU,UAAU;QAC7B,MAAM,IAAIE,MAAM;IAClB;IAEA,IAAI,CAACZ,qMAAAA,CAAkBa,IAAI,CAACH,QAAQ;QAClC,MAAM,IAAIX,mKAAAA,CAAS,GAAGW,MAAM,qCAAqC,CAAC,EAAE;IACtE;IAEA,MAAMI,UAAUJ,MAAMK,OAAO,CAAC,OAAO,QAAQA,OAAO,CAAC,MAAM;IAE3D,MAAMC,SAAS;QAAC;QAAQ;KAAW,CAACC,QAAQ,CAACN,YAAY,MAAM,SAAS;IAExE,OAAO,CAAC,CAAC,EAAEK,SAASF,QAAQ,CAAC,CAAC;AAChC;AAEO,MAAMI,kBAAkB,CAAC,EAAEC,MAAM,EAAER,QAAQ,EAAES,YAAY,EAAEV,KAAK,EAAuB;IAC5F,MAAMW,aAAa,OAAOF,WAAW,WAAWA,OAAOG,IAAI,GAAGH;IAC9D,MAAMI,YAAYH,aACfI,KAAK,CAAC,GACNC,GAAG,CAAC,CAACC;QACJ,OAAO,GAAGA,IAAI,GAAG,CAAC;IACpB,GACCC,IAAI,CAAC;IAER,MAAMC,WAAWR,aAAaS,MAAM,KAAK,IAAI,SAAS,CAAC,EAAE,EAAEN,WAAW;IAEtE,IAAIO,MAAM;IAEV,IAAI;QAAC;QAAM;KAAS,CAACb,QAAQ,CAACN,aAAaoB,MAAMC,OAAO,CAACtB,QAAQ;QAC/DoB,MAAM;QACNpB,MAAMuB,OAAO,CAAC,CAACC,MAAMC;YACnBL,MAAM,GAAGA,MAAMZ,gBAAgB;gBAAEC;gBAAQR,UAAUA,aAAa,OAAO,WAAW;gBAAcS;gBAAcV,OAAOwB;YAAK,KAAKC,MAAMzB,MAAMmB,MAAM,GAAG,IAAI,KAAK,CAAC,CAAC,EAAElB,aAAa,OAAO,OAAO,MAAM,CAAC,CAAC,EAAE;QACxM;QACAmB,MAAM,GAAGA,IAAI,CAAC,CAAC;IACjB,OAAO,IAAInB,aAAa,UAAU;QAChCmB,MAAM,GAAGpB,UAAU,QAAQ,SAAS,GAAG,kBAAkB,EAAEW,WAAW,GAAG,EAAEO,SAAS,EAAE,CAAC;IACzF,OAAO,IAAI;QAAC;KAAW,CAACX,QAAQ,CAACN,WAAW;QAC1C,MAAMyB,iBAAiBnC,WAAW,CAACU,SAAS;QAE5CmB,MAAM,CAAC,sBAAsB,EAAET,WAAW,GAAG,EAAEO,SAAS,MAAM,EAAEQ,eAAeC,SAAS,CAAC,GAAG,CAAC,EAAE5B,cAAcC,OAAOC,UAAU,GAAG,CAAC;IACpI,OAAO;QACLmB,MAAM,CAAC,kBAAkB,EAAET,WAAW,GAAG,EAAEO,SAAS,MAAM,EAAE3B,WAAW,CAACU,SAAS,CAAC,CAAC,EAAEF,cAAcC,OAAOC,UAAU,GAAG,CAAC;IAC1H;IAEA,OAAOmB;AACT,EAAC"}},
    {"offset": {"line": 9002, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/postgres/defaultSnapshot.ts"],"sourcesContent":["import type { DrizzleSnapshotJSON } from 'drizzle-kit/api'\n\nexport const defaultDrizzleSnapshot: DrizzleSnapshotJSON = {\n  id: '00000000-0000-0000-0000-000000000000',\n  _meta: {\n    columns: {},\n    schemas: {},\n    tables: {},\n  },\n  dialect: 'postgresql',\n  enums: {},\n  policies: {},\n  prevId: '00000000-0000-0000-0000-00000000000',\n  roles: {},\n  schemas: {},\n  sequences: {},\n  tables: {},\n  version: '7',\n  views: {},\n}\n"],"names":["defaultDrizzleSnapshot","id","_meta","columns","schemas","tables","dialect","enums","policies","prevId","roles","sequences","version","views"],"mappings":";;;;AAEO,MAAMA,yBAA8C;IACzDC,IAAI;IACJC,OAAO;QACLC,SAAS,CAAC;QACVC,SAAS,CAAC;QACVC,QAAQ,CAAC;IACX;IACAC,SAAS;IACTC,OAAO,CAAC;IACRC,UAAU,CAAC;IACXC,QAAQ;IACRC,OAAO,CAAC;IACRN,SAAS,CAAC;IACVO,WAAW,CAAC;IACZN,QAAQ,CAAC;IACTO,SAAS;IACTC,OAAO,CAAC;AACV,EAAC"}},
    {"offset": {"line": 9028, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/postgres/deleteWhere.ts"],"sourcesContent":["import type { TransactionPg } from '../types.js'\nimport type { DeleteWhere } from './types.js'\n\nexport const deleteWhere: DeleteWhere = async function deleteWhere({ db, tableName, where }) {\n  const table = this.tables[tableName]\n  await (db as TransactionPg).delete(table).where(where)\n}\n"],"names":["deleteWhere","db","tableName","where","table","tables","delete"],"mappings":";;;;AAGO,MAAMA,cAA2B,eAAeA,YAAY,EAAEC,EAAE,EAAEC,SAAS,EAAEC,KAAK,EAAE;IACzF,MAAMC,QAAQ,IAAI,CAACC,MAAM,CAACH,UAAU;IACpC,MAAOD,GAAqBK,MAAM,CAACF,OAAOD,KAAK,CAACA;AAClD,EAAC"}},
    {"offset": {"line": 9040, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/postgres/dropDatabase.ts"],"sourcesContent":["import type { DropDatabase } from './types.js'\n\nexport const dropDatabase: DropDatabase = async function dropDatabase({ adapter }) {\n  await adapter.execute({\n    drizzle: adapter.drizzle,\n    raw: `drop schema if exists ${this.schemaName || 'public'} cascade;\n    create schema ${this.schemaName || 'public'};`,\n  })\n}\n"],"names":["dropDatabase","adapter","execute","drizzle","raw","schemaName"],"mappings":";;;;AAEO,MAAMA,eAA6B,eAAeA,aAAa,EAAEC,OAAO,EAAE;IAC/E,MAAMA,QAAQC,OAAO,CAAC;QACpBC,SAASF,QAAQE,OAAO;QACxBC,KAAK,CAAC,sBAAsB,EAAE,IAAI,CAACC,UAAU,IAAI,SAAS;kBAC5C,EAAE,IAAI,CAACA,UAAU,IAAI,SAAS,CAAC,CAAC;IAChD;AACF,EAAC"}},
    {"offset": {"line": 9055, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/postgres/execute.ts"],"sourcesContent":["import { sql } from 'drizzle-orm'\n\nimport type { Execute } from './types.js'\n\nexport const execute: Execute<any> = function execute({ db, drizzle, raw, sql: statement }) {\n  const executeFrom = db ?? drizzle\n\n  if (raw) {\n    return executeFrom.execute(sql.raw(raw))\n  } else {\n    return executeFrom.execute(sql`${statement}`)\n  }\n}\n"],"names":["sql","execute","db","drizzle","raw","statement","executeFrom"],"mappings":";;;;AAAA,SAASA,GAAG,QAAQ,cAAa;;AAI1B,MAAMC,UAAwB,SAASA,QAAQ,EAAEC,EAAE,EAAEC,OAAO,EAAEC,GAAG,EAAEJ,KAAKK,SAAS,EAAE;IACxF,MAAMC,cAAcJ,MAAMC;IAE1B,IAAIC,KAAK;QACP,OAAOE,YAAYL,OAAO,CAACD,qJAAAA,CAAII,GAAG,CAACA;IACrC,OAAO;QACL,OAAOE,YAAYL,OAAO,CAACD,qJAAG,CAAC,EAAEK,UAAU,CAAC;IAC9C;AACF,EAAC"}},
    {"offset": {"line": 9073, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/schema/buildDrizzleRelations.ts"],"sourcesContent":["import type { Relation } from 'drizzle-orm'\n\nimport { relations } from 'drizzle-orm'\n\nimport type { DrizzleAdapter } from '../types.js'\n\nexport const buildDrizzleRelations = ({ adapter }: { adapter: DrizzleAdapter }) => {\n  for (const tableName in adapter.rawRelations) {\n    const rawRelations = adapter.rawRelations[tableName]\n\n    adapter.relations[`relations_${tableName}`] = relations(\n      adapter.tables[tableName],\n      ({ many, one }) => {\n        const result: Record<string, Relation<string>> = {}\n\n        for (const key in rawRelations) {\n          const relation = rawRelations[key]\n\n          if (relation.type === 'one') {\n            result[key] = one(adapter.tables[relation.to], {\n              fields: relation.fields.map(\n                (field) => adapter.tables[field.table][field.name],\n              ) as any,\n              references: relation.references.map(\n                (reference) => adapter.tables[relation.to][reference],\n              ),\n              relationName: relation.relationName,\n            })\n          } else {\n            if (adapter.tables[relation.to]) {\n              result[key] = many(adapter.tables[relation.to], {\n                relationName: relation.relationName,\n              })\n            }\n          }\n        }\n\n        return result\n      },\n    )\n  }\n}\n"],"names":["relations","buildDrizzleRelations","adapter","tableName","rawRelations","tables","many","one","result","key","relation","type","to","fields","map","field","table","name","references","reference","relationName"],"mappings":";;;;AAEA,SAASA,SAAS,QAAQ,cAAa;;AAIhC,MAAMC,wBAAwB,CAAC,EAAEC,OAAO,EAA+B;IAC5E,IAAK,MAAMC,aAAaD,QAAQE,YAAY,CAAE;QAC5C,MAAMA,eAAeF,QAAQE,YAAY,CAACD,UAAU;QAEpDD,QAAQF,SAAS,CAAC,CAAC,UAAU,EAAEG,WAAW,CAAC,OAAGH,0JAAAA,EAC5CE,QAAQG,MAAM,CAACF,UAAU,EACzB,CAAC,EAAEG,IAAI,EAAEC,GAAG,EAAE;YACZ,MAAMC,SAA2C,CAAC;YAElD,IAAK,MAAMC,OAAOL,aAAc;gBAC9B,MAAMM,WAAWN,YAAY,CAACK,IAAI;gBAElC,IAAIC,SAASC,IAAI,KAAK,OAAO;oBAC3BH,MAAM,CAACC,IAAI,GAAGF,IAAIL,QAAQG,MAAM,CAACK,SAASE,EAAE,CAAC,EAAE;wBAC7CC,QAAQH,SAASG,MAAM,CAACC,GAAG,CACzB,CAACC,QAAUb,QAAQG,MAAM,CAACU,MAAMC,KAAK,CAAC,CAACD,MAAME,IAAI,CAAC;wBAEpDC,YAAYR,SAASQ,UAAU,CAACJ,GAAG,CACjC,CAACK,YAAcjB,QAAQG,MAAM,CAACK,SAASE,EAAE,CAAC,CAACO,UAAU;wBAEvDC,cAAcV,SAASU,YAAY;oBACrC;gBACF,OAAO;oBACL,IAAIlB,QAAQG,MAAM,CAACK,SAASE,EAAE,CAAC,EAAE;wBAC/BJ,MAAM,CAACC,IAAI,GAAGH,KAAKJ,QAAQG,MAAM,CAACK,SAASE,EAAE,CAAC,EAAE;4BAC9CQ,cAAcV,SAASU,YAAY;wBACrC;oBACF;gBACF;YACF;YAEA,OAAOZ;QACT;IAEJ;AACF,EAAC"}},
    {"offset": {"line": 9108, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/createTableName.ts"],"sourcesContent":["import type { DBIdentifierName } from 'payload'\n\nimport { APIError } from 'payload'\nimport toSnakeCase from 'to-snake-case'\n\nimport type { DrizzleAdapter } from './types.js'\n\ntype Args = {\n  adapter: Pick<DrizzleAdapter, 'tableNameMap' | 'versionsSuffix'>\n  /** The collection, global or field config **/\n  config: {\n    dbName?: DBIdentifierName\n    enumName?: DBIdentifierName\n    name?: string\n    slug?: string\n  }\n  /** For nested tables passed for the user custom dbName functions to handle their own iterations */\n  parentTableName?: string\n  /** For sub tables (array for example) this needs to include the parentTableName */\n  prefix?: string\n  /** For tables based on fields that could have both enumName and dbName (ie: select with hasMany), default: 'dbName' */\n  target?: 'dbName' | 'enumName'\n  /** Throws error if true for postgres when table and enum names exceed 63 characters */\n  throwValidationError?: boolean\n  /** Adds the versions suffix to the default table name - should only be used on the base collection to avoid duplicate suffixing */\n  versions?: boolean\n  /** Adds the versions suffix to custom dbName only - this is used while creating blocks / selects / arrays / etc */\n  versionsCustomName?: boolean\n}\n\n/**\n * Used to name database enums and tables\n * Returns the table or enum name for a given entity\n */\nexport const createTableName = ({\n  adapter,\n  config: { name, slug },\n  config,\n  parentTableName,\n  prefix = '',\n  target = 'dbName',\n  throwValidationError = false,\n  versions = false,\n  versionsCustomName = false,\n}: Args): string => {\n  let customNameDefinition = config[target]\n\n  let defaultTableName = `${prefix}${toSnakeCase(name ?? slug)}`\n\n  if (versions) {\n    defaultTableName = `_${defaultTableName}${adapter.versionsSuffix}`\n  }\n\n  let customTableNameResult: string\n\n  if (!customNameDefinition && target === 'enumName') {\n    customNameDefinition = config['dbName']\n  }\n\n  if (customNameDefinition) {\n    customTableNameResult =\n      typeof customNameDefinition === 'function'\n        ? customNameDefinition({ tableName: parentTableName })\n        : customNameDefinition\n\n    if (versionsCustomName) {\n      customTableNameResult = `_${customTableNameResult}${adapter.versionsSuffix}`\n    }\n  }\n\n  const result = customTableNameResult || defaultTableName\n\n  adapter.tableNameMap.set(defaultTableName, result)\n\n  if (!throwValidationError) {\n    return result\n  }\n\n  if (result.length > 63) {\n    throw new APIError(\n      `Exceeded max identifier length for table or enum name of 63 characters. Invalid name: ${result}.\nTip: You can use the dbName property to reduce the table name length.\n      `,\n    )\n  }\n\n  return result\n}\n"],"names":["APIError","toSnakeCase","createTableName","adapter","config","name","slug","parentTableName","prefix","target","throwValidationError","versions","versionsCustomName","customNameDefinition","defaultTableName","versionsSuffix","customTableNameResult","tableName","result","tableNameMap","set","length"],"mappings":";;;;AAEA,SAASA,QAAQ,QAAQ,UAAS;AAClC,OAAOC,iBAAiB,gBAAe;;;AA+BhC,MAAMC,kBAAkB,CAAC,EAC9BC,OAAO,EACPC,QAAQ,EAAEC,IAAI,EAAEC,IAAI,EAAE,EACtBF,MAAM,EACNG,eAAe,EACfC,SAAS,EAAE,EACXC,SAAS,QAAQ,EACjBC,uBAAuB,KAAK,EAC5BC,WAAW,KAAK,EAChBC,qBAAqB,KAAK,EACrB;IACL,IAAIC,uBAAuBT,MAAM,CAACK,OAAO;IAEzC,IAAIK,mBAAmB,GAAGN,aAASP,yJAAAA,EAAYI,QAAQC,OAAO;IAE9D,IAAIK,UAAU;QACZG,mBAAmB,CAAC,CAAC,EAAEA,mBAAmBX,QAAQY,cAAc,EAAE;IACpE;IAEA,IAAIC;IAEJ,IAAI,CAACH,wBAAwBJ,WAAW,YAAY;QAClDI,uBAAuBT,MAAM,CAAC,SAAS;IACzC;IAEA,IAAIS,sBAAsB;QACxBG,wBACE,OAAOH,yBAAyB,aAC5BA,qBAAqB;YAAEI,WAAWV;QAAgB,KAClDM;QAEN,IAAID,oBAAoB;YACtBI,wBAAwB,CAAC,CAAC,EAAEA,wBAAwBb,QAAQY,cAAc,EAAE;QAC9E;IACF;IAEA,MAAMG,SAASF,yBAAyBF;IAExCX,QAAQgB,YAAY,CAACC,GAAG,CAACN,kBAAkBI;IAE3C,IAAI,CAACR,sBAAsB;QACzB,OAAOQ;IACT;IAEA,IAAIA,OAAOG,MAAM,GAAG,IAAI;QACtB,MAAM,IAAIrB,mKAAAA,CACR,CAAC,sFAAsF,EAAEkB,OAAO;;MAEhG,CAAC;IAEL;IAEA,OAAOA;AACT,EAAC"}},
    {"offset": {"line": 9150, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/utilities/buildIndexName.ts"],"sourcesContent":["import type { DrizzleAdapter } from '../types.js'\n\nexport const buildIndexName = ({\n  name,\n  adapter,\n  appendSuffix = true,\n  number = 0,\n}: {\n  adapter: DrizzleAdapter\n  appendSuffix?: boolean\n  name: string\n  number?: number\n}): string => {\n  let indexName = `${name}${number ? `_${number}` : ''}${appendSuffix ? '_idx' : ''}`\n\n  if (indexName.length > 60) {\n    const suffix = `${number ? `_${number}` : ''}${appendSuffix ? '_idx' : ''}`\n    indexName = `${name.slice(0, 60 - suffix.length)}${suffix}`\n  }\n\n  if (!adapter.indexes.has(indexName) && !(indexName in adapter.rawTables)) {\n    adapter.indexes.add(indexName)\n    return indexName\n  }\n\n  return buildIndexName({\n    name,\n    adapter,\n    appendSuffix,\n    number: number + 1,\n  })\n}\n"],"names":["buildIndexName","name","adapter","appendSuffix","number","indexName","length","suffix","slice","indexes","has","rawTables","add"],"mappings":";;;;AAEO,MAAMA,iBAAiB,CAAC,EAC7BC,IAAI,EACJC,OAAO,EACPC,eAAe,IAAI,EACnBC,SAAS,CAAC,EAMX;IACC,IAAIC,YAAY,GAAGJ,OAAOG,SAAS,CAAC,CAAC,EAAEA,QAAQ,GAAG,KAAKD,eAAe,SAAS,IAAI;IAEnF,IAAIE,UAAUC,MAAM,GAAG,IAAI;QACzB,MAAMC,SAAS,GAAGH,SAAS,CAAC,CAAC,EAAEA,QAAQ,GAAG,KAAKD,eAAe,SAAS,IAAI;QAC3EE,YAAY,GAAGJ,KAAKO,KAAK,CAAC,GAAG,KAAKD,OAAOD,MAAM,IAAIC,QAAQ;IAC7D;IAEA,IAAI,CAACL,QAAQO,OAAO,CAACC,GAAG,CAACL,cAAc,CAAEA,CAAAA,aAAaH,QAAQS,SAAQ,GAAI;QACxET,QAAQO,OAAO,CAACG,GAAG,CAACP;QACpB,OAAOA;IACT;IAEA,OAAOL,eAAe;QACpBC;QACAC;QACAC;QACAC,QAAQA,SAAS;IACnB;AACF,EAAC"}},
    {"offset": {"line": 9175, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/utilities/buildForeignKeyName.ts"],"sourcesContent":["import type { DrizzleAdapter } from '../types.js'\n\nexport const buildForeignKeyName = ({\n  name,\n  adapter,\n  number = 0,\n}: {\n  adapter: DrizzleAdapter\n  name: string\n  number?: number\n}): string => {\n  let foreignKeyName = `${name}${number ? `_${number}` : ''}_fk`\n\n  if (foreignKeyName.length > 60) {\n    const suffix = `${number ? `_${number}` : ''}_fk`\n    foreignKeyName = `${name.slice(0, 60 - suffix.length)}${suffix}`\n  }\n\n  if (!adapter.foreignKeys.has(foreignKeyName)) {\n    adapter.foreignKeys.add(foreignKeyName)\n    return foreignKeyName\n  }\n\n  return buildForeignKeyName({\n    name,\n    adapter,\n    number: number + 1,\n  })\n}\n"],"names":["buildForeignKeyName","name","adapter","number","foreignKeyName","length","suffix","slice","foreignKeys","has","add"],"mappings":";;;;AAEO,MAAMA,sBAAsB,CAAC,EAClCC,IAAI,EACJC,OAAO,EACPC,SAAS,CAAC,EAKX;IACC,IAAIC,iBAAiB,GAAGH,OAAOE,SAAS,CAAC,CAAC,EAAEA,QAAQ,GAAG,GAAG,GAAG,CAAC;IAE9D,IAAIC,eAAeC,MAAM,GAAG,IAAI;QAC9B,MAAMC,SAAS,GAAGH,SAAS,CAAC,CAAC,EAAEA,QAAQ,GAAG,GAAG,GAAG,CAAC;QACjDC,iBAAiB,GAAGH,KAAKM,KAAK,CAAC,GAAG,KAAKD,OAAOD,MAAM,IAAIC,QAAQ;IAClE;IAEA,IAAI,CAACJ,QAAQM,WAAW,CAACC,GAAG,CAACL,iBAAiB;QAC5CF,QAAQM,WAAW,CAACE,GAAG,CAACN;QACxB,OAAOA;IACT;IAEA,OAAOJ,oBAAoB;QACzBC;QACAC;QACAC,QAAQA,SAAS;IACnB;AACF,EAAC"}},
    {"offset": {"line": 9199, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/utilities/hasLocalesTable.ts"],"sourcesContent":["import type { Field } from 'payload'\n\nimport { fieldAffectsData, fieldHasSubFields, fieldShouldBeLocalized } from 'payload/shared'\n\nexport const hasLocalesTable = ({\n  fields,\n  parentIsLocalized,\n}: {\n  fields: Field[]\n  /**\n   * @todo make required in v4.0. Usually you'd wanna pass this in\n   */\n  parentIsLocalized?: boolean\n}): boolean => {\n  return fields.some((field) => {\n    // arrays always get a separate table\n    if (field.type === 'array') {\n      return false\n    }\n    if (fieldAffectsData(field) && fieldShouldBeLocalized({ field, parentIsLocalized })) {\n      return true\n    }\n    if (fieldHasSubFields(field)) {\n      return hasLocalesTable({\n        fields: field.fields,\n        parentIsLocalized: parentIsLocalized || ('localized' in field && field.localized),\n      })\n    }\n    if (field.type === 'tabs') {\n      return field.tabs.some((tab) =>\n        hasLocalesTable({\n          fields: tab.fields,\n          parentIsLocalized: parentIsLocalized || tab.localized,\n        }),\n      )\n    }\n    return false\n  })\n}\n"],"names":["fieldAffectsData","fieldHasSubFields","fieldShouldBeLocalized","hasLocalesTable","fields","parentIsLocalized","some","field","type","localized","tabs","tab"],"mappings":";;;;AAEA,SAASA,gBAAgB,EAAEC,iBAAiB,EAAEC,sBAAsB,QAAQ,iBAAgB;;AAErF,MAAMC,kBAAkB,CAAC,EAC9BC,MAAM,EACNC,iBAAiB,EAOlB;IACC,OAAOD,OAAOE,IAAI,CAAC,CAACC;QAClB,qCAAqC;QACrC,IAAIA,MAAMC,IAAI,KAAK,SAAS;YAC1B,OAAO;QACT;QACA,QAAIR,kLAAAA,EAAiBO,cAAUL,wLAAAA,EAAuB;YAAEK;YAAOF;QAAkB,IAAI;YACnF,OAAO;QACT;QACA,QAAIJ,mLAAAA,EAAkBM,QAAQ;YAC5B,OAAOJ,gBAAgB;gBACrBC,QAAQG,MAAMH,MAAM;gBACpBC,mBAAmBA,qBAAsB,eAAeE,SAASA,MAAME,SAAS;YAClF;QACF;QACA,IAAIF,MAAMC,IAAI,KAAK,QAAQ;YACzB,OAAOD,MAAMG,IAAI,CAACJ,IAAI,CAAC,CAACK,MACtBR,gBAAgB;oBACdC,QAAQO,IAAIP,MAAM;oBAClBC,mBAAmBA,qBAAqBM,IAAIF,SAAS;gBACvD;QAEJ;QACA,OAAO;IACT;AACF,EAAC"}},
    {"offset": {"line": 9236, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/schema/idToUUID.ts"],"sourcesContent":["import type { FlattenedField } from 'payload'\n\nexport const idToUUID = (fields: FlattenedField[]): FlattenedField[] =>\n  fields.map((field) => {\n    if ('name' in field && field.name === 'id') {\n      return {\n        ...field,\n        name: '_uuid',\n      }\n    }\n\n    return field\n  })\n"],"names":["idToUUID","fields","map","field","name"],"mappings":";;;;AAEO,MAAMA,WAAW,CAACC,SACvBA,OAAOC,GAAG,CAAC,CAACC;QACV,IAAI,UAAUA,SAASA,MAAMC,IAAI,KAAK,MAAM;YAC1C,OAAO;gBACL,GAAGD,KAAK;gBACRC,MAAM;YACR;QACF;QAEA,OAAOD;IACT,GAAE"}},
    {"offset": {"line": 9253, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/schema/withDefault.ts"],"sourcesContent":["import type { FieldAffectingData } from 'payload'\n\nimport type { RawColumn } from '../types.js'\n\nexport const withDefault = (column: RawColumn, field: FieldAffectingData): RawColumn => {\n  if (typeof field.defaultValue === 'undefined' || typeof field.defaultValue === 'function') {\n    return column\n  }\n\n  return {\n    ...column,\n    default: field.defaultValue,\n  }\n}\n"],"names":["withDefault","column","field","defaultValue","default"],"mappings":";;;;AAIO,MAAMA,cAAc,CAACC,QAAmBC;IAC7C,IAAI,OAAOA,MAAMC,YAAY,KAAK,eAAe,OAAOD,MAAMC,YAAY,KAAK,YAAY;QACzF,OAAOF;IACT;IAEA,OAAO;QACL,GAAGA,MAAM;QACTG,SAASF,MAAMC,YAAY;IAC7B;AACF,EAAC"}},
    {"offset": {"line": 9270, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/schema/traverseFields.ts"],"sourcesContent":["import type { FlattenedField } from 'payload'\n\nimport { InvalidConfiguration } from 'payload'\nimport {\n  fieldAffectsData,\n  fieldIsVirtual,\n  fieldShouldBeLocalized,\n  optionIsObject,\n} from 'payload/shared'\nimport toSnakeCase from 'to-snake-case'\n\nimport type {\n  DrizzleAdapter,\n  IDType,\n  RawColumn,\n  RawForeignKey,\n  RawIndex,\n  RawRelation,\n  RelationMap,\n  SetColumnID,\n} from '../types.js'\n\nimport { createTableName } from '../createTableName.js'\nimport { buildIndexName } from '../utilities/buildIndexName.js'\nimport { getArrayRelationName } from '../utilities/getArrayRelationName.js'\nimport { hasLocalesTable } from '../utilities/hasLocalesTable.js'\nimport {\n  InternalBlockTableNameIndex,\n  setInternalBlockIndex,\n  validateExistingBlockIsIdentical,\n} from '../utilities/validateExistingBlockIsIdentical.js'\nimport { buildTable } from './build.js'\nimport { idToUUID } from './idToUUID.js'\nimport { withDefault } from './withDefault.js'\n\ntype Args = {\n  adapter: DrizzleAdapter\n  blocksTableNameMap: Record<string, number>\n  columnPrefix?: string\n  columns: Record<string, RawColumn>\n  disableNotNull: boolean\n  disableRelsTableUnique?: boolean\n  disableUnique?: boolean\n  fieldPrefix?: string\n  fields: FlattenedField[]\n  forceLocalized?: boolean\n  indexes: Record<string, RawIndex>\n  localesColumns: Record<string, RawColumn>\n  localesIndexes: Record<string, RawIndex>\n  newTableName: string\n  parentIsLocalized: boolean\n  parentTableName: string\n  relationships: Set<string>\n  relationsToBuild: RelationMap\n  rootRelationsToBuild?: RelationMap\n  rootTableIDColType: IDType\n  rootTableName: string\n  setColumnID: SetColumnID\n  uniqueRelationships: Set<string>\n  versions: boolean\n  /**\n   * Tracks whether or not this table is built\n   * from the result of a localized array or block field at some point\n   */\n  withinLocalizedArrayOrBlock?: boolean\n}\n\ntype Result = {\n  hasLocalizedField: boolean\n  hasLocalizedManyNumberField: boolean\n  hasLocalizedManyTextField: boolean\n  hasLocalizedRelationshipField: boolean\n  hasManyNumberField: 'index' | boolean\n  hasManyTextField: 'index' | boolean\n}\n\nexport const traverseFields = ({\n  adapter,\n  blocksTableNameMap,\n  columnPrefix,\n  columns,\n  disableNotNull,\n  disableRelsTableUnique,\n  disableUnique = false,\n  fieldPrefix,\n  fields,\n  forceLocalized,\n  indexes,\n  localesColumns,\n  localesIndexes,\n  newTableName,\n  parentIsLocalized,\n  parentTableName,\n  relationships,\n  relationsToBuild,\n  rootRelationsToBuild,\n  rootTableIDColType,\n  rootTableName,\n  setColumnID,\n  uniqueRelationships,\n  versions,\n  withinLocalizedArrayOrBlock,\n}: Args): Result => {\n  const throwValidationError = true\n  let hasLocalizedField = false\n  let hasLocalizedRelationshipField = false\n  let hasManyTextField: 'index' | boolean = false\n  let hasLocalizedManyTextField = false\n  let hasManyNumberField: 'index' | boolean = false\n  let hasLocalizedManyNumberField = false\n\n  let parentIDColType: IDType = 'integer'\n\n  const idColumn = columns.id\n\n  if (idColumn && ['numeric', 'text', 'uuid', 'varchar'].includes(idColumn.type)) {\n    parentIDColType = idColumn.type as IDType\n  }\n\n  fields.forEach((field) => {\n    if ('name' in field && field.name === 'id') {\n      return\n    }\n    if (fieldIsVirtual(field)) {\n      return\n    }\n\n    let targetTable = columns\n    let targetIndexes = indexes\n\n    const columnName = `${columnPrefix || ''}${field.name[0] === '_' ? '_' : ''}${toSnakeCase(\n      field.name,\n    )}`\n    const fieldName = `${fieldPrefix?.replace('.', '_') || ''}${field.name}`\n\n    const isFieldLocalized = fieldShouldBeLocalized({ field, parentIsLocalized })\n\n    // If field is localized,\n    // add the column to the locale table instead of main table\n    if (\n      adapter.payload.config.localization &&\n      (isFieldLocalized || forceLocalized) &&\n      field.type !== 'array' &&\n      (field.type !== 'blocks' || adapter.blocksAsJSON) &&\n      (('hasMany' in field && field.hasMany !== true) || !('hasMany' in field))\n    ) {\n      hasLocalizedField = true\n      targetTable = localesColumns\n      targetIndexes = localesIndexes\n    }\n\n    if (\n      (field.unique || field.index || ['relationship', 'upload'].includes(field.type)) &&\n      !['array', 'blocks', 'group'].includes(field.type) &&\n      !('hasMany' in field && field.hasMany === true) &&\n      !('relationTo' in field && Array.isArray(field.relationTo))\n    ) {\n      const unique = disableUnique !== true && field.unique\n      if (unique) {\n        const constraintValue = `${fieldPrefix || ''}${field.name}`\n        if (!adapter.fieldConstraints?.[rootTableName]) {\n          adapter.fieldConstraints[rootTableName] = {}\n        }\n        adapter.fieldConstraints[rootTableName][`${columnName}_idx`] = constraintValue\n      }\n\n      const indexName = buildIndexName({ name: `${newTableName}_${columnName}`, adapter })\n\n      targetIndexes[indexName] = {\n        name: indexName,\n        on: isFieldLocalized ? [fieldName, '_locale'] : fieldName,\n        unique,\n      }\n    }\n\n    switch (field.type) {\n      case 'array': {\n        const disableNotNullFromHere = Boolean(field.admin?.condition) || disableNotNull\n\n        const arrayTableName = createTableName({\n          adapter,\n          config: field,\n          parentTableName: newTableName,\n          prefix: `${newTableName}_`,\n          throwValidationError,\n          versionsCustomName: versions,\n        })\n\n        const baseColumns: Record<string, RawColumn> = {\n          _order: {\n            name: '_order',\n            type: 'integer',\n            notNull: true,\n          },\n          _parentID: {\n            name: '_parent_id',\n            type: parentIDColType,\n            notNull: true,\n          },\n        }\n\n        const baseIndexes: Record<string, RawIndex> = {\n          _orderIdx: {\n            name: `${arrayTableName}_order_idx`,\n            on: ['_order'],\n          },\n          _parentIDIdx: {\n            name: `${arrayTableName}_parent_id_idx`,\n            on: '_parentID',\n          },\n        }\n\n        const baseForeignKeys: Record<string, RawForeignKey> = {\n          _parentIDFk: {\n            name: `${arrayTableName}_parent_id_fk`,\n            columns: ['_parentID'],\n            foreignColumns: [\n              {\n                name: 'id',\n                table: parentTableName,\n              },\n            ],\n            onDelete: 'cascade',\n          },\n        }\n\n        const isLocalized =\n          Boolean(isFieldLocalized && adapter.payload.config.localization) ||\n          withinLocalizedArrayOrBlock ||\n          forceLocalized\n\n        if (isLocalized) {\n          baseColumns._locale = {\n            name: '_locale',\n            type: 'enum',\n            locale: true,\n            notNull: true,\n          }\n\n          baseIndexes._localeIdx = {\n            name: `${arrayTableName}_locale_idx`,\n            on: '_locale',\n          }\n        }\n\n        const {\n          hasLocalizedManyNumberField: subHasLocalizedManyNumberField,\n          hasLocalizedManyTextField: subHasLocalizedManyTextField,\n          hasLocalizedRelationshipField: subHasLocalizedRelationshipField,\n          hasManyNumberField: subHasManyNumberField,\n          hasManyTextField: subHasManyTextField,\n          relationsToBuild: subRelationsToBuild,\n        } = buildTable({\n          adapter,\n          baseColumns,\n          baseForeignKeys,\n          baseIndexes,\n          blocksTableNameMap,\n          disableNotNull: disableNotNullFromHere,\n          disableRelsTableUnique: true,\n          disableUnique,\n          fields: disableUnique ? idToUUID(field.flattenedFields) : field.flattenedFields,\n          parentIsLocalized: parentIsLocalized || field.localized,\n          rootRelationships: relationships,\n          rootRelationsToBuild,\n          rootTableIDColType,\n          rootTableName,\n          rootUniqueRelationships: uniqueRelationships,\n          setColumnID,\n          tableName: arrayTableName,\n          versions,\n          withinLocalizedArrayOrBlock: isLocalized,\n        })\n\n        if (subHasLocalizedManyNumberField) {\n          hasLocalizedManyNumberField = subHasLocalizedManyNumberField\n        }\n\n        if (subHasLocalizedRelationshipField) {\n          hasLocalizedRelationshipField = subHasLocalizedRelationshipField\n        }\n\n        if (subHasLocalizedManyTextField) {\n          hasLocalizedManyTextField = subHasLocalizedManyTextField\n        }\n\n        if (subHasManyTextField) {\n          if (!hasManyTextField || subHasManyTextField === 'index') {\n            hasManyTextField = subHasManyTextField\n          }\n        }\n        if (subHasManyNumberField) {\n          if (!hasManyNumberField || subHasManyNumberField === 'index') {\n            hasManyNumberField = subHasManyNumberField\n          }\n        }\n\n        const relationName = getArrayRelationName({\n          field,\n          path: fieldName,\n          tableName: arrayTableName,\n        })\n\n        relationsToBuild.set(relationName, {\n          type: 'many',\n          // arrays have their own localized table, independent of the base table.\n          localized: false,\n          target: arrayTableName,\n        })\n\n        const arrayRelations: Record<string, RawRelation> = {\n          _parentID: {\n            type: 'one',\n            fields: [\n              {\n                name: '_parentID',\n                table: arrayTableName,\n              },\n            ],\n            references: ['id'],\n            relationName,\n            to: parentTableName,\n          },\n        }\n\n        if (\n          hasLocalesTable({\n            fields: field.fields,\n            parentIsLocalized: parentIsLocalized || field.localized,\n          })\n        ) {\n          arrayRelations._locales = {\n            type: 'many',\n            relationName: '_locales',\n            to: `${arrayTableName}${adapter.localesSuffix}`,\n          }\n        }\n\n        subRelationsToBuild.forEach(({ type, localized, target }, key) => {\n          if (type === 'one') {\n            const arrayWithLocalized = localized\n              ? `${arrayTableName}${adapter.localesSuffix}`\n              : arrayTableName\n\n            arrayRelations[key] = {\n              type: 'one',\n              fields: [\n                {\n                  name: key,\n                  table: arrayWithLocalized,\n                },\n              ],\n              references: ['id'],\n              relationName: key,\n              to: target,\n            }\n          }\n\n          if (type === 'many') {\n            arrayRelations[key] = {\n              type: 'many',\n              relationName: key,\n              to: target,\n            }\n          }\n        })\n\n        adapter.rawRelations[arrayTableName] = arrayRelations\n\n        break\n      }\n      case 'blocks': {\n        if (adapter.blocksAsJSON) {\n          targetTable[fieldName] = withDefault(\n            {\n              name: columnName,\n              type: 'jsonb',\n            },\n            field,\n          )\n          break\n        }\n\n        const disableNotNullFromHere = Boolean(field.admin?.condition) || disableNotNull\n\n        ;(field.blockReferences ?? field.blocks).forEach((_block) => {\n          const block = typeof _block === 'string' ? adapter.payload.blocks[_block] : _block\n\n          let blockTableName = createTableName({\n            adapter,\n            config: block,\n            parentTableName: rootTableName,\n            prefix: `${rootTableName}_blocks_`,\n            throwValidationError,\n            versionsCustomName: versions,\n          })\n\n          if (typeof blocksTableNameMap[blockTableName] === 'undefined') {\n            blocksTableNameMap[blockTableName] = 1\n          } else if (\n            !adapter.rawTables[blockTableName] ||\n            !validateExistingBlockIsIdentical({\n              block,\n              localized: field.localized,\n              rootTableName,\n              table: adapter.rawTables[blockTableName],\n              tableLocales: adapter.rawTables[`${blockTableName}${adapter.localesSuffix}`],\n            })\n          ) {\n            blocksTableNameMap[blockTableName]++\n            setInternalBlockIndex(block, blocksTableNameMap[blockTableName])\n            blockTableName = `${blockTableName}_${blocksTableNameMap[blockTableName]}`\n          }\n          let relationName = `_blocks_${block.slug}`\n          if (typeof block[InternalBlockTableNameIndex] !== 'undefined') {\n            relationName = `_blocks_${block.slug}_${block[InternalBlockTableNameIndex]}`\n          }\n\n          if (!adapter.rawTables[blockTableName]) {\n            const baseColumns: Record<string, RawColumn> = {\n              _order: {\n                name: '_order',\n                type: 'integer',\n                notNull: true,\n              },\n              _parentID: {\n                name: '_parent_id',\n                type: rootTableIDColType,\n                notNull: true,\n              },\n              _path: {\n                name: '_path',\n                type: 'text',\n                notNull: true,\n              },\n            }\n\n            const baseIndexes: Record<string, RawIndex> = {\n              _orderIdx: {\n                name: `${blockTableName}_order_idx`,\n                on: '_order',\n              },\n              _parentIDIdx: {\n                name: `${blockTableName}_parent_id_idx`,\n                on: ['_parentID'],\n              },\n              _pathIdx: {\n                name: `${blockTableName}_path_idx`,\n                on: '_path',\n              },\n            }\n\n            const baseForeignKeys: Record<string, RawForeignKey> = {\n              _parentIdFk: {\n                name: `${blockTableName}_parent_id_fk`,\n                columns: ['_parentID'],\n                foreignColumns: [\n                  {\n                    name: 'id',\n                    table: rootTableName,\n                  },\n                ],\n                onDelete: 'cascade',\n              },\n            }\n\n            const isLocalized =\n              Boolean(isFieldLocalized && adapter.payload.config.localization) ||\n              withinLocalizedArrayOrBlock ||\n              forceLocalized\n\n            if (isLocalized) {\n              baseColumns._locale = {\n                name: '_locale',\n                type: 'enum',\n                locale: true,\n                notNull: true,\n              }\n\n              baseIndexes._localeIdx = {\n                name: `${blockTableName}_locale_idx`,\n                on: '_locale',\n              }\n            }\n\n            const {\n              hasLocalizedManyNumberField: subHasLocalizedManyNumberField,\n              hasLocalizedManyTextField: subHasLocalizedManyTextField,\n              hasLocalizedRelationshipField: subHasLocalizedRelationshipField,\n              hasManyNumberField: subHasManyNumberField,\n              hasManyTextField: subHasManyTextField,\n              relationsToBuild: subRelationsToBuild,\n            } = buildTable({\n              adapter,\n              baseColumns,\n              baseForeignKeys,\n              baseIndexes,\n              blocksTableNameMap,\n              disableNotNull: disableNotNullFromHere,\n              disableRelsTableUnique: true,\n              disableUnique,\n              fields: disableUnique ? idToUUID(block.flattenedFields) : block.flattenedFields,\n              parentIsLocalized: parentIsLocalized || field.localized,\n              rootRelationships: relationships,\n              rootRelationsToBuild,\n              rootTableIDColType,\n              rootTableName,\n              rootUniqueRelationships: uniqueRelationships,\n              setColumnID,\n              tableName: blockTableName,\n              versions,\n              withinLocalizedArrayOrBlock: isLocalized,\n            })\n\n            if (subHasLocalizedManyNumberField) {\n              hasLocalizedManyNumberField = subHasLocalizedManyNumberField\n            }\n\n            if (subHasLocalizedRelationshipField) {\n              hasLocalizedRelationshipField = subHasLocalizedRelationshipField\n            }\n\n            if (subHasLocalizedManyTextField) {\n              hasLocalizedManyTextField = subHasLocalizedManyTextField\n            }\n\n            if (subHasManyTextField) {\n              if (!hasManyTextField || subHasManyTextField === 'index') {\n                hasManyTextField = subHasManyTextField\n              }\n            }\n\n            if (subHasManyNumberField) {\n              if (!hasManyNumberField || subHasManyNumberField === 'index') {\n                hasManyNumberField = subHasManyNumberField\n              }\n            }\n\n            const blockRelations: Record<string, RawRelation> = {\n              _parentID: {\n                type: 'one',\n                fields: [\n                  {\n                    name: '_parentID',\n                    table: blockTableName,\n                  },\n                ],\n                references: ['id'],\n                relationName,\n                to: rootTableName,\n              },\n            }\n\n            if (\n              hasLocalesTable({\n                fields: block.fields,\n                parentIsLocalized: parentIsLocalized || field.localized,\n              })\n            ) {\n              blockRelations._locales = {\n                type: 'many',\n                relationName: '_locales',\n                to: `${blockTableName}${adapter.localesSuffix}`,\n              }\n            }\n\n            subRelationsToBuild.forEach(({ type, localized, target }, key) => {\n              if (type === 'one') {\n                const blockWithLocalized = localized\n                  ? `${blockTableName}${adapter.localesSuffix}`\n                  : blockTableName\n\n                blockRelations[key] = {\n                  type: 'one',\n                  fields: [\n                    {\n                      name: key,\n                      table: blockWithLocalized,\n                    },\n                  ],\n                  references: ['id'],\n                  relationName: key,\n                  to: target,\n                }\n              }\n\n              if (type === 'many') {\n                blockRelations[key] = {\n                  type: 'many',\n                  relationName: key,\n                  to: target,\n                }\n              }\n            })\n\n            adapter.rawRelations[blockTableName] = blockRelations\n          }\n\n          // blocks relationships are defined from the collection or globals table down to the block, bypassing any subBlocks\n          rootRelationsToBuild.set(relationName, {\n            type: 'many',\n            // blocks are not localized on the parent table\n            localized: false,\n            target: blockTableName,\n          })\n        })\n\n        break\n      }\n      case 'checkbox': {\n        targetTable[fieldName] = withDefault(\n          {\n            name: columnName,\n            type: 'boolean',\n          },\n          field,\n        )\n\n        break\n      }\n\n      case 'code':\n      case 'email':\n      case 'textarea': {\n        targetTable[fieldName] = withDefault(\n          {\n            name: columnName,\n            type: 'varchar',\n          },\n          field,\n        )\n\n        break\n      }\n\n      case 'date': {\n        targetTable[fieldName] = withDefault(\n          {\n            name: columnName,\n            type: 'timestamp',\n            mode: 'string',\n            precision: 3,\n            withTimezone: true,\n          },\n          field,\n        )\n\n        break\n      }\n\n      case 'group':\n      case 'tab': {\n        const disableNotNullFromHere = Boolean(field.admin?.condition) || disableNotNull\n\n        const {\n          hasLocalizedField: groupHasLocalizedField,\n          hasLocalizedManyNumberField: groupHasLocalizedManyNumberField,\n          hasLocalizedManyTextField: groupHasLocalizedManyTextField,\n          hasLocalizedRelationshipField: groupHasLocalizedRelationshipField,\n          hasManyNumberField: groupHasManyNumberField,\n          hasManyTextField: groupHasManyTextField,\n        } = traverseFields({\n          adapter,\n          blocksTableNameMap,\n          columnPrefix: `${columnName}_`,\n          columns,\n          disableNotNull: disableNotNullFromHere,\n          disableUnique,\n          fieldPrefix: `${fieldName}.`,\n          fields: field.flattenedFields,\n          forceLocalized: isFieldLocalized,\n          indexes,\n          localesColumns,\n          localesIndexes,\n          newTableName: `${parentTableName}_${columnName}`,\n          parentIsLocalized: parentIsLocalized || field.localized,\n          parentTableName,\n          relationships,\n          relationsToBuild,\n          rootRelationsToBuild,\n          rootTableIDColType,\n          rootTableName,\n          setColumnID,\n          uniqueRelationships,\n          versions,\n          withinLocalizedArrayOrBlock: withinLocalizedArrayOrBlock || isFieldLocalized,\n        })\n\n        if (groupHasLocalizedField) {\n          hasLocalizedField = true\n        }\n        if (groupHasLocalizedRelationshipField) {\n          hasLocalizedRelationshipField = true\n        }\n        if (groupHasManyTextField) {\n          hasManyTextField = true\n        }\n        if (groupHasLocalizedManyTextField) {\n          hasLocalizedManyTextField = true\n        }\n        if (groupHasManyNumberField) {\n          hasManyNumberField = true\n        }\n        if (groupHasLocalizedManyNumberField) {\n          hasLocalizedManyNumberField = true\n        }\n        break\n      }\n\n      case 'json':\n      case 'richText': {\n        targetTable[fieldName] = withDefault(\n          {\n            name: columnName,\n            type: 'jsonb',\n          },\n          field,\n        )\n\n        break\n      }\n\n      case 'number': {\n        if (field.hasMany) {\n          const isLocalized =\n            Boolean(isFieldLocalized && adapter.payload.config.localization) ||\n            withinLocalizedArrayOrBlock ||\n            forceLocalized\n\n          if (isLocalized) {\n            hasLocalizedManyNumberField = true\n          }\n\n          if (field.index) {\n            hasManyNumberField = 'index'\n          } else if (!hasManyNumberField) {\n            hasManyNumberField = true\n          }\n\n          if (field.unique) {\n            throw new InvalidConfiguration(\n              'Unique is not supported in Postgres for hasMany number fields.',\n            )\n          }\n        } else {\n          targetTable[fieldName] = withDefault(\n            {\n              name: columnName,\n              type: 'numeric',\n            },\n            field,\n          )\n        }\n\n        break\n      }\n\n      case 'point': {\n        targetTable[fieldName] = withDefault(\n          {\n            name: columnName,\n            type: 'geometry',\n          },\n          field,\n        )\n\n        break\n      }\n\n      case 'radio':\n      case 'select': {\n        const enumName = createTableName({\n          adapter,\n          config: field,\n          parentTableName: newTableName,\n          prefix: `enum_${newTableName}_`,\n          target: 'enumName',\n          throwValidationError,\n        })\n\n        const options = field.options.map((option) => {\n          if (optionIsObject(option)) {\n            return option.value\n          }\n\n          return option\n        })\n\n        if (field.type === 'select' && field.hasMany) {\n          const selectTableName = createTableName({\n            adapter,\n            config: field,\n            parentTableName: newTableName,\n            prefix: `${newTableName}_`,\n            throwValidationError,\n            versionsCustomName: versions,\n          })\n\n          const baseColumns: Record<string, RawColumn> = {\n            order: {\n              name: 'order',\n              type: 'integer',\n              notNull: true,\n            },\n            parent: {\n              name: 'parent_id',\n              type: parentIDColType,\n              notNull: true,\n            },\n            value: {\n              name: 'value',\n              type: 'enum',\n              enumName: createTableName({\n                adapter,\n                config: field,\n                parentTableName: newTableName,\n                prefix: `enum_${newTableName}_`,\n                target: 'enumName',\n                throwValidationError,\n              }),\n              options,\n            },\n          }\n\n          const baseIndexes: Record<string, RawIndex> = {\n            orderIdx: {\n              name: `${selectTableName}_order_idx`,\n              on: 'order',\n            },\n            parentIdx: {\n              name: `${selectTableName}_parent_idx`,\n              on: 'parent',\n            },\n          }\n\n          const baseForeignKeys: Record<string, RawForeignKey> = {\n            parentFk: {\n              name: `${selectTableName}_parent_fk`,\n              columns: ['parent'],\n              foreignColumns: [\n                {\n                  name: 'id',\n                  table: parentTableName,\n                },\n              ],\n              onDelete: 'cascade',\n            },\n          }\n\n          const isLocalized =\n            Boolean(isFieldLocalized && adapter.payload.config.localization) ||\n            withinLocalizedArrayOrBlock ||\n            forceLocalized\n\n          if (isLocalized) {\n            baseColumns.locale = {\n              name: 'locale',\n              type: 'enum',\n              locale: true,\n              notNull: true,\n            }\n\n            baseIndexes.localeIdx = {\n              name: `${selectTableName}_locale_idx`,\n              on: 'locale',\n            }\n          }\n\n          if (field.index) {\n            baseIndexes.value = {\n              name: `${selectTableName}_value_idx`,\n              on: 'value',\n            }\n          }\n\n          buildTable({\n            adapter,\n            baseColumns,\n            baseForeignKeys,\n            baseIndexes,\n            blocksTableNameMap,\n            disableNotNull,\n            disableUnique,\n            fields: [],\n            parentIsLocalized: parentIsLocalized || field.localized,\n            rootTableName,\n            setColumnID,\n            tableName: selectTableName,\n            versions,\n          })\n\n          relationsToBuild.set(fieldName, {\n            type: 'many',\n            // selects have their own localized table, independent of the base table.\n            localized: false,\n            target: selectTableName,\n          })\n\n          adapter.rawRelations[selectTableName] = {\n            parent: {\n              type: 'one',\n              fields: [\n                {\n                  name: 'parent',\n                  table: selectTableName,\n                },\n              ],\n              references: ['id'],\n              relationName: fieldName,\n              to: parentTableName,\n            },\n          }\n        } else {\n          targetTable[fieldName] = withDefault(\n            {\n              name: columnName,\n              type: 'enum',\n              enumName,\n              options,\n            },\n            field,\n          )\n        }\n        break\n      }\n\n      case 'relationship':\n      case 'upload':\n        if (Array.isArray(field.relationTo)) {\n          field.relationTo.forEach((relation) => {\n            relationships.add(relation)\n            if (field.unique && !disableUnique && !disableRelsTableUnique) {\n              uniqueRelationships.add(relation)\n            }\n          })\n        } else if (field.hasMany) {\n          relationships.add(field.relationTo)\n          if (field.unique && !disableUnique && !disableRelsTableUnique) {\n            uniqueRelationships.add(field.relationTo)\n          }\n        } else {\n          // simple relationships get a column on the targetTable with a foreign key to the relationTo table\n          const relationshipConfig = adapter.payload.collections[field.relationTo].config\n\n          const tableName = adapter.tableNameMap.get(toSnakeCase(field.relationTo))\n\n          // get the id type of the related collection\n          let colType: IDType = adapter.idType === 'uuid' ? 'uuid' : 'integer'\n          const relatedCollectionCustomID = relationshipConfig.fields.find(\n            (field) => fieldAffectsData(field) && field.name === 'id',\n          )\n          if (relatedCollectionCustomID?.type === 'number') {\n            colType = 'numeric'\n          }\n          if (relatedCollectionCustomID?.type === 'text') {\n            colType = 'varchar'\n          }\n\n          // make the foreign key column for relationship using the correct id column type\n          targetTable[fieldName] = {\n            name: `${columnName}_id`,\n            type: colType,\n            reference: {\n              name: 'id',\n              onDelete: 'set null',\n              table: tableName,\n            },\n          }\n\n          // add relationship to table\n          relationsToBuild.set(fieldName, {\n            type: 'one',\n            localized: adapter.payload.config.localization && (isFieldLocalized || forceLocalized),\n            target: tableName,\n          })\n\n          // add notNull when not required\n          if (!disableNotNull && field.required && !field.admin?.condition) {\n            targetTable[fieldName].notNull = true\n          }\n          break\n        }\n\n        if (\n          Boolean(isFieldLocalized && adapter.payload.config.localization) ||\n          withinLocalizedArrayOrBlock\n        ) {\n          hasLocalizedRelationshipField = true\n        }\n\n        break\n\n      case 'text': {\n        if (field.hasMany) {\n          const isLocalized =\n            Boolean(isFieldLocalized && adapter.payload.config.localization) ||\n            withinLocalizedArrayOrBlock ||\n            forceLocalized\n\n          if (isLocalized) {\n            hasLocalizedManyTextField = true\n          }\n\n          if (field.index) {\n            hasManyTextField = 'index'\n          } else if (!hasManyTextField) {\n            hasManyTextField = true\n          }\n\n          if (field.unique) {\n            throw new InvalidConfiguration(\n              'Unique is not supported in Postgres for hasMany text fields.',\n            )\n          }\n        } else {\n          targetTable[fieldName] = withDefault(\n            {\n              name: columnName,\n              type: 'varchar',\n            },\n            field,\n          )\n        }\n        break\n      }\n\n      default:\n        break\n    }\n\n    const condition = field.admin && field.admin.condition\n\n    if (\n      !disableNotNull &&\n      targetTable[fieldName] &&\n      'required' in field &&\n      field.required &&\n      !condition\n    ) {\n      targetTable[fieldName].notNull = true\n    }\n  })\n\n  return {\n    hasLocalizedField,\n    hasLocalizedManyNumberField,\n    hasLocalizedManyTextField,\n    hasLocalizedRelationshipField,\n    hasManyNumberField,\n    hasManyTextField,\n  }\n}\n"],"names":["InvalidConfiguration","fieldAffectsData","fieldIsVirtual","fieldShouldBeLocalized","optionIsObject","toSnakeCase","createTableName","buildIndexName","getArrayRelationName","hasLocalesTable","InternalBlockTableNameIndex","setInternalBlockIndex","validateExistingBlockIsIdentical","buildTable","idToUUID","withDefault","traverseFields","adapter","blocksTableNameMap","columnPrefix","columns","disableNotNull","disableRelsTableUnique","disableUnique","fieldPrefix","fields","forceLocalized","indexes","localesColumns","localesIndexes","newTableName","parentIsLocalized","parentTableName","relationships","relationsToBuild","rootRelationsToBuild","rootTableIDColType","rootTableName","setColumnID","uniqueRelationships","versions","withinLocalizedArrayOrBlock","throwValidationError","hasLocalizedField","hasLocalizedRelationshipField","hasManyTextField","hasLocalizedManyTextField","hasManyNumberField","hasLocalizedManyNumberField","parentIDColType","idColumn","id","includes","type","forEach","field","name","targetTable","targetIndexes","columnName","fieldName","replace","isFieldLocalized","payload","config","localization","blocksAsJSON","hasMany","unique","index","Array","isArray","relationTo","constraintValue","fieldConstraints","indexName","on","disableNotNullFromHere","Boolean","admin","condition","arrayTableName","prefix","versionsCustomName","baseColumns","_order","notNull","_parentID","baseIndexes","_orderIdx","_parentIDIdx","baseForeignKeys","_parentIDFk","foreignColumns","table","onDelete","isLocalized","_locale","locale","_localeIdx","subHasLocalizedManyNumberField","subHasLocalizedManyTextField","subHasLocalizedRelationshipField","subHasManyNumberField","subHasManyTextField","subRelationsToBuild","flattenedFields","localized","rootRelationships","rootUniqueRelationships","tableName","relationName","path","set","target","arrayRelations","references","to","_locales","localesSuffix","key","arrayWithLocalized","rawRelations","blockReferences","blocks","_block","block","blockTableName","rawTables","tableLocales","slug","_path","_pathIdx","_parentIdFk","blockRelations","blockWithLocalized","mode","precision","withTimezone","groupHasLocalizedField","groupHasLocalizedManyNumberField","groupHasLocalizedManyTextField","groupHasLocalizedRelationshipField","groupHasManyNumberField","groupHasManyTextField","enumName","options","map","option","value","selectTableName","order","parent","orderIdx","parentIdx","parentFk","localeIdx","relation","add","relationshipConfig","collections","tableNameMap","get","colType","idType","relatedCollectionCustomID","find","reference","required"],"mappings":"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"}},
    {"offset": {"line": 10096, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/schema/build.ts"],"sourcesContent":["import type { FlattenedField, SanitizedCompoundIndex } from 'payload'\n\nimport { InvalidConfiguration } from 'payload'\nimport toSnakeCase from 'to-snake-case'\n\nimport type {\n  DrizzleAdapter,\n  IDType,\n  RawColumn,\n  RawForeignKey,\n  RawIndex,\n  RawRelation,\n  RawTable,\n  RelationMap,\n  SetColumnID,\n} from '../types.js'\n\nimport { createTableName } from '../createTableName.js'\nimport { buildForeignKeyName } from '../utilities/buildForeignKeyName.js'\nimport { buildIndexName } from '../utilities/buildIndexName.js'\nimport { traverseFields } from './traverseFields.js'\n\ntype Args = {\n  adapter: DrizzleAdapter\n  baseColumns?: Record<string, RawColumn>\n  /**\n   * After table is created, run these functions to add extra config to the table\n   * ie. indexes, multiple columns, etc\n   */\n  baseForeignKeys?: Record<string, RawForeignKey>\n  /**\n   * After table is created, run these functions to add extra config to the table\n   * ie. indexes, multiple columns, etc\n   */\n  baseIndexes?: Record<string, RawIndex>\n  blocksTableNameMap: Record<string, number>\n  buildNumbers?: boolean\n  buildRelationships?: boolean\n  compoundIndexes?: SanitizedCompoundIndex[]\n  disableNotNull: boolean\n  disableRelsTableUnique?: boolean\n  disableUnique: boolean\n  fields: FlattenedField[]\n  parentIsLocalized: boolean\n  rootRelationships?: Set<string>\n  rootRelationsToBuild?: RelationMap\n  rootTableIDColType?: IDType\n  rootTableName?: string\n  rootUniqueRelationships?: Set<string>\n  setColumnID: SetColumnID\n  tableName: string\n  timestamps?: boolean\n  versions: boolean\n  /**\n   * Tracks whether or not this table is built\n   * from the result of a localized array or block field at some point\n   */\n  withinLocalizedArrayOrBlock?: boolean\n}\n\ntype Result = {\n  hasLocalizedManyNumberField: boolean\n  hasLocalizedManyTextField: boolean\n  hasLocalizedRelationshipField: boolean\n  hasManyNumberField: 'index' | boolean\n  hasManyTextField: 'index' | boolean\n  relationsToBuild: RelationMap\n}\n\nexport const buildTable = ({\n  adapter,\n  baseColumns = {},\n  baseForeignKeys = {},\n  baseIndexes = {},\n  blocksTableNameMap,\n  compoundIndexes,\n  disableNotNull,\n  disableRelsTableUnique = false,\n  disableUnique = false,\n  fields,\n  parentIsLocalized,\n  rootRelationships,\n  rootRelationsToBuild,\n  rootTableIDColType,\n  rootTableName: incomingRootTableName,\n  rootUniqueRelationships,\n  setColumnID,\n  tableName,\n  timestamps,\n  versions,\n  withinLocalizedArrayOrBlock,\n}: Args): Result => {\n  const isRoot = !incomingRootTableName\n  const rootTableName = incomingRootTableName || tableName\n  const columns: Record<string, RawColumn> = baseColumns\n  const indexes: Record<string, RawIndex> = baseIndexes\n\n  const localesColumns: Record<string, RawColumn> = {}\n  const localesIndexes: Record<string, RawIndex> = {}\n  let localesTable: RawTable\n  let textsTable: RawTable\n  let numbersTable: RawTable\n\n  // Relationships to the base collection\n  const relationships: Set<string> = rootRelationships || new Set()\n\n  // Unique relationships to the base collection\n  const uniqueRelationships: Set<string> = rootUniqueRelationships || new Set()\n\n  let relationshipsTable: RawTable\n\n  // Drizzle relations\n  const relationsToBuild: RelationMap = new Map()\n\n  const idColType: IDType = setColumnID({ adapter, columns, fields })\n\n  const {\n    hasLocalizedField,\n    hasLocalizedManyNumberField,\n    hasLocalizedManyTextField,\n    hasLocalizedRelationshipField,\n    hasManyNumberField,\n    hasManyTextField,\n  } = traverseFields({\n    adapter,\n    blocksTableNameMap,\n    columns,\n    disableNotNull,\n    disableRelsTableUnique,\n    disableUnique,\n    fields,\n    indexes,\n    localesColumns,\n    localesIndexes,\n    newTableName: tableName,\n    parentIsLocalized,\n    parentTableName: tableName,\n    relationships,\n    relationsToBuild,\n    rootRelationsToBuild: rootRelationsToBuild || relationsToBuild,\n    rootTableIDColType: rootTableIDColType || idColType,\n    rootTableName,\n    setColumnID,\n    uniqueRelationships,\n    versions,\n    withinLocalizedArrayOrBlock,\n  })\n\n  // split the relationsToBuild by localized and non-localized\n  const localizedRelations = new Map()\n  const nonLocalizedRelations = new Map()\n\n  relationsToBuild.forEach(({ type, localized, relationName, target }, key) => {\n    const map = localized ? localizedRelations : nonLocalizedRelations\n    map.set(key, { type, relationName, target })\n  })\n\n  if (timestamps) {\n    columns.createdAt = {\n      name: 'created_at',\n      type: 'timestamp',\n      defaultNow: true,\n      mode: 'string',\n      notNull: true,\n      precision: 3,\n      withTimezone: true,\n    }\n\n    columns.updatedAt = {\n      name: 'updated_at',\n      type: 'timestamp',\n      defaultNow: true,\n      mode: 'string',\n      notNull: true,\n      precision: 3,\n      withTimezone: true,\n    }\n  }\n\n  const table: RawTable = {\n    name: tableName,\n    columns,\n    foreignKeys: baseForeignKeys,\n    indexes,\n  }\n\n  adapter.rawTables[tableName] = table\n\n  if (hasLocalizedField || localizedRelations.size) {\n    const localeTableName = `${tableName}${adapter.localesSuffix}`\n    adapter.rawTables[localeTableName] = localesTable\n\n    localesColumns.id = {\n      name: 'id',\n      type: 'serial',\n      primaryKey: true,\n    }\n\n    localesColumns._locale = {\n      name: '_locale',\n      type: 'enum',\n      locale: true,\n      notNull: true,\n    }\n\n    localesColumns._parentID = {\n      name: '_parent_id',\n      type: idColType,\n      notNull: true,\n    }\n\n    localesIndexes._localeParent = {\n      name: buildIndexName({\n        name: `${localeTableName}_locale_parent_id_unique`,\n        adapter,\n        appendSuffix: false,\n      }),\n      on: ['_locale', '_parentID'],\n      unique: true,\n    }\n\n    localesTable = {\n      name: localeTableName,\n      columns: localesColumns,\n      foreignKeys: {\n        _parentIdFk: {\n          name: buildForeignKeyName({ name: `${localeTableName}_parent_id`, adapter }),\n          columns: ['_parentID'],\n          foreignColumns: [\n            {\n              name: 'id',\n              table: tableName,\n            },\n          ],\n          onDelete: 'cascade',\n        },\n      },\n      indexes: localesIndexes,\n    }\n\n    adapter.rawTables[localeTableName] = localesTable\n\n    const localeRelations: Record<string, RawRelation> = {\n      _parentID: {\n        type: 'one',\n        fields: [\n          {\n            name: '_parentID',\n            table: localeTableName,\n          },\n        ],\n        references: ['id'],\n        relationName: '_locales',\n        to: tableName,\n      },\n    }\n\n    localizedRelations.forEach(({ type, target }, key) => {\n      if (type === 'one') {\n        localeRelations[key] = {\n          type: 'one',\n          fields: [\n            {\n              name: key,\n              table: localeTableName,\n            },\n          ],\n          references: ['id'],\n          relationName: key,\n          to: target,\n        }\n      }\n      if (type === 'many') {\n        localeRelations[key] = {\n          type: 'many',\n          relationName: key,\n          to: target,\n        }\n      }\n    })\n    adapter.rawRelations[localeTableName] = localeRelations\n  }\n\n  if (compoundIndexes) {\n    for (const index of compoundIndexes) {\n      let someLocalized: boolean | null = null\n      const columns: string[] = []\n\n      const getTableToUse = () => {\n        if (someLocalized) {\n          return localesTable\n        }\n\n        return table\n      }\n\n      for (const { path, pathHasLocalized } of index.fields) {\n        if (someLocalized === null) {\n          someLocalized = pathHasLocalized\n        }\n\n        if (someLocalized !== pathHasLocalized) {\n          throw new InvalidConfiguration(\n            `Compound indexes within localized and non localized fields are not supported in SQL. Expected ${path} to be ${someLocalized ? 'non' : ''} localized.`,\n          )\n        }\n\n        const columnPath = path.replaceAll('.', '_')\n\n        if (!getTableToUse().columns[columnPath]) {\n          throw new InvalidConfiguration(\n            `Column ${columnPath} for compound index on ${path} was not found in the ${getTableToUse().name} table.`,\n          )\n        }\n\n        columns.push(columnPath)\n      }\n\n      if (someLocalized) {\n        columns.push('_locale')\n      }\n\n      let name = columns.join('_')\n      // truncate against the limit, buildIndexName will handle collisions\n      if (name.length > 63) {\n        name = 'compound_index'\n      }\n\n      const indexName = buildIndexName({ name, adapter })\n\n      getTableToUse().indexes[indexName] = {\n        name: indexName,\n        on: columns,\n        unique: disableUnique ? false : index.unique,\n      }\n    }\n  }\n\n  if (isRoot) {\n    if (hasManyTextField) {\n      const textsTableName = `${rootTableName}_texts`\n      adapter.rawTables[textsTableName] = textsTable\n\n      const columns: Record<string, RawColumn> = {\n        id: {\n          name: 'id',\n          type: 'serial',\n          primaryKey: true,\n        },\n        order: {\n          name: 'order',\n          type: 'integer',\n          notNull: true,\n        },\n        parent: {\n          name: 'parent_id',\n          type: idColType,\n          notNull: true,\n        },\n        path: {\n          name: 'path',\n          type: 'varchar',\n\n          notNull: true,\n        },\n        text: {\n          name: 'text',\n          type: 'varchar',\n        },\n      }\n\n      if (hasLocalizedManyTextField) {\n        columns.locale = {\n          name: 'locale',\n          type: 'enum',\n          locale: true,\n        }\n      }\n\n      const textsTableIndexes: Record<string, RawIndex> = {\n        orderParentIdx: {\n          name: buildIndexName({\n            name: `${textsTableName}_order_parent`,\n            adapter,\n            appendSuffix: false,\n          }),\n          on: ['order', 'parent'],\n        },\n      }\n\n      if (hasManyTextField === 'index') {\n        textsTableIndexes.text_idx = {\n          name: buildIndexName({ name: `${textsTableName}_text`, adapter }),\n          on: 'text',\n        }\n      }\n\n      if (hasLocalizedManyTextField) {\n        textsTableIndexes.localeParent = {\n          name: buildIndexName({\n            name: `${textsTableName}_locale_parent`,\n            adapter,\n            appendSuffix: false,\n          }),\n          on: ['locale', 'parent'],\n        }\n      }\n\n      textsTable = {\n        name: textsTableName,\n        columns,\n        foreignKeys: {\n          parentFk: {\n            name: buildForeignKeyName({ name: `${textsTableName}_parent`, adapter }),\n            columns: ['parent'],\n            foreignColumns: [\n              {\n                name: 'id',\n                table: tableName,\n              },\n            ],\n            onDelete: 'cascade',\n          },\n        },\n        indexes: textsTableIndexes,\n      }\n\n      adapter.rawTables[textsTableName] = textsTable\n\n      adapter.rawRelations[textsTableName] = {\n        parent: {\n          type: 'one',\n          fields: [\n            {\n              name: 'parent',\n              table: textsTableName,\n            },\n          ],\n          references: ['id'],\n          relationName: '_texts',\n          to: tableName,\n        },\n      }\n    }\n\n    if (hasManyNumberField) {\n      const numbersTableName = `${rootTableName}_numbers`\n      adapter.rawTables[numbersTableName] = numbersTable\n      const columns: Record<string, RawColumn> = {\n        id: {\n          name: 'id',\n          type: 'serial',\n          primaryKey: true,\n        },\n        number: {\n          name: 'number',\n          type: 'numeric',\n        },\n        order: {\n          name: 'order',\n          type: 'integer',\n          notNull: true,\n        },\n        parent: {\n          name: 'parent_id',\n          type: idColType,\n          notNull: true,\n        },\n        path: {\n          name: 'path',\n          type: 'varchar',\n          notNull: true,\n        },\n      }\n\n      if (hasLocalizedManyNumberField) {\n        columns.locale = {\n          name: 'locale',\n          type: 'enum',\n          locale: true,\n        }\n      }\n\n      const numbersTableIndexes: Record<string, RawIndex> = {\n        orderParentIdx: {\n          name: buildIndexName({ name: `${numbersTableName}_order_parent`, adapter }),\n          on: ['order', 'parent'],\n        },\n      }\n\n      if (hasManyNumberField === 'index') {\n        numbersTableIndexes.numberIdx = {\n          name: buildIndexName({ name: `${numbersTableName}_number`, adapter }),\n          on: 'number',\n        }\n      }\n\n      if (hasLocalizedManyNumberField) {\n        numbersTableIndexes.localeParent = {\n          name: buildIndexName({\n            name: `${numbersTableName}_locale_parent`,\n            adapter,\n            appendSuffix: false,\n          }),\n          on: ['locale', 'parent'],\n        }\n      }\n\n      numbersTable = {\n        name: numbersTableName,\n        columns,\n        foreignKeys: {\n          parentFk: {\n            name: buildForeignKeyName({ name: `${numbersTableName}_parent`, adapter }),\n            columns: ['parent'],\n            foreignColumns: [\n              {\n                name: 'id',\n                table: tableName,\n              },\n            ],\n            onDelete: 'cascade',\n          },\n        },\n        indexes: numbersTableIndexes,\n      }\n\n      adapter.rawTables[numbersTableName] = numbersTable\n\n      adapter.rawRelations[numbersTableName] = {\n        parent: {\n          type: 'one',\n          fields: [\n            {\n              name: 'parent',\n              table: numbersTableName,\n            },\n          ],\n          references: ['id'],\n          relationName: '_numbers',\n          to: tableName,\n        },\n      }\n    }\n\n    if (relationships.size) {\n      const relationshipColumns: Record<string, RawColumn> = {\n        id: {\n          name: 'id',\n          type: 'serial',\n          primaryKey: true,\n        },\n        order: {\n          name: 'order',\n          type: 'integer',\n        },\n        parent: {\n          name: 'parent_id',\n          type: idColType,\n          notNull: true,\n        },\n        path: {\n          name: 'path',\n          type: 'varchar',\n          notNull: true,\n        },\n      }\n\n      if (hasLocalizedRelationshipField) {\n        relationshipColumns.locale = {\n          name: 'locale',\n          type: 'enum',\n          locale: true,\n        }\n      }\n\n      const relationshipsTableName = `${tableName}${adapter.relationshipsSuffix}`\n\n      const relationshipIndexes: Record<string, RawIndex> = {\n        order: {\n          name: buildIndexName({ name: `${relationshipsTableName}_order`, adapter }),\n          on: 'order',\n        },\n        parentIdx: {\n          name: buildIndexName({ name: `${relationshipsTableName}_parent`, adapter }),\n          on: 'parent',\n        },\n        pathIdx: {\n          name: buildIndexName({ name: `${relationshipsTableName}_path`, adapter }),\n          on: 'path',\n        },\n      }\n\n      if (hasLocalizedRelationshipField) {\n        relationshipIndexes.localeIdx = {\n          name: buildIndexName({ name: `${relationshipsTableName}_locale`, adapter }),\n          on: 'locale',\n        }\n      }\n\n      const relationshipForeignKeys: Record<string, RawForeignKey> = {\n        parentFk: {\n          name: buildForeignKeyName({ name: `${relationshipsTableName}_parent`, adapter }),\n          columns: ['parent'],\n          foreignColumns: [\n            {\n              name: 'id',\n              table: tableName,\n            },\n          ],\n          onDelete: 'cascade',\n        },\n      }\n\n      relationships.forEach((relationTo) => {\n        const relationshipConfig = adapter.payload.collections[relationTo].config\n        const formattedRelationTo = createTableName({\n          adapter,\n          config: relationshipConfig,\n          throwValidationError: true,\n        })\n        let colType: 'integer' | 'numeric' | 'uuid' | 'varchar' =\n          adapter.idType === 'uuid' ? 'uuid' : 'integer'\n        const relatedCollectionCustomIDType =\n          adapter.payload.collections[relationshipConfig.slug]?.customIDType\n\n        if (relatedCollectionCustomIDType === 'number') {\n          colType = 'numeric'\n        }\n        if (relatedCollectionCustomIDType === 'text') {\n          colType = 'varchar'\n        }\n\n        const colName = `${relationTo}ID`\n\n        relationshipColumns[colName] = {\n          name: `${formattedRelationTo}_id`,\n          type: colType,\n        }\n\n        relationshipForeignKeys[`${relationTo}IdFk`] = {\n          name: buildForeignKeyName({\n            name: `${relationshipsTableName}_${toSnakeCase(relationTo)}`,\n            adapter,\n          }),\n          columns: [colName],\n          foreignColumns: [\n            {\n              name: 'id',\n              table: formattedRelationTo,\n            },\n          ],\n          onDelete: 'cascade',\n        }\n\n        const indexColumns = [colName]\n\n        const unique = !disableUnique && uniqueRelationships.has(relationTo)\n\n        if (unique) {\n          indexColumns.push('path')\n        }\n        if (hasLocalizedRelationshipField) {\n          indexColumns.push('locale')\n        }\n\n        const indexName = buildIndexName({\n          name: `${relationshipsTableName}_${formattedRelationTo}_id`,\n          adapter,\n        })\n\n        relationshipIndexes[indexName] = {\n          name: indexName,\n          on: indexColumns,\n          unique,\n        }\n      })\n\n      relationshipsTable = {\n        name: relationshipsTableName,\n        columns: relationshipColumns,\n        foreignKeys: relationshipForeignKeys,\n        indexes: relationshipIndexes,\n      }\n\n      adapter.rawTables[relationshipsTableName] = relationshipsTable\n\n      const relationshipsTableRelations: Record<string, RawRelation> = {\n        parent: {\n          type: 'one',\n          fields: [\n            {\n              name: 'parent',\n              table: relationshipsTableName,\n            },\n          ],\n          references: ['id'],\n          relationName: '_rels',\n          to: tableName,\n        },\n      }\n\n      relationships.forEach((relationTo) => {\n        const relatedTableName = createTableName({\n          adapter,\n          config: adapter.payload.collections[relationTo].config,\n          throwValidationError: true,\n        })\n        const idColumnName = `${relationTo}ID`\n\n        relationshipsTableRelations[idColumnName] = {\n          type: 'one',\n          fields: [\n            {\n              name: idColumnName,\n              table: relationshipsTableName,\n            },\n          ],\n          references: ['id'],\n          relationName: relationTo,\n          to: relatedTableName,\n        }\n      })\n      adapter.rawRelations[relationshipsTableName] = relationshipsTableRelations\n    }\n  }\n\n  const tableRelations: Record<string, RawRelation> = {}\n\n  nonLocalizedRelations.forEach(({ type, relationName, target }, key) => {\n    if (type === 'one') {\n      tableRelations[key] = {\n        type: 'one',\n        fields: [\n          {\n            name: key,\n            table: tableName,\n          },\n        ],\n        references: ['id'],\n        relationName: key,\n        to: target,\n      }\n    }\n    if (type === 'many') {\n      tableRelations[key] = {\n        type: 'many',\n        relationName: relationName || key,\n        to: target,\n      }\n    }\n  })\n\n  if (hasLocalizedField) {\n    tableRelations._locales = {\n      type: 'many',\n      relationName: '_locales',\n      to: localesTable.name,\n    }\n  }\n\n  if (isRoot && textsTable) {\n    tableRelations._texts = {\n      type: 'many',\n      relationName: '_texts',\n      to: textsTable.name,\n    }\n  }\n\n  if (isRoot && numbersTable) {\n    tableRelations._numbers = {\n      type: 'many',\n      relationName: '_numbers',\n      to: numbersTable.name,\n    }\n  }\n\n  if (relationships.size && relationshipsTable) {\n    tableRelations._rels = {\n      type: 'many',\n      relationName: '_rels',\n      to: relationshipsTable.name,\n    }\n  }\n\n  adapter.rawRelations[tableName] = tableRelations\n\n  return {\n    hasLocalizedManyNumberField,\n    hasLocalizedManyTextField,\n    hasLocalizedRelationshipField,\n    hasManyNumberField,\n    hasManyTextField,\n    relationsToBuild,\n  }\n}\n"],"names":["InvalidConfiguration","toSnakeCase","createTableName","buildForeignKeyName","buildIndexName","traverseFields","buildTable","adapter","baseColumns","baseForeignKeys","baseIndexes","blocksTableNameMap","compoundIndexes","disableNotNull","disableRelsTableUnique","disableUnique","fields","parentIsLocalized","rootRelationships","rootRelationsToBuild","rootTableIDColType","rootTableName","incomingRootTableName","rootUniqueRelationships","setColumnID","tableName","timestamps","versions","withinLocalizedArrayOrBlock","isRoot","columns","indexes","localesColumns","localesIndexes","localesTable","textsTable","numbersTable","relationships","Set","uniqueRelationships","relationshipsTable","relationsToBuild","Map","idColType","hasLocalizedField","hasLocalizedManyNumberField","hasLocalizedManyTextField","hasLocalizedRelationshipField","hasManyNumberField","hasManyTextField","newTableName","parentTableName","localizedRelations","nonLocalizedRelations","forEach","type","localized","relationName","target","key","map","set","createdAt","name","defaultNow","mode","notNull","precision","withTimezone","updatedAt","table","foreignKeys","rawTables","size","localeTableName","localesSuffix","id","primaryKey","_locale","locale","_parentID","_localeParent","appendSuffix","on","unique","_parentIdFk","foreignColumns","onDelete","localeRelations","references","to","rawRelations","index","someLocalized","getTableToUse","path","pathHasLocalized","columnPath","replaceAll","push","join","length","indexName","textsTableName","order","parent","text","textsTableIndexes","orderParentIdx","text_idx","localeParent","parentFk","numbersTableName","number","numbersTableIndexes","numberIdx","relationshipColumns","relationshipsTableName","relationshipsSuffix","relationshipIndexes","parentIdx","pathIdx","localeIdx","relationshipForeignKeys","relationTo","relationshipConfig","payload","collections","config","formattedRelationTo","throwValidationError","colType","idType","relatedCollectionCustomIDType","slug","customIDType","colName","indexColumns","has","relationshipsTableRelations","relatedTableName","idColumnName","tableRelations","_locales","_texts","_numbers","_rels"],"mappings":"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"}},
    {"offset": {"line": 10812, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/schema/buildRawSchema.ts"],"sourcesContent":["import {\n  buildVersionCollectionFields,\n  buildVersionCompoundIndexes,\n  buildVersionGlobalFields,\n} from 'payload'\nimport { hasDraftsEnabled } from 'payload/shared'\nimport toSnakeCase from 'to-snake-case'\n\nimport type { DrizzleAdapter, RawIndex, SetColumnID } from '../types.js'\n\nimport { createTableName } from '../createTableName.js'\nimport { buildIndexName } from '../utilities/buildIndexName.js'\nimport { buildTable } from './build.js'\n\n/**\n * Builds abstract Payload SQL schema\n */\nexport const buildRawSchema = ({\n  adapter,\n  setColumnID,\n}: {\n  adapter: DrizzleAdapter\n  setColumnID: SetColumnID\n}) => {\n  adapter.indexes = new Set()\n  adapter.foreignKeys = new Set()\n\n  adapter.payload.config.collections.forEach((collection) => {\n    createTableName({\n      adapter,\n      config: collection,\n    })\n\n    if (collection.versions) {\n      createTableName({\n        adapter,\n        config: collection,\n        versions: true,\n        versionsCustomName: true,\n      })\n    }\n  })\n\n  adapter.payload.config.collections.forEach((collection) => {\n    const tableName = adapter.tableNameMap.get(toSnakeCase(collection.slug))\n    const config = adapter.payload.config\n\n    const baseIndexes: Record<string, RawIndex> = {}\n\n    if (collection.upload.filenameCompoundIndex) {\n      const indexName = buildIndexName({ name: `${tableName}_filename_compound`, adapter })\n\n      baseIndexes.filename_compound_index = {\n        name: indexName,\n        on: collection.upload.filenameCompoundIndex.map((f) => f),\n        unique: true,\n      }\n    }\n\n    buildTable({\n      adapter,\n      baseIndexes,\n      blocksTableNameMap: {},\n      compoundIndexes: collection.sanitizedIndexes,\n      disableNotNull: !!collection?.versions?.drafts,\n      disableUnique: false,\n      fields: collection.flattenedFields,\n      parentIsLocalized: false,\n      setColumnID,\n      tableName,\n      timestamps: collection.timestamps,\n      versions: false,\n    })\n\n    if (collection.versions) {\n      const versionsTableName = adapter.tableNameMap.get(\n        `_${toSnakeCase(collection.slug)}${adapter.versionsSuffix}`,\n      )\n      const versionFields = buildVersionCollectionFields(config, collection, true)\n\n      buildTable({\n        adapter,\n        blocksTableNameMap: {},\n        compoundIndexes: buildVersionCompoundIndexes({ indexes: collection.sanitizedIndexes }),\n        disableNotNull: !!collection.versions?.drafts,\n        disableUnique: true,\n        fields: versionFields,\n        parentIsLocalized: false,\n        setColumnID,\n        tableName: versionsTableName,\n        timestamps: true,\n        versions: true,\n      })\n    }\n  })\n\n  adapter.payload.config.globals.forEach((global) => {\n    const tableName = createTableName({\n      adapter,\n      config: global,\n    })\n\n    buildTable({\n      adapter,\n      blocksTableNameMap: {},\n      disableNotNull: hasDraftsEnabled(global),\n      disableUnique: false,\n      fields: global.flattenedFields,\n      parentIsLocalized: false,\n      setColumnID,\n      tableName,\n      timestamps: false,\n      versions: false,\n    })\n\n    if (global.versions) {\n      const versionsTableName = createTableName({\n        adapter,\n        config: global,\n        versions: true,\n        versionsCustomName: true,\n      })\n      const config = adapter.payload.config\n      const versionFields = buildVersionGlobalFields(config, global, true)\n\n      buildTable({\n        adapter,\n        blocksTableNameMap: {},\n        disableNotNull: !!global.versions?.drafts,\n        disableUnique: true,\n        fields: versionFields,\n        parentIsLocalized: false,\n        setColumnID,\n        tableName: versionsTableName,\n        timestamps: true,\n        versions: true,\n      })\n    }\n  })\n}\n"],"names":["buildVersionCollectionFields","buildVersionCompoundIndexes","buildVersionGlobalFields","hasDraftsEnabled","toSnakeCase","createTableName","buildIndexName","buildTable","buildRawSchema","adapter","setColumnID","indexes","Set","foreignKeys","payload","config","collections","forEach","collection","versions","versionsCustomName","tableName","tableNameMap","get","slug","baseIndexes","upload","filenameCompoundIndex","indexName","name","filename_compound_index","on","map","f","unique","blocksTableNameMap","compoundIndexes","sanitizedIndexes","disableNotNull","drafts","disableUnique","fields","flattenedFields","parentIsLocalized","timestamps","versionsTableName","versionsSuffix","versionFields","globals","global"],"mappings":"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"}},
    {"offset": {"line": 10941, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/utilities/extendDrizzleTable.ts"],"sourcesContent":["/**\n * Implemented from:\n * https://github.com/drizzle-team/drizzle-orm/blob/main/drizzle-orm/src/pg-core/table.ts#L73\n * Drizzle uses @internal JSDoc to remove their internal methods from types, for example\n * Table.Symbol, columnBuilder.build - but they actually exist.\n */\nimport type { ColumnBuilderBase } from 'drizzle-orm'\n\nimport { Table } from 'drizzle-orm'\nimport { APIError } from 'payload'\n\nconst { Symbol: DrizzleSymbol } = Table as unknown as {\n  Symbol: {\n    Columns: symbol\n    ExtraConfigBuilder: symbol\n    ExtraConfigColumns: symbol\n  }\n}\n\ntype Args = {\n  columns?: Record<string, ColumnBuilderBase<any>>\n  extraConfig?: (self: Record<string, any>) => object\n  table: Table\n}\n\n/**\n * Extends the passed table with additional columns / extra config\n */\nexport const extendDrizzleTable = ({ columns, extraConfig, table }: Args): void => {\n  const InlineForeignKeys = Object.getOwnPropertySymbols(table).find((symbol) => {\n    return symbol.description?.includes('InlineForeignKeys')\n  })\n\n  if (!InlineForeignKeys) {\n    throw new APIError(`Error when finding InlineForeignKeys Symbol`, 500)\n  }\n\n  if (columns) {\n    for (const [name, columnBuilder] of Object.entries(columns) as [string, any][]) {\n      const column = columnBuilder.build(table)\n\n      table[name] = column\n      table[InlineForeignKeys].push(...columnBuilder.buildForeignKeys(column, table))\n      table[DrizzleSymbol.Columns][name] = column\n\n      table[DrizzleSymbol.ExtraConfigColumns][name] =\n        'buildExtraConfigColumn' in columnBuilder\n          ? columnBuilder.buildExtraConfigColumn(table)\n          : column\n    }\n  }\n\n  if (extraConfig) {\n    const originalExtraConfigBuilder = table[DrizzleSymbol.ExtraConfigBuilder]\n\n    table[DrizzleSymbol.ExtraConfigBuilder] = (t) => {\n      return {\n        ...originalExtraConfigBuilder(t),\n        ...extraConfig(t),\n      }\n    }\n  }\n}\n"],"names":["Table","APIError","Symbol","DrizzleSymbol","extendDrizzleTable","columns","extraConfig","table","InlineForeignKeys","Object","getOwnPropertySymbols","find","symbol","description","includes","name","columnBuilder","entries","column","build","push","buildForeignKeys","Columns","ExtraConfigColumns","buildExtraConfigColumn","originalExtraConfigBuilder","ExtraConfigBuilder","t"],"mappings":";;;;AAAA;;;;;CAKC,GAGD,SAASA,KAAK,QAAQ,cAAa;AACnC,SAASC,QAAQ,QAAQ,UAAS;;;AAElC,MAAM,EAAEC,QAAQC,aAAa,EAAE,GAAGH,kJAAAA;AAiB3B,MAAMI,qBAAqB,CAAC,EAAEC,OAAO,EAAEC,WAAW,EAAEC,KAAK,EAAQ;IACtE,MAAMC,oBAAoBC,OAAOC,qBAAqB,CAACH,OAAOI,IAAI,CAAC,CAACC;QAClE,OAAOA,OAAOC,WAAW,EAAEC,SAAS;IACtC;IAEA,IAAI,CAACN,mBAAmB;QACtB,MAAM,IAAIP,mKAAAA,CAAS,CAAC,2CAA2C,CAAC,EAAE;IACpE;IAEA,IAAII,SAAS;QACX,KAAK,MAAM,CAACU,MAAMC,cAAc,IAAIP,OAAOQ,OAAO,CAACZ,SAA6B;YAC9E,MAAMa,SAASF,cAAcG,KAAK,CAACZ;YAEnCA,KAAK,CAACQ,KAAK,GAAGG;YACdX,KAAK,CAACC,kBAAkB,CAACY,IAAI,IAAIJ,cAAcK,gBAAgB,CAACH,QAAQX;YACxEA,KAAK,CAACJ,cAAcmB,OAAO,CAAC,CAACP,KAAK,GAAGG;YAErCX,KAAK,CAACJ,cAAcoB,kBAAkB,CAAC,CAACR,KAAK,GAC3C,4BAA4BC,gBACxBA,cAAcQ,sBAAsB,CAACjB,SACrCW;QACR;IACF;IAEA,IAAIZ,aAAa;QACf,MAAMmB,6BAA6BlB,KAAK,CAACJ,cAAcuB,kBAAkB,CAAC;QAE1EnB,KAAK,CAACJ,cAAcuB,kBAAkB,CAAC,GAAG,CAACC;YACzC,OAAO;gBACL,GAAGF,2BAA2BE,EAAE;gBAChC,GAAGrB,YAAYqB,EAAE;YACnB;QACF;IACF;AACF,EAAC"}},
    {"offset": {"line": 10985, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/utilities/executeSchemaHooks.ts"],"sourcesContent":["import type { DrizzleAdapter } from '../types.js'\n\nimport { extendDrizzleTable } from './extendDrizzleTable.js'\n\ntype DatabaseSchema = {\n  enums?: DrizzleAdapter['enums']\n  relations: Record<string, any>\n  tables: DrizzleAdapter['tables']\n}\n\ntype Adapter = {\n  afterSchemaInit: DatabaseSchemaHook[]\n  beforeSchemaInit: DatabaseSchemaHook[]\n} & DatabaseSchema\n\ntype DatabaseSchemaHookArgs = {\n  adapter: Record<string, unknown>\n  extendTable: typeof extendDrizzleTable\n  schema: DatabaseSchema\n}\n\ntype DatabaseSchemaHook = (args: DatabaseSchemaHookArgs) => DatabaseSchema | Promise<DatabaseSchema>\n\ntype Args = {\n  adapter: Adapter\n  type: 'afterSchemaInit' | 'beforeSchemaInit'\n}\n\nexport const executeSchemaHooks = async ({ type, adapter }: Args): Promise<void> => {\n  for (const hook of (adapter as unknown as Adapter)[type]) {\n    const result = await hook({\n      adapter: adapter as unknown as Adapter,\n      extendTable: extendDrizzleTable,\n      schema: {\n        enums: adapter.enums,\n        relations: adapter.relations,\n        tables: adapter.tables,\n      },\n    })\n    if (result.enums) {\n      adapter.enums = result.enums\n    }\n\n    adapter.tables = result.tables\n    adapter.relations = result.relations\n  }\n}\n"],"names":["extendDrizzleTable","executeSchemaHooks","type","adapter","hook","result","extendTable","schema","enums","relations","tables"],"mappings":";;;;AAEA,SAASA,kBAAkB,QAAQ,0BAAyB;;AA0BrD,MAAMC,qBAAqB,OAAO,EAAEC,IAAI,EAAEC,OAAO,EAAQ;IAC9D,KAAK,MAAMC,QAASD,OAA8B,CAACD,KAAK,CAAE;QACxD,MAAMG,SAAS,MAAMD,KAAK;YACxBD,SAASA;YACTG,aAAaN,0MAAAA;YACbO,QAAQ;gBACNC,OAAOL,QAAQK,KAAK;gBACpBC,WAAWN,QAAQM,SAAS;gBAC5BC,QAAQP,QAAQO,MAAM;YACxB;QACF;QACA,IAAIL,OAAOG,KAAK,EAAE;YAChBL,QAAQK,KAAK,GAAGH,OAAOG,KAAK;QAC9B;QAEAL,QAAQO,MAAM,GAAGL,OAAOK,MAAM;QAC9BP,QAAQM,SAAS,GAAGJ,OAAOI,SAAS;IACtC;AACF,EAAC"}},
    {"offset": {"line": 11013, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/postgres/schema/geometryColumn.ts"],"sourcesContent":["// Uses custom one instead of geometry() from drizzle-orm/pg-core because it's broken on pushDevSchema\n// Why?\n// It tries to give us a prompt \"you're about to change.. from geometry(Point) to geometry(point)\"\nimport { customType } from 'drizzle-orm/pg-core'\nimport { parseEWKB } from 'drizzle-orm/pg-core/columns/postgis_extension/utils'\n\ntype Point = [number, number]\n\nexport const geometryColumn = (name: string) =>\n  customType<{ data: Point; driverData: string }>({\n    dataType() {\n      return `geometry(Point)`\n    },\n    fromDriver(value: string) {\n      return parseEWKB(value)\n    },\n    toDriver(value: Point) {\n      return `SRID=4326;point(${value[0]} ${value[1]})`\n    },\n  })(name)\n"],"names":["customType","parseEWKB","geometryColumn","name","dataType","fromDriver","value","toDriver"],"mappings":";;;;AAAA,sGAAsG;AACtG,OAAO;AACP,kGAAkG;AAClG,SAASA,UAAU,QAAQ,sBAAqB;AAChD,SAASC,SAAS,QAAQ,sDAAqD;;;AAIxE,MAAMC,iBAAiB,CAACC,WAC7BH,iLAAAA,EAAgD;QAC9CI;YACE,OAAO,CAAC,eAAe,CAAC;QAC1B;QACAC,YAAWC,KAAa;YACtB,WAAOL,oMAAAA,EAAUK;QACnB;QACAC,UAASD,KAAY;YACnB,OAAO,CAAC,gBAAgB,EAAEA,KAAK,CAAC,EAAE,CAAC,CAAC,EAAEA,KAAK,CAAC,EAAE,CAAC,CAAC,CAAC;QACnD;IACF,GAAGH,MAAK"}},
    {"offset": {"line": 11039, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/postgres/schema/buildDrizzleTable.ts"],"sourcesContent":["import type { ForeignKeyBuilder, IndexBuilder } from 'drizzle-orm/pg-core'\n\nimport {\n  bit,\n  boolean,\n  foreignKey,\n  halfvec,\n  index,\n  integer,\n  jsonb,\n  numeric,\n  serial,\n  sparsevec,\n  text,\n  timestamp,\n  uniqueIndex,\n  uuid,\n  varchar,\n  vector,\n} from 'drizzle-orm/pg-core'\n\nimport type { RawColumn, RawTable } from '../../types.js'\nimport type { BasePostgresAdapter } from '../types.js'\n\nimport { geometryColumn } from './geometryColumn.js'\n\nconst rawColumnBuilderMap: Partial<Record<RawColumn['type'], any>> = {\n  boolean,\n  geometry: geometryColumn,\n  integer,\n  jsonb,\n  numeric,\n  serial,\n  text,\n  uuid,\n  varchar,\n}\n\nexport const buildDrizzleTable = ({\n  adapter,\n  rawTable,\n}: {\n  adapter: BasePostgresAdapter\n  rawTable: RawTable\n}) => {\n  const columns: Record<string, any> = {}\n\n  for (const [key, column] of Object.entries(rawTable.columns)) {\n    switch (column.type) {\n      case 'bit': {\n        const builder = bit(column.name, { dimensions: column.dimensions })\n\n        columns[key] = builder\n\n        break\n      }\n\n      case 'enum':\n        if ('locale' in column) {\n          columns[key] = adapter.enums.enum__locales(column.name)\n        } else {\n          adapter.enums[column.enumName] = adapter.pgSchema.enum(\n            column.enumName,\n            column.options as [string, ...string[]],\n          )\n          columns[key] = adapter.enums[column.enumName](column.name)\n        }\n        break\n\n      case 'halfvec': {\n        const builder = halfvec(column.name, { dimensions: column.dimensions })\n\n        columns[key] = builder\n        break\n      }\n\n      case 'numeric': {\n        columns[key] = numeric(column.name, { mode: 'number' })\n        break\n      }\n\n      case 'sparsevec': {\n        const builder = sparsevec(column.name, { dimensions: column.dimensions })\n\n        columns[key] = builder\n\n        break\n      }\n\n      case 'timestamp': {\n        let builder = timestamp(column.name, {\n          mode: column.mode,\n          precision: column.precision,\n          withTimezone: column.withTimezone,\n        })\n\n        if (column.defaultNow) {\n          builder = builder.defaultNow()\n        }\n\n        columns[key] = builder\n        break\n      }\n\n      case 'uuid': {\n        let builder = uuid(column.name)\n\n        if (column.defaultRandom) {\n          builder = builder.defaultRandom()\n        }\n\n        columns[key] = builder\n        break\n      }\n\n      case 'vector': {\n        const builder = vector(column.name, { dimensions: column.dimensions })\n        columns[key] = builder\n\n        break\n      }\n\n      default:\n        columns[key] = rawColumnBuilderMap[column.type](column.name)\n        break\n    }\n\n    if (column.reference) {\n      columns[key].references(() => adapter.tables[column.reference.table][column.reference.name], {\n        onDelete: column.reference.onDelete,\n      })\n    }\n\n    if (column.primaryKey) {\n      columns[key].primaryKey()\n    }\n\n    if (column.notNull) {\n      columns[key].notNull()\n    }\n\n    if (typeof column.default !== 'undefined') {\n      let sanitizedDefault = column.default\n\n      if (column.type === 'geometry' && Array.isArray(column.default)) {\n        sanitizedDefault = `SRID=4326;POINT(${column.default[0]} ${column.default[1]})`\n      }\n\n      columns[key].default(sanitizedDefault)\n    }\n\n    if (column.type === 'geometry') {\n      if (!adapter.extensions.postgis) {\n        adapter.extensions.postgis = true\n      }\n    }\n  }\n\n  const extraConfig = (cols: any) => {\n    const config: Record<string, ForeignKeyBuilder | IndexBuilder> = {}\n\n    if (rawTable.indexes) {\n      for (const [key, rawIndex] of Object.entries(rawTable.indexes)) {\n        let fn: any = index\n        if (rawIndex.unique) {\n          fn = uniqueIndex\n        }\n\n        if (Array.isArray(rawIndex.on)) {\n          if (rawIndex.on.length) {\n            config[key] = fn(rawIndex.name).on(...rawIndex.on.map((colName) => cols[colName]))\n          }\n        } else {\n          config[key] = fn(rawIndex.name).on(cols[rawIndex.on])\n        }\n      }\n    }\n\n    if (rawTable.foreignKeys) {\n      for (const [key, rawForeignKey] of Object.entries(rawTable.foreignKeys)) {\n        let builder = foreignKey({\n          name: rawForeignKey.name,\n          columns: rawForeignKey.columns.map((colName) => cols[colName]) as any,\n          foreignColumns: rawForeignKey.foreignColumns.map(\n            (column) => adapter.tables[column.table][column.name],\n          ),\n        })\n\n        if (rawForeignKey.onDelete) {\n          builder = builder.onDelete(rawForeignKey.onDelete)\n        }\n\n        if (rawForeignKey.onUpdate) {\n          builder = builder.onDelete(rawForeignKey.onUpdate)\n        }\n\n        config[key] = builder\n      }\n    }\n\n    return config\n  }\n\n  adapter.tables[rawTable.name] = adapter.pgSchema.table(\n    rawTable.name,\n    columns as any,\n    extraConfig as any,\n  )\n}\n"],"names":["bit","boolean","foreignKey","halfvec","index","integer","jsonb","numeric","serial","sparsevec","text","timestamp","uniqueIndex","uuid","varchar","vector","geometryColumn","rawColumnBuilderMap","geometry","buildDrizzleTable","adapter","rawTable","columns","key","column","Object","entries","type","builder","name","dimensions","enums","enum__locales","enumName","pgSchema","enum","options","mode","precision","withTimezone","defaultNow","defaultRandom","reference","references","tables","table","onDelete","primaryKey","notNull","default","sanitizedDefault","Array","isArray","extensions","postgis","extraConfig","cols","config","indexes","rawIndex","fn","unique","on","length","map","colName","foreignKeys","rawForeignKey","foreignColumns","onUpdate"],"mappings":"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"}},
    {"offset": {"line": 11214, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/postgres/schema/setColumnID.ts"],"sourcesContent":["import type { SetColumnID } from '../../types.js'\n\nexport const setColumnID: SetColumnID = ({ adapter, columns, fields }) => {\n  const idField = fields.find((field) => field.name === 'id')\n  if (idField) {\n    if (idField.type === 'number') {\n      columns.id = {\n        name: 'id',\n        type: 'numeric',\n        primaryKey: true,\n      }\n\n      return 'numeric'\n    }\n\n    if (idField.type === 'text') {\n      columns.id = {\n        name: 'id',\n        type: 'varchar',\n        primaryKey: true,\n      }\n      return 'varchar'\n    }\n  }\n\n  if (adapter.idType === 'uuid') {\n    columns.id = {\n      name: 'id',\n      type: 'uuid',\n      defaultRandom: true,\n      primaryKey: true,\n    }\n\n    return 'uuid'\n  }\n\n  columns.id = {\n    name: 'id',\n    type: 'serial',\n    primaryKey: true,\n  }\n\n  return 'integer'\n}\n"],"names":["setColumnID","adapter","columns","fields","idField","find","field","name","type","id","primaryKey","idType","defaultRandom"],"mappings":";;;;AAEO,MAAMA,cAA2B,CAAC,EAAEC,OAAO,EAAEC,OAAO,EAAEC,MAAM,EAAE;IACnE,MAAMC,UAAUD,OAAOE,IAAI,CAAC,CAACC,QAAUA,MAAMC,IAAI,KAAK;IACtD,IAAIH,SAAS;QACX,IAAIA,QAAQI,IAAI,KAAK,UAAU;YAC7BN,QAAQO,EAAE,GAAG;gBACXF,MAAM;gBACNC,MAAM;gBACNE,YAAY;YACd;YAEA,OAAO;QACT;QAEA,IAAIN,QAAQI,IAAI,KAAK,QAAQ;YAC3BN,QAAQO,EAAE,GAAG;gBACXF,MAAM;gBACNC,MAAM;gBACNE,YAAY;YACd;YACA,OAAO;QACT;IACF;IAEA,IAAIT,QAAQU,MAAM,KAAK,QAAQ;QAC7BT,QAAQO,EAAE,GAAG;YACXF,MAAM;YACNC,MAAM;YACNI,eAAe;YACfF,YAAY;QACd;QAEA,OAAO;IACT;IAEAR,QAAQO,EAAE,GAAG;QACXF,MAAM;QACNC,MAAM;QACNE,YAAY;IACd;IAEA,OAAO;AACT,EAAC"}},
    {"offset": {"line": 11258, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/postgres/init.ts"],"sourcesContent":["import type { Init } from 'payload'\n\nimport type { BasePostgresAdapter } from './types.js'\n\nimport { buildDrizzleRelations } from '../schema/buildDrizzleRelations.js'\nimport { buildRawSchema } from '../schema/buildRawSchema.js'\nimport { executeSchemaHooks } from '../utilities/executeSchemaHooks.js'\nimport { buildDrizzleTable } from './schema/buildDrizzleTable.js'\nimport { setColumnID } from './schema/setColumnID.js'\n\nexport const init: Init = async function init(this: BasePostgresAdapter) {\n  this.rawRelations = {}\n  this.rawTables = {}\n\n  buildRawSchema({\n    adapter: this,\n    setColumnID,\n  })\n\n  await executeSchemaHooks({ type: 'beforeSchemaInit', adapter: this })\n\n  if (this.payload.config.localization) {\n    this.enums.enum__locales = this.pgSchema.enum(\n      '_locales',\n      this.payload.config.localization.locales.map(({ code }) => code) as [string, ...string[]],\n    )\n  }\n\n  for (const tableName in this.rawTables) {\n    buildDrizzleTable({ adapter: this, rawTable: this.rawTables[tableName] })\n  }\n\n  buildDrizzleRelations({\n    adapter: this,\n  })\n\n  await executeSchemaHooks({ type: 'afterSchemaInit', adapter: this })\n\n  this.schema = {\n    pgSchema: this.pgSchema,\n    ...this.tables,\n    ...this.relations,\n    ...this.enums,\n  }\n}\n"],"names":["buildDrizzleRelations","buildRawSchema","executeSchemaHooks","buildDrizzleTable","setColumnID","init","rawRelations","rawTables","adapter","type","payload","config","localization","enums","enum__locales","pgSchema","enum","locales","map","code","tableName","rawTable","schema","tables","relations"],"mappings":";;;;AAIA,SAASA,qBAAqB,QAAQ,qCAAoC;AAC1E,SAASC,cAAc,QAAQ,8BAA6B;AAC5D,SAASC,kBAAkB,QAAQ,qCAAoC;AACvE,SAASC,iBAAiB,QAAQ,gCAA+B;AACjE,SAASC,WAAW,QAAQ,0BAAyB;;;;;;AAE9C,MAAMC,OAAa,eAAeA;IACvC,IAAI,CAACC,YAAY,GAAG,CAAC;IACrB,IAAI,CAACC,SAAS,GAAG,CAAC;QAElBN,+LAAAA,EAAe;QACbO,SAAS,IAAI;qBACbJ,qMAAAA;IACF;IAEA,UAAMF,0MAAAA,EAAmB;QAAEO,MAAM;QAAoBD,SAAS,IAAI;IAAC;IAEnE,IAAI,IAAI,CAACE,OAAO,CAACC,MAAM,CAACC,YAAY,EAAE;QACpC,IAAI,CAACC,KAAK,CAACC,aAAa,GAAG,IAAI,CAACC,QAAQ,CAACC,IAAI,CAC3C,YACA,IAAI,CAACN,OAAO,CAACC,MAAM,CAACC,YAAY,CAACK,OAAO,CAACC,GAAG,CAAC,CAAC,EAAEC,IAAI,EAAE,GAAKA;IAE/D;IAEA,IAAK,MAAMC,aAAa,IAAI,CAACb,SAAS,CAAE;YACtCJ,iNAAAA,EAAkB;YAAEK,SAAS,IAAI;YAAEa,UAAU,IAAI,CAACd,SAAS,CAACa,UAAU;QAAC;IACzE;QAEApB,6MAAAA,EAAsB;QACpBQ,SAAS,IAAI;IACf;IAEA,UAAMN,0MAAAA,EAAmB;QAAEO,MAAM;QAAmBD,SAAS,IAAI;IAAC;IAElE,IAAI,CAACc,MAAM,GAAG;QACZP,UAAU,IAAI,CAACA,QAAQ;QACvB,GAAG,IAAI,CAACQ,MAAM;QACd,GAAG,IAAI,CAACC,SAAS;QACjB,GAAG,IAAI,CAACX,KAAK;IACf;AACF,EAAC"}},
    {"offset": {"line": 11310, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/postgres/insert.ts"],"sourcesContent":["import type { TransactionPg } from '../types.js'\nimport type { Insert } from './types.js'\n\nexport const insert: Insert = async function insert({\n  db,\n  onConflictDoUpdate,\n  tableName,\n  values,\n}): Promise<Record<string, unknown>[]> {\n  const table = this.tables[tableName]\n  let result\n\n  if (onConflictDoUpdate) {\n    result = await (db as TransactionPg)\n      .insert(table)\n      .values(values)\n      .onConflictDoUpdate(onConflictDoUpdate)\n      .returning()\n  } else {\n    result = await (db as TransactionPg).insert(table).values(values).returning()\n  }\n\n  return result\n}\n"],"names":["insert","db","onConflictDoUpdate","tableName","values","table","tables","result","returning"],"mappings":";;;;AAGO,MAAMA,SAAiB,eAAeA,OAAO,EAClDC,EAAE,EACFC,kBAAkB,EAClBC,SAAS,EACTC,MAAM,EACP;IACC,MAAMC,QAAQ,IAAI,CAACC,MAAM,CAACH,UAAU;IACpC,IAAII;IAEJ,IAAIL,oBAAoB;QACtBK,SAAS,MAAON,GACbD,MAAM,CAACK,OACPD,MAAM,CAACA,QACPF,kBAAkB,CAACA,oBACnBM,SAAS;IACd,OAAO;QACLD,SAAS,MAAON,GAAqBD,MAAM,CAACK,OAAOD,MAAM,CAACA,QAAQI,SAAS;IAC7E;IAEA,OAAOD;AACT,EAAC"}},
    {"offset": {"line": 11328, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/postgres/requireDrizzleKit.ts"],"sourcesContent":["import { createRequire } from 'module'\n\nimport type { RequireDrizzleKit } from '../types.js'\n\nconst require = createRequire(import.meta.url)\n\nexport const requireDrizzleKit: RequireDrizzleKit = () => {\n  const {\n    generateDrizzleJson,\n    generateMigration,\n    pushSchema,\n    upPgSnapshot,\n  } = require('drizzle-kit/api')\n\n  return {\n    generateDrizzleJson,\n    generateMigration,\n    pushSchema,\n    upSnapshot: upPgSnapshot,\n  }\n}\n"],"names":["createRequire","require","url","requireDrizzleKit","generateDrizzleJson","generateMigration","pushSchema","upPgSnapshot","upSnapshot"],"mappings":";;;;AAAA,SAASA,aAAa,QAAQ,SAAQ;;;;;;;AAItC,MAAMC,cAAUD,sHAAAA,EAAc,8BAAYE,GAAG;AAEtC,MAAMC,oBAAuC;IAClD,MAAM,EACJC,mBAAmB,EACnBC,iBAAiB,EACjBC,UAAU,EACVC,YAAY,EACb,GAAGN,QAAQ;IAEZ,OAAO;QACLG;QACAC;QACAC;QACAE,YAAYD;IACd;AACF,EAAC"}},
    {"offset": {"line": 11353, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/%40payloadcms/drizzle/src/utilities/pushDevSchema.ts"],"sourcesContent":["import { dequal } from 'dequal'\nimport prompts from 'prompts'\n\nimport type { BasePostgresAdapter } from '../postgres/types.js'\nimport type { DrizzleAdapter, PostgresDB, RawTable } from '../types.js'\n\nconst previousSchema: {\n  localeCodes: null | string[]\n  rawTables: null | Record<string, RawTable>\n} = {\n  localeCodes: null,\n  rawTables: null,\n}\n\n/**\n * Pushes the development schema to the database using Drizzle.\n *\n * @param {DrizzleAdapter} adapter - The PostgresAdapter instance connected to the database.\n * @returns {Promise<void>} - A promise that resolves once the schema push is complete.\n */\nexport const pushDevSchema = async (adapter: DrizzleAdapter) => {\n  if (process.env.PAYLOAD_FORCE_DRIZZLE_PUSH !== 'true') {\n    const localeCodes =\n      adapter.payload.config.localization && adapter.payload.config.localization.localeCodes\n\n    const equal = dequal(previousSchema, {\n      localeCodes,\n      rawTables: adapter.rawTables,\n    })\n\n    if (equal) {\n      if (adapter.logger) {\n        adapter.payload.logger.info('No changes detected in schema, skipping schema push.')\n      }\n\n      return\n    } else {\n      previousSchema.localeCodes = localeCodes\n      previousSchema.rawTables = adapter.rawTables\n    }\n  }\n\n  const { pushSchema } = adapter.requireDrizzleKit()\n\n  const { extensions = {}, tablesFilter } = adapter as BasePostgresAdapter\n\n  // This will prompt if clarifications are needed for Drizzle to push new schema\n  const { apply, hasDataLoss, warnings } = await pushSchema(\n    adapter.schema,\n    adapter.drizzle,\n    adapter.schemaName ? [adapter.schemaName] : undefined,\n    tablesFilter,\n    // Drizzle extensionsFilter supports only postgis for now\n    // https://github.com/drizzle-team/drizzle-orm/blob/83daf2d5cf023112de878bc2249ee2c41a2a5b1b/drizzle-kit/src/cli/validations/cli.ts#L26\n    extensions.postgis ? ['postgis'] : undefined,\n  )\n\n  if (warnings.length) {\n    let message = `Warnings detected during schema push: \\n\\n${warnings.join('\\n')}\\n\\n`\n\n    if (hasDataLoss) {\n      message += `DATA LOSS WARNING: Possible data loss detected if schema is pushed.\\n\\n`\n    }\n\n    message += `Accept warnings and push schema to database?`\n\n    const { confirm: acceptWarnings } = await prompts(\n      {\n        name: 'confirm',\n        type: 'confirm',\n        initial: false,\n        message,\n      },\n      {\n        onCancel: () => {\n          process.exit(0)\n        },\n      },\n    )\n\n    // Exit if user does not accept warnings.\n    // Q: Is this the right type of exit for this interaction?\n    if (!acceptWarnings) {\n      process.exit(0)\n    }\n  }\n\n  await apply()\n  const migrationsTable = adapter.schemaName\n    ? `\"${adapter.schemaName}\".\"payload_migrations\"`\n    : '\"payload_migrations\"'\n\n  const drizzle = adapter.drizzle as PostgresDB\n\n  const result = await adapter.execute({\n    drizzle,\n    raw: `SELECT * FROM ${migrationsTable} WHERE batch = '-1'`,\n  })\n\n  const devPush = result.rows\n\n  if (!devPush.length) {\n    // Use drizzle for insert so $defaultFn's are called\n    await drizzle.insert(adapter.tables.payload_migrations).values({\n      name: 'dev',\n      batch: -1,\n    })\n  } else {\n    await adapter.execute({\n      drizzle,\n      raw: `UPDATE ${migrationsTable} SET updated_at = CURRENT_TIMESTAMP WHERE batch = '-1'`,\n    })\n  }\n}\n"],"names":["dequal","prompts","previousSchema","localeCodes","rawTables","pushDevSchema","adapter","process","env","PAYLOAD_FORCE_DRIZZLE_PUSH","payload","config","localization","equal","logger","info","pushSchema","requireDrizzleKit","extensions","tablesFilter","apply","hasDataLoss","warnings","schema","drizzle","schemaName","undefined","postgis","length","message","join","confirm","acceptWarnings","name","type","initial","onCancel","exit","migrationsTable","result","execute","raw","devPush","rows","insert","tables","payload_migrations","values","batch"],"mappings":";;;;AAAA,SAASA,MAAM,QAAQ,SAAQ;AAC/B,OAAOC,aAAa,UAAS;;;AAK7B,MAAMC,iBAGF;IACFC,aAAa;IACbC,WAAW;AACb;AAQO,MAAMC,gBAAgB,OAAOC;IAClC,IAAIC,QAAQC,GAAG,CAACC,0BAA0B,KAAK,QAAQ;QACrD,MAAMN,cACJG,QAAQI,OAAO,CAACC,MAAM,CAACC,YAAY,IAAIN,QAAQI,OAAO,CAACC,MAAM,CAACC,YAAY,CAACT,WAAW;QAExF,MAAMU,YAAQb,oJAAAA,EAAOE,gBAAgB;YACnCC;YACAC,WAAWE,QAAQF,SAAS;QAC9B;QAEA,IAAIS,OAAO;YACT,IAAIP,QAAQQ,MAAM,EAAE;gBAClBR,QAAQI,OAAO,CAACI,MAAM,CAACC,IAAI,CAAC;YAC9B;YAEA;QACF,OAAO;YACLb,eAAeC,WAAW,GAAGA;YAC7BD,eAAeE,SAAS,GAAGE,QAAQF,SAAS;QAC9C;IACF;IAEA,MAAM,EAAEY,UAAU,EAAE,GAAGV,QAAQW,iBAAiB;IAEhD,MAAM,EAAEC,aAAa,CAAC,CAAC,EAAEC,YAAY,EAAE,GAAGb;IAE1C,+EAA+E;IAC/E,MAAM,EAAEc,KAAK,EAAEC,WAAW,EAAEC,QAAQ,EAAE,GAAG,MAAMN,WAC7CV,QAAQiB,MAAM,EACdjB,QAAQkB,OAAO,EACflB,QAAQmB,UAAU,GAAG;QAACnB,QAAQmB,UAAU;KAAC,GAAGC,WAC5CP,cACA,AACA,yDADyD,8EAC8E;IACvID,WAAWS,OAAO,GAAG;QAAC;KAAU,GAAGD;IAGrC,IAAIJ,SAASM,MAAM,EAAE;QACnB,IAAIC,UAAU,CAAC,0CAA0C,EAAEP,SAASQ,IAAI,CAAC,MAAM,IAAI,CAAC;QAEpF,IAAIT,aAAa;YACfQ,WAAW,CAAC,uEAAuE,CAAC;QACtF;QAEAA,WAAW,CAAC,4CAA4C,CAAC;QAEzD,MAAM,EAAEE,SAASC,cAAc,EAAE,GAAG,UAAM/B,6IAAAA,EACxC;YACEgC,MAAM;YACNC,MAAM;YACNC,SAAS;YACTN;QACF,GACA;YACEO,UAAU;gBACR7B,QAAQ8B,IAAI,CAAC;YACf;QACF;QAGF,yCAAyC;QACzC,0DAA0D;QAC1D,IAAI,CAACL,gBAAgB;YACnBzB,QAAQ8B,IAAI,CAAC;QACf;IACF;IAEA,MAAMjB;IACN,MAAMkB,kBAAkBhC,QAAQmB,UAAU,GACtC,CAAC,CAAC,EAAEnB,QAAQmB,UAAU,CAAC,sBAAsB,CAAC,GAC9C;IAEJ,MAAMD,UAAUlB,QAAQkB,OAAO;IAE/B,MAAMe,SAAS,MAAMjC,QAAQkC,OAAO,CAAC;QACnChB;QACAiB,KAAK,CAAC,cAAc,EAAEH,gBAAgB,mBAAmB,CAAC;IAC5D;IAEA,MAAMI,UAAUH,OAAOI,IAAI;IAE3B,IAAI,CAACD,QAAQd,MAAM,EAAE;QACnB,oDAAoD;QACpD,MAAMJ,QAAQoB,MAAM,CAACtC,QAAQuC,MAAM,CAACC,kBAAkB,EAAEC,MAAM,CAAC;YAC7Dd,MAAM;YACNe,OAAO,CAAC;QACV;IACF,OAAO;QACL,MAAM1C,QAAQkC,OAAO,CAAC;YACpBhB;YACAiB,KAAK,CAAC,OAAO,EAAEH,gBAAgB,sDAAsD,CAAC;QACxF;IACF;AACF,EAAC"}}]
}