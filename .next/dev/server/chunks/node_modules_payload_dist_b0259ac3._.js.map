{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/errors/APIError.ts"],"sourcesContent":["import { status as httpStatus } from 'http-status'\n\n// This gets dynamically reassigned during compilation\nexport let APIErrorName = 'APIError'\n\nclass ExtendableError<TData extends object = { [key: string]: unknown }> extends Error {\n  data: TData\n\n  isOperational: boolean\n\n  isPublic: boolean\n\n  status: number\n\n  constructor(message: string, status: number, data: TData, isPublic: boolean) {\n    super(message, {\n      // show data in cause\n      cause: data,\n    })\n    APIErrorName = this.constructor.name\n    this.name = this.constructor.name\n    this.message = message\n    this.status = status\n    this.data = data\n    this.isPublic = isPublic\n    this.isOperational = true // This is required since bluebird 4 doesn't append it anymore.\n    Error.captureStackTrace(this, this.constructor)\n  }\n}\n\n/**\n * Class representing an API error.\n * @extends ExtendableError\n */\nexport class APIError<\n  TData extends null | object = { [key: string]: unknown } | null,\n  // @ts-expect-error - vestiges of when tsconfig was not strict. Feel free to improve\n> extends ExtendableError<TData> {\n  /**\n   * Creates an API error.\n   * @param {string} message - Error message.\n   * @param {number} status - HTTP status code of error.\n   * @param {object} data - response data to be returned.\n   * @param {boolean} isPublic - Whether the message should be visible to user or not.\n   */\n  constructor(\n    message: string,\n    status: number = httpStatus.INTERNAL_SERVER_ERROR,\n    data: TData = null!,\n    isPublic?: boolean,\n  ) {\n    super(\n      message,\n      status,\n      data,\n      typeof isPublic === 'boolean' ? isPublic : status !== httpStatus.INTERNAL_SERVER_ERROR,\n    )\n  }\n}\n"],"names":["status","httpStatus","APIErrorName","ExtendableError","Error","data","isOperational","isPublic","message","cause","name","captureStackTrace","APIError","INTERNAL_SERVER_ERROR"],"mappings":";;;;;;;AAAA,SAASA,UAAUC,UAAU,QAAQ,cAAa;;AAG3C,IAAIC,eAAe,WAAU;AAEpC,MAAMC,wBAA2EC;IAC/EC,KAAW;IAEXC,cAAsB;IAEtBC,SAAiB;IAEjBP,OAAc;IAEd,YAAYQ,OAAe,EAAER,MAAc,EAAEK,IAAW,EAAEE,QAAiB,CAAE;QAC3E,KAAK,CAACC,SAAS;YACb,qBAAqB;YACrBC,OAAOJ;QACT;QACAH,eAAe,IAAI,CAAC,WAAW,CAACQ,IAAI;QACpC,IAAI,CAACA,IAAI,GAAG,IAAI,CAAC,WAAW,CAACA,IAAI;QACjC,IAAI,CAACF,OAAO,GAAGA;QACf,IAAI,CAACR,MAAM,GAAGA;QACd,IAAI,CAACK,IAAI,GAAGA;QACZ,IAAI,CAACE,QAAQ,GAAGA;QAChB,IAAI,CAACD,aAAa,GAAG,MAAK,+DAA+D;QACzFF,MAAMO,iBAAiB,CAAC,IAAI,EAAE,IAAI,CAAC,WAAW;IAChD;AACF;AAMO,MAAMC,iBAGHT;IACR;;;;;;GAMC,GACD,YACEK,OAAe,EACfR,SAAiBC,sMAAAA,CAAWY,qBAAqB,EACjDR,OAAc,IAAK,EACnBE,QAAkB,CAClB;QACA,KAAK,CACHC,SACAR,QACAK,MACA,OAAOE,aAAa,YAAYA,WAAWP,WAAWC,sMAAAA,CAAWY,qBAAqB;IAE1F;AACF"}},
    {"offset": {"line": 49, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/errors/Forbidden.ts"],"sourcesContent":["import type { TFunction } from '@payloadcms/translations'\n\nimport { en } from '@payloadcms/translations/languages/en'\nimport { status as httpStatus } from 'http-status'\n\nimport { APIError } from './APIError.js'\n\nexport class Forbidden extends APIError {\n  constructor(t?: TFunction) {\n    super(\n      t ? t('error:notAllowedToPerformAction') : en.translations.error.notAllowedToPerformAction,\n      httpStatus.FORBIDDEN,\n    )\n  }\n}\n"],"names":["en","status","httpStatus","APIError","Forbidden","t","translations","error","notAllowedToPerformAction","FORBIDDEN"],"mappings":";;;;AAEA,SAASA,EAAE,QAAQ,wCAAuC;;AAC1D,SAASC,UAAUC,UAAU,QAAQ,cAAa;AAElD,SAASC,QAAQ,QAAQ,gBAAe;;;;AAEjC,MAAMC,kBAAkBD,mKAAAA;IAC7B,YAAYE,CAAa,CAAE;QACzB,KAAK,CACHA,IAAIA,EAAE,qCAAqCL,+KAAAA,CAAGM,YAAY,CAACC,KAAK,CAACC,yBAAyB,EAC1FN,sMAAAA,CAAWO,SAAS;IAExB;AACF"}},
    {"offset": {"line": 69, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/errors/AuthenticationError.ts"],"sourcesContent":["import type { TFunction } from '@payloadcms/translations'\n\nimport { en } from '@payloadcms/translations/languages/en'\nimport { status as httpStatus } from 'http-status'\n\nimport { APIError } from './APIError.js'\n\nexport class AuthenticationError extends APIError {\n  constructor(t?: TFunction, loginWithUsername?: boolean) {\n    super(\n      t\n        ? `${loginWithUsername ? t('error:usernameOrPasswordIncorrect') : t('error:emailOrPasswordIncorrect')}`\n        : en.translations.error.emailOrPasswordIncorrect,\n      httpStatus.UNAUTHORIZED,\n    )\n  }\n}\n"],"names":["en","status","httpStatus","APIError","AuthenticationError","t","loginWithUsername","translations","error","emailOrPasswordIncorrect","UNAUTHORIZED"],"mappings":";;;;AAEA,SAASA,EAAE,QAAQ,wCAAuC;;AAC1D,SAASC,UAAUC,UAAU,QAAQ,cAAa;AAElD,SAASC,QAAQ,QAAQ,gBAAe;;;;AAEjC,MAAMC,4BAA4BD,mKAAAA;IACvC,YAAYE,CAAa,EAAEC,iBAA2B,CAAE;QACtD,KAAK,CACHD,IACI,GAAGC,oBAAoBD,EAAE,uCAAuCA,EAAE,mCAAmC,GACrGL,+KAAAA,CAAGO,YAAY,CAACC,KAAK,CAACC,wBAAwB,EAClDP,sMAAAA,CAAWQ,YAAY;IAE3B;AACF"}},
    {"offset": {"line": 89, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/errors/LockedAuth.ts"],"sourcesContent":["import type { TFunction } from '@payloadcms/translations'\n\nimport { en } from '@payloadcms/translations/languages/en'\nimport { status as httpStatus } from 'http-status'\n\nimport { APIError } from './APIError.js'\n\nexport class LockedAuth extends APIError {\n  constructor(t?: TFunction) {\n    super(t ? t('error:userLocked') : en.translations.error.userLocked, httpStatus.UNAUTHORIZED)\n  }\n}\n"],"names":["en","status","httpStatus","APIError","LockedAuth","t","translations","error","userLocked","UNAUTHORIZED"],"mappings":";;;;AAEA,SAASA,EAAE,QAAQ,wCAAuC;;AAC1D,SAASC,UAAUC,UAAU,QAAQ,cAAa;AAElD,SAASC,QAAQ,QAAQ,gBAAe;;;;AAEjC,MAAMC,mBAAmBD,mKAAAA;IAC9B,YAAYE,CAAa,CAAE;QACzB,KAAK,CAACA,IAAIA,EAAE,sBAAsBL,+KAAAA,CAAGM,YAAY,CAACC,KAAK,CAACC,UAAU,EAAEN,sMAAAA,CAAWO,YAAY;IAC7F;AACF"}},
    {"offset": {"line": 109, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/errors/UnverifiedEmail.ts"],"sourcesContent":["import type { TFunction } from '@payloadcms/translations'\n\nimport { en } from '@payloadcms/translations/languages/en'\nimport { status as httpStatus } from 'http-status'\n\nimport { APIError } from './APIError.js'\n\nexport class UnverifiedEmail extends APIError {\n  constructor({ t }: { t?: TFunction }) {\n    super(\n      t ? t('error:unverifiedEmail') : en.translations.error.unverifiedEmail,\n      httpStatus.FORBIDDEN,\n    )\n  }\n}\n"],"names":["en","status","httpStatus","APIError","UnverifiedEmail","t","translations","error","unverifiedEmail","FORBIDDEN"],"mappings":";;;;AAEA,SAASA,EAAE,QAAQ,wCAAuC;;AAC1D,SAASC,UAAUC,UAAU,QAAQ,cAAa;AAElD,SAASC,QAAQ,QAAQ,gBAAe;;;;AAEjC,MAAMC,wBAAwBD,mKAAAA;IACnC,YAAY,EAAEE,CAAC,EAAqB,CAAE;QACpC,KAAK,CACHA,IAAIA,EAAE,2BAA2BL,+KAAAA,CAAGM,YAAY,CAACC,KAAK,CAACC,eAAe,EACtEN,sMAAAA,CAAWO,SAAS;IAExB;AACF"}},
    {"offset": {"line": 129, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/errors/ValidationError.ts"],"sourcesContent":["import type { TFunction } from '@payloadcms/translations'\n\nimport { en } from '@payloadcms/translations/languages/en'\nimport { status as httpStatus } from 'http-status'\n\nimport type { LabelFunction, StaticLabel } from '../config/types.js'\nimport type { PayloadRequest } from '../types/index.js'\n\nimport { APIError } from './APIError.js'\n\n// This gets dynamically reassigned during compilation\nexport let ValidationErrorName = 'ValidationError'\n\nexport type ValidationFieldError = {\n  label?: LabelFunction | StaticLabel\n  // The error message to display for this field\n  message: string\n  path: string\n}\n\nexport class ValidationError extends APIError<{\n  collection?: string\n  errors: ValidationFieldError[]\n  global?: string\n}> {\n  constructor(\n    results: {\n      collection?: string\n      errors: ValidationFieldError[]\n      global?: string\n      id?: number | string\n      /**\n       *  req needs to be passed through (if you have one) in order to resolve label functions that may be part of the errors array\n       */\n      req?: Partial<PayloadRequest>\n    },\n    t?: TFunction,\n  ) {\n    const message = t\n      ? t('error:followingFieldsInvalid', { count: results.errors.length })\n      : results.errors.length === 1\n        ? en.translations.error.followingFieldsInvalid_one\n        : en.translations.error.followingFieldsInvalid_other\n\n    const req = results.req\n    // delete to avoid logging the whole req\n    delete results['req']\n\n    super(\n      `${message} ${results.errors\n        .map((f) => {\n          if (f.label) {\n            if (typeof f.label === 'function') {\n              if (!req || !req.i18n || !req.t) {\n                return f.path\n              }\n\n              return f.label({ i18n: req.i18n, t: req.t })\n            }\n\n            if (typeof f.label === 'object') {\n              if (req?.i18n?.language) {\n                return f.label[req.i18n.language]\n              }\n\n              return f.label[Object.keys(f.label)[0]!]\n            }\n\n            return f.label\n          }\n\n          return f.path\n        })\n        .join(', ')}`,\n      httpStatus.BAD_REQUEST,\n      results,\n    )\n\n    ValidationErrorName = this.constructor.name\n  }\n}\n"],"names":["en","status","httpStatus","APIError","ValidationErrorName","ValidationError","results","t","message","count","errors","length","translations","error","followingFieldsInvalid_one","followingFieldsInvalid_other","req","map","f","label","i18n","path","language","Object","keys","join","BAD_REQUEST","name"],"mappings":";;;;;;AAEA,SAASA,EAAE,QAAQ,wCAAuC;;AAC1D,SAASC,UAAUC,UAAU,QAAQ,cAAa;AAKlD,SAASC,QAAQ,QAAQ,gBAAe;;;;AAGjC,IAAIC,sBAAsB,kBAAiB;AAS3C,MAAMC,wBAAwBF,mKAAAA;IAKnC,YACEG,OASC,EACDC,CAAa,CACb;QACA,MAAMC,UAAUD,IACZA,EAAE,gCAAgC;YAAEE,OAAOH,QAAQI,MAAM,CAACC,MAAM;QAAC,KACjEL,QAAQI,MAAM,CAACC,MAAM,KAAK,IACxBX,+KAAAA,CAAGY,YAAY,CAACC,KAAK,CAACC,0BAA0B,GAChDd,+KAAAA,CAAGY,YAAY,CAACC,KAAK,CAACE,4BAA4B;QAExD,MAAMC,MAAMV,QAAQU,GAAG;QACvB,wCAAwC;QACxC,OAAOV,OAAO,CAAC,MAAM;QAErB,KAAK,CACH,GAAGE,QAAQ,CAAC,EAAEF,QAAQI,MAAM,CACzBO,GAAG,CAAC,CAACC;YACJ,IAAIA,EAAEC,KAAK,EAAE;gBACX,IAAI,OAAOD,EAAEC,KAAK,KAAK,YAAY;oBACjC,IAAI,CAACH,OAAO,CAACA,IAAII,IAAI,IAAI,CAACJ,IAAIT,CAAC,EAAE;wBAC/B,OAAOW,EAAEG,IAAI;oBACf;oBAEA,OAAOH,EAAEC,KAAK,CAAC;wBAAEC,MAAMJ,IAAII,IAAI;wBAAEb,GAAGS,IAAIT,CAAC;oBAAC;gBAC5C;gBAEA,IAAI,OAAOW,EAAEC,KAAK,KAAK,UAAU;oBAC/B,IAAIH,KAAKI,MAAME,UAAU;wBACvB,OAAOJ,EAAEC,KAAK,CAACH,IAAII,IAAI,CAACE,QAAQ,CAAC;oBACnC;oBAEA,OAAOJ,EAAEC,KAAK,CAACI,OAAOC,IAAI,CAACN,EAAEC,KAAK,CAAC,CAAC,EAAE,CAAE;gBAC1C;gBAEA,OAAOD,EAAEC,KAAK;YAChB;YAEA,OAAOD,EAAEG,IAAI;QACf,GACCI,IAAI,CAAC,OAAO,EACfvB,sMAAAA,CAAWwB,WAAW,EACtBpB;QAGFF,sBAAsB,IAAI,CAAC,WAAW,CAACuB,IAAI;IAC7C;AACF"}},
    {"offset": {"line": 179, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/errors/MissingEditorProp.ts"],"sourcesContent":["import type { Field } from '../fields/config/types.js'\n\nimport { fieldAffectsData } from '../fields/config/types.js'\nimport { APIError } from './APIError.js'\n\nexport class MissingEditorProp extends APIError {\n  constructor(field: Field) {\n    super(\n      `RichText field${fieldAffectsData(field) ? ` \"${field.name}\"` : ''} is missing the editor prop. For sub-richText fields, the editor props is required, as it would otherwise create infinite recursion.`,\n    )\n  }\n}\n"],"names":["fieldAffectsData","APIError","MissingEditorProp","field","name"],"mappings":";;;;AAEA,SAASA,gBAAgB,QAAQ,4BAA2B;AAC5D,SAASC,QAAQ,QAAQ,gBAAe;;;AAEjC,MAAMC,0BAA0BD,mKAAAA;IACrC,YAAYE,KAAY,CAAE;QACxB,KAAK,CACH,CAAC,cAAc,MAAEH,kLAAAA,EAAiBG,SAAS,CAAC,EAAE,EAAEA,MAAMC,IAAI,CAAC,CAAC,CAAC,GAAG,GAAG,oIAAoI,CAAC;IAE5M;AACF"}},
    {"offset": {"line": 196, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/errors/QueryError.ts"],"sourcesContent":["import { status as httpStatus } from 'http-status'\n\nimport { APIError } from './APIError.js'\n\nexport class QueryError extends APIError<{ path: string }[]> {\n  constructor(results: { path: string }[]) {\n    const message = `The following path${results.length === 1 ? '' : 's'} cannot be queried:`\n\n    super(\n      `${message} ${results.map((err) => err.path).join(', ')}`,\n      httpStatus.BAD_REQUEST,\n      results,\n    )\n  }\n}\n"],"names":["status","httpStatus","APIError","QueryError","results","message","length","map","err","path","join","BAD_REQUEST"],"mappings":";;;;;AAAA,SAASA,UAAUC,UAAU,QAAQ,cAAa;AAElD,SAASC,QAAQ,QAAQ,gBAAe;;;AAEjC,MAAMC,mBAAmBD,mKAAAA;IAC9B,YAAYE,OAA2B,CAAE;QACvC,MAAMC,UAAU,CAAC,kBAAkB,EAAED,QAAQE,MAAM,KAAK,IAAI,KAAK,IAAI,mBAAmB,CAAC;QAEzF,KAAK,CACH,GAAGD,QAAQ,CAAC,EAAED,QAAQG,GAAG,CAAC,CAACC,MAAQA,IAAIC,IAAI,EAAEC,IAAI,CAAC,OAAO,EACzDT,sMAAAA,CAAWU,WAAW,EACtBP;IAEJ;AACF"}},
    {"offset": {"line": 215, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/errors/NotFound.ts"],"sourcesContent":["import type { TFunction } from '@payloadcms/translations'\n\nimport { en } from '@payloadcms/translations/languages/en'\nimport { status as httpStatus } from 'http-status'\n\nimport { APIError } from './APIError.js'\n\nexport class NotFound extends APIError {\n  constructor(t?: TFunction) {\n    super(t ? t('general:notFound') : en.translations.general.notFound, httpStatus.NOT_FOUND)\n  }\n}\n"],"names":["en","status","httpStatus","APIError","NotFound","t","translations","general","notFound","NOT_FOUND"],"mappings":";;;;AAEA,SAASA,EAAE,QAAQ,wCAAuC;;AAC1D,SAASC,UAAUC,UAAU,QAAQ,cAAa;AAElD,SAASC,QAAQ,QAAQ,gBAAe;;;;AAEjC,MAAMC,iBAAiBD,mKAAAA;IAC5B,YAAYE,CAAa,CAAE;QACzB,KAAK,CAACA,IAAIA,EAAE,sBAAsBL,+KAAAA,CAAGM,YAAY,CAACC,OAAO,CAACC,QAAQ,EAAEN,sMAAAA,CAAWO,SAAS;IAC1F;AACF"}},
    {"offset": {"line": 235, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/errors/FileRetrievalError.ts"],"sourcesContent":["import type { TFunction } from '@payloadcms/translations'\n\nimport { status as httpStatus } from 'http-status'\n\nimport { APIError } from './APIError.js'\n\nexport class FileRetrievalError extends APIError {\n  constructor(t?: TFunction, message?: string) {\n    let msg = t ? t('error:problemUploadingFile') : 'There was a problem while retrieving the file.'\n\n    if (message) {\n      msg += ` ${message}`\n    }\n    super(msg, httpStatus.INTERNAL_SERVER_ERROR)\n  }\n}\n"],"names":["status","httpStatus","APIError","FileRetrievalError","t","message","msg","INTERNAL_SERVER_ERROR"],"mappings":";;;;;AAEA,SAASA,UAAUC,UAAU,QAAQ,cAAa;AAElD,SAASC,QAAQ,QAAQ,gBAAe;;;AAEjC,MAAMC,2BAA2BD,mKAAAA;IACtC,YAAYE,CAAa,EAAEC,OAAgB,CAAE;QAC3C,IAAIC,MAAMF,IAAIA,EAAE,gCAAgC;QAEhD,IAAIC,SAAS;YACXC,OAAO,CAAC,CAAC,EAAED,SAAS;QACtB;QACA,KAAK,CAACC,KAAKL,sMAAAA,CAAWM,qBAAqB;IAC7C;AACF"}},
    {"offset": {"line": 257, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/errors/FileUploadError.ts"],"sourcesContent":["import type { TFunction } from '@payloadcms/translations'\n\nimport { en } from '@payloadcms/translations/languages/en'\nimport { status as httpStatus } from 'http-status'\n\nimport { APIError } from './APIError.js'\n\nexport class FileUploadError extends APIError {\n  constructor(t?: TFunction) {\n    super(\n      t ? t('error:problemUploadingFile') : en.translations.error.problemUploadingFile,\n      httpStatus.BAD_REQUEST,\n    )\n  }\n}\n"],"names":["en","status","httpStatus","APIError","FileUploadError","t","translations","error","problemUploadingFile","BAD_REQUEST"],"mappings":";;;;AAEA,SAASA,EAAE,QAAQ,wCAAuC;;AAC1D,SAASC,UAAUC,UAAU,QAAQ,cAAa;AAElD,SAASC,QAAQ,QAAQ,gBAAe;;;;AAEjC,MAAMC,wBAAwBD,mKAAAA;IACnC,YAAYE,CAAa,CAAE;QACzB,KAAK,CACHA,IAAIA,EAAE,gCAAgCL,+KAAAA,CAAGM,YAAY,CAACC,KAAK,CAACC,oBAAoB,EAChFN,sMAAAA,CAAWO,WAAW;IAE1B;AACF"}},
    {"offset": {"line": 277, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/errors/MissingFile.ts"],"sourcesContent":["import type { TFunction } from '@payloadcms/translations'\n\nimport { en } from '@payloadcms/translations/languages/en'\nimport { status as httpStatus } from 'http-status'\n\nimport { APIError } from './APIError.js'\n\nexport class MissingFile extends APIError {\n  constructor(t?: TFunction) {\n    super(\n      t ? t('error:noFilesUploaded') : en.translations.error.noFilesUploaded,\n      httpStatus.BAD_REQUEST,\n    )\n  }\n}\n"],"names":["en","status","httpStatus","APIError","MissingFile","t","translations","error","noFilesUploaded","BAD_REQUEST"],"mappings":";;;;AAEA,SAASA,EAAE,QAAQ,wCAAuC;;AAC1D,SAASC,UAAUC,UAAU,QAAQ,cAAa;AAElD,SAASC,QAAQ,QAAQ,gBAAe;;;;AAEjC,MAAMC,oBAAoBD,mKAAAA;IAC/B,YAAYE,CAAa,CAAE;QACzB,KAAK,CACHA,IAAIA,EAAE,2BAA2BL,+KAAAA,CAAGM,YAAY,CAACC,KAAK,CAACC,eAAe,EACtEN,sMAAAA,CAAWO,WAAW;IAE1B;AACF"}},
    {"offset": {"line": 297, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/errors/UnauthorizedError.ts"],"sourcesContent":["import type { TFunction } from '@payloadcms/translations'\n\nimport { en } from '@payloadcms/translations/languages/en'\nimport { status as httpStatus } from 'http-status'\n\nimport { APIError } from './APIError.js'\n\nexport class UnauthorizedError extends APIError {\n  constructor(t?: TFunction) {\n    super(t ? t('error:unauthorized') : en.translations.error.unauthorized, httpStatus.UNAUTHORIZED)\n  }\n}\n"],"names":["en","status","httpStatus","APIError","UnauthorizedError","t","translations","error","unauthorized","UNAUTHORIZED"],"mappings":";;;;AAEA,SAASA,EAAE,QAAQ,wCAAuC;;AAC1D,SAASC,UAAUC,UAAU,QAAQ,cAAa;AAElD,SAASC,QAAQ,QAAQ,gBAAe;;;;AAEjC,MAAMC,0BAA0BD,mKAAAA;IACrC,YAAYE,CAAa,CAAE;QACzB,KAAK,CAACA,IAAIA,EAAE,wBAAwBL,+KAAAA,CAAGM,YAAY,CAACC,KAAK,CAACC,YAAY,EAAEN,sMAAAA,CAAWO,YAAY;IACjG;AACF"}},
    {"offset": {"line": 317, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/errors/ErrorDeletingFile.ts"],"sourcesContent":["import type { TFunction } from '@payloadcms/translations'\n\nimport { en } from '@payloadcms/translations/languages/en'\nimport { status as httpStatus } from 'http-status'\n\nimport { APIError } from './APIError.js'\n\nexport class ErrorDeletingFile extends APIError {\n  constructor(t?: TFunction) {\n    super(\n      t ? t('error:deletingFile') : en.translations.error.deletingFile,\n      httpStatus.INTERNAL_SERVER_ERROR,\n    )\n  }\n}\n"],"names":["en","status","httpStatus","APIError","ErrorDeletingFile","t","translations","error","deletingFile","INTERNAL_SERVER_ERROR"],"mappings":";;;;AAEA,SAASA,EAAE,QAAQ,wCAAuC;;AAC1D,SAASC,UAAUC,UAAU,QAAQ,cAAa;AAElD,SAASC,QAAQ,QAAQ,gBAAe;;;;AAEjC,MAAMC,0BAA0BD,mKAAAA;IACrC,YAAYE,CAAa,CAAE;QACzB,KAAK,CACHA,IAAIA,EAAE,wBAAwBL,+KAAAA,CAAGM,YAAY,CAACC,KAAK,CAACC,YAAY,EAChEN,sMAAAA,CAAWO,qBAAqB;IAEpC;AACF"}},
    {"offset": {"line": 337, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/errors/Locked.ts"],"sourcesContent":["import { status as httpStatus } from 'http-status'\n\nimport { APIError } from './APIError.js'\n\nexport class Locked extends APIError {\n  constructor(message: string) {\n    super(message, httpStatus.LOCKED)\n  }\n}\n"],"names":["status","httpStatus","APIError","Locked","message","LOCKED"],"mappings":";;;;;AAAA,SAASA,UAAUC,UAAU,QAAQ,cAAa;AAElD,SAASC,QAAQ,QAAQ,gBAAe;;;AAEjC,MAAMC,eAAeD,mKAAAA;IAC1B,YAAYE,OAAe,CAAE;QAC3B,KAAK,CAACA,SAASH,sMAAAA,CAAWI,MAAM;IAClC;AACF"}},
    {"offset": {"line": 355, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/translations/getLocalI18n.ts"],"sourcesContent":["import type { AcceptedLanguages } from '@payloadcms/translations'\n\nimport { initI18n } from '@payloadcms/translations'\n\nimport type { SanitizedConfig } from '../config/types.js'\n\nexport const getLocalI18n = async ({\n  config,\n  language,\n}: {\n  config: SanitizedConfig\n  language: AcceptedLanguages\n}) =>\n  initI18n({\n    config: config.i18n,\n    context: 'api',\n    language,\n  })\n"],"names":["initI18n","getLocalI18n","config","language","i18n","context"],"mappings":";;;;AAEA,SAASA,QAAQ,QAAQ,2BAA0B;;AAI5C,MAAMC,eAAe,OAAO,EACjCC,MAAM,EACNC,QAAQ,EAIT,OACCH,uLAAAA,EAAS;QACPE,QAAQA,OAAOE,IAAI;QACnBC,SAAS;QACTF;IACF,GAAE"}},
    {"offset": {"line": 370, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/database/combineQueries.ts"],"sourcesContent":["import type { Where } from '../types/index.js'\n\nimport { hasWhereAccessResult } from '../auth/index.js'\n\n/**\n * Combines two queries into a single query, using an AND operator\n */\nexport const combineQueries = (where: Where, access: boolean | Where): Where => {\n  if (!where && !access) {\n    return {}\n  }\n\n  const and: Where[] = where ? [where] : []\n\n  if (hasWhereAccessResult(access)) {\n    and.push(access)\n  }\n\n  return {\n    and,\n  }\n}\n"],"names":["hasWhereAccessResult","combineQueries","where","access","and","push"],"mappings":";;;;AAEA,SAASA,oBAAoB,QAAQ,mBAAkB;;AAKhD,MAAMC,iBAAiB,CAACC,OAAcC;IAC3C,IAAI,CAACD,SAAS,CAACC,QAAQ;QACrB,OAAO,CAAC;IACV;IAEA,MAAMC,MAAeF,QAAQ;QAACA;KAAM,GAAG,EAAE;IAEzC,QAAIF,0KAAAA,EAAqBG,SAAS;QAChCC,IAAIC,IAAI,CAACF;IACX;IAEA,OAAO;QACLC;IACF;AACF,EAAC"}},
    {"offset": {"line": 394, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/database/getLocalizedPaths.ts"],"sourcesContent":["import type { PathToQuery } from './queryValidation/types.js'\n\nimport {\n  type Field,\n  fieldShouldBeLocalized,\n  type FlattenedBlock,\n  type FlattenedField,\n} from '../fields/config/types.js'\nimport { APIError, type Payload, type SanitizedCollectionConfig } from '../index.js'\n\nexport function getLocalizedPaths({\n  collectionSlug,\n  fields,\n  globalSlug,\n  incomingPath,\n  locale,\n  overrideAccess = false,\n  parentIsLocalized,\n  payload,\n}: {\n  collectionSlug?: string\n  fields: FlattenedField[]\n  globalSlug?: string\n  incomingPath: string\n  locale?: string\n  overrideAccess?: boolean\n  /**\n   * @todo make required in v4.0. Usually, you'd wanna pass this through\n   */\n  parentIsLocalized?: boolean\n  payload: Payload\n}): PathToQuery[] {\n  const pathSegments = incomingPath.split('.')\n  const localizationConfig = payload.config.localization\n\n  let paths: PathToQuery[] = [\n    {\n      collectionSlug,\n      complete: false,\n      // @ts-expect-error - vestiges of when tsconfig was not strict. Feel free to improve\n      field: undefined,\n      fields,\n      globalSlug,\n      invalid: false,\n      parentIsLocalized: parentIsLocalized!,\n      path: '',\n    },\n  ]\n\n  for (let i = 0; i < pathSegments.length; i += 1) {\n    const segment = pathSegments[i]\n\n    const lastIncompletePath = paths.find(({ complete }) => !complete)\n\n    if (lastIncompletePath) {\n      const { path } = lastIncompletePath\n      let currentPath = path ? `${path}.${segment}` : segment\n\n      let fieldsToSearch: FlattenedField[]\n      let _parentIsLocalized = parentIsLocalized\n\n      let matchedField!: FlattenedField\n\n      if (lastIncompletePath?.field?.type === 'blocks') {\n        if (segment === 'blockType') {\n          matchedField = {\n            name: 'blockType',\n            type: 'text',\n          }\n        } else {\n          for (const _block of lastIncompletePath.field.blockReferences ??\n            lastIncompletePath.field.blocks) {\n            let block: FlattenedBlock\n            if (typeof _block === 'string') {\n              block = payload.blocks[_block]!\n            } else {\n              block = _block\n            }\n\n            matchedField = block.flattenedFields.find((field) => field.name === segment)!\n            if (matchedField) {\n              break\n            }\n          }\n        }\n      } else {\n        if (lastIncompletePath?.field && 'flattenedFields' in lastIncompletePath.field) {\n          fieldsToSearch = lastIncompletePath.field.flattenedFields\n        } else {\n          fieldsToSearch = lastIncompletePath.fields!\n        }\n        _parentIsLocalized = parentIsLocalized || lastIncompletePath.field?.localized\n\n        matchedField = fieldsToSearch.find((field) => field.name === segment)!\n      }\n\n      lastIncompletePath.field = matchedField!\n\n      if (currentPath === 'globalType' && globalSlug) {\n        lastIncompletePath.path = currentPath\n        lastIncompletePath.complete = true\n        lastIncompletePath.field = {\n          name: 'globalType',\n          type: 'text',\n        }\n\n        return paths\n      }\n\n      if (currentPath === 'relationTo') {\n        lastIncompletePath.path = currentPath\n        lastIncompletePath.complete = true\n        lastIncompletePath.field = {\n          name: 'relationTo',\n          type: 'select',\n          options: Object.keys(payload.collections),\n        }\n\n        return paths\n      }\n\n      if (!matchedField && currentPath === 'id' && i === pathSegments.length - 1) {\n        lastIncompletePath.path = currentPath\n        const idField: Field = {\n          name: 'id',\n          type: payload.db.defaultIDType as 'text',\n        }\n        lastIncompletePath.field = idField\n        lastIncompletePath.complete = true\n        return paths\n      }\n\n      if (matchedField) {\n        if ('hidden' in matchedField && matchedField.hidden && !overrideAccess) {\n          lastIncompletePath.invalid = true\n        }\n\n        const nextSegment = pathSegments[i + 1]!\n        const currentFieldIsLocalized = fieldShouldBeLocalized({\n          field: matchedField,\n          parentIsLocalized: _parentIsLocalized!,\n        })\n\n        const nextSegmentIsLocale =\n          localizationConfig &&\n          localizationConfig.localeCodes.includes(nextSegment) &&\n          currentFieldIsLocalized\n\n        if (nextSegmentIsLocale) {\n          // Skip the next iteration, because it's a locale\n          i += 1\n          currentPath = `${currentPath}.${nextSegment}`\n        } else if (localizationConfig && currentFieldIsLocalized) {\n          currentPath = `${currentPath}.${locale}`\n        }\n\n        switch (matchedField.type) {\n          case 'join':\n          case 'relationship':\n          case 'upload': {\n            // If this is a polymorphic relation,\n            // We only support querying directly (no nested querying)\n            if (matchedField.type !== 'join' && typeof matchedField.relationTo !== 'string') {\n              lastIncompletePath.path = pathSegments.join('.')\n              if (![matchedField.name, 'relationTo', 'value'].includes(pathSegments.at(-1)!)) {\n                lastIncompletePath.invalid = true\n              } else {\n                lastIncompletePath.complete = true\n              }\n            } else {\n              lastIncompletePath.complete = true\n              lastIncompletePath.path = currentPath!\n\n              const nestedPathToQuery = pathSegments\n                .slice(nextSegmentIsLocale ? i + 2 : i + 1)\n                .join('.')\n\n              if (nestedPathToQuery) {\n                let relatedCollection: SanitizedCollectionConfig\n                if (matchedField.type === 'join') {\n                  if (Array.isArray(matchedField.collection)) {\n                    throw new APIError('Not supported')\n                  }\n\n                  relatedCollection = payload.collections[matchedField.collection]!.config\n                } else {\n                  relatedCollection = payload.collections[matchedField.relationTo as string]!.config\n                }\n\n                const remainingPaths = getLocalizedPaths({\n                  collectionSlug: relatedCollection.slug,\n                  fields: relatedCollection.flattenedFields,\n                  globalSlug,\n                  incomingPath: nestedPathToQuery,\n                  locale,\n                  parentIsLocalized: false,\n                  payload,\n                })\n\n                paths = [...paths, ...remainingPaths]\n              }\n\n              return paths\n            }\n\n            break\n          }\n          case 'json':\n          case 'richText': {\n            const upcomingSegments = pathSegments.slice(i + 1).join('.')\n            pathSegments.forEach((path) => {\n              if (!/^\\w+(?:\\.\\w+)*$/.test(path)) {\n                lastIncompletePath.invalid = true\n              }\n            })\n            lastIncompletePath.complete = true\n            lastIncompletePath.path = upcomingSegments\n              ? `${currentPath}.${upcomingSegments}`\n              : currentPath!\n            return paths\n          }\n\n          default: {\n            if (i + 1 === pathSegments.length) {\n              lastIncompletePath.complete = true\n            }\n            lastIncompletePath.path = currentPath!\n          }\n        }\n      } else {\n        lastIncompletePath.invalid = true\n        lastIncompletePath.path = currentPath!\n        return paths\n      }\n    }\n  }\n\n  return paths\n}\n"],"names":["fieldShouldBeLocalized","APIError","getLocalizedPaths","collectionSlug","fields","globalSlug","incomingPath","locale","overrideAccess","parentIsLocalized","payload","pathSegments","split","localizationConfig","config","localization","paths","complete","field","undefined","invalid","path","i","length","segment","lastIncompletePath","find","currentPath","fieldsToSearch","_parentIsLocalized","matchedField","type","name","_block","blockReferences","blocks","block","flattenedFields","localized","options","Object","keys","collections","idField","db","defaultIDType","hidden","nextSegment","currentFieldIsLocalized","nextSegmentIsLocale","localeCodes","includes","relationTo","join","at","nestedPathToQuery","slice","relatedCollection","Array","isArray","collection","remainingPaths","slug","upcomingSegments","forEach","test"],"mappings":"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"}},
    {"offset": {"line": 587, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/database/queryValidation/validateSearchParams.ts"],"sourcesContent":["import type { SanitizedCollectionConfig } from '../../collections/config/types.js'\nimport type { FlattenedField } from '../../fields/config/types.js'\nimport type { SanitizedGlobalConfig } from '../../globals/config/types.js'\nimport type { PayloadRequest, WhereField } from '../../types/index.js'\nimport type { EntityPolicies, PathToQuery } from './types.js'\n\nimport { fieldAffectsData } from '../../fields/config/types.js'\nimport { getEntityPermissions } from '../../utilities/getEntityPermissions/getEntityPermissions.js'\nimport { isolateObjectProperty } from '../../utilities/isolateObjectProperty.js'\nimport { getLocalizedPaths } from '../getLocalizedPaths.js'\nimport { validateQueryPaths } from './validateQueryPaths.js'\n\ntype Args = {\n  collectionConfig?: SanitizedCollectionConfig\n  constraint: WhereField\n  errors: { path: string }[]\n  fields: FlattenedField[]\n  globalConfig?: SanitizedGlobalConfig\n  operator: string\n  overrideAccess: boolean\n  parentIsLocalized?: boolean\n  path: string\n  // TODO: Rename to permissions or entityPermissions in 4.0\n  policies: EntityPolicies\n  polymorphicJoin?: boolean\n  req: PayloadRequest\n  val: unknown\n  versionFields?: FlattenedField[]\n}\n\n/**\n * Validate the Payload key / value / operator\n */\nexport async function validateSearchParam({\n  collectionConfig,\n  constraint,\n  errors,\n  fields,\n  globalConfig,\n  operator,\n  overrideAccess,\n  parentIsLocalized,\n  path: incomingPath,\n  policies,\n  polymorphicJoin,\n  req,\n  val,\n  versionFields,\n}: Args): Promise<void> {\n  // Replace GraphQL nested field double underscore formatting\n  let sanitizedPath\n  if (incomingPath === '_id') {\n    sanitizedPath = 'id'\n  } else {\n    sanitizedPath = incomingPath.replace(/__/g, '.')\n  }\n  let paths: PathToQuery[] = []\n  const { slug } = (collectionConfig || globalConfig)!\n\n  const blockReferencesPermissions = {}\n\n  if (globalConfig && !policies.globals![slug]) {\n    policies.globals![slug] = await getEntityPermissions({\n      blockReferencesPermissions,\n      entity: globalConfig,\n      entityType: 'global',\n      fetchData: false,\n      operations: ['read'],\n      req,\n    })\n  }\n\n  if (sanitizedPath !== 'id') {\n    paths = getLocalizedPaths({\n      collectionSlug: collectionConfig?.slug,\n      fields,\n      globalSlug: globalConfig?.slug,\n      incomingPath: sanitizedPath,\n      locale: req.locale!,\n      overrideAccess,\n      parentIsLocalized,\n      payload: req.payload,\n    })\n  }\n  const promises: Promise<void>[] = []\n\n  // Sanitize relation.otherRelation.id to relation.otherRelation\n  if (paths.at(-1)?.path === 'id') {\n    const previousField = paths.at(-2)?.field\n    if (\n      previousField &&\n      (previousField.type === 'relationship' || previousField.type === 'upload') &&\n      typeof previousField.relationTo === 'string'\n    ) {\n      paths.pop()\n    }\n  }\n\n  promises.push(\n    ...paths.map(async ({ collectionSlug, field, invalid, path }, i) => {\n      if (invalid) {\n        if (!polymorphicJoin) {\n          errors.push({ path })\n        }\n\n        return\n      }\n\n      // where: { relatedPosts: { equals: 1}} -> { 'relatedPosts.id': { equals: 1}}\n      if (field.type === 'join' && path === incomingPath) {\n        constraint[`${path}.id` as keyof WhereField] = constraint[path as keyof WhereField]\n        delete constraint[path as keyof WhereField]\n      }\n\n      if ('virtual' in field && field.virtual) {\n        if (field.virtual === true) {\n          errors.push({ path })\n        }\n      }\n\n      if (polymorphicJoin && path === 'relationTo') {\n        return\n      }\n\n      if (!overrideAccess && fieldAffectsData(field)) {\n        if (collectionSlug) {\n          if (!policies.collections![collectionSlug]) {\n            policies.collections![collectionSlug] = await getEntityPermissions({\n              blockReferencesPermissions,\n              entity: req.payload.collections[collectionSlug]!.config,\n              entityType: 'collection',\n              fetchData: false,\n              operations: ['read'],\n              req: isolateObjectProperty(req, 'transactionID'),\n            })\n          }\n\n          if (\n            ['hash', 'salt'].includes(incomingPath) &&\n            collectionConfig!.auth &&\n            !collectionConfig!.auth?.disableLocalStrategy\n          ) {\n            errors.push({ path: incomingPath })\n          }\n        }\n        let fieldPath = path\n        // remove locale from end of path\n        if (path.endsWith(`.${req.locale}`)) {\n          fieldPath = path.slice(0, -(req.locale!.length + 1))\n        }\n        // remove \".value\" from ends of polymorphic relationship paths\n        if (\n          (field.type === 'relationship' || field.type === 'upload') &&\n          Array.isArray(field.relationTo)\n        ) {\n          fieldPath = fieldPath.replace('.value', '')\n        }\n\n        const entityType: 'collections' | 'globals' = globalConfig ? 'globals' : 'collections'\n        const entitySlug = collectionSlug || globalConfig!.slug\n        const segments = fieldPath.split('.')\n\n        let fieldAccess: any\n\n        if (versionFields) {\n          fieldAccess = policies[entityType]![entitySlug]!.fields\n\n          if (\n            segments[0] === 'parent' ||\n            segments[0] === 'version' ||\n            segments[0] === 'snapshot' ||\n            segments[0] === 'latest'\n          ) {\n            segments.shift()\n          }\n        } else {\n          fieldAccess = policies[entityType]![entitySlug]!.fields\n        }\n\n        if (segments.length) {\n          segments.forEach((segment) => {\n            if (fieldAccess[segment]) {\n              if ('fields' in fieldAccess[segment]) {\n                fieldAccess = fieldAccess[segment].fields\n              } else {\n                fieldAccess = fieldAccess[segment]\n              }\n            }\n          })\n\n          if (!fieldAccess?.read?.permission) {\n            errors.push({ path: fieldPath })\n          }\n        }\n      }\n\n      if (i > 1) {\n        // Remove top collection and reverse array\n        // to work backwards from top\n        const pathsToQuery = paths.slice(1).reverse()\n\n        pathsToQuery.forEach(\n          ({ collectionSlug: pathCollectionSlug, path: subPath }, pathToQueryIndex) => {\n            // On the \"deepest\" collection,\n            // validate query of the relationship\n            if (pathToQueryIndex === 0) {\n              promises.push(\n                validateQueryPaths({\n                  collectionConfig: req.payload.collections[pathCollectionSlug!]!.config,\n                  errors,\n                  globalConfig: undefined,\n                  overrideAccess,\n                  policies,\n                  req,\n                  where: {\n                    [subPath]: {\n                      [operator]: val,\n                    },\n                  },\n                }),\n              )\n            }\n          },\n        )\n      }\n    }),\n  )\n  await Promise.all(promises)\n}\n"],"names":["fieldAffectsData","getEntityPermissions","isolateObjectProperty","getLocalizedPaths","validateQueryPaths","validateSearchParam","collectionConfig","constraint","errors","fields","globalConfig","operator","overrideAccess","parentIsLocalized","path","incomingPath","policies","polymorphicJoin","req","val","versionFields","sanitizedPath","replace","paths","slug","blockReferencesPermissions","globals","entity","entityType","fetchData","operations","collectionSlug","globalSlug","locale","payload","promises","at","previousField","field","type","relationTo","pop","push","map","invalid","i","virtual","collections","config","includes","auth","disableLocalStrategy","fieldPath","endsWith","slice","length","Array","isArray","entitySlug","segments","split","fieldAccess","shift","forEach","segment","read","permission","pathsToQuery","reverse","pathCollectionSlug","subPath","pathToQueryIndex","undefined","where","Promise","all"],"mappings":";;;;AAMA,SAASA,gBAAgB,QAAQ,+BAA8B;AAC/D,SAASC,oBAAoB,QAAQ,+DAA8D;AACnG,SAASC,qBAAqB,QAAQ,2CAA0C;AAChF,SAASC,iBAAiB,QAAQ,0BAAyB;AAC3D,SAASC,kBAAkB,QAAQ,0BAAyB;;;;;;AAuBrD,eAAeC,oBAAoB,EACxCC,gBAAgB,EAChBC,UAAU,EACVC,MAAM,EACNC,MAAM,EACNC,YAAY,EACZC,QAAQ,EACRC,cAAc,EACdC,iBAAiB,EACjBC,MAAMC,YAAY,EAClBC,QAAQ,EACRC,eAAe,EACfC,GAAG,EACHC,GAAG,EACHC,aAAa,EACR;IACL,4DAA4D;IAC5D,IAAIC;IACJ,IAAIN,iBAAiB,OAAO;QAC1BM,gBAAgB;IAClB,OAAO;QACLA,gBAAgBN,aAAaO,OAAO,CAAC,OAAO;IAC9C;IACA,IAAIC,QAAuB,EAAE;IAC7B,MAAM,EAAEC,IAAI,EAAE,GAAIlB,oBAAoBI;IAEtC,MAAMe,6BAA6B,CAAC;IAEpC,IAAIf,gBAAgB,CAACM,SAASU,OAAQ,CAACF,KAAK,EAAE;QAC5CR,SAASU,OAAQ,CAACF,KAAK,GAAG,UAAMvB,sNAAAA,EAAqB;YACnDwB;YACAE,QAAQjB;YACRkB,YAAY;YACZC,WAAW;YACXC,YAAY;gBAAC;aAAO;YACpBZ;QACF;IACF;IAEA,IAAIG,kBAAkB,MAAM;QAC1BE,YAAQpB,uLAAAA,EAAkB;YACxB4B,gBAAgBzB,kBAAkBkB;YAClCf;YACAuB,YAAYtB,cAAcc;YAC1BT,cAAcM;YACdY,QAAQf,IAAIe,MAAM;YAClBrB;YACAC;YACAqB,SAAShB,IAAIgB,OAAO;QACtB;IACF;IACA,MAAMC,WAA4B,EAAE;IAEpC,+DAA+D;IAC/D,IAAIZ,MAAMa,EAAE,CAAC,CAAC,IAAItB,SAAS,MAAM;QAC/B,MAAMuB,gBAAgBd,MAAMa,EAAE,CAAC,CAAC,IAAIE;QACpC,IACED,iBACCA,CAAAA,cAAcE,IAAI,KAAK,kBAAkBF,cAAcE,IAAI,KAAK,QAAO,KACxE,OAAOF,cAAcG,UAAU,KAAK,UACpC;YACAjB,MAAMkB,GAAG;QACX;IACF;IAEAN,SAASO,IAAI,IACRnB,MAAMoB,GAAG,CAAC,OAAO,EAAEZ,cAAc,EAAEO,KAAK,EAAEM,OAAO,EAAE9B,IAAI,EAAE,EAAE+B;QAC5D,IAAID,SAAS;YACX,IAAI,CAAC3B,iBAAiB;gBACpBT,OAAOkC,IAAI,CAAC;oBAAE5B;gBAAK;YACrB;YAEA;QACF;QAEA,6EAA6E;QAC7E,IAAIwB,MAAMC,IAAI,KAAK,UAAUzB,SAASC,cAAc;YAClDR,UAAU,CAAC,GAAGO,KAAK,GAAG,CAAC,CAAqB,GAAGP,UAAU,CAACO,KAAyB;YACnF,OAAOP,UAAU,CAACO,KAAyB;QAC7C;QAEA,IAAI,aAAawB,SAASA,MAAMQ,OAAO,EAAE;YACvC,IAAIR,MAAMQ,OAAO,KAAK,MAAM;gBAC1BtC,OAAOkC,IAAI,CAAC;oBAAE5B;gBAAK;YACrB;QACF;QAEA,IAAIG,mBAAmBH,SAAS,cAAc;YAC5C;QACF;QAEA,IAAI,CAACF,sBAAkBZ,kLAAAA,EAAiBsC,QAAQ;YAC9C,IAAIP,gBAAgB;gBAClB,IAAI,CAACf,SAAS+B,WAAY,CAAChB,eAAe,EAAE;oBAC1Cf,SAAS+B,WAAY,CAAChB,eAAe,GAAG,UAAM9B,sNAAAA,EAAqB;wBACjEwB;wBACAE,QAAQT,IAAIgB,OAAO,CAACa,WAAW,CAAChB,eAAe,CAAEiB,MAAM;wBACvDpB,YAAY;wBACZC,WAAW;wBACXC,YAAY;4BAAC;yBAAO;wBACpBZ,SAAKhB,gMAAAA,EAAsBgB,KAAK;oBAClC;gBACF;gBAEA,IACE;oBAAC;oBAAQ;iBAAO,CAAC+B,QAAQ,CAAClC,iBAC1BT,iBAAkB4C,IAAI,IACtB,CAAC5C,iBAAkB4C,IAAI,EAAEC,sBACzB;oBACA3C,OAAOkC,IAAI,CAAC;wBAAE5B,MAAMC;oBAAa;gBACnC;YACF;YACA,IAAIqC,YAAYtC;YAChB,iCAAiC;YACjC,IAAIA,KAAKuC,QAAQ,CAAC,CAAC,CAAC,EAAEnC,IAAIe,MAAM,EAAE,GAAG;gBACnCmB,YAAYtC,KAAKwC,KAAK,CAAC,GAAG,CAAEpC,CAAAA,IAAIe,MAAM,CAAEsB,MAAM,GAAG,CAAA;YACnD;YACA,8DAA8D;YAC9D,IACGjB,CAAAA,MAAMC,IAAI,KAAK,kBAAkBD,MAAMC,IAAI,KAAK,QAAO,KACxDiB,MAAMC,OAAO,CAACnB,MAAME,UAAU,GAC9B;gBACAY,YAAYA,UAAU9B,OAAO,CAAC,UAAU;YAC1C;YAEA,MAAMM,aAAwClB,eAAe,YAAY;YACzE,MAAMgD,aAAa3B,kBAAkBrB,aAAcc,IAAI;YACvD,MAAMmC,WAAWP,UAAUQ,KAAK,CAAC;YAEjC,IAAIC;YAEJ,IAAIzC,eAAe;gBACjByC,cAAc7C,QAAQ,CAACY,WAAY,CAAC8B,WAAW,CAAEjD,MAAM;gBAEvD,IACEkD,QAAQ,CAAC,EAAE,KAAK,YAChBA,QAAQ,CAAC,EAAE,KAAK,aAChBA,QAAQ,CAAC,EAAE,KAAK,cAChBA,QAAQ,CAAC,EAAE,KAAK,UAChB;oBACAA,SAASG,KAAK;gBAChB;YACF,OAAO;gBACLD,cAAc7C,QAAQ,CAACY,WAAY,CAAC8B,WAAW,CAAEjD,MAAM;YACzD;YAEA,IAAIkD,SAASJ,MAAM,EAAE;gBACnBI,SAASI,OAAO,CAAC,CAACC;oBAChB,IAAIH,WAAW,CAACG,QAAQ,EAAE;wBACxB,IAAI,YAAYH,WAAW,CAACG,QAAQ,EAAE;4BACpCH,cAAcA,WAAW,CAACG,QAAQ,CAACvD,MAAM;wBAC3C,OAAO;4BACLoD,cAAcA,WAAW,CAACG,QAAQ;wBACpC;oBACF;gBACF;gBAEA,IAAI,CAACH,aAAaI,MAAMC,YAAY;oBAClC1D,OAAOkC,IAAI,CAAC;wBAAE5B,MAAMsC;oBAAU;gBAChC;YACF;QACF;QAEA,IAAIP,IAAI,GAAG;YACT,0CAA0C;YAC1C,6BAA6B;YAC7B,MAAMsB,eAAe5C,MAAM+B,KAAK,CAAC,GAAGc,OAAO;YAE3CD,aAAaJ,OAAO,CAClB,CAAC,EAAEhC,gBAAgBsC,kBAAkB,EAAEvD,MAAMwD,OAAO,EAAE,EAAEC;gBACtD,+BAA+B;gBAC/B,qCAAqC;gBACrC,IAAIA,qBAAqB,GAAG;oBAC1BpC,SAASO,IAAI,KACXtC,4MAAAA,EAAmB;wBACjBE,kBAAkBY,IAAIgB,OAAO,CAACa,WAAW,CAACsB,mBAAoB,CAAErB,MAAM;wBACtExC;wBACAE,cAAc8D;wBACd5D;wBACAI;wBACAE;wBACAuD,OAAO;4BACL,CAACH,QAAQ,EAAE;gCACT,CAAC3D,SAAS,EAAEQ;4BACd;wBACF;oBACF;gBAEJ;YACF;QAEJ;IACF;IAEF,MAAMuD,QAAQC,GAAG,CAACxC;AACpB"}},
    {"offset": {"line": 760, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/database/queryValidation/validateQueryPaths.ts"],"sourcesContent":["import type { SanitizedCollectionConfig } from '../../collections/config/types.js'\nimport type { FlattenedField } from '../../fields/config/types.js'\nimport type { SanitizedGlobalConfig } from '../../globals/config/types.js'\nimport type { Operator, PayloadRequest, Where, WhereField } from '../../types/index.js'\nimport type { EntityPolicies } from './types.js'\n\nimport { QueryError } from '../../errors/QueryError.js'\nimport { validOperatorSet } from '../../types/constants.js'\nimport { validateSearchParam } from './validateSearchParams.js'\n\ntype Args = {\n  errors?: { path: string }[]\n  overrideAccess: boolean\n  // TODO: Rename to permissions or entityPermissions in 4.0\n  policies?: EntityPolicies\n  polymorphicJoin?: boolean\n  req: PayloadRequest\n  versionFields?: FlattenedField[]\n  where: Where\n} & (\n  | {\n      collectionConfig: SanitizedCollectionConfig\n      globalConfig?: never | undefined\n    }\n  | {\n      collectionConfig?: never | undefined\n      globalConfig: SanitizedGlobalConfig\n    }\n)\n\nexport async function validateQueryPaths({\n  collectionConfig,\n  errors = [],\n  globalConfig,\n  overrideAccess,\n  policies = {\n    collections: {},\n    globals: {},\n  },\n  polymorphicJoin,\n  req,\n  versionFields,\n  where,\n}: Args): Promise<void> {\n  const fields = versionFields || (globalConfig || collectionConfig).flattenedFields\n\n  if (typeof where === 'object') {\n    // We need to determine if the whereKey is an AND, OR, or a schema path\n    const promises: Promise<void>[] = []\n    for (const path in where) {\n      const constraint = where[path]\n\n      if ((path === 'and' || path === 'or') && Array.isArray(constraint)) {\n        for (const item of constraint) {\n          if (collectionConfig) {\n            promises.push(\n              validateQueryPaths({\n                collectionConfig,\n                errors,\n                overrideAccess,\n                policies,\n                polymorphicJoin,\n                req,\n                versionFields,\n                where: item,\n              }),\n            )\n          } else {\n            promises.push(\n              validateQueryPaths({\n                errors,\n                globalConfig,\n                overrideAccess,\n                policies,\n                polymorphicJoin,\n                req,\n                versionFields,\n                where: item,\n              }),\n            )\n          }\n        }\n      } else if (!Array.isArray(constraint)) {\n        for (const operator in constraint) {\n          const val = constraint[operator as keyof typeof constraint]\n          if (validOperatorSet.has(operator as Operator)) {\n            promises.push(\n              validateSearchParam({\n                collectionConfig,\n                constraint: where as WhereField,\n                errors,\n                fields,\n                globalConfig,\n                operator,\n                overrideAccess,\n                path,\n                policies,\n                polymorphicJoin,\n                req,\n                val,\n                versionFields,\n              }),\n            )\n          }\n        }\n      }\n    }\n\n    await Promise.all(promises)\n    if (errors.length > 0) {\n      throw new QueryError(errors)\n    }\n  }\n}\n"],"names":["QueryError","validOperatorSet","validateSearchParam","validateQueryPaths","collectionConfig","errors","globalConfig","overrideAccess","policies","collections","globals","polymorphicJoin","req","versionFields","where","fields","flattenedFields","promises","path","constraint","Array","isArray","item","push","operator","val","has","Promise","all","length"],"mappings":";;;;AAMA,SAASA,UAAU,QAAQ,6BAA4B;AACvD,SAASC,gBAAgB,QAAQ,2BAA0B;AAC3D,SAASC,mBAAmB,QAAQ,4BAA2B;;;;AAsBxD,eAAeC,mBAAmB,EACvCC,gBAAgB,EAChBC,SAAS,EAAE,EACXC,YAAY,EACZC,cAAc,EACdC,WAAW;IACTC,aAAa,CAAC;IACdC,SAAS,CAAC;AACZ,CAAC,EACDC,eAAe,EACfC,GAAG,EACHC,aAAa,EACbC,KAAK,EACA;IACL,MAAMC,SAASF,iBAAkBP,CAAAA,gBAAgBF,gBAAe,EAAGY,eAAe;IAElF,IAAI,OAAOF,UAAU,UAAU;QAC7B,uEAAuE;QACvE,MAAMG,WAA4B,EAAE;QACpC,IAAK,MAAMC,QAAQJ,MAAO;YACxB,MAAMK,aAAaL,KAAK,CAACI,KAAK;YAE9B,IAAKA,CAAAA,SAAS,SAASA,SAAS,IAAG,KAAME,MAAMC,OAAO,CAACF,aAAa;gBAClE,KAAK,MAAMG,QAAQH,WAAY;oBAC7B,IAAIf,kBAAkB;wBACpBa,SAASM,IAAI,CACXpB,mBAAmB;4BACjBC;4BACAC;4BACAE;4BACAC;4BACAG;4BACAC;4BACAC;4BACAC,OAAOQ;wBACT;oBAEJ,OAAO;wBACLL,SAASM,IAAI,CACXpB,mBAAmB;4BACjBE;4BACAC;4BACAC;4BACAC;4BACAG;4BACAC;4BACAC;4BACAC,OAAOQ;wBACT;oBAEJ;gBACF;YACF,OAAO,IAAI,CAACF,MAAMC,OAAO,CAACF,aAAa;gBACrC,IAAK,MAAMK,YAAYL,WAAY;oBACjC,MAAMM,MAAMN,UAAU,CAACK,SAAoC;oBAC3D,IAAIvB,2KAAAA,CAAiByB,GAAG,CAACF,WAAuB;wBAC9CP,SAASM,IAAI,KACXrB,+MAAAA,EAAoB;4BAClBE;4BACAe,YAAYL;4BACZT;4BACAU;4BACAT;4BACAkB;4BACAjB;4BACAW;4BACAV;4BACAG;4BACAC;4BACAa;4BACAZ;wBACF;oBAEJ;gBACF;YACF;QACF;QAEA,MAAMc,QAAQC,GAAG,CAACX;QAClB,IAAIZ,OAAOwB,MAAM,GAAG,GAAG;YACrB,MAAM,IAAI7B,uKAAAA,CAAWK;QACvB;IACF;AACF"}},
    {"offset": {"line": 839, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/database/sanitizeWhereQuery.ts"],"sourcesContent":["import type { FlattenedField } from '../fields/config/types.js'\nimport type { Payload, Where } from '../types/index.js'\n\n/**\n * Currently used only for virtual fields linked with relationships\n */\nexport const sanitizeWhereQuery = ({\n  fields,\n  payload,\n  where,\n}: {\n  fields: FlattenedField[]\n  payload: Payload\n  where: Where\n}) => {\n  for (const key in where) {\n    const value = where[key]\n\n    if (['and', 'or'].includes(key.toLowerCase()) && Array.isArray(value)) {\n      for (const where of value) {\n        sanitizeWhereQuery({ fields, payload, where })\n      }\n      continue\n    }\n\n    const paths = key.split('.')\n    let pathHasChanged = false\n\n    let currentFields = fields\n\n    for (let i = 0; i < paths.length; i++) {\n      const path = paths[i]!\n      const field = currentFields.find((each) => each.name === path)\n\n      if (!field) {\n        break\n      }\n\n      if ('virtual' in field && field.virtual && typeof field.virtual === 'string') {\n        paths[i] = field.virtual\n        pathHasChanged = true\n      }\n\n      if ('flattenedFields' in field) {\n        currentFields = field.flattenedFields\n      }\n\n      if (\n        (field.type === 'relationship' || field.type === 'upload') &&\n        typeof field.relationTo === 'string'\n      ) {\n        const relatedCollection = payload.collections[field.relationTo]\n        if (relatedCollection) {\n          currentFields = relatedCollection.config.flattenedFields\n        }\n      }\n    }\n\n    if (pathHasChanged) {\n      where[paths.join('.')] = where[key]!\n      delete where[key]\n    }\n  }\n}\n"],"names":["sanitizeWhereQuery","fields","payload","where","key","value","includes","toLowerCase","Array","isArray","paths","split","pathHasChanged","currentFields","i","length","path","field","find","each","name","virtual","flattenedFields","type","relationTo","relatedCollection","collections","config","join"],"mappings":"AAGA;;CAEC,GACD;;;;AAAO,MAAMA,qBAAqB,CAAC,EACjCC,MAAM,EACNC,OAAO,EACPC,KAAK,EAKN;IACC,IAAK,MAAMC,OAAOD,MAAO;QACvB,MAAME,QAAQF,KAAK,CAACC,IAAI;QAExB,IAAI;YAAC;YAAO;SAAK,CAACE,QAAQ,CAACF,IAAIG,WAAW,OAAOC,MAAMC,OAAO,CAACJ,QAAQ;YACrE,KAAK,MAAMF,SAASE,MAAO;gBACzBL,mBAAmB;oBAAEC;oBAAQC;oBAASC;gBAAM;YAC9C;YACA;QACF;QAEA,MAAMO,QAAQN,IAAIO,KAAK,CAAC;QACxB,IAAIC,iBAAiB;QAErB,IAAIC,gBAAgBZ;QAEpB,IAAK,IAAIa,IAAI,GAAGA,IAAIJ,MAAMK,MAAM,EAAED,IAAK;YACrC,MAAME,OAAON,KAAK,CAACI,EAAE;YACrB,MAAMG,QAAQJ,cAAcK,IAAI,CAAC,CAACC,OAASA,KAAKC,IAAI,KAAKJ;YAEzD,IAAI,CAACC,OAAO;gBACV;YACF;YAEA,IAAI,aAAaA,SAASA,MAAMI,OAAO,IAAI,OAAOJ,MAAMI,OAAO,KAAK,UAAU;gBAC5EX,KAAK,CAACI,EAAE,GAAGG,MAAMI,OAAO;gBACxBT,iBAAiB;YACnB;YAEA,IAAI,qBAAqBK,OAAO;gBAC9BJ,gBAAgBI,MAAMK,eAAe;YACvC;YAEA,IACGL,CAAAA,MAAMM,IAAI,KAAK,kBAAkBN,MAAMM,IAAI,KAAK,QAAO,KACxD,OAAON,MAAMO,UAAU,KAAK,UAC5B;gBACA,MAAMC,oBAAoBvB,QAAQwB,WAAW,CAACT,MAAMO,UAAU,CAAC;gBAC/D,IAAIC,mBAAmB;oBACrBZ,gBAAgBY,kBAAkBE,MAAM,CAACL,eAAe;gBAC1D;YACF;QACF;QAEA,IAAIV,gBAAgB;YAClBT,KAAK,CAACO,MAAMkB,IAAI,CAAC,KAAK,GAAGzB,KAAK,CAACC,IAAI;YACnC,OAAOD,KAAK,CAACC,IAAI;QACnB;IACF;AACF,EAAC"}},
    {"offset": {"line": 894, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/database/sanitizeJoinQuery.ts"],"sourcesContent":["import type { SanitizedCollectionConfig, SanitizedJoin } from '../collections/config/types.js'\nimport type { JoinQuery, PayloadRequest } from '../types/index.js'\n\nimport { executeAccess } from '../auth/executeAccess.js'\nimport { QueryError } from '../errors/QueryError.js'\nimport { combineQueries } from './combineQueries.js'\nimport { validateQueryPaths } from './queryValidation/validateQueryPaths.js'\n\ntype Args = {\n  collectionConfig: SanitizedCollectionConfig\n  joins?: JoinQuery\n  overrideAccess: boolean\n  req: PayloadRequest\n}\n\nconst sanitizeJoinFieldQuery = async ({\n  collectionSlug,\n  errors,\n  join,\n  joinsQuery,\n  overrideAccess,\n  promises,\n  req,\n}: {\n  collectionSlug: string\n  errors: { path: string }[]\n  join: SanitizedJoin\n  joinsQuery: JoinQuery\n  overrideAccess: boolean\n  promises: Promise<void>[]\n  req: PayloadRequest\n}) => {\n  const { joinPath } = join\n\n  // TODO: fix any's in joinsQuery[joinPath]\n\n  if ((joinsQuery as any)[joinPath] === false) {\n    return\n  }\n\n  const joinCollectionConfig = req.payload.collections[collectionSlug]!.config\n\n  const accessResult = !overrideAccess\n    ? await executeAccess({ disableErrors: true, req }, joinCollectionConfig.access.read)\n    : true\n\n  if (accessResult === false) {\n    ;(joinsQuery as any)[joinPath] = false\n    return\n  }\n\n  if (!(joinsQuery as any)[joinPath]) {\n    ;(joinsQuery as any)[joinPath] = {}\n  }\n\n  const joinQuery = (joinsQuery as any)[joinPath]\n\n  if (!joinQuery.where) {\n    joinQuery.where = {}\n  }\n\n  if (join.field.where) {\n    joinQuery.where = combineQueries(joinQuery.where, join.field.where)\n  }\n\n  promises.push(\n    validateQueryPaths({\n      collectionConfig: joinCollectionConfig,\n      errors,\n      overrideAccess,\n      polymorphicJoin: Array.isArray(join.field.collection),\n      req,\n      // incoming where input, but we shouldn't validate generated from the access control.\n      where: joinQuery.where,\n    }),\n  )\n\n  if (typeof accessResult === 'object') {\n    joinQuery.where = combineQueries(joinQuery.where, accessResult)\n  }\n}\n\n/**\n * * Validates `where` for each join\n * * Combines the access result for joined collection\n * * Combines the default join's `where`\n */\nexport const sanitizeJoinQuery = async ({\n  collectionConfig,\n  joins: joinsQuery,\n  overrideAccess,\n  req,\n}: Args) => {\n  if (joinsQuery === false) {\n    return false\n  }\n\n  if (!joinsQuery) {\n    joinsQuery = {}\n  }\n\n  const errors: { path: string }[] = []\n  const promises: Promise<void>[] = []\n\n  for (const collectionSlug in collectionConfig.joins) {\n    for (const join of collectionConfig.joins[collectionSlug]!) {\n      await sanitizeJoinFieldQuery({\n        collectionSlug,\n        errors,\n        join,\n        joinsQuery,\n        overrideAccess,\n        promises,\n        req,\n      })\n    }\n  }\n\n  for (const join of collectionConfig.polymorphicJoins) {\n    for (const collectionSlug of join.field.collection) {\n      await sanitizeJoinFieldQuery({\n        collectionSlug,\n        errors,\n        join,\n        joinsQuery,\n        overrideAccess,\n        promises,\n        req,\n      })\n    }\n  }\n\n  await Promise.all(promises)\n\n  if (errors.length > 0) {\n    throw new QueryError(errors)\n  }\n\n  return joinsQuery\n}\n"],"names":["executeAccess","QueryError","combineQueries","validateQueryPaths","sanitizeJoinFieldQuery","collectionSlug","errors","join","joinsQuery","overrideAccess","promises","req","joinPath","joinCollectionConfig","payload","collections","config","accessResult","disableErrors","access","read","joinQuery","where","field","push","collectionConfig","polymorphicJoin","Array","isArray","collection","sanitizeJoinQuery","joins","polymorphicJoins","Promise","all","length"],"mappings":";;;;AAGA,SAASA,aAAa,QAAQ,2BAA0B;AACxD,SAASC,UAAU,QAAQ,0BAAyB;AACpD,SAASC,cAAc,QAAQ,sBAAqB;AACpD,SAASC,kBAAkB,QAAQ,0CAAyC;;;;;AAS5E,MAAMC,yBAAyB,OAAO,EACpCC,cAAc,EACdC,MAAM,EACNC,IAAI,EACJC,UAAU,EACVC,cAAc,EACdC,QAAQ,EACRC,GAAG,EASJ;IACC,MAAM,EAAEC,QAAQ,EAAE,GAAGL;IAErB,0CAA0C;IAE1C,IAAKC,UAAkB,CAACI,SAAS,KAAK,OAAO;QAC3C;IACF;IAEA,MAAMC,uBAAuBF,IAAIG,OAAO,CAACC,WAAW,CAACV,eAAe,CAAEW,MAAM;IAE5E,MAAMC,eAAe,CAACR,iBAClB,UAAMT,2KAAAA,EAAc;QAAEkB,eAAe;QAAMP;IAAI,GAAGE,qBAAqBM,MAAM,CAACC,IAAI,IAClF;IAEJ,IAAIH,iBAAiB,OAAO;;QACxBT,UAAkB,CAACI,SAAS,GAAG;QACjC;IACF;IAEA,IAAI,CAAEJ,UAAkB,CAACI,SAAS,EAAE;;QAChCJ,UAAkB,CAACI,SAAS,GAAG,CAAC;IACpC;IAEA,MAAMS,YAAab,UAAkB,CAACI,SAAS;IAE/C,IAAI,CAACS,UAAUC,KAAK,EAAE;QACpBD,UAAUC,KAAK,GAAG,CAAC;IACrB;IAEA,IAAIf,KAAKgB,KAAK,CAACD,KAAK,EAAE;QACpBD,UAAUC,KAAK,OAAGpB,iLAAAA,EAAemB,UAAUC,KAAK,EAAEf,KAAKgB,KAAK,CAACD,KAAK;IACpE;IAEAZ,SAASc,IAAI,KACXrB,4MAAAA,EAAmB;QACjBsB,kBAAkBZ;QAClBP;QACAG;QACAiB,iBAAiBC,MAAMC,OAAO,CAACrB,KAAKgB,KAAK,CAACM,UAAU;QACpDlB;QACA,qFAAqF;QACrFW,OAAOD,UAAUC,KAAK;IACxB;IAGF,IAAI,OAAOL,iBAAiB,UAAU;QACpCI,UAAUC,KAAK,OAAGpB,iLAAAA,EAAemB,UAAUC,KAAK,EAAEL;IACpD;AACF;AAOO,MAAMa,oBAAoB,OAAO,EACtCL,gBAAgB,EAChBM,OAAOvB,UAAU,EACjBC,cAAc,EACdE,GAAG,EACE;IACL,IAAIH,eAAe,OAAO;QACxB,OAAO;IACT;IAEA,IAAI,CAACA,YAAY;QACfA,aAAa,CAAC;IAChB;IAEA,MAAMF,SAA6B,EAAE;IACrC,MAAMI,WAA4B,EAAE;IAEpC,IAAK,MAAML,kBAAkBoB,iBAAiBM,KAAK,CAAE;QACnD,KAAK,MAAMxB,QAAQkB,iBAAiBM,KAAK,CAAC1B,eAAe,CAAG;YAC1D,MAAMD,uBAAuB;gBAC3BC;gBACAC;gBACAC;gBACAC;gBACAC;gBACAC;gBACAC;YACF;QACF;IACF;IAEA,KAAK,MAAMJ,QAAQkB,iBAAiBO,gBAAgB,CAAE;QACpD,KAAK,MAAM3B,kBAAkBE,KAAKgB,KAAK,CAACM,UAAU,CAAE;YAClD,MAAMzB,uBAAuB;gBAC3BC;gBACAC;gBACAC;gBACAC;gBACAC;gBACAC;gBACAC;YACF;QACF;IACF;IAEA,MAAMsB,QAAQC,GAAG,CAACxB;IAElB,IAAIJ,OAAO6B,MAAM,GAAG,GAAG;QACrB,MAAM,IAAIlC,uKAAAA,CAAWK;IACvB;IAEA,OAAOE;AACT,EAAC"}},
    {"offset": {"line": 991, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/types/constants.ts"],"sourcesContent":["export const validOperators = [\n  'equals',\n  'contains',\n  'not_equals',\n  'in',\n  'all',\n  'not_in',\n  'exists',\n  'greater_than',\n  'greater_than_equal',\n  'less_than',\n  'less_than_equal',\n  'like',\n  'not_like',\n  'within',\n  'intersects',\n  'near',\n] as const\n\nexport type Operator = (typeof validOperators)[number]\n\nexport const validOperatorSet = new Set<Operator>(validOperators)\n"],"names":["validOperators","validOperatorSet","Set"],"mappings":";;;;;;AAAO,MAAMA,iBAAiB;IAC5B;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;CACD,CAAS;AAIH,MAAMC,mBAAmB,IAAIC,IAAcF,gBAAe"}},
    {"offset": {"line": 1020, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/types/index.ts"],"sourcesContent":["import type { I18n, TFunction } from '@payloadcms/translations'\nimport type DataLoader from 'dataloader'\nimport type { OptionalKeys, RequiredKeys } from 'ts-essentials'\nimport type { URL } from 'url'\n\nimport type {\n  DataFromCollectionSlug,\n  QueryDraftDataFromCollectionSlug,\n  TypeWithID,\n  TypeWithTimestamps,\n} from '../collections/config/types.js'\nimport type payload from '../index.js'\nimport type {\n  CollectionSlug,\n  DataFromGlobalSlug,\n  GlobalSlug,\n  Payload,\n  RequestContext,\n  TypedCollectionJoins,\n  TypedCollectionSelect,\n  TypedFallbackLocale,\n  TypedLocale,\n  TypedUser,\n} from '../index.js'\nimport type { Operator } from './constants.js'\nexport type { Payload } from '../index.js'\n\nexport type CustomPayloadRequestProperties = {\n  context: RequestContext\n  /** The locale that should be used for a field when it is not translated to the requested locale */\n  fallbackLocale?: TypedFallbackLocale\n  i18n: I18n\n  /**\n   * The requested locale if specified\n   * Only available for localized collections\n   *\n   * Suppressing warning below as it is a valid use case - won't be an issue if generated types exist\n   */\n  // eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents\n  locale?: 'all' | TypedLocale\n  /**\n   * The payload object\n   */\n  payload: typeof payload\n  /**\n   * The context in which the request is being made\n   */\n  payloadAPI: 'GraphQL' | 'local' | 'REST'\n  /** Optimized document loader */\n  payloadDataLoader: {\n    /**\n     * Wraps `payload.find` with a cache to deduplicate requests\n     * @experimental This is may be replaced by a more robust cache strategy in future versions\n     * By calling this method with the same arguments many times in one request, it will only be handled one time\n     * const result = await req.payloadDataLoader.find({\n     *  collection,\n     *  req,\n     *  where: findWhere,\n     * })\n     */\n    find: Payload['find']\n  } & DataLoader<string, TypeWithID>\n  /** Resized versions of the image that was uploaded during this request */\n  payloadUploadSizes?: Record<string, Buffer>\n  /** Query params on the request */\n  query: Record<string, unknown>\n  /** Any response headers that are required to be set when a response is sent */\n  responseHeaders?: Headers\n  /** The route parameters\n   * @example\n   * /:collection/:id -> /posts/123\n   * { collection: 'posts', id: '123' }\n   */\n  routeParams?: Record<string, unknown>\n  /** Translate function - duplicate of i18n.t */\n  t: TFunction\n  /**\n   * Identifier for the database transaction for interactions in a single, all-or-nothing operation.\n   * Can also be used to ensure consistency when multiple operations try to create a transaction concurrently on the same request.\n   */\n  transactionID?: number | Promise<number | string> | string\n  /**\n   * Used to ensure consistency when multiple operations try to create a transaction concurrently on the same request\n   * @deprecated This is not used anywhere, instead `transactionID` is used for the above. Will be removed in next major version.\n   */\n  transactionIDPromise?: Promise<void>\n  /** The signed-in user */\n  user: null | TypedUser\n} & Pick<\n  URL,\n  'hash' | 'host' | 'href' | 'origin' | 'pathname' | 'port' | 'protocol' | 'search' | 'searchParams'\n>\ntype PayloadRequestData = {\n  /**\n   * Data from the request body\n   *\n   * Within Payload operations, i.e. hooks, data will be there\n   * BUT in custom endpoints it will not be, you will need to\n   * use either:\n   *  1. `const data = await req.json()`\n   *\n   *  2. import { addDataAndFileToRequest } from 'payload'\n   *    `await addDataAndFileToRequest(req)`\n   *\n   * You should not expect this object to be the document data. It is the request data.\n   * */\n  data?: JsonObject\n  /** The file on the request, same rules apply as the `data` property */\n  file?: {\n    /**\n     * Context of the file when it was uploaded via client side.\n     */\n    clientUploadContext?: unknown\n    data: Buffer\n    mimetype: string\n    name: string\n    size: number\n    tempFilePath?: string\n  }\n}\nexport interface PayloadRequest\n  extends CustomPayloadRequestProperties,\n    Partial<Request>,\n    PayloadRequestData {\n  headers: Request['headers']\n}\n\nexport type { Operator }\n\n// Makes it so things like passing new Date() will error\nexport type JsonValue = JsonArray | JsonObject | unknown //Date | JsonArray | JsonObject | boolean | null | number | string // TODO: Evaluate proper, strong type for this\n\nexport type JsonArray = Array<JsonValue>\n\nexport interface JsonObject {\n  [key: string]: any\n}\n\nexport type WhereField = {\n  // any json-serializable value\n  [key in Operator]?: JsonValue\n}\n\nexport type Where = {\n  [key: string]: Where[] | WhereField\n  // @ts-expect-error - vestiges of when tsconfig was not strict. Feel free to improve\n  and?: Where[]\n  // @ts-expect-error - vestiges of when tsconfig was not strict. Feel free to improve\n  or?: Where[]\n}\n\nexport type Sort = Array<string> | string\n\ntype SerializableValue = boolean | number | object | string\nexport type DefaultValue =\n  | ((args: {\n      locale?: TypedLocale\n      req: PayloadRequest\n      user: PayloadRequest['user']\n    }) => SerializableValue)\n  | SerializableValue\n\n/**\n * Applies pagination for join fields for including collection relationships\n */\nexport type JoinQuery<TSlug extends CollectionSlug = string> =\n  TypedCollectionJoins[TSlug] extends Record<string, string>\n    ?\n        | false\n        | Partial<{\n            [K in keyof TypedCollectionJoins[TSlug]]:\n              | {\n                  count?: boolean\n                  limit?: number\n                  page?: number\n                  sort?: string\n                  where?: Where\n                }\n              | false\n          }>\n    : never\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type Document = any\n\nexport type Operation = 'create' | 'delete' | 'read' | 'update'\nexport type VersionOperations = 'readVersions'\nexport type AuthOperations = 'unlock'\nexport type AllOperations = AuthOperations | Operation | VersionOperations\n\nexport function docHasTimestamps(doc: any): doc is TypeWithTimestamps {\n  return doc?.createdAt && doc?.updatedAt\n}\n\nexport type IfAny<T, Y, N> = 0 extends 1 & T ? Y : N // This is a commonly used trick to detect 'any'\nexport type IsAny<T> = IfAny<T, true, false>\nexport type ReplaceAny<T, DefaultType> = IsAny<T> extends true ? DefaultType : T\n\nexport type SelectIncludeType = {\n  [k: string]: SelectIncludeType | true\n}\n\nexport type SelectExcludeType = {\n  [k: string]: false | SelectExcludeType\n}\n\nexport type SelectMode = 'exclude' | 'include'\n\nexport type SelectType = SelectExcludeType | SelectIncludeType\n\nexport type ApplyDisableErrors<T, DisableErrors = false> = false extends DisableErrors\n  ? T\n  : null | T\n\nexport type TransformDataWithSelect<\n  Data extends Record<string, any>,\n  Select extends SelectType,\n> = Select extends never\n  ? Data\n  : string extends keyof Select\n    ? Data\n    : // START Handle types when they aren't generated\n      // For example in any package in this repository outside of tests / plugins\n      // This stil gives us autocomplete when using include select mode, i.e select: {title :true} returns type {title: any, id: string | number}\n      string extends keyof Omit<Data, 'id'>\n      ? Select extends SelectIncludeType\n        ? {\n            [K in Data extends TypeWithID ? 'id' | keyof Select : keyof Select]: K extends 'id'\n              ? number | string\n              : unknown\n          }\n        : Data\n      : // END Handle types when they aren't generated\n        // Handle include mode\n        Select extends SelectIncludeType\n        ? {\n            [K in keyof Data as K extends keyof Select\n              ? Select[K] extends object | true\n                ? K\n                : never\n              : // select 'id' always\n                K extends 'id'\n                ? K\n                : never]: Data[K]\n          }\n        : // Handle exclude mode\n          {\n            [K in keyof Data as K extends keyof Select\n              ? Select[K] extends object | undefined\n                ? K\n                : never\n              : K]: Data[K]\n          }\n\nexport type TransformCollectionWithSelect<\n  TSlug extends CollectionSlug,\n  TSelect extends SelectType,\n> = TSelect extends SelectType\n  ? TransformDataWithSelect<DataFromCollectionSlug<TSlug>, TSelect>\n  : DataFromCollectionSlug<TSlug>\n\nexport type DraftTransformCollectionWithSelect<\n  TSlug extends CollectionSlug,\n  TSelect extends SelectType,\n> = TSelect extends SelectType\n  ? TransformDataWithSelect<QueryDraftDataFromCollectionSlug<TSlug>, TSelect>\n  : QueryDraftDataFromCollectionSlug<TSlug>\n\nexport type TransformGlobalWithSelect<\n  TSlug extends GlobalSlug,\n  TSelect extends SelectType,\n> = TSelect extends SelectType\n  ? TransformDataWithSelect<DataFromGlobalSlug<TSlug>, TSelect>\n  : DataFromGlobalSlug<TSlug>\n\nexport type PopulateType = Partial<TypedCollectionSelect>\n\nexport type ResolvedFilterOptions = { [collection: string]: Where }\n\nexport type PickPreserveOptional<T, K extends keyof T> = Partial<\n  Pick<T, Extract<K, OptionalKeys<T>>>\n> &\n  Pick<T, Extract<K, RequiredKeys<T>>>\n\nexport type MaybePromise<T> = Promise<T> | T\n"],"names":["docHasTimestamps","doc","createdAt","updatedAt"],"mappings":";;;;AA8LO,SAASA,iBAAiBC,GAAQ;IACvC,OAAOA,KAAKC,aAAaD,KAAKE;AAChC"}},
    {"offset": {"line": 1031, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/uploads/getFileByPath.ts"],"sourcesContent":["import { fileTypeFromFile } from 'file-type'\nimport fs from 'fs/promises'\nimport path from 'path'\n\nimport type { PayloadRequest } from '../types/index.js'\n\nconst mimeTypeEstimate: Record<string, string> = {\n  svg: 'image/svg+xml',\n}\n\nexport const getFileByPath = async (filePath: string): Promise<PayloadRequest['file']> => {\n  if (typeof filePath !== 'string') {\n    return undefined\n  }\n\n  const name = path.basename(filePath)\n  const ext = path.extname(filePath).slice(1)\n\n  const [data, stat, type] = await Promise.all([\n    fs.readFile(filePath),\n    fs.stat(filePath),\n    fileTypeFromFile(filePath),\n  ])\n\n  return {\n    name,\n    data,\n    mimetype: type?.mime || mimeTypeEstimate[ext]!,\n    size: stat.size,\n  }\n}\n"],"names":["fileTypeFromFile","fs","path","mimeTypeEstimate","svg","getFileByPath","filePath","undefined","name","basename","ext","extname","slice","data","stat","type","Promise","all","readFile","mimetype","mime","size"],"mappings":";;;;AAAA,SAASA,gBAAgB,QAAQ,YAAW;AAC5C,OAAOC,QAAQ,cAAa;AAC5B,OAAOC,UAAU,OAAM;;;;AAIvB,MAAMC,mBAA2C;IAC/CC,KAAK;AACP;AAEO,MAAMC,gBAAgB,OAAOC;IAClC,IAAI,OAAOA,aAAa,UAAU;QAChC,OAAOC;IACT;IAEA,MAAMC,OAAON,4GAAAA,CAAKO,QAAQ,CAACH;IAC3B,MAAMI,MAAMR,4GAAAA,CAAKS,OAAO,CAACL,UAAUM,KAAK,CAAC;IAEzC,MAAM,CAACC,MAAMC,MAAMC,KAAK,GAAG,MAAMC,QAAQC,GAAG,CAAC;QAC3ChB,gIAAAA,CAAGiB,QAAQ,CAACZ;QACZL,gIAAAA,CAAGa,IAAI,CAACR;YACRN,2KAAAA,EAAiBM;KAClB;IAED,OAAO;QACLE;QACAK;QACAM,UAAUJ,MAAMK,QAAQjB,gBAAgB,CAACO,IAAI;QAC7CW,MAAMP,KAAKO,IAAI;IACjB;AACF,EAAC"}},
    {"offset": {"line": 1066, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/uploads/canResizeImage.ts"],"sourcesContent":["export function canResizeImage(mimeType: string): boolean {\n  return (\n    ['image/jpeg', 'image/png', 'image/gif', 'image/webp', 'image/tiff', 'image/avif'].indexOf(\n      mimeType,\n    ) > -1\n  )\n}\n"],"names":["canResizeImage","mimeType","indexOf"],"mappings":";;;;AAAO,SAASA,eAAeC,QAAgB;IAC7C,OACE;QAAC;QAAc;QAAa;QAAa;QAAc;QAAc;KAAa,CAACC,OAAO,CACxFD,YACE,CAAC;AAET"}},
    {"offset": {"line": 1084, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/uploads/detectSvgFromXml.ts"],"sourcesContent":["/**\n * Securely detect if an XML buffer contains a valid SVG document\n */\nexport function detectSvgFromXml(buffer: Buffer): boolean {\n  try {\n    // Limit buffer size to prevent processing large malicious files\n    const maxSize = 2048\n    const content = buffer.toString('utf8', 0, Math.min(buffer.length, maxSize))\n\n    // Check for XML declaration and extract encoding if present\n    const xmlDeclMatch = content.match(/^<\\?xml[^>]*encoding=[\"']([^\"']+)[\"']/i)\n    const declaredEncoding = xmlDeclMatch?.[1]?.toLowerCase()\n\n    // Only support safe encodings\n    if (declaredEncoding && !['ascii', 'utf-8', 'utf8'].includes(declaredEncoding)) {\n      return false\n    }\n\n    // Remove XML declarations, comments, and processing instructions\n    const cleanContent = content\n      .replace(/<\\?xml[^>]*\\?>/gi, '')\n      .replace(/<!--[\\s\\S]*?-->/g, '')\n      .replace(/<\\?[^>]*\\?>/g, '')\n      .trim()\n\n    // Find the first actual element (root element)\n    const rootElementMatch = cleanContent.match(/^<(\\w+)(?:\\s|>)/)\n    if (!rootElementMatch || rootElementMatch[1] !== 'svg') {\n      return false\n    }\n\n    // Validate SVG namespace - must be present for valid SVG\n    const svgNamespaceRegex = /xmlns=[\"']http:\\/\\/www\\.w3\\.org\\/2000\\/svg[\"']/\n    if (!svgNamespaceRegex.test(content)) {\n      return false\n    }\n\n    // Additional validation: ensure it's not malformed\n    const svgOpenTag = content.match(/<svg[\\s>]/)\n    if (!svgOpenTag) {\n      return false\n    }\n\n    return true\n  } catch (_error) {\n    // If any error occurs during parsing, treat as not SVG\n    return false\n  }\n}\n"],"names":["detectSvgFromXml","buffer","maxSize","content","toString","Math","min","length","xmlDeclMatch","match","declaredEncoding","toLowerCase","includes","cleanContent","replace","trim","rootElementMatch","svgNamespaceRegex","test","svgOpenTag","_error"],"mappings":"AAAA;;CAEC,GACD;;;;AAAO,SAASA,iBAAiBC,MAAc;IAC7C,IAAI;QACF,gEAAgE;QAChE,MAAMC,UAAU;QAChB,MAAMC,UAAUF,OAAOG,QAAQ,CAAC,QAAQ,GAAGC,KAAKC,GAAG,CAACL,OAAOM,MAAM,EAAEL;QAEnE,4DAA4D;QAC5D,MAAMM,eAAeL,QAAQM,KAAK,CAAC;QACnC,MAAMC,mBAAmBF,cAAc,CAAC,EAAE,EAAEG;QAE5C,8BAA8B;QAC9B,IAAID,oBAAoB,CAAC;YAAC;YAAS;YAAS;SAAO,CAACE,QAAQ,CAACF,mBAAmB;YAC9E,OAAO;QACT;QAEA,iEAAiE;QACjE,MAAMG,eAAeV,QAClBW,OAAO,CAAC,oBAAoB,IAC5BA,OAAO,CAAC,oBAAoB,IAC5BA,OAAO,CAAC,gBAAgB,IACxBC,IAAI;QAEP,+CAA+C;QAC/C,MAAMC,mBAAmBH,aAAaJ,KAAK,CAAC;QAC5C,IAAI,CAACO,oBAAoBA,gBAAgB,CAAC,EAAE,KAAK,OAAO;YACtD,OAAO;QACT;QAEA,yDAAyD;QACzD,MAAMC,oBAAoB;QAC1B,IAAI,CAACA,kBAAkBC,IAAI,CAACf,UAAU;YACpC,OAAO;QACT;QAEA,mDAAmD;QACnD,MAAMgB,aAAahB,QAAQM,KAAK,CAAC;QACjC,IAAI,CAACU,YAAY;YACf,OAAO;QACT;QAEA,OAAO;IACT,EAAE,OAAOC,QAAQ;QACf,uDAAuD;QACvD,OAAO;IACT;AACF"}},
    {"offset": {"line": 1133, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/uploads/getFileTypeFallback.ts"],"sourcesContent":["type ReturnType = {\n  ext: string\n  mime: string\n}\n\nconst extensionMap: {\n  [ext: string]: string\n} = {\n  css: 'text/css',\n  csv: 'text/csv',\n  htm: 'text/html',\n  html: 'text/html',\n  js: 'application/javascript',\n  json: 'application/json',\n  md: 'text/markdown',\n  svg: 'image/svg+xml',\n  xml: 'application/xml',\n  yml: 'application/x-yaml',\n}\n\nexport const getFileTypeFallback = (path: string): ReturnType => {\n  const ext = path.split('.').pop() || 'txt'\n\n  return {\n    ext,\n    mime: extensionMap[ext] || 'text/plain',\n  }\n}\n"],"names":["extensionMap","css","csv","htm","html","js","json","md","svg","xml","yml","getFileTypeFallback","path","ext","split","pop","mime"],"mappings":";;;;AAKA,MAAMA,eAEF;IACFC,KAAK;IACLC,KAAK;IACLC,KAAK;IACLC,MAAM;IACNC,IAAI;IACJC,MAAM;IACNC,IAAI;IACJC,KAAK;IACLC,KAAK;IACLC,KAAK;AACP;AAEO,MAAMC,sBAAsB,CAACC;IAClC,MAAMC,MAAMD,KAAKE,KAAK,CAAC,KAAKC,GAAG,MAAM;IAErC,OAAO;QACLF;QACAG,MAAMhB,YAAY,CAACa,IAAI,IAAI;IAC7B;AACF,EAAC"}},
    {"offset": {"line": 1160, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/uploads/validateSvg.ts"],"sourcesContent":["/**\n * Validate SVG content for security vulnerabilities\n * Detects and blocks malicious patterns commonly used in SVG-based attacks\n */\nexport function validateSvg(buffer: Buffer): boolean {\n  try {\n    const content = buffer.toString('utf8')\n\n    const dangerousPatterns = [\n      // Script tags\n      /<script[\\s>]/i,\n      /<\\/script>/i,\n\n      // Event handlers (onclick, onload, onerror, etc.)\n      /\\son\\w+\\s*=/i,\n\n      // JavaScript URLs\n      /javascript:/i,\n      /data:text\\/html/i,\n\n      // Foreign objects (can embed HTML)\n      /<foreignObject[\\s>]/i,\n\n      // Embedded iframes\n      /<iframe[\\s>]/i,\n\n      // Embedded objects and embeds\n      /<object[\\s>]/i,\n      /<embed[\\s>]/i,\n\n      // Base64 encoded scripts (common obfuscation technique)\n      /data:image\\/svg\\+xml;base64,[\\w+/]*PHNjcmlwdA/i, // <script in base64\n\n      // XLink href with javascript (deprecated but still dangerous)\n      /xlink:href\\s*=\\s*[\"']javascript:/i,\n\n      // Import statements\n      /@import/i,\n\n      // External resource references that could be dangerous\n      /<!ENTITY/i,\n      /<!DOCTYPE[^>]*\\[/i, // DOCTYPE with internal subset\n\n      // Attempt to use CDATA to hide scripts\n      /<!\\[CDATA\\[[\\s\\S]*<script/i,\n    ]\n\n    for (const pattern of dangerousPatterns) {\n      if (pattern.test(content)) {\n        return false\n      }\n    }\n\n    return true\n  } catch (_error) {\n    return false\n  }\n}\n"],"names":["validateSvg","buffer","content","toString","dangerousPatterns","pattern","test","_error"],"mappings":"AAAA;;;CAGC,GACD;;;;AAAO,SAASA,YAAYC,MAAc;IACxC,IAAI;QACF,MAAMC,UAAUD,OAAOE,QAAQ,CAAC;QAEhC,MAAMC,oBAAoB;YACxB,cAAc;YACd;YACA;YAEA,kDAAkD;YAClD;YAEA,kBAAkB;YAClB;YACA;YAEA,mCAAmC;YACnC;YAEA,mBAAmB;YACnB;YAEA,8BAA8B;YAC9B;YACA;YAEA,wDAAwD;YACxD;YAEA,8DAA8D;YAC9D;YAEA,oBAAoB;YACpB;YAEA,uDAAuD;YACvD;YACA;YAEA,uCAAuC;YACvC;SACD;QAED,KAAK,MAAMC,WAAWD,kBAAmB;YACvC,IAAIC,QAAQC,IAAI,CAACJ,UAAU;gBACzB,OAAO;YACT;QACF;QAEA,OAAO;IACT,EAAE,OAAOK,QAAQ;QACf,OAAO;IACT;AACF"}},
    {"offset": {"line": 1212, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/uploads/checkFileRestrictions.ts"],"sourcesContent":["import { fileTypeFromBuffer } from 'file-type'\n\nimport type { checkFileRestrictionsParams, FileAllowList } from './types.js'\n\nimport { ValidationError } from '../errors/index.js'\nimport { validateMimeType } from '../utilities/validateMimeType.js'\nimport { validatePDF } from '../utilities/validatePDF.js'\nimport { detectSvgFromXml } from './detectSvgFromXml.js'\nimport { getFileTypeFallback } from './getFileTypeFallback.js'\nimport { validateSvg } from './validateSvg.js'\n\n/**\n * Restricted file types and their extensions.\n */\nexport const RESTRICTED_FILE_EXT_AND_TYPES: FileAllowList = [\n  { extensions: ['exe', 'dll'], mimeType: 'application/x-msdownload' },\n  { extensions: ['exe', 'com', 'app', 'action'], mimeType: 'application/x-executable' },\n  { extensions: ['bat', 'cmd'], mimeType: 'application/x-msdos-program' },\n  { extensions: ['exe', 'com'], mimeType: 'application/x-ms-dos-executable' },\n  { extensions: ['dmg'], mimeType: 'application/x-apple-diskimage' },\n  { extensions: ['deb'], mimeType: 'application/x-debian-package' },\n  { extensions: ['rpm'], mimeType: 'application/x-redhat-package-manager' },\n  { extensions: ['exe', 'dll'], mimeType: 'application/vnd.microsoft.portable-executable' },\n  { extensions: ['msi'], mimeType: 'application/x-msi' },\n  { extensions: ['jar', 'ear', 'war'], mimeType: 'application/java-archive' },\n  { extensions: ['desktop'], mimeType: 'application/x-desktop' },\n  { extensions: ['cpl'], mimeType: 'application/x-cpl' },\n  { extensions: ['lnk'], mimeType: 'application/x-ms-shortcut' },\n  { extensions: ['pkg'], mimeType: 'application/x-apple-installer' },\n  { extensions: ['htm', 'html', 'shtml', 'xhtml'], mimeType: 'text/html' },\n  { extensions: ['php', 'phtml'], mimeType: 'application/x-httpd-php' },\n  { extensions: ['js', 'jse'], mimeType: 'text/javascript' },\n  { extensions: ['jsp'], mimeType: 'application/x-jsp' },\n  { extensions: ['py'], mimeType: 'text/x-python' },\n  { extensions: ['rb'], mimeType: 'text/x-ruby' },\n  { extensions: ['pl'], mimeType: 'text/x-perl' },\n  { extensions: ['ps1', 'psc1', 'psd1', 'psh', 'psm1'], mimeType: 'application/x-powershell' },\n  { extensions: ['vbe', 'vbs'], mimeType: 'application/x-vbscript' },\n  { extensions: ['ws', 'wsc', 'wsf', 'wsh'], mimeType: 'application/x-ms-wsh' },\n  { extensions: ['scr'], mimeType: 'application/x-msdownload' },\n  { extensions: ['asp', 'aspx'], mimeType: 'application/x-asp' },\n  { extensions: ['hta'], mimeType: 'application/x-hta' },\n  { extensions: ['reg'], mimeType: 'application/x-registry' },\n  { extensions: ['url'], mimeType: 'application/x-url' },\n  { extensions: ['workflow'], mimeType: 'application/x-workflow' },\n  { extensions: ['command'], mimeType: 'application/x-command' },\n]\n\nexport const checkFileRestrictions = async ({\n  collection,\n  file,\n  req,\n}: checkFileRestrictionsParams): Promise<void> => {\n  const errors: string[] = []\n  const { upload: uploadConfig } = collection\n  const useTempFiles = req?.payload?.config?.upload?.useTempFiles ?? false\n  const configMimeTypes =\n    uploadConfig &&\n    typeof uploadConfig === 'object' &&\n    'mimeTypes' in uploadConfig &&\n    Array.isArray(uploadConfig.mimeTypes)\n      ? uploadConfig.mimeTypes\n      : []\n\n  const allowRestrictedFileTypes =\n    uploadConfig && typeof uploadConfig === 'object' && 'allowRestrictedFileTypes' in uploadConfig\n      ? (uploadConfig as { allowRestrictedFileTypes?: boolean }).allowRestrictedFileTypes\n      : false\n\n  const expectsDetectableType = (mimeType: string): boolean => {\n    const textBasedTypes = ['/svg', 'image/svg+xml', 'image/x-xbitmap', 'image/x-xpixmap']\n\n    if (textBasedTypes.includes(mimeType)) {\n      return false\n    }\n\n    return (\n      mimeType.startsWith('image/') ||\n      mimeType.startsWith('video/') ||\n      mimeType.startsWith('audio/') ||\n      mimeType === 'application/pdf'\n    )\n  }\n\n  // Skip validation if `allowRestrictedFileTypes` is true\n  if (allowRestrictedFileTypes) {\n    return\n  }\n\n  // Secondary mimetype check to assess file type from buffer\n  if (configMimeTypes.length > 0) {\n    let detected = await fileTypeFromBuffer(file.data)\n    const typeFromExtension = file.name.split('.').pop() || ''\n\n    // Handle SVG files that are detected as XML due to <?xml declarations\n    if (\n      detected?.mime === 'application/xml' &&\n      configMimeTypes.some(\n        (type) => type.includes('image/') && (type.includes('svg') || type === 'image/*'),\n      )\n    ) {\n      const isSvg = detectSvgFromXml(file.data)\n      if (isSvg) {\n        detected = { ext: 'svg' as any, mime: 'image/svg+xml' as any }\n      }\n    }\n\n    if (!detected && !useTempFiles) {\n      const mimeTypeFromExtension = getFileTypeFallback(file.name).mime\n      const extIsValid = validateMimeType(mimeTypeFromExtension, configMimeTypes)\n\n      if (!extIsValid) {\n        errors.push(\n          `File type ${mimeTypeFromExtension} (from extension ${typeFromExtension}) is not allowed.`,\n        )\n      } else {\n        // SVG security check (text-based files not detectable by buffer)\n        if (typeFromExtension.toLowerCase() === 'svg') {\n          const isSafeSvg = validateSvg(file.data)\n          if (!isSafeSvg) {\n            errors.push('SVG file contains potentially harmful content.')\n          }\n        }\n\n        // PDF validation\n        if (mimeTypeFromExtension === 'application/pdf') {\n          const isValidPDF = validatePDF(file.data)\n          if (!isValidPDF) {\n            errors.push('Invalid or corrupted PDF file.')\n          }\n        }\n      }\n\n      if (expectsDetectableType(mimeTypeFromExtension)) {\n        req.payload.logger.warn(\n          `File buffer returned no detectable MIME type for ${file.name}. Falling back to extension-based validation.`,\n        )\n      }\n    }\n\n    const passesMimeTypeCheck = detected?.mime && validateMimeType(detected.mime, configMimeTypes)\n\n    if (passesMimeTypeCheck && detected?.mime === 'application/pdf') {\n      const isValidPDF = validatePDF(file?.data)\n      if (!isValidPDF) {\n        errors.push('Invalid PDF file.')\n      }\n    }\n\n    if (detected && !passesMimeTypeCheck) {\n      errors.push(`Invalid MIME type: ${detected.mime}.`)\n    }\n  } else {\n    const isRestricted = RESTRICTED_FILE_EXT_AND_TYPES.some((type) => {\n      const hasRestrictedExt = type.extensions.some((ext) => file.name.toLowerCase().endsWith(ext))\n      const hasRestrictedMime = type.mimeType === file.mimetype\n      return hasRestrictedExt || hasRestrictedMime\n    })\n    if (isRestricted) {\n      errors.push(\n        `File type '${file.mimetype}' not allowed ${file.name}: Restricted file type detected -- set 'allowRestrictedFileTypes' to true to skip this check for this Collection.`,\n      )\n    }\n  }\n\n  if (errors.length > 0) {\n    req.payload.logger.error(errors.join(', '))\n    throw new ValidationError({\n      errors: [{ message: errors.join(', '), path: 'file' }],\n    })\n  }\n}\n"],"names":["fileTypeFromBuffer","ValidationError","validateMimeType","validatePDF","detectSvgFromXml","getFileTypeFallback","validateSvg","RESTRICTED_FILE_EXT_AND_TYPES","extensions","mimeType","checkFileRestrictions","collection","file","req","errors","upload","uploadConfig","useTempFiles","payload","config","configMimeTypes","Array","isArray","mimeTypes","allowRestrictedFileTypes","expectsDetectableType","textBasedTypes","includes","startsWith","length","detected","data","typeFromExtension","name","split","pop","mime","some","type","isSvg","ext","mimeTypeFromExtension","extIsValid","push","toLowerCase","isSafeSvg","isValidPDF","logger","warn","passesMimeTypeCheck","isRestricted","hasRestrictedExt","endsWith","hasRestrictedMime","mimetype","error","join","message","path"],"mappings":"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"}},
    {"offset": {"line": 1540, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/uploads/optionallyAppendMetadata.ts"],"sourcesContent":["import type { Sharp, Metadata as SharpMetadata } from 'sharp'\n\nimport type { PayloadRequest } from '../types/index.js'\n\nexport type WithMetadata =\n  | ((options: { metadata: SharpMetadata; req: PayloadRequest }) => Promise<boolean>)\n  | boolean\n\nexport async function optionallyAppendMetadata({\n  req,\n  sharpFile,\n  withMetadata,\n}: {\n  req: PayloadRequest\n  sharpFile: Sharp\n  withMetadata: WithMetadata\n}): Promise<Sharp> {\n  const metadata = await sharpFile.metadata()\n\n  if (withMetadata === true) {\n    return sharpFile.withMetadata()\n  } else if (typeof withMetadata === 'function') {\n    const useMetadata = await withMetadata({ metadata, req })\n\n    if (useMetadata) {\n      return sharpFile.withMetadata()\n    }\n  }\n\n  return sharpFile\n}\n"],"names":["optionallyAppendMetadata","req","sharpFile","withMetadata","metadata","useMetadata"],"mappings":";;;;AAQO,eAAeA,yBAAyB,EAC7CC,GAAG,EACHC,SAAS,EACTC,YAAY,EAKb;IACC,MAAMC,WAAW,MAAMF,UAAUE,QAAQ;IAEzC,IAAID,iBAAiB,MAAM;QACzB,OAAOD,UAAUC,YAAY;IAC/B,OAAO,IAAI,OAAOA,iBAAiB,YAAY;QAC7C,MAAME,cAAc,MAAMF,aAAa;YAAEC;YAAUH;QAAI;QAEvD,IAAII,aAAa;YACf,OAAOH,UAAUC,YAAY;QAC/B;IACF;IAEA,OAAOD;AACT"}},
    {"offset": {"line": 1563, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/uploads/cropImage.ts"],"sourcesContent":["import type { SharpOptions } from 'sharp'\n\nimport type { SanitizedConfig } from '../config/types.js'\nimport type { PayloadRequest } from '../types/index.js'\nimport type { WithMetadata } from './optionallyAppendMetadata.js'\nimport type { UploadEdits } from './types.js'\n\nimport { optionallyAppendMetadata } from './optionallyAppendMetadata.js'\n\nconst percentToPixel = (value: number, dimension: number) => {\n  return Math.floor((value / 100) * dimension)\n}\n\ntype CropImageArgs = {\n  cropData: UploadEdits['crop']\n  dimensions: { height: number; width: number }\n  file: PayloadRequest['file']\n  heightInPixels: number\n  req?: PayloadRequest\n  sharp: SanitizedConfig['sharp']\n  widthInPixels: number\n  withMetadata?: WithMetadata\n}\nexport async function cropImage({\n  cropData,\n  dimensions,\n  file: fileArg,\n  heightInPixels,\n  req,\n  sharp,\n  widthInPixels,\n  withMetadata,\n}: CropImageArgs) {\n  try {\n    const { x, y } = cropData!\n    const file = fileArg!\n\n    const fileIsAnimatedType = ['image/avif', 'image/gif', 'image/webp'].includes(file.mimetype)\n\n    const sharpOptions: SharpOptions = {}\n\n    if (fileIsAnimatedType) {\n      sharpOptions.animated = true\n    }\n\n    const { height: originalHeight, width: originalWidth } = dimensions\n    const newWidth = Number(widthInPixels)\n    const newHeight = Number(heightInPixels)\n\n    const dimensionsChanged = originalWidth !== newWidth || originalHeight !== newHeight\n\n    if (!dimensionsChanged) {\n      let adjustedHeight = originalHeight\n\n      if (fileIsAnimatedType) {\n        const animatedMetadata = await sharp(\n          file.tempFilePath || file.data,\n          sharpOptions,\n        ).metadata()\n        adjustedHeight = animatedMetadata.pages ? animatedMetadata.height! : originalHeight\n      }\n\n      return {\n        data: file.data,\n        info: {\n          height: adjustedHeight,\n          size: file.size,\n          width: originalWidth,\n        },\n      }\n    }\n\n    const formattedCropData = {\n      height: Number(heightInPixels),\n      left: percentToPixel(x, dimensions.width),\n      top: percentToPixel(y, dimensions.height),\n      width: Number(widthInPixels),\n    }\n\n    let cropped = sharp(file.tempFilePath || file.data, sharpOptions).extract(formattedCropData)\n\n    cropped = await optionallyAppendMetadata({\n      req: req!,\n      sharpFile: cropped,\n      withMetadata: withMetadata!,\n    })\n\n    return await cropped.toBuffer({\n      resolveWithObject: true,\n    })\n  } catch (error) {\n    console.error(`Error cropping image:`, error)\n    throw error\n  }\n}\n"],"names":["optionallyAppendMetadata","percentToPixel","value","dimension","Math","floor","cropImage","cropData","dimensions","file","fileArg","heightInPixels","req","sharp","widthInPixels","withMetadata","x","y","fileIsAnimatedType","includes","mimetype","sharpOptions","animated","height","originalHeight","width","originalWidth","newWidth","Number","newHeight","dimensionsChanged","adjustedHeight","animatedMetadata","tempFilePath","data","metadata","pages","info","size","formattedCropData","left","top","cropped","extract","sharpFile","toBuffer","resolveWithObject","error","console"],"mappings":";;;;AAOA,SAASA,wBAAwB,QAAQ,gCAA+B;;AAExE,MAAMC,iBAAiB,CAACC,OAAeC;IACrC,OAAOC,KAAKC,KAAK,CAAEH,QAAQ,MAAOC;AACpC;AAYO,eAAeG,UAAU,EAC9BC,QAAQ,EACRC,UAAU,EACVC,MAAMC,OAAO,EACbC,cAAc,EACdC,GAAG,EACHC,KAAK,EACLC,aAAa,EACbC,YAAY,EACE;IACd,IAAI;QACF,MAAM,EAAEC,CAAC,EAAEC,CAAC,EAAE,GAAGV;QACjB,MAAME,OAAOC;QAEb,MAAMQ,qBAAqB;YAAC;YAAc;YAAa;SAAa,CAACC,QAAQ,CAACV,KAAKW,QAAQ;QAE3F,MAAMC,eAA6B,CAAC;QAEpC,IAAIH,oBAAoB;YACtBG,aAAaC,QAAQ,GAAG;QAC1B;QAEA,MAAM,EAAEC,QAAQC,cAAc,EAAEC,OAAOC,aAAa,EAAE,GAAGlB;QACzD,MAAMmB,WAAWC,OAAOd;QACxB,MAAMe,YAAYD,OAAOjB;QAEzB,MAAMmB,oBAAoBJ,kBAAkBC,YAAYH,mBAAmBK;QAE3E,IAAI,CAACC,mBAAmB;YACtB,IAAIC,iBAAiBP;YAErB,IAAIN,oBAAoB;gBACtB,MAAMc,mBAAmB,MAAMnB,MAC7BJ,KAAKwB,YAAY,IAAIxB,KAAKyB,IAAI,EAC9Bb,cACAc,QAAQ;gBACVJ,iBAAiBC,iBAAiBI,KAAK,GAAGJ,iBAAiBT,MAAM,GAAIC;YACvE;YAEA,OAAO;gBACLU,MAAMzB,KAAKyB,IAAI;gBACfG,MAAM;oBACJd,QAAQQ;oBACRO,MAAM7B,KAAK6B,IAAI;oBACfb,OAAOC;gBACT;YACF;QACF;QAEA,MAAMa,oBAAoB;YACxBhB,QAAQK,OAAOjB;YACf6B,MAAMvC,eAAee,GAAGR,WAAWiB,KAAK;YACxCgB,KAAKxC,eAAegB,GAAGT,WAAWe,MAAM;YACxCE,OAAOG,OAAOd;QAChB;QAEA,IAAI4B,UAAU7B,MAAMJ,KAAKwB,YAAY,IAAIxB,KAAKyB,IAAI,EAAEb,cAAcsB,OAAO,CAACJ;QAE1EG,UAAU,UAAM1C,oMAAAA,EAAyB;YACvCY,KAAKA;YACLgC,WAAWF;YACX3B,cAAcA;QAChB;QAEA,OAAO,MAAM2B,QAAQG,QAAQ,CAAC;YAC5BC,mBAAmB;QACrB;IACF,EAAE,OAAOC,OAAO;QACdC,QAAQD,KAAK,CAAC,CAAC,qBAAqB,CAAC,EAAEA;QACvC,MAAMA;IACR;AACF"}},
    {"offset": {"line": 1628, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/uploads/safeFetch.ts"],"sourcesContent":["import type { LookupFunction } from 'net'\n\nimport { lookup } from 'dns'\nimport ipaddr from 'ipaddr.js'\nimport { Agent, fetch as undiciFetch } from 'undici'\n\n/**\n * @internal this is used to mock the IP `lookup` function in integration tests\n */\nexport const _internal_safeFetchGlobal = {\n  lookup,\n}\n\nconst isSafeIp = (ip: string) => {\n  try {\n    if (!ip) {\n      return false\n    }\n\n    if (!ipaddr.isValid(ip)) {\n      return false\n    }\n\n    const parsedIpAddress = ipaddr.parse(ip)\n    const range = parsedIpAddress.range()\n    if (range !== 'unicast') {\n      return false // Private IP Range\n    }\n  } catch (ignore) {\n    return false\n  }\n  return true\n}\n\nconst ssrfFilterInterceptor: LookupFunction = (hostname, options, callback) => {\n  _internal_safeFetchGlobal.lookup(hostname, options, (err, address, family) => {\n    if (err) {\n      callback(err, address, family)\n    } else {\n      let ips = [] as string[]\n      if (Array.isArray(address)) {\n        ips = address.map((a) => a.address)\n      } else {\n        ips = [address]\n      }\n\n      if (ips.some((ip) => !isSafeIp(ip))) {\n        callback(new Error(`Blocked unsafe attempt to ${hostname}`), address, family)\n        return\n      }\n\n      callback(null, address, family)\n    }\n  })\n}\n\nconst safeDispatcher = new Agent({\n  connect: { lookup: ssrfFilterInterceptor },\n})\n/**\n * A \"safe\" version of undici's fetch that prevents SSRF attacks.\n *\n * - Utilizes a custom dispatcher that filters out requests to unsafe IP addresses.\n * - Validates domain names by resolving them to IP addresses and checking if they're safe.\n * - Undici was used because it supported interceptors as well as \"credentials: include\". Native fetch\n */\nexport const safeFetch = async (...args: Parameters<typeof undiciFetch>) => {\n  const [unverifiedUrl, options] = args\n\n  try {\n    const url = new URL(unverifiedUrl)\n\n    let hostname = url.hostname\n\n    // Strip brackets from IPv6 addresses (e.g., \"[::1]\" => \"::1\")\n    if (hostname.startsWith('[') && hostname.endsWith(']')) {\n      hostname = hostname.slice(1, -1)\n    }\n\n    if (ipaddr.isValid(hostname)) {\n      if (!isSafeIp(hostname)) {\n        throw new Error(`Blocked unsafe attempt to ${hostname}`)\n      }\n    }\n    return await undiciFetch(url, {\n      ...options,\n      dispatcher: safeDispatcher,\n    })\n  } catch (error) {\n    if (error instanceof Error) {\n      if (error.cause instanceof Error && error.cause.message.includes('unsafe')) {\n        // Errors thrown from within interceptors always have 'fetch error' as the message\n        // The desired message we want to bubble up is in the cause\n        throw new Error(error.cause.message)\n      } else {\n        let stringifiedUrl: string | undefined = undefined\n        if (typeof unverifiedUrl === 'string') {\n          stringifiedUrl = unverifiedUrl\n        } else if (unverifiedUrl instanceof URL) {\n          stringifiedUrl = unverifiedUrl.toString()\n        } else if (unverifiedUrl instanceof Request) {\n          stringifiedUrl = unverifiedUrl.url\n        }\n\n        throw new Error(`Failed to fetch from ${stringifiedUrl}, ${error.message}`)\n      }\n    }\n    throw error\n  }\n}\n"],"names":["lookup","ipaddr","Agent","fetch","undiciFetch","_internal_safeFetchGlobal","isSafeIp","ip","isValid","parsedIpAddress","parse","range","ignore","ssrfFilterInterceptor","hostname","options","callback","err","address","family","ips","Array","isArray","map","a","some","Error","safeDispatcher","connect","safeFetch","args","unverifiedUrl","url","URL","startsWith","endsWith","slice","dispatcher","error","cause","message","includes","stringifiedUrl","undefined","toString","Request"],"mappings":";;;;;;AAEA,SAASA,MAAM,QAAQ,MAAK;AAC5B,OAAOC,YAAY,YAAW;AAC9B,SAASC,KAAK,EAAEC,SAASC,WAAW,QAAQ,SAAQ;;;;AAK7C,MAAMC,4BAA4B;YACvCL,yGAAAA;AACF,EAAC;AAED,MAAMM,WAAW,CAACC;IAChB,IAAI;QACF,IAAI,CAACA,IAAI;YACP,OAAO;QACT;QAEA,IAAI,CAACN,qLAAAA,CAAOO,OAAO,CAACD,KAAK;YACvB,OAAO;QACT;QAEA,MAAME,kBAAkBR,qLAAAA,CAAOS,KAAK,CAACH;QACrC,MAAMI,QAAQF,gBAAgBE,KAAK;QACnC,IAAIA,UAAU,WAAW;YACvB,OAAO,MAAM,mBAAmB;;QAClC;IACF,EAAE,OAAOC,QAAQ;QACf,OAAO;IACT;IACA,OAAO;AACT;AAEA,MAAMC,wBAAwC,CAACC,UAAUC,SAASC;IAChEX,0BAA0BL,MAAM,CAACc,UAAUC,SAAS,CAACE,KAAKC,SAASC;QACjE,IAAIF,KAAK;YACPD,SAASC,KAAKC,SAASC;QACzB,OAAO;YACL,IAAIC,MAAM,EAAE;YACZ,IAAIC,MAAMC,OAAO,CAACJ,UAAU;gBAC1BE,MAAMF,QAAQK,GAAG,CAAC,CAACC,IAAMA,EAAEN,OAAO;YACpC,OAAO;gBACLE,MAAM;oBAACF;iBAAQ;YACjB;YAEA,IAAIE,IAAIK,IAAI,CAAC,CAAClB,KAAO,CAACD,SAASC,MAAM;gBACnCS,SAAS,IAAIU,MAAM,CAAC,0BAA0B,EAAEZ,UAAU,GAAGI,SAASC;gBACtE;YACF;YAEAH,SAAS,MAAME,SAASC;QAC1B;IACF;AACF;AAEA,MAAMQ,iBAAiB,IAAIzB,0IAAAA,CAAM;IAC/B0B,SAAS;QAAE5B,QAAQa;IAAsB;AAC3C;AAQO,MAAMgB,YAAY,OAAO,GAAGC;IACjC,MAAM,CAACC,eAAehB,QAAQ,GAAGe;IAEjC,IAAI;QACF,MAAME,MAAM,IAAIC,IAAIF;QAEpB,IAAIjB,WAAWkB,IAAIlB,QAAQ;QAE3B,8DAA8D;QAC9D,IAAIA,SAASoB,UAAU,CAAC,QAAQpB,SAASqB,QAAQ,CAAC,MAAM;YACtDrB,WAAWA,SAASsB,KAAK,CAAC,GAAG,CAAC;QAChC;QAEA,IAAInC,qLAAAA,CAAOO,OAAO,CAACM,WAAW;YAC5B,IAAI,CAACR,SAASQ,WAAW;gBACvB,MAAM,IAAIY,MAAM,CAAC,0BAA0B,EAAEZ,UAAU;YACzD;QACF;QACA,OAAO,UAAMV,0IAAAA,EAAY4B,KAAK;YAC5B,GAAGjB,OAAO;YACVsB,YAAYV;QACd;IACF,EAAE,OAAOW,OAAO;QACd,IAAIA,iBAAiBZ,OAAO;YAC1B,IAAIY,MAAMC,KAAK,YAAYb,SAASY,MAAMC,KAAK,CAACC,OAAO,CAACC,QAAQ,CAAC,WAAW;gBAC1E,kFAAkF;gBAClF,2DAA2D;gBAC3D,MAAM,IAAIf,MAAMY,MAAMC,KAAK,CAACC,OAAO;YACrC,OAAO;gBACL,IAAIE,iBAAqCC;gBACzC,IAAI,OAAOZ,kBAAkB,UAAU;oBACrCW,iBAAiBX;gBACnB,OAAO,IAAIA,yBAAyBE,KAAK;oBACvCS,iBAAiBX,cAAca,QAAQ;gBACzC,OAAO,IAAIb,yBAAyBc,SAAS;oBAC3CH,iBAAiBX,cAAcC,GAAG;gBACpC;gBAEA,MAAM,IAAIN,MAAM,CAAC,qBAAqB,EAAEgB,eAAe,EAAE,EAAEJ,MAAME,OAAO,EAAE;YAC5E;QACF;QACA,MAAMF;IACR;AACF,EAAC"}},
    {"offset": {"line": 1731, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/uploads/getExternalFile.ts"],"sourcesContent":["import type { PayloadRequest } from '../types/index.js'\nimport type { File, FileData, UploadConfig } from './types.js'\n\nimport { APIError } from '../errors/index.js'\nimport { isURLAllowed } from '../utilities/isURLAllowed.js'\nimport { safeFetch } from './safeFetch.js'\n\ntype Args = {\n  data: FileData\n  req: PayloadRequest\n  uploadConfig: UploadConfig\n}\nexport const getExternalFile = async ({ data, req, uploadConfig }: Args): Promise<File> => {\n  const { filename, url } = data\n\n  let trimAuthCookies = true\n  if (typeof url === 'string') {\n    let fileURL = url\n    if (!url.startsWith('http')) {\n      // URL points to the same server - we can send any cookies safely to our server.\n      trimAuthCookies = false\n      const baseUrl = req.headers.get('origin') || `${req.protocol}://${req.headers.get('host')}`\n      fileURL = `${baseUrl}${url}`\n    }\n\n    let cookies = (req.headers.get('cookie') ?? '').split(';')\n\n    if (trimAuthCookies) {\n      cookies = cookies.filter(\n        (cookie) => !cookie.trim().startsWith(req.payload.config.cookiePrefix),\n      )\n    }\n\n    const headers = uploadConfig.externalFileHeaderFilter\n      ? uploadConfig.externalFileHeaderFilter(Object.fromEntries(new Headers(req.headers)))\n      : {\n          cookie: cookies.join(';'),\n        }\n\n    // Check if URL is allowed because of skipSafeFetch allowList\n    const skipSafeFetch: boolean =\n      uploadConfig.skipSafeFetch === true\n        ? uploadConfig.skipSafeFetch\n        : Array.isArray(uploadConfig.skipSafeFetch) &&\n          isURLAllowed(fileURL, uploadConfig.skipSafeFetch)\n\n    // Check if URL is allowed because of pasteURL allowList\n    const isAllowedPasteUrl: boolean | undefined =\n      uploadConfig.pasteURL &&\n      uploadConfig.pasteURL.allowList &&\n      isURLAllowed(fileURL, uploadConfig.pasteURL.allowList)\n\n    let res\n    if (skipSafeFetch || isAllowedPasteUrl) {\n      // Allowed\n      res = await fetch(fileURL, {\n        credentials: 'include',\n        headers,\n        method: 'GET',\n      })\n    } else {\n      // Default\n      res = await safeFetch(fileURL, {\n        credentials: 'include',\n        headers,\n        method: 'GET',\n      })\n    }\n\n    if (!res.ok) {\n      throw new APIError(`Failed to fetch file from ${fileURL}`, res.status)\n    }\n\n    const data = await res.arrayBuffer()\n\n    return {\n      name: filename,\n      data: Buffer.from(data),\n      mimetype: res.headers.get('content-type') || undefined!,\n      size: Number(res.headers.get('content-length')) || 0,\n    }\n  }\n\n  throw new APIError('Invalid file url', 400)\n}\n"],"names":["APIError","isURLAllowed","safeFetch","getExternalFile","data","req","uploadConfig","filename","url","trimAuthCookies","fileURL","startsWith","baseUrl","headers","get","protocol","cookies","split","filter","cookie","trim","payload","config","cookiePrefix","externalFileHeaderFilter","Object","fromEntries","Headers","join","skipSafeFetch","Array","isArray","isAllowedPasteUrl","pasteURL","allowList","res","fetch","credentials","method","ok","status","arrayBuffer","name","Buffer","from","mimetype","undefined","size","Number"],"mappings":";;;;AAGA,SAASA,QAAQ,QAAQ,qBAAoB;AAC7C,SAASC,YAAY,QAAQ,+BAA8B;AAC3D,SAASC,SAAS,QAAQ,iBAAgB;;;;AAOnC,MAAMC,kBAAkB,OAAO,EAAEC,IAAI,EAAEC,GAAG,EAAEC,YAAY,EAAQ;IACrE,MAAM,EAAEC,QAAQ,EAAEC,GAAG,EAAE,GAAGJ;IAE1B,IAAIK,kBAAkB;IACtB,IAAI,OAAOD,QAAQ,UAAU;QAC3B,IAAIE,UAAUF;QACd,IAAI,CAACA,IAAIG,UAAU,CAAC,SAAS;YAC3B,gFAAgF;YAChFF,kBAAkB;YAClB,MAAMG,UAAUP,IAAIQ,OAAO,CAACC,GAAG,CAAC,aAAa,GAAGT,IAAIU,QAAQ,CAAC,GAAG,EAAEV,IAAIQ,OAAO,CAACC,GAAG,CAAC,SAAS;YAC3FJ,UAAU,GAAGE,UAAUJ,KAAK;QAC9B;QAEA,IAAIQ,UAAWX,CAAAA,IAAIQ,OAAO,CAACC,GAAG,CAAC,aAAa,EAAC,EAAGG,KAAK,CAAC;QAEtD,IAAIR,iBAAiB;YACnBO,UAAUA,QAAQE,MAAM,CACtB,CAACC,SAAW,CAACA,OAAOC,IAAI,GAAGT,UAAU,CAACN,IAAIgB,OAAO,CAACC,MAAM,CAACC,YAAY;QAEzE;QAEA,MAAMV,UAAUP,aAAakB,wBAAwB,GACjDlB,aAAakB,wBAAwB,CAACC,OAAOC,WAAW,CAAC,IAAIC,QAAQtB,IAAIQ,OAAO,MAChF;YACEM,QAAQH,QAAQY,IAAI,CAAC;QACvB;QAEJ,6DAA6D;QAC7D,MAAMC,gBACJvB,aAAauB,aAAa,KAAK,OAC3BvB,aAAauB,aAAa,GAC1BC,MAAMC,OAAO,CAACzB,aAAauB,aAAa,SACxC5B,8KAAAA,EAAaS,SAASJ,aAAauB,aAAa;QAEtD,wDAAwD;QACxD,MAAMG,oBACJ1B,aAAa2B,QAAQ,IACrB3B,aAAa2B,QAAQ,CAACC,SAAS,QAC/BjC,8KAAAA,EAAaS,SAASJ,aAAa2B,QAAQ,CAACC,SAAS;QAEvD,IAAIC;QACJ,IAAIN,iBAAiBG,mBAAmB;YACtC,UAAU;YACVG,MAAM,MAAMC,MAAM1B,SAAS;gBACzB2B,aAAa;gBACbxB;gBACAyB,QAAQ;YACV;QACF,OAAO;YACL,UAAU;YACVH,MAAM,UAAMjC,sKAAAA,EAAUQ,SAAS;gBAC7B2B,aAAa;gBACbxB;gBACAyB,QAAQ;YACV;QACF;QAEA,IAAI,CAACH,IAAII,EAAE,EAAE;YACX,MAAM,IAAIvC,mKAAAA,CAAS,CAAC,0BAA0B,EAAEU,SAAS,EAAEyB,IAAIK,MAAM;QACvE;QAEA,MAAMpC,OAAO,MAAM+B,IAAIM,WAAW;QAElC,OAAO;YACLC,MAAMnC;YACNH,MAAMuC,OAAOC,IAAI,CAACxC;YAClByC,UAAUV,IAAItB,OAAO,CAACC,GAAG,CAAC,mBAAmBgC;YAC7CC,MAAMC,OAAOb,IAAItB,OAAO,CAACC,GAAG,CAAC,sBAAsB;QACrD;IACF;IAEA,MAAM,IAAId,mKAAAA,CAAS,oBAAoB;AACzC,EAAC"}},
    {"offset": {"line": 1796, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/uploads/tempFile.ts"],"sourcesContent":["import fs from 'fs/promises'\nimport os from 'node:os'\nimport path from 'node:path'\nimport { v4 as uuid } from 'uuid'\n\nasync function runTask(temporaryPath: string, callback: (temporaryPath: string) => Promise<any>) {\n  try {\n    return await callback(temporaryPath)\n  } finally {\n    await fs.rm(temporaryPath, { force: true, maxRetries: 2, recursive: true })\n  }\n}\n\ntype Options = {\n  extension?: string\n  name?: string\n}\n\nexport const temporaryFileTask = async (\n  callback: (temporaryPath: string) => Promise<any>,\n  options: Options = {},\n) => {\n  const filePath = await temporaryFile(options)\n  return runTask(filePath, callback)\n}\n\nasync function temporaryFile(options: Options) {\n  if (options.name) {\n    if (options.extension !== undefined && options.extension !== null) {\n      throw new Error('The `name` and `extension` options are mutually exclusive')\n    }\n\n    return path.join(await temporaryDirectory(), options.name)\n  }\n\n  return (\n    (await getPath()) +\n    (options.extension === undefined || options.extension === null\n      ? ''\n      : '.' + options.extension.replace(/^\\./, ''))\n  )\n}\n\nasync function temporaryDirectory({ prefix = '' } = {}) {\n  const directory = await getPath(prefix)\n  await fs.mkdir(directory)\n  return directory\n}\n\nasync function getPath(prefix = ''): Promise<string> {\n  const temporaryDirectory = await fs.realpath(os.tmpdir())\n  return path.join(temporaryDirectory, prefix + uuid())\n}\n"],"names":["fs","os","path","v4","uuid","runTask","temporaryPath","callback","rm","force","maxRetries","recursive","temporaryFileTask","options","filePath","temporaryFile","name","extension","undefined","Error","join","temporaryDirectory","getPath","replace","prefix","directory","mkdir","realpath","tmpdir"],"mappings":";;;;AAAA,OAAOA,QAAQ,cAAa;AAC5B,OAAOC,QAAQ,UAAS;AACxB,OAAOC,UAAU,YAAW;AAC5B,SAASC,MAAMC,IAAI,QAAQ,OAAM;;;;;AAEjC,eAAeC,QAAQC,aAAqB,EAAEC,QAAiD;IAC7F,IAAI;QACF,OAAO,MAAMA,SAASD;IACxB,SAAU;QACR,MAAMN,gIAAAA,CAAGQ,EAAE,CAACF,eAAe;YAAEG,OAAO;YAAMC,YAAY;YAAGC,WAAW;QAAK;IAC3E;AACF;AAOO,MAAMC,oBAAoB,OAC/BL,UACAM,UAAmB,CAAC,CAAC;IAErB,MAAMC,WAAW,MAAMC,cAAcF;IACrC,OAAOR,QAAQS,UAAUP;AAC3B,EAAC;AAED,eAAeQ,cAAcF,OAAgB;IAC3C,IAAIA,QAAQG,IAAI,EAAE;QAChB,IAAIH,QAAQI,SAAS,KAAKC,aAAaL,QAAQI,SAAS,KAAK,MAAM;YACjE,MAAM,IAAIE,MAAM;QAClB;QAEA,OAAOjB,4HAAAA,CAAKkB,IAAI,CAAC,MAAMC,sBAAsBR,QAAQG,IAAI;IAC3D;IAEA,OACG,MAAMM,YACNT,CAAAA,QAAQI,SAAS,KAAKC,aAAaL,QAAQI,SAAS,KAAK,OACtD,KACA,MAAMJ,QAAQI,SAAS,CAACM,OAAO,CAAC,OAAO,GAAE;AAEjD;AAEA,eAAeF,mBAAmB,EAAEG,SAAS,EAAE,EAAE,GAAG,CAAC,CAAC;IACpD,MAAMC,YAAY,MAAMH,QAAQE;IAChC,MAAMxB,gIAAAA,CAAG0B,KAAK,CAACD;IACf,OAAOA;AACT;AAEA,eAAeH,QAAQE,SAAS,EAAE;IAChC,MAAMH,qBAAqB,MAAMrB,gIAAAA,CAAG2B,QAAQ,CAAC1B,wHAAAA,CAAG2B,MAAM;IACtD,OAAO1B,4HAAAA,CAAKkB,IAAI,CAACC,oBAAoBG,aAASpB,0LAAAA;AAChD"}},
    {"offset": {"line": 1845, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/uploads/getImageSize.ts"],"sourcesContent":["import fs from 'fs/promises'\nimport { imageSize } from 'image-size'\nimport { imageSizeFromFile } from 'image-size/fromFile'\n\nimport type { PayloadRequest } from '../types/index.js'\nimport type { ProbedImageSize } from './types.js'\n\nimport { temporaryFileTask } from './tempFile.js'\n\nexport async function getImageSize(file: PayloadRequest['file']): Promise<ProbedImageSize> {\n  if (file?.tempFilePath) {\n    return imageSizeFromFile(file.tempFilePath)\n  }\n\n  // Tiff file do not support buffers or streams, so we must write to file first\n  // then retrieve dimensions. https://github.com/image-size/image-size/issues/103\n  if (file?.mimetype === 'image/tiff') {\n    const dimensions = await temporaryFileTask(\n      async (filepath: string) => {\n        await fs.writeFile(filepath, file.data)\n        return imageSizeFromFile(filepath)\n      },\n      { extension: 'tiff' },\n    )\n    return dimensions\n  }\n\n  return imageSize(file!.data)\n}\n"],"names":["fs","imageSize","imageSizeFromFile","temporaryFileTask","getImageSize","file","tempFilePath","mimetype","dimensions","filepath","writeFile","data","extension"],"mappings":";;;;AAAA,OAAOA,QAAQ,cAAa;AAC5B,SAASC,SAAS,QAAQ,aAAY;AACtC,SAASC,iBAAiB,QAAQ,sBAAqB;AAKvD,SAASC,iBAAiB,QAAQ,gBAAe;;;;;AAE1C,eAAeC,aAAaC,IAA4B;IAC7D,IAAIA,MAAMC,cAAc;QACtB,WAAOJ,yKAAAA,EAAkBG,KAAKC,YAAY;IAC5C;IAEA,8EAA8E;IAC9E,gFAAgF;IAChF,IAAID,MAAME,aAAa,cAAc;QACnC,MAAMC,aAAa,UAAML,6KAAAA,EACvB,OAAOM;YACL,MAAMT,gIAAAA,CAAGU,SAAS,CAACD,UAAUJ,KAAKM,IAAI;YACtC,WAAOT,yKAAAA,EAAkBO;QAC3B,GACA;YAAEG,WAAW;QAAO;QAEtB,OAAOJ;IACT;IAEA,WAAOP,8JAAAA,EAAUI,KAAMM,IAAI;AAC7B"}},
    {"offset": {"line": 1878, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/uploads/docWithFilenameExists.ts"],"sourcesContent":["import type { PayloadRequest, Where } from '../types/index.js'\n\ntype Args = {\n  collectionSlug: string\n  filename: string\n  path: string\n  prefix?: string\n  req: PayloadRequest\n}\n\nexport const docWithFilenameExists = async ({\n  collectionSlug,\n  filename,\n  prefix,\n  req,\n}: Args): Promise<boolean> => {\n  const where: Where = {\n    filename: {\n      equals: filename,\n    },\n  }\n\n  if (prefix) {\n    where.prefix = { equals: prefix }\n  }\n\n  const doc = await req.payload.db.findOne({\n    collection: collectionSlug,\n    req,\n    where,\n  })\n\n  return !!doc\n}\n"],"names":["docWithFilenameExists","collectionSlug","filename","prefix","req","where","equals","doc","payload","db","findOne","collection"],"mappings":";;;;AAUO,MAAMA,wBAAwB,OAAO,EAC1CC,cAAc,EACdC,QAAQ,EACRC,MAAM,EACNC,GAAG,EACE;IACL,MAAMC,QAAe;QACnBH,UAAU;YACRI,QAAQJ;QACV;IACF;IAEA,IAAIC,QAAQ;QACVE,MAAMF,MAAM,GAAG;YAAEG,QAAQH;QAAO;IAClC;IAEA,MAAMI,MAAM,MAAMH,IAAII,OAAO,CAACC,EAAE,CAACC,OAAO,CAAC;QACvCC,YAAYV;QACZG;QACAC;IACF;IAEA,OAAO,CAAC,CAACE;AACX,EAAC"}},
    {"offset": {"line": 1904, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/uploads/fileExists.ts"],"sourcesContent":["import fs from 'fs/promises'\n\nexport const fileExists = async (filename: string): Promise<boolean> => {\n  try {\n    await fs.stat(filename)\n\n    return true\n  } catch (ignore) {\n    return false\n  }\n}\n"],"names":["fs","fileExists","filename","stat","ignore"],"mappings":";;;;AAAA,OAAOA,QAAQ,cAAa;;AAErB,MAAMC,aAAa,OAAOC;IAC/B,IAAI;QACF,MAAMF,gIAAAA,CAAGG,IAAI,CAACD;QAEd,OAAO;IACT,EAAE,OAAOE,QAAQ;QACf,OAAO;IACT;AACF,EAAC"}},
    {"offset": {"line": 1922, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/uploads/getSafeFilename.ts"],"sourcesContent":["import sanitize from 'sanitize-filename'\n\nimport type { PayloadRequest } from '../types/index.js'\n\nimport { docWithFilenameExists } from './docWithFilenameExists.js'\nimport { fileExists } from './fileExists.js'\n\n/**\n * Increments a filename by appending or incrementing a numeric suffix.\n * @example\n * incrementName('file.jpg') // 'file-1.jpg'\n * incrementName('file-1.jpg') // 'file-2.jpg'\n * incrementName('file-99.jpg') // 'file-100.jpg'\n */\nexport const incrementName = (name: string): string => {\n  const extension = name.split('.').pop()\n  const baseFilename = sanitize(name.substring(0, name.lastIndexOf('.')) || name)\n  let incrementedName = baseFilename\n  const regex = /(.*)-(\\d+)$/\n  const found = baseFilename.match(regex)\n  if (found === null) {\n    incrementedName += '-1'\n  } else {\n    const matchedName = found[1]\n    const matchedNumber = found[2]\n    const incremented = Number(matchedNumber) + 1\n    incrementedName = `${matchedName}-${incremented}`\n  }\n  return `${incrementedName}.${extension}`\n}\n\ntype Args = {\n  collectionSlug: string\n  desiredFilename: string\n  prefix?: string\n  req: PayloadRequest\n  staticPath: string\n}\n\n/**\n * Generates a safe, unique filename by checking for conflicts in both the database\n * and filesystem. If a conflict exists, it increments a numeric suffix until a\n * unique name is found.\n *\n * @param args.collectionSlug - The slug of the upload collection\n * @param args.desiredFilename - The original filename to make safe\n * @param args.prefix - Optional prefix path for cloud storage adapters\n * @param args.req - The Payload request object\n * @param args.staticPath - The filesystem path where uploads are stored\n * @returns A unique filename that doesn't conflict with existing files\n *\n * @example\n * // If 'photo.jpg' already exists, returns 'photo-1.jpg'\n * const safeName = await getSafeFileName({\n *   collectionSlug: 'media',\n *   desiredFilename: 'photo.jpg',\n *   req,\n *   staticPath: '/uploads/media',\n * })\n */\nexport async function getSafeFileName({\n  collectionSlug,\n  desiredFilename,\n  prefix,\n  req,\n  staticPath,\n}: Args): Promise<string> {\n  let modifiedFilename = desiredFilename\n\n  while (\n    (await docWithFilenameExists({\n      collectionSlug,\n      filename: modifiedFilename,\n      path: staticPath,\n      prefix,\n      req,\n    })) ||\n    (await fileExists(`${staticPath}/${modifiedFilename}`))\n  ) {\n    modifiedFilename = incrementName(modifiedFilename)\n  }\n  return modifiedFilename\n}\n"],"names":["sanitize","docWithFilenameExists","fileExists","incrementName","name","extension","split","pop","baseFilename","substring","lastIndexOf","incrementedName","regex","found","match","matchedName","matchedNumber","incremented","Number","getSafeFileName","collectionSlug","desiredFilename","prefix","req","staticPath","modifiedFilename","filename","path"],"mappings":";;;;;;AAAA,OAAOA,cAAc,oBAAmB;AAIxC,SAASC,qBAAqB,QAAQ,6BAA4B;AAClE,SAASC,UAAU,QAAQ,kBAAiB;;;;AASrC,MAAMC,gBAAgB,CAACC;IAC5B,MAAMC,YAAYD,KAAKE,KAAK,CAAC,KAAKC,GAAG;IACrC,MAAMC,mBAAeR,0JAAAA,EAASI,KAAKK,SAAS,CAAC,GAAGL,KAAKM,WAAW,CAAC,SAASN;IAC1E,IAAIO,kBAAkBH;IACtB,MAAMI,QAAQ;IACd,MAAMC,QAAQL,aAAaM,KAAK,CAACF;IACjC,IAAIC,UAAU,MAAM;QAClBF,mBAAmB;IACrB,OAAO;QACL,MAAMI,cAAcF,KAAK,CAAC,EAAE;QAC5B,MAAMG,gBAAgBH,KAAK,CAAC,EAAE;QAC9B,MAAMI,cAAcC,OAAOF,iBAAiB;QAC5CL,kBAAkB,GAAGI,YAAY,CAAC,EAAEE,aAAa;IACnD;IACA,OAAO,GAAGN,gBAAgB,CAAC,EAAEN,WAAW;AAC1C,EAAC;AA+BM,eAAec,gBAAgB,EACpCC,cAAc,EACdC,eAAe,EACfC,MAAM,EACNC,GAAG,EACHC,UAAU,EACL;IACL,IAAIC,mBAAmBJ;IAEvB,MACG,UAAMpB,8LAAAA,EAAsB;QAC3BmB;QACAM,UAAUD;QACVE,MAAMH;QACNF;QACAC;IACF,MACC,UAAMrB,wKAAAA,EAAW,GAAGsB,WAAW,CAAC,EAAEC,kBAAkB,EACrD;QACAA,mBAAmBtB,cAAcsB;IACnC;IACA,OAAOA;AACT"}},
    {"offset": {"line": 1967, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/uploads/image-resizing/createImageSize.ts"],"sourcesContent":["/**\n * Create the result object for the image resize operation based on the\n * provided parameters. If the name is not provided, an empty result object\n * is returned.\n *\n * @param filename - the filename of the image\n * @param width - the width of the image\n * @param height - the height of the image\n * @param filesize - the filesize of the image\n * @param mimeType - the mime type of the image\n * @returns a FileSize result object\n */\n\nimport type { FileSize } from '../types.js'\n\ntype CreateResultArgs = {\n  filename?: FileSize['filename']\n  filesize?: FileSize['filesize']\n  height?: FileSize['height']\n  mimeType?: FileSize['mimeType']\n  url?: FileSize['url']\n  width?: FileSize['width']\n}\nexport const createImageSize = ({\n  filename = null,\n  filesize = null,\n  height = null,\n  mimeType = null,\n  url = null,\n  width = null,\n}: CreateResultArgs): FileSize => {\n  return {\n    filename,\n    filesize,\n    height,\n    mimeType,\n    url,\n    width,\n  }\n}\n"],"names":["createImageSize","filename","filesize","height","mimeType","url","width"],"mappings":"AAAA;;;;;;;;;;;CAWC,GAYD;;;;AAAO,MAAMA,kBAAkB,CAAC,EAC9BC,WAAW,IAAI,EACfC,WAAW,IAAI,EACfC,SAAS,IAAI,EACbC,WAAW,IAAI,EACfC,MAAM,IAAI,EACVC,QAAQ,IAAI,EACK;IACjB,OAAO;QACLL;QACAC;QACAC;QACAC;QACAC;QACAC;IACF;AACF,EAAC"}},
    {"offset": {"line": 1996, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/uploads/image-resizing/extractHeightFromImage.ts"],"sourcesContent":["import type { Metadata as SharpMetadata } from 'sharp'\n\n/**\n * Used to extract height from images, animated or not.\n *\n * @param sharpMetadata - the sharp metadata\n * @returns the height of the image\n */\nexport function extractHeightFromImage(sharpMetadata: SharpMetadata): number {\n  if (sharpMetadata?.pages) {\n    return sharpMetadata.height! / sharpMetadata.pages\n  }\n  return sharpMetadata.height!\n}\n"],"names":["extractHeightFromImage","sharpMetadata","pages","height"],"mappings":"AAEA;;;;;CAKC,GACD;;;;AAAO,SAASA,uBAAuBC,aAA4B;IACjE,IAAIA,eAAeC,OAAO;QACxB,OAAOD,cAAcE,MAAM,GAAIF,cAAcC,KAAK;IACpD;IACA,OAAOD,cAAcE,MAAM;AAC7B"}},
    {"offset": {"line": 2015, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/uploads/image-resizing/generateImageSizeFilename.ts"],"sourcesContent":["/**\n * Create a new image name based on the output image name, the dimensions and\n * the extension.\n *\n * Ignore the fact that duplicate names could happen if the there is one\n * size with `width AND height` and one with only `height OR width`. Because\n * space is expensive, we will reuse the same image for both sizes.\n *\n * @param outputImageName - the sanitized image name\n * @param bufferInfo - the buffer info\n * @param extension - the extension to use\n * @returns the new image name that is not taken\n */\ntype CreateImageNameArgs = {\n  extension: string\n  height: number\n  outputImageName: string\n  width: number\n}\nexport const generateImageSizeFilename = ({\n  extension,\n  height,\n  outputImageName,\n  width,\n}: CreateImageNameArgs): string => {\n  return `${outputImageName}-${width}x${height}.${extension}`\n}\n"],"names":["generateImageSizeFilename","extension","height","outputImageName","width"],"mappings":"AAAA;;;;;;;;;;;;CAYC,GAOD;;;;AAAO,MAAMA,4BAA4B,CAAC,EACxCC,SAAS,EACTC,MAAM,EACNC,eAAe,EACfC,KAAK,EACe;IACpB,OAAO,GAAGD,gBAAgB,CAAC,EAAEC,MAAM,CAAC,EAAEF,OAAO,CAAC,EAAED,WAAW;AAC7D,EAAC"}},
    {"offset": {"line": 2038, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/uploads/image-resizing/getImageResizeAction.ts"],"sourcesContent":["import type { ImageSize, ProbedImageSize } from '../types.js'\n\nimport { isNumber } from '../../utilities/isNumber.js'\n\n/**\n * Determine whether or not to resize the image.\n * - resize using image config\n * - resize using image config with focal adjustments\n * - do not resize at all\n *\n * `imageResizeConfig.withoutEnlargement`:\n * - undefined [default]: uploading images with smaller width AND height than the image size will return null\n * - false: always enlarge images to the image size\n * - true: if the image is smaller than the image size, return the original image\n *\n * `imageResizeConfig.withoutReduction`:\n * - false [default]: always enlarge images to the image size\n * - true: if the image is smaller than the image size, return the original image\n *\n * @return 'omit' | 'resize' | 'resizeWithFocalPoint'\n */\nexport const getImageResizeAction = ({\n  dimensions: originalImage,\n  hasFocalPoint,\n  imageResizeConfig,\n}: {\n  dimensions: ProbedImageSize\n  hasFocalPoint?: boolean\n  imageResizeConfig: ImageSize\n}): 'omit' | 'resize' | 'resizeWithFocalPoint' => {\n  const { fit, withoutEnlargement, withoutReduction } = imageResizeConfig\n  const targetWidth = imageResizeConfig.width!\n  const targetHeight = imageResizeConfig.height!\n\n  // prevent upscaling by default when x and y are both smaller than target image size\n  if (targetHeight && targetWidth) {\n    const originalImageIsSmallerXAndY =\n      originalImage.width < targetWidth && originalImage.height < targetHeight\n    if (withoutEnlargement === undefined && originalImageIsSmallerXAndY) {\n      return 'omit' // prevent image size from being enlarged\n    }\n  }\n\n  if (withoutEnlargement === undefined && (!targetWidth || !targetHeight)) {\n    if (\n      (targetWidth && originalImage.width < targetWidth) ||\n      (targetHeight && originalImage.height < targetHeight)\n    ) {\n      return 'omit'\n    }\n  }\n\n  const originalImageIsSmallerXOrY =\n    originalImage.width < targetWidth || originalImage.height < targetHeight\n  if (fit === 'contain' || fit === 'inside') {\n    return 'resize'\n  }\n  if (!isNumber(targetHeight) && !isNumber(targetWidth)) {\n    return 'resize'\n  }\n\n  const targetAspectRatio = targetWidth / targetHeight\n  const originalAspectRatio = originalImage.width / originalImage.height\n  if (originalAspectRatio === targetAspectRatio) {\n    return 'resize'\n  }\n\n  if (withoutEnlargement && originalImageIsSmallerXOrY) {\n    return 'resize'\n  }\n  if (withoutReduction && !originalImageIsSmallerXOrY) {\n    return 'resize'\n  }\n\n  return hasFocalPoint ? 'resizeWithFocalPoint' : 'resize'\n}\n"],"names":["isNumber","getImageResizeAction","dimensions","originalImage","hasFocalPoint","imageResizeConfig","fit","withoutEnlargement","withoutReduction","targetWidth","width","targetHeight","height","originalImageIsSmallerXAndY","undefined","originalImageIsSmallerXOrY","targetAspectRatio","originalAspectRatio"],"mappings":";;;;AAEA,SAASA,QAAQ,QAAQ,8BAA6B;;AAmB/C,MAAMC,uBAAuB,CAAC,EACnCC,YAAYC,aAAa,EACzBC,aAAa,EACbC,iBAAiB,EAKlB;IACC,MAAM,EAAEC,GAAG,EAAEC,kBAAkB,EAAEC,gBAAgB,EAAE,GAAGH;IACtD,MAAMI,cAAcJ,kBAAkBK,KAAK;IAC3C,MAAMC,eAAeN,kBAAkBO,MAAM;IAE7C,oFAAoF;IACpF,IAAID,gBAAgBF,aAAa;QAC/B,MAAMI,8BACJV,cAAcO,KAAK,GAAGD,eAAeN,cAAcS,MAAM,GAAGD;QAC9D,IAAIJ,uBAAuBO,aAAaD,6BAA6B;YACnE,OAAO,OAAO,yCAAyC;;QACzD;IACF;IAEA,IAAIN,uBAAuBO,aAAc,CAAA,CAACL,eAAe,CAACE,YAAW,GAAI;QACvE,IACGF,eAAeN,cAAcO,KAAK,GAAGD,eACrCE,gBAAgBR,cAAcS,MAAM,GAAGD,cACxC;YACA,OAAO;QACT;IACF;IAEA,MAAMI,6BACJZ,cAAcO,KAAK,GAAGD,eAAeN,cAAcS,MAAM,GAAGD;IAC9D,IAAIL,QAAQ,aAAaA,QAAQ,UAAU;QACzC,OAAO;IACT;IACA,IAAI,KAACN,sKAAAA,EAASW,iBAAiB,KAACX,sKAAAA,EAASS,cAAc;QACrD,OAAO;IACT;IAEA,MAAMO,oBAAoBP,cAAcE;IACxC,MAAMM,sBAAsBd,cAAcO,KAAK,GAAGP,cAAcS,MAAM;IACtE,IAAIK,wBAAwBD,mBAAmB;QAC7C,OAAO;IACT;IAEA,IAAIT,sBAAsBQ,4BAA4B;QACpD,OAAO;IACT;IACA,IAAIP,oBAAoB,CAACO,4BAA4B;QACnD,OAAO;IACT;IAEA,OAAOX,gBAAgB,yBAAyB;AAClD,EAAC"}},
    {"offset": {"line": 2085, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/uploads/image-resizing/parseFilename.ts"],"sourcesContent":["import sanitize from 'sanitize-filename'\n\ntype SanitizedImageData = {\n  ext: string\n  name: string\n}\n\n/**\n * Sanitize the image name and extract the extension from the source image\n *\n * @param sourceImage - the source image\n * @returns the sanitized name and extension\n */\nexport const parseFilename = (sourceImage: string): SanitizedImageData => {\n  const extension = sourceImage.split('.').pop()\n  const name = sanitize(sourceImage.substring(0, sourceImage.lastIndexOf('.')) || sourceImage)\n  return { name, ext: extension! }\n}\n"],"names":["sanitize","parseFilename","sourceImage","extension","split","pop","name","substring","lastIndexOf","ext"],"mappings":";;;;AAAA,OAAOA,cAAc,oBAAmB;;AAajC,MAAMC,gBAAgB,CAACC;IAC5B,MAAMC,YAAYD,YAAYE,KAAK,CAAC,KAAKC,GAAG;IAC5C,MAAMC,WAAON,0JAAAA,EAASE,YAAYK,SAAS,CAAC,GAAGL,YAAYM,WAAW,CAAC,SAASN;IAChF,OAAO;QAAEI;QAAMG,KAAKN;IAAW;AACjC,EAAC"}},
    {"offset": {"line": 2103, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/uploads/image-resizing/sanitizeResizeConfig.ts"],"sourcesContent":["import type { ImageSize } from '../types.js'\n\n/**\n * Sanitize the resize config. If the resize config has the `withoutReduction`\n * property set to true, the `fit` and `position` properties will be set to `contain`\n * and `top left` respectively.\n *\n * @param resizeConfig - the resize config\n * @returns a sanitized resize config\n */\nexport const sanitizeResizeConfig = (resizeConfig: ImageSize): ImageSize => {\n  if (resizeConfig.withoutReduction) {\n    return {\n      ...resizeConfig,\n      // Why fit `contain` should also be set to https://github.com/lovell/sharp/issues/3595\n      fit: resizeConfig?.fit || 'contain',\n      position: resizeConfig?.position || 'left top',\n    }\n  }\n  return resizeConfig\n}\n"],"names":["sanitizeResizeConfig","resizeConfig","withoutReduction","fit","position"],"mappings":"AAEA;;;;;;;CAOC,GACD;;;;AAAO,MAAMA,uBAAuB,CAACC;IACnC,IAAIA,aAAaC,gBAAgB,EAAE;QACjC,OAAO;YACL,GAAGD,YAAY;YACf,sFAAsF;YACtFE,KAAKF,cAAcE,OAAO;YAC1BC,UAAUH,cAAcG,YAAY;QACtC;IACF;IACA,OAAOH;AACT,EAAC"}},
    {"offset": {"line": 2129, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/uploads/image-resizing/createImageSizes.ts"],"sourcesContent":["import type { Sharp, SharpOptions } from 'sharp'\n\nimport { fileTypeFromBuffer } from 'file-type'\nimport fs from 'fs/promises'\n\nimport type { SanitizedCollectionConfig } from '../../collections/config/types.js'\nimport type { SharpDependency } from '../../config/types.js'\nimport type { PayloadRequest } from '../../types/index.js'\nimport type { WithMetadata } from '../optionallyAppendMetadata.js'\nimport type { FileSize, FileSizes, FileToSave, FocalPoint, ProbedImageSize } from '../types.js'\n\nimport { fileExists } from '../fileExists.js'\nimport { optionallyAppendMetadata } from '../optionallyAppendMetadata.js'\nimport { createImageSize } from './createImageSize.js'\nimport { extractHeightFromImage } from './extractHeightFromImage.js'\nimport { generateImageSizeFilename } from './generateImageSizeFilename.js'\nimport { getImageResizeAction } from './getImageResizeAction.js'\nimport { parseFilename } from './parseFilename.js'\nimport { sanitizeResizeConfig } from './sanitizeResizeConfig.js'\n\n/**\n * For the provided image sizes, handle the resizing and the transforms\n * (format, trim, etc.) of each requested image size and return the result object.\n * This only handles the image sizes. The transforms of the original image\n * are handled in {@link ./generateFileData.ts}.\n *\n * The image will be resized according to the provided\n * resize config. If no image sizes are requested, the resolved data will be empty.\n * For every image that does not need to be resized, a result object with `null`\n * parameters will be returned.\n *\n * @param resizeConfig - the resize config\n * @returns the result of the resize operation(s)\n */\n\ntype ResizeArgs = {\n  config: SanitizedCollectionConfig\n  dimensions: ProbedImageSize\n  file: PayloadRequest['file']\n  focalPoint?: FocalPoint\n  mimeType: string\n  req: PayloadRequest\n  savedFilename: string\n  sharp?: SharpDependency\n  staticPath: string\n  withMetadata?: WithMetadata\n}\n\n/** Result from resizing and transforming the requested image sizes */\ntype ImageSizesResult = {\n  sizeData: FileSizes\n  sizesToSave: FileToSave[]\n}\n\nexport async function createImageSizes({\n  config,\n  dimensions,\n  file,\n  focalPoint,\n  mimeType,\n  req,\n  savedFilename,\n  sharp,\n  staticPath,\n  withMetadata,\n}: ResizeArgs): Promise<ImageSizesResult> {\n  const { imageSizes } = config.upload\n\n  if (!imageSizes || !sharp) {\n    return {\n      sizeData: {},\n      sizesToSave: [],\n    }\n  }\n\n  // Determine if the file is animated\n  const fileIsAnimatedType = ['image/avif', 'image/gif', 'image/webp'].includes(file!.mimetype)\n  const sharpOptions: SharpOptions = {}\n\n  if (fileIsAnimatedType) {\n    sharpOptions.animated = true\n  }\n\n  const sharpBase: Sharp | undefined = sharp(\n    file!.tempFilePath || file!.data,\n    sharpOptions,\n  ).rotate() // pass rotate() to auto-rotate based on EXIF data. https://github.com/payloadcms/payload/pull/3081\n  const originalImageMeta = await sharpBase.metadata()\n\n  let adjustedDimensions = { ...dimensions }\n\n  // Images with an exif orientation of 5, 6, 7, or 8 are auto-rotated by sharp\n  // Need to adjust the dimensions to match the original image\n  if ([5, 6, 7, 8].includes(originalImageMeta.orientation!)) {\n    adjustedDimensions = {\n      ...dimensions,\n      height: dimensions.width,\n      width: dimensions.height,\n    }\n  }\n\n  const resizeImageMeta = {\n    height: originalImageMeta.height,\n    width: originalImageMeta.width,\n  }\n\n  const sizes = {} as Record<string, FileSize>\n  const imageSizeFiles: FileToSave[] = []\n\n  await Promise.all(\n    imageSizes.map(async (imageResizeConfig): Promise<void> => {\n      imageResizeConfig = sanitizeResizeConfig(imageResizeConfig)\n\n      const resizeAction = getImageResizeAction({\n        dimensions,\n        hasFocalPoint: Boolean(focalPoint),\n        imageResizeConfig,\n      })\n\n      if (resizeAction === 'omit') {\n        sizes[imageResizeConfig.name] = createImageSize({})\n        return\n      }\n\n      const imageToResize = sharpBase.clone()\n      let resized = imageToResize\n\n      if (resizeAction === 'resizeWithFocalPoint') {\n        let { height: resizeHeight, width: resizeWidth } = imageResizeConfig\n\n        const originalAspectRatio = adjustedDimensions.width / adjustedDimensions.height\n\n        // Calculate resizeWidth based on original aspect ratio if it's undefined\n        if (resizeHeight && !resizeWidth) {\n          resizeWidth = Math.round(resizeHeight * originalAspectRatio)\n        }\n\n        // Calculate resizeHeight based on original aspect ratio if it's undefined\n        if (resizeWidth && !resizeHeight) {\n          resizeHeight = Math.round(resizeWidth / originalAspectRatio)\n        }\n\n        if (!resizeHeight) {\n          resizeHeight = resizeImageMeta.height\n        }\n        if (!resizeWidth) {\n          resizeWidth = resizeImageMeta.width\n        }\n\n        const resizeAspectRatio = resizeWidth! / resizeHeight!\n        const prioritizeHeight = resizeAspectRatio < originalAspectRatio\n        // Scales the image before extracting from it\n        resized = imageToResize.resize({\n          fastShrinkOnLoad: false,\n          height: prioritizeHeight ? resizeHeight : undefined,\n          width: prioritizeHeight ? undefined : resizeWidth,\n        })\n\n        const metadataAppendedFile = await optionallyAppendMetadata({\n          req,\n          sharpFile: resized,\n          withMetadata: withMetadata!,\n        })\n\n        // Must read from buffer, resized.metadata will return the original image metadata\n        const { info } = await metadataAppendedFile.toBuffer({ resolveWithObject: true })\n\n        resizeImageMeta.height = extractHeightFromImage({\n          ...originalImageMeta,\n          height: info.height,\n        })\n        resizeImageMeta.width = info.width\n\n        const halfResizeX = resizeWidth! / 2\n        const xFocalCenter = resizeImageMeta.width * (focalPoint!.x / 100)\n        const calculatedRightPixelBound = xFocalCenter + halfResizeX\n        let leftBound = xFocalCenter - halfResizeX\n\n        // if the right bound is greater than the image width, adjust the left bound\n        // keeping focus on the right\n        if (calculatedRightPixelBound > resizeImageMeta.width) {\n          leftBound = resizeImageMeta.width - resizeWidth!\n        }\n\n        // if the left bound is less than 0, adjust the left bound to 0\n        // keeping the focus on the left\n        if (leftBound < 0) {\n          leftBound = 0\n        }\n\n        const halfResizeY = resizeHeight! / 2\n        const yFocalCenter = resizeImageMeta.height * (focalPoint!.y / 100)\n        const calculatedBottomPixelBound = yFocalCenter + halfResizeY\n        let topBound = yFocalCenter - halfResizeY\n\n        // if the bottom bound is greater than the image height, adjust the top bound\n        // keeping the image as far right as possible\n        if (calculatedBottomPixelBound > resizeImageMeta.height) {\n          topBound = resizeImageMeta.height - resizeHeight!\n        }\n\n        // if the top bound is less than 0, adjust the top bound to 0\n        // keeping the image focus near the top\n        if (topBound < 0) {\n          topBound = 0\n        }\n\n        resized = resized.extract({\n          height: resizeHeight!,\n          left: Math.floor(leftBound),\n          top: Math.floor(topBound),\n          width: resizeWidth!,\n        })\n      } else {\n        resized = imageToResize.resize(imageResizeConfig)\n      }\n\n      if (imageResizeConfig.formatOptions) {\n        resized = resized.toFormat(\n          imageResizeConfig.formatOptions.format,\n          imageResizeConfig.formatOptions.options,\n        )\n      }\n\n      if (imageResizeConfig.trimOptions) {\n        resized = resized.trim(imageResizeConfig.trimOptions)\n      }\n\n      const metadataAppendedFile = await optionallyAppendMetadata({\n        req,\n        sharpFile: resized,\n        withMetadata: withMetadata!,\n      })\n\n      const { data: bufferData, info: bufferInfo } = await metadataAppendedFile.toBuffer({\n        resolveWithObject: true,\n      })\n\n      const { name, ext } = parseFilename(savedFilename)\n\n      if (req.payloadUploadSizes) {\n        req.payloadUploadSizes[imageResizeConfig.name] = bufferData\n      }\n\n      const mimeInfo = await fileTypeFromBuffer(bufferData)\n\n      const imageNameWithDimensions = imageResizeConfig.generateImageName\n        ? imageResizeConfig.generateImageName({\n            extension: mimeInfo?.ext || ext,\n            height: extractHeightFromImage({\n              ...originalImageMeta,\n              height: bufferInfo.height,\n            }),\n            originalName: name,\n            sizeName: imageResizeConfig.name,\n            width: bufferInfo.width,\n          })\n        : generateImageSizeFilename({\n            extension: mimeInfo?.ext || ext,\n            height: extractHeightFromImage({\n              ...originalImageMeta,\n              height: bufferInfo.height,\n            }),\n            outputImageName: name,\n            width: bufferInfo.width,\n          })\n\n      const imagePath = `${staticPath}/${imageNameWithDimensions}`\n\n      if (await fileExists(imagePath)) {\n        try {\n          await fs.unlink(imagePath)\n        } catch {\n          // Ignore unlink errors\n        }\n      }\n\n      const { height, size, width } = bufferInfo\n      sizes[imageResizeConfig.name] = createImageSize({\n        filename: imageNameWithDimensions,\n        filesize: size,\n        height:\n          fileIsAnimatedType && originalImageMeta.pages ? height / originalImageMeta.pages : height,\n        mimeType: mimeInfo?.mime || mimeType,\n        width,\n      })\n\n      imageSizeFiles.push({\n        buffer: bufferData,\n        path: imagePath,\n      })\n    }),\n  )\n\n  return {\n    sizeData: sizes,\n    sizesToSave: imageSizeFiles,\n  }\n}\n"],"names":["fileTypeFromBuffer","fs","fileExists","optionallyAppendMetadata","createImageSize","extractHeightFromImage","generateImageSizeFilename","getImageResizeAction","parseFilename","sanitizeResizeConfig","createImageSizes","config","dimensions","file","focalPoint","mimeType","req","savedFilename","sharp","staticPath","withMetadata","imageSizes","upload","sizeData","sizesToSave","fileIsAnimatedType","includes","mimetype","sharpOptions","animated","sharpBase","tempFilePath","data","rotate","originalImageMeta","metadata","adjustedDimensions","orientation","height","width","resizeImageMeta","sizes","imageSizeFiles","Promise","all","map","imageResizeConfig","resizeAction","hasFocalPoint","Boolean","name","imageToResize","clone","resized","resizeHeight","resizeWidth","originalAspectRatio","Math","round","resizeAspectRatio","prioritizeHeight","resize","fastShrinkOnLoad","undefined","metadataAppendedFile","sharpFile","info","toBuffer","resolveWithObject","halfResizeX","xFocalCenter","x","calculatedRightPixelBound","leftBound","halfResizeY","yFocalCenter","y","calculatedBottomPixelBound","topBound","extract","left","floor","top","formatOptions","toFormat","format","options","trimOptions","trim","bufferData","bufferInfo","ext","payloadUploadSizes","mimeInfo","imageNameWithDimensions","generateImageName","extension","originalName","sizeName","outputImageName","imagePath","unlink","size","filename","filesize","pages","mime","push","buffer","path"],"mappings":"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"}},
    {"offset": {"line": 2353, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/uploads/isImage.ts"],"sourcesContent":["export function isImage(mimeType: string): boolean {\n  return (\n    [\n      'image/jpeg',\n      'image/png',\n      'image/gif',\n      'image/svg+xml',\n      'image/webp',\n      'image/avif',\n      'image/jxl',\n    ].indexOf(mimeType) > -1\n  )\n}\n"],"names":["isImage","mimeType","indexOf"],"mappings":";;;;AAAO,SAASA,QAAQC,QAAgB;IACtC,OACE;QACE;QACA;QACA;QACA;QACA;QACA;QACA;KACD,CAACC,OAAO,CAACD,YAAY,CAAC;AAE3B"}},
    {"offset": {"line": 2372, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/uploads/generateFileData.ts"],"sourcesContent":["import type { OutputInfo, Sharp, SharpOptions } from 'sharp'\n\nimport { fileTypeFromBuffer } from 'file-type'\nimport fs from 'fs/promises'\nimport sanitize from 'sanitize-filename'\n\nimport type { Collection } from '../collections/config/types.js'\nimport type { SanitizedConfig } from '../config/types.js'\nimport type { Document, PayloadRequest } from '../types/index.js'\nimport type { FileData, FileToSave, ProbedImageSize, UploadEdits } from './types.js'\n\nimport { FileRetrievalError, FileUploadError, Forbidden, MissingFile } from '../errors/index.js'\nimport { isNumber } from '../utilities/isNumber.js'\nimport { canResizeImage } from './canResizeImage.js'\nimport { checkFileRestrictions } from './checkFileRestrictions.js'\nimport { cropImage } from './cropImage.js'\nimport { getExternalFile } from './getExternalFile.js'\nimport { getFileByPath } from './getFileByPath.js'\nimport { getImageSize } from './getImageSize.js'\nimport { getSafeFileName } from './getSafeFilename.js'\nimport { createImageSizes } from './image-resizing/createImageSizes.js'\nimport { isImage } from './isImage.js'\nimport { optionallyAppendMetadata } from './optionallyAppendMetadata.js'\ntype Args<T> = {\n  collection: Collection\n  config: SanitizedConfig\n  data: T\n  isDuplicating?: boolean\n  operation: 'create' | 'update'\n  originalDoc?: T\n  overwriteExistingFiles?: boolean\n  req: PayloadRequest\n  throwOnMissingFile?: boolean\n}\n\ntype Result<T> = Promise<{\n  data: T\n  files: FileToSave[]\n}>\n\nconst shouldReupload = (\n  uploadEdits: UploadEdits,\n  fileData: Record<string, unknown> | undefined,\n) => {\n  if (!fileData) {\n    return false\n  }\n\n  if (uploadEdits.crop || uploadEdits.heightInPixels || uploadEdits.widthInPixels) {\n    return true\n  }\n\n  // Since uploadEdits always has focalPoint, compare to the value in the data if it was changed\n  if (uploadEdits.focalPoint) {\n    const incomingFocalX = uploadEdits.focalPoint.x\n    const incomingFocalY = uploadEdits.focalPoint.y\n\n    const currentFocalX = 'focalX' in fileData && fileData.focalX\n    const currentFocalY = 'focalY' in fileData && fileData.focalY\n\n    const isEqual = incomingFocalX === currentFocalX && incomingFocalY === currentFocalY\n    return !isEqual\n  }\n\n  return false\n}\n\nexport const generateFileData = async <T>({\n  collection: { config: collectionConfig },\n  data,\n  isDuplicating,\n  operation,\n  originalDoc,\n  overwriteExistingFiles,\n  req,\n  throwOnMissingFile,\n}: Args<T>): Result<T> => {\n  if (!collectionConfig.upload) {\n    return {\n      data,\n      files: [],\n    }\n  }\n\n  const { serverURL, sharp } = req.payload.config\n\n  let file = req.file\n\n  const uploadEdits = parseUploadEditsFromReqOrIncomingData({\n    data,\n    isDuplicating,\n    operation,\n    originalDoc,\n    req,\n  })\n\n  const {\n    constructorOptions,\n    disableLocalStorage,\n    focalPoint: focalPointEnabled = true,\n    formatOptions,\n    imageSizes,\n    resizeOptions,\n    staticDir,\n    trimOptions,\n    withMetadata,\n  } = collectionConfig.upload\n\n  const staticPath = staticDir\n\n  const incomingFileData: Document = isDuplicating ? originalDoc : data\n  let isLocalFile = false\n\n  if (\n    !file &&\n    (isDuplicating || shouldReupload(uploadEdits, incomingFileData as Record<string, unknown>))\n  ) {\n    const { filename, url } = incomingFileData as unknown as FileData\n    if (filename && (filename.includes('../') || filename.includes('..\\\\'))) {\n      throw new Forbidden(req.t)\n    }\n\n    if ((serverURL && url?.startsWith(serverURL)) || url?.startsWith('/')) {\n      isLocalFile = true\n    }\n\n    try {\n      if (!disableLocalStorage && isLocalFile) {\n        // File is stored locally\n        const filePath = `${staticPath}/${filename}`\n        const response = await getFileByPath(filePath)\n        file = response\n        overwriteExistingFiles = true\n      } else if (filename && url) {\n        // File is remote\n        file = await getExternalFile({\n          data: incomingFileData as unknown as FileData,\n          req,\n          uploadConfig: collectionConfig.upload,\n        })\n        overwriteExistingFiles = true\n      }\n    } catch (err: unknown) {\n      throw new FileRetrievalError(req.t, err instanceof Error ? err.message : undefined)\n    }\n  }\n\n  if (isDuplicating) {\n    overwriteExistingFiles = false\n  }\n\n  if (!file) {\n    if (throwOnMissingFile) {\n      throw new MissingFile(req.t)\n    }\n\n    return {\n      data: incomingFileData!,\n      files: [],\n    }\n  }\n\n  await checkFileRestrictions({\n    collection: collectionConfig,\n    file,\n    req,\n  })\n\n  if (!disableLocalStorage) {\n    await fs.mkdir(staticPath!, { recursive: true })\n  }\n\n  let newData = incomingFileData as T\n  const filesToSave: FileToSave[] = []\n  const fileData: Partial<FileData> = {}\n  const fileIsAnimatedType = ['image/avif', 'image/gif', 'image/webp'].includes(file.mimetype)\n  const cropData =\n    typeof uploadEdits === 'object' && 'crop' in uploadEdits ? uploadEdits.crop : undefined\n\n  try {\n    const fileSupportsResize = canResizeImage(file.mimetype)\n    let fsSafeName: string\n    let sharpFile: Sharp | undefined\n    let dimensions: ProbedImageSize | undefined\n    let fileBuffer!: { data: Buffer; info: OutputInfo }\n    let ext\n    let mime: string\n    const fileHasAdjustments =\n      fileSupportsResize &&\n      Boolean(\n        resizeOptions || formatOptions || trimOptions || constructorOptions || file.tempFilePath,\n      )\n\n    const sharpOptions: SharpOptions = { ...constructorOptions }\n\n    if (fileIsAnimatedType) {\n      sharpOptions.animated = true\n    }\n\n    if (sharp && (fileIsAnimatedType || fileHasAdjustments)) {\n      if (file.tempFilePath) {\n        sharpFile = sharp(file.tempFilePath, sharpOptions).rotate() // pass rotate() to auto-rotate based on EXIF data. https://github.com/payloadcms/payload/pull/3081\n      } else {\n        sharpFile = sharp(file.data, sharpOptions).rotate() // pass rotate() to auto-rotate based on EXIF data. https://github.com/payloadcms/payload/pull/3081\n      }\n\n      if (fileHasAdjustments) {\n        if (resizeOptions) {\n          sharpFile = sharpFile.resize(resizeOptions)\n        }\n        if (formatOptions) {\n          sharpFile = sharpFile.toFormat(formatOptions.format, formatOptions.options)\n        }\n        if (trimOptions) {\n          sharpFile = sharpFile.trim(trimOptions)\n        }\n      }\n    }\n\n    if (fileSupportsResize || isImage(file.mimetype)) {\n      dimensions = await getImageSize(file)\n      fileData.width = dimensions.width\n      fileData.height = dimensions.height\n    }\n\n    if (sharpFile) {\n      const metadata = await sharpFile.metadata()\n      sharpFile = await optionallyAppendMetadata({\n        req,\n        sharpFile,\n        withMetadata: withMetadata!,\n      })\n      fileBuffer = await sharpFile.toBuffer({ resolveWithObject: true })\n      ;({ ext, mime } = (await fileTypeFromBuffer(fileBuffer.data))!) // This is getting an incorrect gif height back.\n      fileData.width = fileBuffer.info.width\n      fileData.height = fileBuffer.info.height\n      fileData.filesize = fileBuffer.info.size\n\n      // Animated GIFs + WebP aggregate the height from every frame, so we need to use divide by number of pages\n      if (metadata.pages) {\n        fileData.height = fileBuffer.info.height / metadata.pages\n        fileData.filesize = fileBuffer.data.length\n      }\n    } else {\n      mime = file.mimetype\n      fileData.filesize = file.size\n\n      if (file.name.includes('.')) {\n        ext = file.name.split('.').pop()?.split('?')[0]\n      } else {\n        ext = ''\n      }\n    }\n\n    // Adjust SVG mime type. fromBuffer modifies it.\n    if (mime === 'application/xml' && ext === 'svg') {\n      mime = 'image/svg+xml'\n    }\n    fileData.mimeType = mime\n\n    const baseFilename = sanitize(file.name.substring(0, file.name.lastIndexOf('.')) || file.name)\n    fsSafeName = `${baseFilename}${ext ? `.${ext}` : ''}`\n\n    if (!overwriteExistingFiles) {\n      // Extract prefix if present (added by plugin-cloud-storage)\n      const prefix = (data as Record<string, unknown>)?.prefix as string | undefined\n      fsSafeName = await getSafeFileName({\n        collectionSlug: collectionConfig.slug,\n        desiredFilename: fsSafeName,\n        prefix,\n        req,\n        staticPath: staticPath!,\n      })\n    }\n\n    fileData.filename = fsSafeName\n\n    let fileForResize = file\n\n    if (cropData && sharp) {\n      const { data: croppedImage, info } = await cropImage({\n        cropData,\n        dimensions: dimensions!,\n        file,\n        heightInPixels: uploadEdits.heightInPixels!,\n        req,\n        sharp,\n        widthInPixels: uploadEdits.widthInPixels!,\n        withMetadata,\n      })\n\n      // Apply resize after cropping to ensure it conforms to resizeOptions\n      if (resizeOptions && !resizeOptions.withoutEnlargement) {\n        const resizedAfterCrop = await sharp(croppedImage)\n          .resize({\n            fit: resizeOptions?.fit || 'cover',\n            height: resizeOptions?.height,\n            position: resizeOptions?.position || 'center',\n            width: resizeOptions?.width,\n          })\n          .toBuffer({ resolveWithObject: true })\n\n        filesToSave.push({\n          buffer: resizedAfterCrop.data,\n          path: `${staticPath}/${fsSafeName}`,\n        })\n\n        fileForResize = {\n          ...fileForResize,\n          data: resizedAfterCrop.data,\n          size: resizedAfterCrop.info.size,\n        }\n\n        fileData.width = resizedAfterCrop.info.width\n        fileData.height = resizedAfterCrop.info.height\n        if (fileIsAnimatedType) {\n          const metadata = await sharpFile!.metadata()\n          fileData.height = metadata.pages\n            ? resizedAfterCrop.info.height / metadata.pages\n            : resizedAfterCrop.info.height\n        }\n        fileData.filesize = resizedAfterCrop.info.size\n      } else {\n        // If resizeOptions is not present, just save the cropped image\n        filesToSave.push({\n          buffer: croppedImage,\n          path: `${staticPath}/${fsSafeName}`,\n        })\n\n        fileForResize = {\n          ...file,\n          data: croppedImage,\n          size: info.size,\n        }\n\n        fileData.width = info.width\n        fileData.height = info.height\n        if (fileIsAnimatedType) {\n          const metadata = await sharpFile!.metadata()\n          fileData.height = metadata.pages ? info.height / metadata.pages : info.height\n        }\n        fileData.filesize = info.size\n      }\n\n      if (file.tempFilePath) {\n        await fs.writeFile(file.tempFilePath, croppedImage) // write fileBuffer to the temp path\n      } else {\n        req.file = fileForResize\n      }\n    } else {\n      filesToSave.push({\n        buffer: fileBuffer?.data || file.data,\n        path: `${staticPath}/${fsSafeName}`,\n      })\n\n      // If using temp files and the image is being resized, write the file to the temp path\n      if (fileBuffer?.data || file.data.length > 0) {\n        if (file.tempFilePath) {\n          await fs.writeFile(file.tempFilePath, fileBuffer?.data || file.data) // write fileBuffer to the temp path\n        } else {\n          // Assign the _possibly modified_ file to the request object\n          req.file = {\n            ...file,\n            data: fileBuffer?.data || file.data,\n            size: fileBuffer?.info.size,\n          }\n        }\n      }\n    }\n\n    if (fileSupportsResize && (Array.isArray(imageSizes) || focalPointEnabled !== false)) {\n      req.payloadUploadSizes = {}\n      // Focal point adjustments\n      const focalPoint =\n        focalPointEnabled && uploadEdits?.focalPoint\n          ? {\n              x: isNumber(uploadEdits.focalPoint.x) ? Math.round(uploadEdits.focalPoint.x) : 50,\n              y: isNumber(uploadEdits.focalPoint.y) ? Math.round(uploadEdits.focalPoint.y) : 50,\n            }\n          : undefined\n\n      const { sizeData, sizesToSave } = await createImageSizes({\n        config: collectionConfig,\n        dimensions: !cropData\n          ? dimensions!\n          : {\n              ...dimensions,\n              height: fileData.height!,\n              width: fileData.width!,\n            },\n        file: fileForResize,\n        focalPoint,\n        mimeType: fileData.mimeType,\n        req,\n        savedFilename: fsSafeName || file.name,\n        sharp,\n        staticPath: staticPath!,\n        withMetadata,\n      })\n\n      fileData.sizes = sizeData\n      fileData.focalX = focalPoint?.x\n      fileData.focalY = focalPoint?.y\n      filesToSave.push(...sizesToSave)\n    }\n  } catch (err) {\n    req.payload.logger.error(err)\n    throw new FileUploadError(req.t)\n  }\n\n  newData = {\n    ...newData,\n    ...fileData,\n  }\n\n  return {\n    data: newData,\n    files: filesToSave,\n  }\n}\n\n/**\n * Parse upload edits from req or incoming data\n */\nfunction parseUploadEditsFromReqOrIncomingData(args: {\n  data: unknown\n  isDuplicating?: boolean\n  operation: 'create' | 'update'\n  originalDoc: unknown\n  req: PayloadRequest\n}): UploadEdits {\n  const { data, isDuplicating, operation, originalDoc, req } = args\n\n  // Get intended focal point change from query string or incoming data\n  const uploadEdits =\n    req.query?.uploadEdits && typeof req.query.uploadEdits === 'object'\n      ? (req.query.uploadEdits as UploadEdits)\n      : {}\n\n  if (uploadEdits.focalPoint) {\n    return uploadEdits\n  }\n\n  const incomingData = data as FileData\n  const origDoc = originalDoc as FileData\n\n  if (origDoc && 'focalX' in origDoc && 'focalY' in origDoc) {\n    // If no change in focal point, return undefined.\n    // This prevents a refocal operation triggered from admin, because it always sends the focal point.\n    if (incomingData.focalX === origDoc.focalX && incomingData.focalY === origDoc.focalY) {\n      return undefined!\n    }\n\n    if (isDuplicating) {\n      uploadEdits.focalPoint = {\n        x: incomingData?.focalX || origDoc.focalX!,\n        y: incomingData?.focalY || origDoc.focalY!,\n      }\n      return uploadEdits\n    }\n  }\n\n  if (incomingData?.focalX && incomingData?.focalY) {\n    uploadEdits.focalPoint = {\n      x: incomingData.focalX,\n      y: incomingData.focalY,\n    }\n    return uploadEdits\n  }\n\n  // If no focal point is set, default to center\n  if (operation === 'create') {\n    uploadEdits.focalPoint = {\n      x: 50,\n      y: 50,\n    }\n  }\n\n  return uploadEdits\n}\n"],"names":["fileTypeFromBuffer","fs","sanitize","FileRetrievalError","FileUploadError","Forbidden","MissingFile","isNumber","canResizeImage","checkFileRestrictions","cropImage","getExternalFile","getFileByPath","getImageSize","getSafeFileName","createImageSizes","isImage","optionallyAppendMetadata","shouldReupload","uploadEdits","fileData","crop","heightInPixels","widthInPixels","focalPoint","incomingFocalX","x","incomingFocalY","y","currentFocalX","focalX","currentFocalY","focalY","isEqual","generateFileData","collection","config","collectionConfig","data","isDuplicating","operation","originalDoc","overwriteExistingFiles","req","throwOnMissingFile","upload","files","serverURL","sharp","payload","file","parseUploadEditsFromReqOrIncomingData","constructorOptions","disableLocalStorage","focalPointEnabled","formatOptions","imageSizes","resizeOptions","staticDir","trimOptions","withMetadata","staticPath","incomingFileData","isLocalFile","filename","url","includes","t","startsWith","filePath","response","uploadConfig","err","Error","message","undefined","mkdir","recursive","newData","filesToSave","fileIsAnimatedType","mimetype","cropData","fileSupportsResize","fsSafeName","sharpFile","dimensions","fileBuffer","ext","mime","fileHasAdjustments","Boolean","tempFilePath","sharpOptions","animated","rotate","resize","toFormat","format","options","trim","width","height","metadata","toBuffer","resolveWithObject","info","filesize","size","pages","length","name","split","pop","mimeType","baseFilename","substring","lastIndexOf","prefix","collectionSlug","slug","desiredFilename","fileForResize","croppedImage","withoutEnlargement","resizedAfterCrop","fit","position","push","buffer","path","writeFile","Array","isArray","payloadUploadSizes","Math","round","sizeData","sizesToSave","savedFilename","sizes","logger","error","args","query","incomingData","origDoc"],"mappings":"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"}},
    {"offset": {"line": 2759, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/uploads/unlinkTempFiles.ts"],"sourcesContent":["import fs from 'fs/promises'\n\nimport type { SanitizedCollectionConfig } from '../collections/config/types.js'\nimport type { SanitizedConfig } from '../config/types.js'\nimport type { PayloadRequest } from '../types/index.js'\n\nimport { mapAsync } from '../utilities/mapAsync.js'\n\ntype Args = {\n  collectionConfig: SanitizedCollectionConfig\n  config: SanitizedConfig\n  req: PayloadRequest\n}\n/**\n * Cleanup temp files after operation lifecycle\n */\nexport const unlinkTempFiles: (args: Args) => Promise<void> = async ({\n  collectionConfig,\n  config,\n  req,\n}) => {\n  if (config.upload?.useTempFiles && collectionConfig.upload) {\n    const { file } = req\n    const fileArray = [{ file }]\n    await mapAsync(fileArray, async ({ file }) => {\n      // Still need this check because this will not be populated if using local API\n      if (file?.tempFilePath) {\n        await fs.unlink(file.tempFilePath)\n      }\n    })\n  }\n}\n"],"names":["fs","mapAsync","unlinkTempFiles","collectionConfig","config","req","upload","useTempFiles","file","fileArray","tempFilePath","unlink"],"mappings":";;;;AAAA,OAAOA,QAAQ,cAAa;AAM5B,SAASC,QAAQ,QAAQ,2BAA0B;;;AAU5C,MAAMC,kBAAiD,OAAO,EACnEC,gBAAgB,EAChBC,MAAM,EACNC,GAAG,EACJ;IACC,IAAID,OAAOE,MAAM,EAAEC,gBAAgBJ,iBAAiBG,MAAM,EAAE;QAC1D,MAAM,EAAEE,IAAI,EAAE,GAAGH;QACjB,MAAMI,YAAY;YAAC;gBAAED;YAAK;SAAE;QAC5B,UAAMP,sKAAAA,EAASQ,WAAW,OAAO,EAAED,IAAI,EAAE;YACvC,8EAA8E;YAC9E,IAAIA,MAAME,cAAc;gBACtB,MAAMV,gIAAAA,CAAGW,MAAM,CAACH,KAAKE,YAAY;YACnC;QACF;IACF;AACF,EAAC"}},
    {"offset": {"line": 2787, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/uploads/saveBufferToFile.ts"],"sourcesContent":["import fs from 'fs/promises'\nimport { Readable } from 'stream'\n\n/**\n * Save buffer data to a file.\n * @param {Buffer} buffer - buffer to save to a file.\n * @param {string} filePath - path to a file.\n */\nexport const saveBufferToFile = async (buffer: Buffer, filePath: string): Promise<void> => {\n  // Setup readable stream from buffer.\n  let streamData = buffer\n  const readStream = new Readable()\n  readStream._read = () => {\n    readStream.push(streamData)\n    streamData = null!\n  }\n  // Setup file system writable stream.\n  return await fs.writeFile(filePath, buffer)\n}\n"],"names":["fs","Readable","saveBufferToFile","buffer","filePath","streamData","readStream","_read","push","writeFile"],"mappings":";;;;AAAA,OAAOA,QAAQ,cAAa;AAC5B,SAASC,QAAQ,QAAQ,SAAQ;;;AAO1B,MAAMC,mBAAmB,OAAOC,QAAgBC;IACrD,qCAAqC;IACrC,IAAIC,aAAaF;IACjB,MAAMG,aAAa,IAAIL,iHAAAA;IACvBK,WAAWC,KAAK,GAAG;QACjBD,WAAWE,IAAI,CAACH;QAChBA,aAAa;IACf;IACA,qCAAqC;IACrC,OAAO,MAAML,gIAAAA,CAAGS,SAAS,CAACL,UAAUD;AACtC,EAAC"}},
    {"offset": {"line": 2810, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/uploads/uploadFiles.ts"],"sourcesContent":["import type { Payload } from '../index.js'\nimport type { PayloadRequest } from '../types/index.js'\nimport type { FileToSave } from './types.js'\n\nimport { FileUploadError } from '../errors/index.js'\nimport { saveBufferToFile } from './saveBufferToFile.js'\n\nexport const uploadFiles = async (\n  payload: Payload,\n  files: FileToSave[],\n  req: PayloadRequest,\n): Promise<void> => {\n  try {\n    await Promise.all(\n      files.map(async ({ buffer, path }) => {\n        await saveBufferToFile(buffer, path)\n      }),\n    )\n  } catch (err) {\n    payload.logger.error(err)\n    throw new FileUploadError(req.t)\n  }\n}\n"],"names":["FileUploadError","saveBufferToFile","uploadFiles","payload","files","req","Promise","all","map","buffer","path","err","logger","error","t"],"mappings":";;;;AAIA,SAASA,eAAe,QAAQ,qBAAoB;AACpD,SAASC,gBAAgB,QAAQ,wBAAuB;;;AAEjD,MAAMC,cAAc,OACzBC,SACAC,OACAC;IAEA,IAAI;QACF,MAAMC,QAAQC,GAAG,CACfH,MAAMI,GAAG,CAAC,OAAO,EAAEC,MAAM,EAAEC,IAAI,EAAE;YAC/B,UAAMT,oLAAAA,EAAiBQ,QAAQC;QACjC;IAEJ,EAAE,OAAOC,KAAK;QACZR,QAAQS,MAAM,CAACC,KAAK,CAACF;QACrB,MAAM,IAAIX,iLAAAA,CAAgBK,IAAIS,CAAC;IACjC;AACF,EAAC"}},
    {"offset": {"line": 2832, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/uploads/deleteAssociatedFiles.ts"],"sourcesContent":["import fs from 'fs/promises'\n\nimport type { SanitizedCollectionConfig } from '../collections/config/types.js'\nimport type { SanitizedConfig } from '../config/types.js'\nimport type { PayloadRequest } from '../types/index.js'\nimport type { FileData, FileToSave } from './types.js'\n\nimport { ErrorDeletingFile } from '../errors/index.js'\nimport { fileExists } from './fileExists.js'\n\ntype Args = {\n  collectionConfig: SanitizedCollectionConfig\n  config: SanitizedConfig\n  doc: Record<string, unknown>\n  files?: FileToSave[]\n  overrideDelete: boolean\n  req: PayloadRequest\n}\n\nexport const deleteAssociatedFiles: (args: Args) => Promise<void> = async ({\n  collectionConfig,\n  doc,\n  files = [],\n  overrideDelete,\n  req,\n}) => {\n  if (!collectionConfig.upload) {\n    return\n  }\n  if (overrideDelete || files.length > 0) {\n    const { staticDir: staticPath } = collectionConfig.upload\n\n    const fileToDelete = `${staticPath}/${doc.filename as string}`\n\n    try {\n      if (await fileExists(fileToDelete)) {\n        await fs.unlink(fileToDelete)\n      }\n    } catch (ignore) {\n      throw new ErrorDeletingFile(req.t)\n    }\n\n    if (doc.sizes) {\n      const sizes: FileData[] = Object.values(doc.sizes)\n      // Since forEach will not wait until unlink is finished it could\n      // happen that two operations will try to delete the same file.\n      // To avoid this it is recommended to use \"sync\" instead\n\n      for (const size of sizes) {\n        const sizeToDelete = `${staticPath}/${size.filename}`\n        try {\n          if (await fileExists(sizeToDelete)) {\n            await fs.unlink(sizeToDelete)\n          }\n        } catch (ignore) {\n          throw new ErrorDeletingFile(req.t)\n        }\n      }\n    }\n  }\n}\n"],"names":["fs","ErrorDeletingFile","fileExists","deleteAssociatedFiles","collectionConfig","doc","files","overrideDelete","req","upload","length","staticDir","staticPath","fileToDelete","filename","unlink","ignore","t","sizes","Object","values","size","sizeToDelete"],"mappings":";;;;AAAA,OAAOA,QAAQ,cAAa;AAO5B,SAASC,iBAAiB,QAAQ,qBAAoB;AACtD,SAASC,UAAU,QAAQ,kBAAiB;;;;AAWrC,MAAMC,wBAAuD,OAAO,EACzEC,gBAAgB,EAChBC,GAAG,EACHC,QAAQ,EAAE,EACVC,cAAc,EACdC,GAAG,EACJ;IACC,IAAI,CAACJ,iBAAiBK,MAAM,EAAE;QAC5B;IACF;IACA,IAAIF,kBAAkBD,MAAMI,MAAM,GAAG,GAAG;QACtC,MAAM,EAAEC,WAAWC,UAAU,EAAE,GAAGR,iBAAiBK,MAAM;QAEzD,MAAMI,eAAe,GAAGD,WAAW,CAAC,EAAEP,IAAIS,QAAQ,EAAY;QAE9D,IAAI;YACF,IAAI,UAAMZ,wKAAAA,EAAWW,eAAe;gBAClC,MAAMb,gIAAAA,CAAGe,MAAM,CAACF;YAClB;QACF,EAAE,OAAOG,QAAQ;YACf,MAAM,IAAIf,qLAAAA,CAAkBO,IAAIS,CAAC;QACnC;QAEA,IAAIZ,IAAIa,KAAK,EAAE;YACb,MAAMA,QAAoBC,OAAOC,MAAM,CAACf,IAAIa,KAAK;YACjD,gEAAgE;YAChE,+DAA+D;YAC/D,wDAAwD;YAExD,KAAK,MAAMG,QAAQH,MAAO;gBACxB,MAAMI,eAAe,GAAGV,WAAW,CAAC,EAAES,KAAKP,QAAQ,EAAE;gBACrD,IAAI;oBACF,IAAI,UAAMZ,wKAAAA,EAAWoB,eAAe;wBAClC,MAAMtB,gIAAAA,CAAGe,MAAM,CAACO;oBAClB;gBACF,EAAE,OAAON,QAAQ;oBACf,MAAM,IAAIf,qLAAAA,CAAkBO,IAAIS,CAAC;gBACnC;YACF;QACF;IACF;AACF,EAAC"}},
    {"offset": {"line": 2878, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/versions/defaults.ts"],"sourcesContent":["export const versionDefaults = {\n  autosaveInterval: 2000,\n}\n"],"names":["versionDefaults","autosaveInterval"],"mappings":";;;;AAAO,MAAMA,kBAAkB;IAC7BC,kBAAkB;AACpB,EAAC"}},
    {"offset": {"line": 2889, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/versions/drafts/appendVersionToQueryKey.ts"],"sourcesContent":["import type { Where } from '../../types/index.js'\n\nexport const appendVersionToQueryKey = (query: Where = {}): Where => {\n  return Object.entries(query).reduce((res, [key, val]) => {\n    if (['AND', 'and', 'OR', 'or'].includes(key) && Array.isArray(val)) {\n      return {\n        ...res,\n        [key.toLowerCase()]: val.map((subQuery) => appendVersionToQueryKey(subQuery)),\n      }\n    }\n\n    if (key !== 'id') {\n      return {\n        ...res,\n        [`version.${key}`]: val,\n      }\n    }\n\n    return {\n      ...res,\n      parent: val,\n    }\n  }, {})\n}\n"],"names":["appendVersionToQueryKey","query","Object","entries","reduce","res","key","val","includes","Array","isArray","toLowerCase","map","subQuery","parent"],"mappings":";;;;AAEO,MAAMA,0BAA0B,CAACC,QAAe,CAAC,CAAC;IACvD,OAAOC,OAAOC,OAAO,CAACF,OAAOG,MAAM,CAAC,CAACC,KAAK,CAACC,KAAKC,IAAI;QAClD,IAAI;YAAC;YAAO;YAAO;YAAM;SAAK,CAACC,QAAQ,CAACF,QAAQG,MAAMC,OAAO,CAACH,MAAM;YAClE,OAAO;gBACL,GAAGF,GAAG;gBACN,CAACC,IAAIK,WAAW,GAAG,EAAEJ,IAAIK,GAAG,CAAC,CAACC,WAAab,wBAAwBa;YACrE;QACF;QAEA,IAAIP,QAAQ,MAAM;YAChB,OAAO;gBACL,GAAGD,GAAG;gBACN,CAAC,CAAC,QAAQ,EAAEC,KAAK,CAAC,EAAEC;YACtB;QACF;QAEA,OAAO;YACL,GAAGF,GAAG;YACNS,QAAQP;QACV;IACF,GAAG,CAAC;AACN,EAAC"}},
    {"offset": {"line": 2922, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/versions/getLatestCollectionVersion.ts"],"sourcesContent":["import type { SanitizedCollectionConfig, TypeWithID } from '../collections/config/types.js'\nimport type { FindOneArgs } from '../database/types.js'\nimport type { Payload, PayloadRequest, Where } from '../types/index.js'\nimport type { TypeWithVersion } from './types.js'\n\nimport { combineQueries } from '../database/combineQueries.js'\nimport { hasDraftsEnabled } from '../utilities/getVersionsConfig.js'\nimport { appendVersionToQueryKey } from './drafts/appendVersionToQueryKey.js'\n\ntype Args = {\n  config: SanitizedCollectionConfig\n  id: number | string\n  payload: Payload\n  published?: boolean\n  query: FindOneArgs\n  req?: PayloadRequest\n}\n\nexport const getLatestCollectionVersion = async <T extends TypeWithID = any>({\n  id,\n  config,\n  payload,\n  published,\n  query,\n  req,\n}: Args): Promise<T | undefined> => {\n  let latestVersion!: TypeWithVersion<T>\n\n  const whereQuery = published\n    ? { and: [{ parent: { equals: id } }, { 'version._status': { equals: 'published' } }] }\n    : { and: [{ parent: { equals: id } }, { latest: { equals: true } }] }\n\n  if (hasDraftsEnabled(config)) {\n    const { docs } = await payload.db.findVersions<T>({\n      collection: config.slug,\n      limit: 1,\n      locale: req?.locale || query.locale,\n      pagination: false,\n      req,\n      sort: '-updatedAt',\n      where: combineQueries(appendVersionToQueryKey(query.where), whereQuery as unknown as Where),\n    })\n    latestVersion = docs[0]!\n  }\n\n  if (!latestVersion) {\n    if (!published) {\n      const doc = await payload.db.findOne<T>({ ...query, req })\n\n      return doc ?? undefined\n    }\n\n    return undefined\n  }\n\n  latestVersion.version.id = id\n\n  return latestVersion.version\n}\n"],"names":["combineQueries","hasDraftsEnabled","appendVersionToQueryKey","getLatestCollectionVersion","id","config","payload","published","query","req","latestVersion","whereQuery","and","parent","equals","latest","docs","db","findVersions","collection","slug","limit","locale","pagination","sort","where","doc","findOne","undefined","version"],"mappings":";;;;AAKA,SAASA,cAAc,QAAQ,gCAA+B;AAC9D,SAASC,gBAAgB,QAAQ,oCAAmC;AACpE,SAASC,uBAAuB,QAAQ,sCAAqC;;;;AAWtE,MAAMC,6BAA6B,OAAmC,EAC3EC,EAAE,EACFC,MAAM,EACNC,OAAO,EACPC,SAAS,EACTC,KAAK,EACLC,GAAG,EACE;IACL,IAAIC;IAEJ,MAAMC,aAAaJ,YACf;QAAEK,KAAK;YAAC;gBAAEC,QAAQ;oBAAEC,QAAQV;gBAAG;YAAE;YAAG;gBAAE,mBAAmB;oBAAEU,QAAQ;gBAAY;YAAE;SAAE;IAAC,IACpF;QAAEF,KAAK;YAAC;gBAAEC,QAAQ;oBAAEC,QAAQV;gBAAG;YAAE;YAAG;gBAAEW,QAAQ;oBAAED,QAAQ;gBAAK;YAAE;SAAE;IAAC;IAEtE,QAAIb,uLAAAA,EAAiBI,SAAS;QAC5B,MAAM,EAAEW,IAAI,EAAE,GAAG,MAAMV,QAAQW,EAAE,CAACC,YAAY,CAAI;YAChDC,YAAYd,OAAOe,IAAI;YACvBC,OAAO;YACPC,QAAQb,KAAKa,UAAUd,MAAMc,MAAM;YACnCC,YAAY;YACZd;YACAe,MAAM;YACNC,WAAOzB,iLAAAA,MAAeE,6MAAAA,EAAwBM,MAAMiB,KAAK,GAAGd;QAC9D;QACAD,gBAAgBM,IAAI,CAAC,EAAE;IACzB;IAEA,IAAI,CAACN,eAAe;QAClB,IAAI,CAACH,WAAW;YACd,MAAMmB,MAAM,MAAMpB,QAAQW,EAAE,CAACU,OAAO,CAAI;gBAAE,GAAGnB,KAAK;gBAAEC;YAAI;YAExD,OAAOiB,OAAOE;QAChB;QAEA,OAAOA;IACT;IAEAlB,cAAcmB,OAAO,CAACzB,EAAE,GAAGA;IAE3B,OAAOM,cAAcmB,OAAO;AAC9B,EAAC"}},
    {"offset": {"line": 2990, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/versions/drafts/getQueryDraftsSelect.ts"],"sourcesContent":["import type { SelectType } from '../../types/index.js'\n\nimport { getSelectMode } from '../../utilities/getSelectMode.js'\n\nexport const getQueryDraftsSelect = ({\n  select,\n}: {\n  select?: SelectType\n}): SelectType | undefined => {\n  if (!select) {\n    return\n  }\n\n  const mode = getSelectMode(select)\n\n  if (mode === 'include') {\n    return {\n      parent: true,\n      version: select,\n    } as SelectType\n  }\n\n  return {\n    version: select,\n  } as SelectType\n}\n"],"names":["getSelectMode","getQueryDraftsSelect","select","mode","parent","version"],"mappings":";;;;AAEA,SAASA,aAAa,QAAQ,mCAAkC;;AAEzD,MAAMC,uBAAuB,CAAC,EACnCC,MAAM,EAGP;IACC,IAAI,CAACA,QAAQ;QACX;IACF;IAEA,MAAMC,WAAOH,gLAAAA,EAAcE;IAE3B,IAAIC,SAAS,WAAW;QACtB,OAAO;YACLC,QAAQ;YACRC,SAASH;QACX;IACF;IAEA,OAAO;QACLG,SAASH;IACX;AACF,EAAC"}},
    {"offset": {"line": 3015, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/versions/enforceMaxVersions.ts"],"sourcesContent":["import type { SanitizedCollectionConfig } from '../collections/config/types.js'\nimport type { DeleteVersionsArgs } from '../database/types.js'\nimport type { SanitizedGlobalConfig } from '../globals/config/types.js'\nimport type { Payload, PayloadRequest, Where } from '../types/index.js'\n\ntype Args = {\n  collection?: SanitizedCollectionConfig\n  global?: SanitizedGlobalConfig\n  id?: number | string\n  max: number\n  payload: Payload\n  req?: PayloadRequest\n}\n\nexport const enforceMaxVersions = async ({\n  id,\n  collection,\n  global: globalConfig,\n  max,\n  payload,\n  req,\n}: Args): Promise<void> => {\n  const entityType = collection ? 'collection' : 'global'\n  const slug = collection ? collection.slug : globalConfig?.slug\n\n  try {\n    const where: Where = {}\n    let oldestAllowedDoc\n\n    if (collection) {\n      where.parent = {\n        equals: id,\n      }\n\n      const query = await payload.db.findVersions({\n        collection: collection.slug,\n        limit: 1,\n        page: max + 1,\n        pagination: false,\n        req,\n        sort: '-updatedAt',\n        where,\n      })\n\n      ;[oldestAllowedDoc] = query.docs\n    } else if (globalConfig) {\n      const query = await payload.db.findGlobalVersions({\n        global: globalConfig.slug,\n        limit: 1,\n        page: max + 1,\n        pagination: false,\n        req,\n        sort: '-updatedAt',\n        where,\n      })\n\n      ;[oldestAllowedDoc] = query.docs\n    }\n\n    if (oldestAllowedDoc?.updatedAt) {\n      const deleteQuery: Where = {\n        updatedAt: {\n          less_than_equal: oldestAllowedDoc.updatedAt,\n        },\n      }\n\n      if (collection) {\n        deleteQuery.parent = {\n          equals: id,\n        }\n      }\n\n      const deleteVersionsArgs: DeleteVersionsArgs = { req, where: deleteQuery }\n\n      if (globalConfig) {\n        deleteVersionsArgs.globalSlug = slug\n      } else {\n        deleteVersionsArgs.collection = slug\n      }\n\n      await payload.db.deleteVersions(deleteVersionsArgs)\n    }\n  } catch (err) {\n    payload.logger.error(err)\n    payload.logger.error(\n      `There was an error cleaning up old versions for the ${entityType} ${slug}`,\n    )\n  }\n}\n"],"names":["enforceMaxVersions","id","collection","global","globalConfig","max","payload","req","entityType","slug","where","oldestAllowedDoc","parent","equals","query","db","findVersions","limit","page","pagination","sort","docs","findGlobalVersions","updatedAt","deleteQuery","less_than_equal","deleteVersionsArgs","globalSlug","deleteVersions","err","logger","error"],"mappings":";;;;AAcO,MAAMA,qBAAqB,OAAO,EACvCC,EAAE,EACFC,UAAU,EACVC,QAAQC,YAAY,EACpBC,GAAG,EACHC,OAAO,EACPC,GAAG,EACE;IACL,MAAMC,aAAaN,aAAa,eAAe;IAC/C,MAAMO,OAAOP,aAAaA,WAAWO,IAAI,GAAGL,cAAcK;IAE1D,IAAI;QACF,MAAMC,QAAe,CAAC;QACtB,IAAIC;QAEJ,IAAIT,YAAY;YACdQ,MAAME,MAAM,GAAG;gBACbC,QAAQZ;YACV;YAEA,MAAMa,QAAQ,MAAMR,QAAQS,EAAE,CAACC,YAAY,CAAC;gBAC1Cd,YAAYA,WAAWO,IAAI;gBAC3BQ,OAAO;gBACPC,MAAMb,MAAM;gBACZc,YAAY;gBACZZ;gBACAa,MAAM;gBACNV;YACF;YAEC,CAACC,iBAAiB,GAAGG,MAAMO,IAAI;QAClC,OAAO,IAAIjB,cAAc;YACvB,MAAMU,QAAQ,MAAMR,QAAQS,EAAE,CAACO,kBAAkB,CAAC;gBAChDnB,QAAQC,aAAaK,IAAI;gBACzBQ,OAAO;gBACPC,MAAMb,MAAM;gBACZc,YAAY;gBACZZ;gBACAa,MAAM;gBACNV;YACF;YAEC,CAACC,iBAAiB,GAAGG,MAAMO,IAAI;QAClC;QAEA,IAAIV,kBAAkBY,WAAW;YAC/B,MAAMC,cAAqB;gBACzBD,WAAW;oBACTE,iBAAiBd,iBAAiBY,SAAS;gBAC7C;YACF;YAEA,IAAIrB,YAAY;gBACdsB,YAAYZ,MAAM,GAAG;oBACnBC,QAAQZ;gBACV;YACF;YAEA,MAAMyB,qBAAyC;gBAAEnB;gBAAKG,OAAOc;YAAY;YAEzE,IAAIpB,cAAc;gBAChBsB,mBAAmBC,UAAU,GAAGlB;YAClC,OAAO;gBACLiB,mBAAmBxB,UAAU,GAAGO;YAClC;YAEA,MAAMH,QAAQS,EAAE,CAACa,cAAc,CAACF;QAClC;IACF,EAAE,OAAOG,KAAK;QACZvB,QAAQwB,MAAM,CAACC,KAAK,CAACF;QACrBvB,QAAQwB,MAAM,CAACC,KAAK,CAClB,CAAC,oDAAoD,EAAEvB,WAAW,CAAC,EAAEC,MAAM;IAE/E;AACF,EAAC"}},
    {"offset": {"line": 3082, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/versions/saveSnapshot.ts"],"sourcesContent":["import type { SanitizedCollectionConfig } from '../collections/config/types.js'\nimport type { SanitizedGlobalConfig } from '../globals/config/types.js'\nimport type { Payload, TypeWithVersion } from '../index.js'\nimport type { JsonObject, PayloadRequest, SelectType } from '../types/index.js'\n\nimport { deepCopyObjectSimple } from '../index.js'\nimport { getQueryDraftsSelect } from './drafts/getQueryDraftsSelect.js'\n\ntype Args<T extends JsonObject = JsonObject> = {\n  autosave?: boolean\n  collection?: SanitizedCollectionConfig\n  data?: T\n  global?: SanitizedGlobalConfig\n  id?: number | string\n  payload: Payload\n  publishSpecificLocale?: string\n  req?: PayloadRequest\n  select?: SelectType\n}\n\nexport const saveSnapshot = async <T extends JsonObject = JsonObject>({\n  id,\n  autosave,\n  collection,\n  data,\n  global,\n  payload,\n  publishSpecificLocale,\n  req,\n  select,\n}: Args<T>): Promise<Omit<TypeWithVersion<T>, 'parent'> | TypeWithVersion<T> | undefined> => {\n  const docData: {\n    _status?: 'draft'\n  } & T = deepCopyObjectSimple<T>(data || ({} as T))\n\n  if (docData._id) {\n    delete docData._id\n  }\n\n  const snapshotDate = new Date().toISOString()\n\n  const sharedCreateVersionArgs = {\n    autosave: Boolean(autosave),\n    createdAt: snapshotDate,\n    publishedLocale: publishSpecificLocale || undefined,\n    req,\n    returning: false,\n    select: getQueryDraftsSelect({ select }),\n    updatedAt: snapshotDate,\n    versionData: docData,\n  }\n\n  if (collection && id) {\n    return payload.db.createVersion<T>({\n      ...sharedCreateVersionArgs,\n      collectionSlug: collection.slug,\n      parent: id,\n      snapshot: true,\n    })\n  }\n  if (global) {\n    return payload.db.createGlobalVersion<T>({\n      ...sharedCreateVersionArgs,\n      globalSlug: global.slug,\n      snapshot: true,\n    })\n  }\n}\n"],"names":["deepCopyObjectSimple","getQueryDraftsSelect","saveSnapshot","id","autosave","collection","data","global","payload","publishSpecificLocale","req","select","docData","_id","snapshotDate","Date","toISOString","sharedCreateVersionArgs","Boolean","createdAt","publishedLocale","undefined","returning","updatedAt","versionData","db","createVersion","collectionSlug","slug","parent","snapshot","createGlobalVersion","globalSlug"],"mappings":";;;;AAKA,SAASA,oBAAoB,QAAQ,cAAa;AAClD,SAASC,oBAAoB,QAAQ,mCAAkC;;;AAchE,MAAMC,eAAe,OAA0C,EACpEC,EAAE,EACFC,QAAQ,EACRC,UAAU,EACVC,IAAI,EACJC,MAAM,EACNC,OAAO,EACPC,qBAAqB,EACrBC,GAAG,EACHC,MAAM,EACE;IACR,MAAMC,cAEEZ,wLAAAA,EAAwBM,QAAS,CAAC;IAE1C,IAAIM,QAAQC,GAAG,EAAE;QACf,OAAOD,QAAQC,GAAG;IACpB;IAEA,MAAMC,eAAe,IAAIC,OAAOC,WAAW;IAE3C,MAAMC,0BAA0B;QAC9Bb,UAAUc,QAAQd;QAClBe,WAAWL;QACXM,iBAAiBX,yBAAyBY;QAC1CX;QACAY,WAAW;QACXX,YAAQV,uMAAAA,EAAqB;YAAEU;QAAO;QACtCY,WAAWT;QACXU,aAAaZ;IACf;IAEA,IAAIP,cAAcF,IAAI;QACpB,OAAOK,QAAQiB,EAAE,CAACC,aAAa,CAAI;YACjC,GAAGT,uBAAuB;YAC1BU,gBAAgBtB,WAAWuB,IAAI;YAC/BC,QAAQ1B;YACR2B,UAAU;QACZ;IACF;IACA,IAAIvB,QAAQ;QACV,OAAOC,QAAQiB,EAAE,CAACM,mBAAmB,CAAI;YACvC,GAAGd,uBAAuB;YAC1Be,YAAYzB,OAAOqB,IAAI;YACvBE,UAAU;QACZ;IACF;AACF,EAAC"}},
    {"offset": {"line": 3128, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/versions/saveVersion.ts"],"sourcesContent":["import type { SanitizedCollectionConfig } from '../collections/config/types.js'\nimport type { SanitizedGlobalConfig } from '../globals/config/types.js'\nimport type { CreateGlobalVersionArgs, CreateVersionArgs, Payload } from '../index.js'\nimport type { JsonObject, PayloadRequest, SelectType } from '../types/index.js'\n\nimport { deepCopyObjectSimple } from '../index.js'\nimport { getVersionsMax } from '../utilities/getVersionsConfig.js'\nimport { sanitizeInternalFields } from '../utilities/sanitizeInternalFields.js'\nimport { getQueryDraftsSelect } from './drafts/getQueryDraftsSelect.js'\nimport { enforceMaxVersions } from './enforceMaxVersions.js'\nimport { saveSnapshot } from './saveSnapshot.js'\n\ntype Args<T extends JsonObject = JsonObject> = {\n  autosave?: boolean\n  collection?: SanitizedCollectionConfig\n  docWithLocales: T\n  draft?: boolean\n  global?: SanitizedGlobalConfig\n  id?: number | string\n  operation?: 'create' | 'restoreVersion' | 'update'\n  payload: Payload\n  publishSpecificLocale?: string\n  req?: PayloadRequest\n  returning?: boolean\n  select?: SelectType\n  snapshot?: any\n}\n\nexport async function saveVersion<TData extends JsonObject = JsonObject>(\n  args: { returning: false } & Args<TData>,\n): Promise<null>\nexport async function saveVersion<TData extends JsonObject = JsonObject>(\n  args: { returning: true } & Args<TData>,\n): Promise<JsonObject>\nexport async function saveVersion<TData extends JsonObject = JsonObject>(\n  args: Omit<Args<TData>, 'returning'>,\n): Promise<JsonObject>\nexport async function saveVersion<TData extends JsonObject = JsonObject>({\n  id,\n  autosave,\n  collection,\n  docWithLocales,\n  draft,\n  global,\n  operation,\n  payload,\n  publishSpecificLocale,\n  req,\n  returning,\n  select,\n  snapshot,\n}: Args<TData>): Promise<JsonObject | null> {\n  let result: JsonObject | undefined\n  let createNewVersion = true\n  const now = new Date().toISOString()\n  const versionData: {\n    _status?: 'draft'\n    updatedAt?: string\n  } & TData = deepCopyObjectSimple(docWithLocales)\n\n  if (collection?.timestamps && draft) {\n    versionData.updatedAt = now\n  }\n\n  if (versionData._id) {\n    delete versionData._id\n  }\n\n  try {\n    if (autosave) {\n      let docs\n      const findVersionArgs = {\n        limit: 1,\n        pagination: false,\n        req,\n        sort: '-updatedAt',\n      }\n\n      if (collection) {\n        ;({ docs } = await payload.db.findVersions<TData>({\n          ...findVersionArgs,\n          collection: collection.slug,\n          limit: 1,\n          pagination: false,\n          req,\n          where: {\n            parent: {\n              equals: id,\n            },\n          },\n        }))\n      } else {\n        ;({ docs } = await payload.db.findGlobalVersions<TData>({\n          ...findVersionArgs,\n          global: global!.slug,\n          limit: 1,\n          pagination: false,\n          req,\n        }))\n      }\n      const [latestVersion] = docs\n\n      // overwrite the latest version if it's set to autosave\n      if (latestVersion && 'autosave' in latestVersion && latestVersion.autosave === true) {\n        createNewVersion = false\n\n        const updateVersionArgs = {\n          id: latestVersion.id,\n          req,\n          versionData: {\n            createdAt: new Date(latestVersion.createdAt).toISOString(),\n            latest: true,\n            parent: id,\n            updatedAt: now,\n            version: {\n              ...versionData,\n            },\n          },\n        }\n\n        if (collection) {\n          result = await payload.db.updateVersion<TData>({\n            ...updateVersionArgs,\n            collection: collection.slug,\n            req,\n          })\n        } else {\n          result = await payload.db.updateGlobalVersion<TData>({\n            ...updateVersionArgs,\n            global: global!.slug,\n            req,\n          })\n        }\n      }\n    }\n\n    if (createNewVersion) {\n      const createVersionArgs = {\n        autosave: Boolean(autosave),\n        collectionSlug: undefined as string | undefined,\n        createdAt: operation === 'restoreVersion' ? versionData.createdAt : now,\n        globalSlug: undefined as string | undefined,\n        parent: collection ? id : undefined,\n        publishedLocale: publishSpecificLocale || undefined,\n        req,\n        returning,\n        select: getQueryDraftsSelect({ select }),\n        updatedAt: now,\n        versionData,\n      }\n\n      if (collection) {\n        createVersionArgs.collectionSlug = collection.slug\n        result = await payload.db.createVersion(createVersionArgs as CreateVersionArgs)\n      }\n\n      if (global) {\n        createVersionArgs.globalSlug = global.slug\n        result = await payload.db.createGlobalVersion(createVersionArgs as CreateGlobalVersionArgs)\n      }\n\n      if (snapshot) {\n        await saveSnapshot<TData>({\n          id,\n          autosave,\n          collection,\n          data: snapshot,\n          global,\n          payload,\n          publishSpecificLocale,\n          req,\n          select,\n        })\n      }\n    }\n  } catch (err) {\n    let errorMessage: string | undefined\n\n    if (collection) {\n      errorMessage = `There was an error while saving a version for the ${typeof collection.labels.singular === 'string' ? collection.labels.singular : collection.slug} with ID ${id}.`\n    }\n    if (global) {\n      errorMessage = `There was an error while saving a version for the global ${typeof global.label === 'string' ? global.label : global.slug}.`\n    }\n    payload.logger.error({ err, msg: errorMessage })\n    return undefined!\n  }\n\n  const max = getVersionsMax(collection || global!)\n\n  if (createNewVersion && max > 0) {\n    await enforceMaxVersions({\n      id,\n      collection,\n      global,\n      max,\n      payload,\n      req,\n    })\n  }\n  if (returning === false) {\n    return null\n  }\n\n  let createdVersion = (result as any).version\n\n  createdVersion = sanitizeInternalFields(createdVersion)\n  createdVersion.id = (result as any).parent\n\n  return createdVersion\n}\n"],"names":["deepCopyObjectSimple","getVersionsMax","sanitizeInternalFields","getQueryDraftsSelect","enforceMaxVersions","saveSnapshot","saveVersion","id","autosave","collection","docWithLocales","draft","global","operation","payload","publishSpecificLocale","req","returning","select","snapshot","result","createNewVersion","now","Date","toISOString","versionData","timestamps","updatedAt","_id","docs","findVersionArgs","limit","pagination","sort","db","findVersions","slug","where","parent","equals","findGlobalVersions","latestVersion","updateVersionArgs","createdAt","latest","version","updateVersion","updateGlobalVersion","createVersionArgs","Boolean","collectionSlug","undefined","globalSlug","publishedLocale","createVersion","createGlobalVersion","data","err","errorMessage","labels","singular","label","logger","error","msg","max","createdVersion"],"mappings":"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"}},
    {"offset": {"line": 3295, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/versions/deleteCollectionVersions.ts"],"sourcesContent":["import type { PayloadRequest } from '../types/index.js'\n\nimport { type Payload } from '../index.js'\n\ntype Args = {\n  id?: number | string\n  payload: Payload\n  req?: PayloadRequest\n  slug: string\n}\n\nexport const deleteCollectionVersions = async ({ id, slug, payload, req }: Args): Promise<void> => {\n  try {\n    await payload.db.deleteVersions({\n      collection: slug,\n      req,\n      where: {\n        parent: {\n          equals: id,\n        },\n      },\n    })\n  } catch (err) {\n    payload.logger.error({\n      err,\n      msg: `There was an error removing versions for the deleted ${slug} document with ID ${id}.`,\n    })\n  }\n}\n"],"names":["deleteCollectionVersions","id","slug","payload","req","db","deleteVersions","collection","where","parent","equals","err","logger","error","msg"],"mappings":";;;;AAWO,MAAMA,2BAA2B,OAAO,EAAEC,EAAE,EAAEC,IAAI,EAAEC,OAAO,EAAEC,GAAG,EAAQ;IAC7E,IAAI;QACF,MAAMD,QAAQE,EAAE,CAACC,cAAc,CAAC;YAC9BC,YAAYL;YACZE;YACAI,OAAO;gBACLC,QAAQ;oBACNC,QAAQT;gBACV;YACF;QACF;IACF,EAAE,OAAOU,KAAK;QACZR,QAAQS,MAAM,CAACC,KAAK,CAAC;YACnBF;YACAG,KAAK,CAAC,qDAAqD,EAAEZ,KAAK,kBAAkB,EAAED,GAAG,CAAC,CAAC;QAC7F;IACF;AACF,EAAC"}},
    {"offset": {"line": 3321, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/versions/deleteScheduledPublishJobs.ts"],"sourcesContent":["import type { PayloadRequest } from '../types/index.js'\n\nimport { type Payload } from '../index.js'\nimport { jobsCollectionSlug } from '../queues/config/collection.js'\n\ntype Args = {\n  id?: number | string\n  payload: Payload\n  req?: PayloadRequest\n  slug: string\n}\n\nexport const deleteScheduledPublishJobs = async ({\n  id,\n  slug,\n  payload,\n  req,\n}: Args): Promise<void> => {\n  try {\n    await payload.db.deleteMany({\n      collection: jobsCollectionSlug,\n      req,\n      where: {\n        and: [\n          // only want to delete jobs have not run yet\n          {\n            completedAt: {\n              exists: false,\n            },\n          },\n          {\n            processing: {\n              equals: false,\n            },\n          },\n          {\n            'input.doc.value': {\n              equals: id,\n            },\n          },\n          {\n            'input.doc.relationTo': {\n              equals: slug,\n            },\n          },\n          // data.type narrows scheduled publish jobs in case of another job having input.doc.value\n          {\n            taskSlug: {\n              equals: 'schedulePublish',\n            },\n          },\n        ],\n      },\n    })\n  } catch (err) {\n    payload.logger.error({\n      err,\n      msg: `There was an error deleting scheduled publish jobs from the queue for ${slug} document with ID ${id}.`,\n    })\n  }\n}\n"],"names":["jobsCollectionSlug","deleteScheduledPublishJobs","id","slug","payload","req","db","deleteMany","collection","where","and","completedAt","exists","processing","equals","taskSlug","err","logger","error","msg"],"mappings":";;;;AAGA,SAASA,kBAAkB,QAAQ,iCAAgC;;AAS5D,MAAMC,6BAA6B,OAAO,EAC/CC,EAAE,EACFC,IAAI,EACJC,OAAO,EACPC,GAAG,EACE;IACL,IAAI;QACF,MAAMD,QAAQE,EAAE,CAACC,UAAU,CAAC;YAC1BC,YAAYR,yLAAAA;YACZK;YACAI,OAAO;gBACLC,KAAK;oBACH,4CAA4C;oBAC5C;wBACEC,aAAa;4BACXC,QAAQ;wBACV;oBACF;oBACA;wBACEC,YAAY;4BACVC,QAAQ;wBACV;oBACF;oBACA;wBACE,mBAAmB;4BACjBA,QAAQZ;wBACV;oBACF;oBACA;wBACE,wBAAwB;4BACtBY,QAAQX;wBACV;oBACF;oBACA,yFAAyF;oBACzF;wBACEY,UAAU;4BACRD,QAAQ;wBACV;oBACF;iBACD;YACH;QACF;IACF,EAAE,OAAOE,KAAK;QACZZ,QAAQa,MAAM,CAACC,KAAK,CAAC;YACnBF;YACAG,KAAK,CAAC,sEAAsE,EAAEhB,KAAK,kBAAkB,EAAED,GAAG,CAAC,CAAC;QAC9G;IACF;AACF,EAAC"}},
    {"offset": {"line": 3375, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/versions/baseFields.ts"],"sourcesContent":["// @ts-strict-ignore\nimport type { CheckboxField, Field, Option } from '../fields/config/types.js'\n\nexport const statuses: Option[] = [\n  {\n    label: ({ t }) => t('version:draft'),\n    value: 'draft',\n  },\n  {\n    label: ({ t }) => t('version:published'),\n    value: 'published',\n  },\n]\n\nexport const baseVersionFields = ({ localized }: { localized: boolean }): Field[] => [\n  {\n    name: '_status',\n    type: 'select',\n    admin: {\n      components: {\n        Field: false,\n      },\n      disableBulkEdit: true,\n    },\n    defaultValue: 'draft',\n    index: true,\n    label: ({ t }) => t('version:status'),\n    localized: Boolean(localized),\n    options: statuses,\n  },\n]\n\n// When publishing a specific locale,\n// we need to create a new draft which acts as a\n// \"snapshot\" to retain all existing draft data.\n// This field will be used to exclude any snapshot versions\n// from the admin Versions list\nexport const versionSnapshotField: CheckboxField = {\n  name: 'snapshot',\n  type: 'checkbox',\n  admin: {\n    disableBulkEdit: true,\n    disabled: true,\n  },\n  index: true,\n}\n"],"names":["statuses","label","t","value","baseVersionFields","localized","name","type","admin","components","Field","disableBulkEdit","defaultValue","index","Boolean","options","versionSnapshotField","disabled"],"mappings":"AAAA,oBAAoB;;;;;;;;;AAGb,MAAMA,WAAqB;IAChC;QACEC,OAAO,CAAC,EAAEC,CAAC,EAAE,GAAKA,EAAE;QACpBC,OAAO;IACT;IACA;QACEF,OAAO,CAAC,EAAEC,CAAC,EAAE,GAAKA,EAAE;QACpBC,OAAO;IACT;CACD,CAAA;AAEM,MAAMC,oBAAoB,CAAC,EAAEC,SAAS,EAA0B,GAAc;QACnF;YACEC,MAAM;YACNC,MAAM;YACNC,OAAO;gBACLC,YAAY;oBACVC,OAAO;gBACT;gBACAC,iBAAiB;YACnB;YACAC,cAAc;YACdC,OAAO;YACPZ,OAAO,CAAC,EAAEC,CAAC,EAAE,GAAKA,EAAE;YACpBG,WAAWS,QAAQT;YACnBU,SAASf;QACX;KACD,CAAA;AAOM,MAAMgB,uBAAsC;IACjDV,MAAM;IACNC,MAAM;IACNC,OAAO;QACLG,iBAAiB;QACjBM,UAAU;IACZ;IACAJ,OAAO;AACT,EAAC"}},
    {"offset": {"line": 3424, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/versions/buildCollectionFields.ts"],"sourcesContent":["import type { SanitizedCollectionConfig } from '../collections/config/types.js'\nimport type { SanitizedConfig } from '../config/types.js'\nimport type { Field, FlattenedField } from '../fields/config/types.js'\n\nimport { hasAutosaveEnabled, hasDraftsEnabled } from '../utilities/getVersionsConfig.js'\nimport { versionSnapshotField } from './baseFields.js'\n\nexport const buildVersionCollectionFields = <T extends boolean = false>(\n  config: SanitizedConfig,\n  collection: SanitizedCollectionConfig,\n  flatten?: T,\n): true extends T ? FlattenedField[] : Field[] => {\n  const fields: FlattenedField[] = [\n    {\n      name: 'parent',\n      type: 'relationship',\n      index: true,\n      relationTo: collection.slug,\n    },\n    {\n      name: 'version',\n      type: 'group',\n      fields: collection.fields.filter((field) => !('name' in field) || field.name !== 'id'),\n      ...(flatten && {\n        flattenedFields: collection.flattenedFields.filter((each) => each.name !== 'id'),\n      })!,\n    },\n    {\n      name: 'createdAt',\n      type: 'date',\n      admin: {\n        disabled: true,\n      },\n      index: true,\n    },\n    {\n      name: 'updatedAt',\n      type: 'date',\n      admin: {\n        disabled: true,\n      },\n      index: true,\n    },\n  ]\n\n  if (hasDraftsEnabled(collection)) {\n    if (config.localization) {\n      fields.push(versionSnapshotField)\n\n      fields.push({\n        name: 'publishedLocale',\n        type: 'select',\n        admin: {\n          disableBulkEdit: true,\n          disabled: true,\n        },\n        index: true,\n        options: config.localization.locales.map((locale) => {\n          if (typeof locale === 'string') {\n            return locale\n          }\n\n          return locale.code\n        }),\n      })\n    }\n\n    fields.push({\n      name: 'latest',\n      type: 'checkbox',\n      admin: {\n        disabled: true,\n      },\n      index: true,\n    })\n\n    if (hasAutosaveEnabled(collection)) {\n      fields.push({\n        name: 'autosave',\n        type: 'checkbox',\n        index: true,\n      })\n    }\n  }\n\n  return fields as true extends T ? FlattenedField[] : Field[]\n}\n"],"names":["hasAutosaveEnabled","hasDraftsEnabled","versionSnapshotField","buildVersionCollectionFields","config","collection","flatten","fields","name","type","index","relationTo","slug","filter","field","flattenedFields","each","admin","disabled","localization","push","disableBulkEdit","options","locales","map","locale","code"],"mappings":";;;;AAIA,SAASA,kBAAkB,EAAEC,gBAAgB,QAAQ,oCAAmC;AACxF,SAASC,oBAAoB,QAAQ,kBAAiB;;;AAE/C,MAAMC,+BAA+B,CAC1CC,QACAC,YACAC;IAEA,MAAMC,SAA2B;QAC/B;YACEC,MAAM;YACNC,MAAM;YACNC,OAAO;YACPC,YAAYN,WAAWO,IAAI;QAC7B;QACA;YACEJ,MAAM;YACNC,MAAM;YACNF,QAAQF,WAAWE,MAAM,CAACM,MAAM,CAAC,CAACC,QAAU,CAAE,CAAA,UAAUA,KAAI,KAAMA,MAAMN,IAAI,KAAK;YACjF,GAAIF,WAAW;gBACbS,iBAAiBV,WAAWU,eAAe,CAACF,MAAM,CAAC,CAACG,OAASA,KAAKR,IAAI,KAAK;YAC7E,CAAC;QACH;QACA;YACEA,MAAM;YACNC,MAAM;YACNQ,OAAO;gBACLC,UAAU;YACZ;YACAR,OAAO;QACT;QACA;YACEF,MAAM;YACNC,MAAM;YACNQ,OAAO;gBACLC,UAAU;YACZ;YACAR,OAAO;QACT;KACD;IAED,QAAIT,uLAAAA,EAAiBI,aAAa;QAChC,IAAID,OAAOe,YAAY,EAAE;YACvBZ,OAAOa,IAAI,CAAClB,mLAAAA;YAEZK,OAAOa,IAAI,CAAC;gBACVZ,MAAM;gBACNC,MAAM;gBACNQ,OAAO;oBACLI,iBAAiB;oBACjBH,UAAU;gBACZ;gBACAR,OAAO;gBACPY,SAASlB,OAAOe,YAAY,CAACI,OAAO,CAACC,GAAG,CAAC,CAACC;oBACxC,IAAI,OAAOA,WAAW,UAAU;wBAC9B,OAAOA;oBACT;oBAEA,OAAOA,OAAOC,IAAI;gBACpB;YACF;QACF;QAEAnB,OAAOa,IAAI,CAAC;YACVZ,MAAM;YACNC,MAAM;YACNQ,OAAO;gBACLC,UAAU;YACZ;YACAR,OAAO;QACT;QAEA,QAAIV,yLAAAA,EAAmBK,aAAa;YAClCE,OAAOa,IAAI,CAAC;gBACVZ,MAAM;gBACNC,MAAM;gBACNC,OAAO;YACT;QACF;IACF;IAEA,OAAOH;AACT,EAAC"}},
    {"offset": {"line": 3506, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/versions/drafts/getQueryDraftsSort.ts"],"sourcesContent":["import type { SanitizedCollectionConfig } from '../../collections/config/types.js'\nimport type { Sort } from '../../types/index.js'\n\n/**\n * Takes the incoming sort argument and prefixes it with `versions.` and preserves any `-` prefixes for descending order\n * @param sort\n */\nexport const getQueryDraftsSort = ({\n  collectionConfig,\n  sort,\n}: {\n  collectionConfig: SanitizedCollectionConfig\n  sort?: Sort\n}): Sort => {\n  if (!sort) {\n    if (collectionConfig.defaultSort) {\n      sort = collectionConfig.defaultSort\n    } else {\n      sort = '-createdAt'\n    }\n  }\n\n  if (typeof sort === 'string') {\n    sort = [sort]\n  }\n\n  return sort.map((field: string) => {\n    let orderBy: string\n    let direction = ''\n    if (field[0] === '-') {\n      orderBy = field.substring(1)\n      direction = '-'\n    } else {\n      orderBy = field\n    }\n\n    if (orderBy === 'id') {\n      return `${direction}parent`\n    }\n\n    return `${direction}version.${orderBy}`\n  })\n}\n"],"names":["getQueryDraftsSort","collectionConfig","sort","defaultSort","map","field","orderBy","direction","substring"],"mappings":"AAGA;;;CAGC,GACD;;;;AAAO,MAAMA,qBAAqB,CAAC,EACjCC,gBAAgB,EAChBC,IAAI,EAIL;IACC,IAAI,CAACA,MAAM;QACT,IAAID,iBAAiBE,WAAW,EAAE;YAChCD,OAAOD,iBAAiBE,WAAW;QACrC,OAAO;YACLD,OAAO;QACT;IACF;IAEA,IAAI,OAAOA,SAAS,UAAU;QAC5BA,OAAO;YAACA;SAAK;IACf;IAEA,OAAOA,KAAKE,GAAG,CAAC,CAACC;QACf,IAAIC;QACJ,IAAIC,YAAY;QAChB,IAAIF,KAAK,CAAC,EAAE,KAAK,KAAK;YACpBC,UAAUD,MAAMG,SAAS,CAAC;YAC1BD,YAAY;QACd,OAAO;YACLD,UAAUD;QACZ;QAEA,IAAIC,YAAY,MAAM;YACpB,OAAO,GAAGC,UAAU,MAAM,CAAC;QAC7B;QAEA,OAAO,GAAGA,UAAU,QAAQ,EAAED,SAAS;IACzC;AACF,EAAC"}},
    {"offset": {"line": 3545, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/versions/drafts/replaceWithDraftIfAvailable.ts"],"sourcesContent":["// @ts-strict-ignore\nimport type { SanitizedCollectionConfig, TypeWithID } from '../../collections/config/types.js'\nimport type { AccessResult } from '../../config/types.js'\nimport type { FindGlobalVersionsArgs, FindVersionsArgs } from '../../database/types.js'\nimport type { SanitizedGlobalConfig } from '../../globals/config/types.js'\nimport type { PayloadRequest, SelectType, Where } from '../../types/index.js'\n\nimport { hasWhereAccessResult } from '../../auth/index.js'\nimport { combineQueries } from '../../database/combineQueries.js'\nimport { docHasTimestamps } from '../../types/index.js'\nimport { hasLocalizeStatusEnabled } from '../../utilities/getVersionsConfig.js'\nimport { sanitizeInternalFields } from '../../utilities/sanitizeInternalFields.js'\nimport { appendVersionToQueryKey } from './appendVersionToQueryKey.js'\nimport { getQueryDraftsSelect } from './getQueryDraftsSelect.js'\n\ntype Arguments<T> = {\n  accessResult: AccessResult\n  doc: T\n  entity: SanitizedCollectionConfig | SanitizedGlobalConfig\n  entityType: 'collection' | 'global'\n  overrideAccess: boolean\n  req: PayloadRequest\n  select?: SelectType\n}\n\nexport const replaceWithDraftIfAvailable = async <T extends TypeWithID>({\n  accessResult,\n  doc,\n  entity,\n  entityType,\n  req,\n  select,\n}: Arguments<T>): Promise<T> => {\n  const { locale, payload } = req\n\n  let queryToBuild: Where = {\n    and: [\n      {\n        'version._status': {\n          equals: 'draft',\n        },\n      },\n    ],\n  }\n\n  if (hasLocalizeStatusEnabled(entity)) {\n    if (locale === 'all') {\n      queryToBuild = {\n        and: [\n          {\n            or: (\n              (payload.config.localization && payload.config.localization.localeCodes) ||\n              []\n            ).map((localeCode) => ({\n              [`version._status.${localeCode}`]: {\n                equals: 'draft',\n              },\n            })),\n          },\n        ],\n      }\n    } else if (locale) {\n      queryToBuild = {\n        and: [\n          {\n            [`version._status.${locale}`]: {\n              equals: 'draft',\n            },\n          },\n        ],\n      }\n    }\n  }\n\n  if (entityType === 'collection') {\n    queryToBuild.and!.push({\n      parent: {\n        equals: doc.id,\n      },\n    })\n  }\n\n  if (docHasTimestamps(doc)) {\n    queryToBuild.and!.push({\n      or: [\n        {\n          updatedAt: {\n            greater_than: doc.updatedAt,\n          },\n        },\n        {\n          latest: {\n            equals: true,\n          },\n        },\n      ],\n    })\n  }\n\n  let versionAccessResult: undefined | Where\n\n  if (hasWhereAccessResult(accessResult)) {\n    versionAccessResult = appendVersionToQueryKey(accessResult)\n  }\n\n  const findVersionsArgs: FindGlobalVersionsArgs & FindVersionsArgs = {\n    collection: entity.slug,\n    global: entity.slug,\n    limit: 1,\n    locale: locale!,\n    pagination: false,\n    req,\n    select: getQueryDraftsSelect({ select }),\n    sort: '-updatedAt',\n    where: combineQueries(queryToBuild, versionAccessResult!),\n  }\n\n  let versionDocs\n  if (entityType === 'global') {\n    versionDocs = (await req.payload.db.findGlobalVersions<T>(findVersionsArgs)).docs\n  } else {\n    versionDocs = (await req.payload.db.findVersions<T>(findVersionsArgs)).docs\n  }\n\n  let draft = versionDocs[0]\n\n  if (!draft) {\n    return doc\n  }\n\n  draft = sanitizeInternalFields(draft)\n\n  // Patch globalType onto version doc\n  if (entityType === 'global' && 'globalType' in doc) {\n    // @ts-expect-error - vestiges of when tsconfig was not strict. Feel free to improve\n    draft.version.globalType = doc.globalType\n  }\n\n  // handle when .version wasn't selected due to projection\n  if (!draft.version) {\n    draft.version = {} as T\n  }\n\n  // Disregard all other draft content at this point,\n  // Only interested in the version itself.\n  // Operations will handle firing hooks, etc.\n\n  draft.version.id = doc.id\n\n  return draft.version\n}\n"],"names":["hasWhereAccessResult","combineQueries","docHasTimestamps","hasLocalizeStatusEnabled","sanitizeInternalFields","appendVersionToQueryKey","getQueryDraftsSelect","replaceWithDraftIfAvailable","accessResult","doc","entity","entityType","req","select","locale","payload","queryToBuild","and","equals","or","config","localization","localeCodes","map","localeCode","push","parent","id","updatedAt","greater_than","latest","versionAccessResult","findVersionsArgs","collection","slug","global","limit","pagination","sort","where","versionDocs","db","findGlobalVersions","docs","findVersions","draft","version","globalType"],"mappings":"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"}},
    {"offset": {"line": 3670, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/versions/buildGlobalFields.ts"],"sourcesContent":["import type { SanitizedConfig } from '../config/types.js'\nimport type { Field, FlattenedField } from '../fields/config/types.js'\nimport type { SanitizedGlobalConfig } from '../globals/config/types.js'\n\nimport { hasAutosaveEnabled, hasDraftsEnabled } from '../utilities/getVersionsConfig.js'\nimport { versionSnapshotField } from './baseFields.js'\n\nexport const buildVersionGlobalFields = <T extends boolean = false>(\n  config: SanitizedConfig,\n  global: SanitizedGlobalConfig,\n  flatten?: T,\n): true extends T ? FlattenedField[] : Field[] => {\n  const fields: FlattenedField[] = [\n    {\n      name: 'version',\n      type: 'group',\n      fields: global.fields,\n      ...(flatten && {\n        flattenedFields: global.flattenedFields,\n      })!,\n    },\n    {\n      name: 'createdAt',\n      type: 'date',\n      admin: {\n        disabled: true,\n      },\n      index: true,\n    },\n    {\n      name: 'updatedAt',\n      type: 'date',\n      admin: {\n        disabled: true,\n      },\n      index: true,\n    },\n  ]\n\n  if (hasDraftsEnabled(global)) {\n    if (config.localization) {\n      fields.push(versionSnapshotField)\n\n      fields.push({\n        name: 'publishedLocale',\n        type: 'select',\n        admin: {\n          disableBulkEdit: true,\n          disabled: true,\n        },\n        index: true,\n        options: config.localization.locales.map((locale) => {\n          if (typeof locale === 'string') {\n            return locale\n          }\n\n          return locale.code\n        }),\n      })\n    }\n\n    fields.push({\n      name: 'latest',\n      type: 'checkbox',\n      admin: {\n        disabled: true,\n      },\n      index: true,\n    })\n\n    if (hasAutosaveEnabled(global)) {\n      fields.push({\n        name: 'autosave',\n        type: 'checkbox',\n        index: true,\n      })\n    }\n  }\n\n  return fields as true extends T ? FlattenedField[] : Field[]\n}\n"],"names":["hasAutosaveEnabled","hasDraftsEnabled","versionSnapshotField","buildVersionGlobalFields","config","global","flatten","fields","name","type","flattenedFields","admin","disabled","index","localization","push","disableBulkEdit","options","locales","map","locale","code"],"mappings":";;;;AAIA,SAASA,kBAAkB,EAAEC,gBAAgB,QAAQ,oCAAmC;AACxF,SAASC,oBAAoB,QAAQ,kBAAiB;;;AAE/C,MAAMC,2BAA2B,CACtCC,QACAC,QACAC;IAEA,MAAMC,SAA2B;QAC/B;YACEC,MAAM;YACNC,MAAM;YACNF,QAAQF,OAAOE,MAAM;YACrB,GAAID,WAAW;gBACbI,iBAAiBL,OAAOK,eAAe;YACzC,CAAC;QACH;QACA;YACEF,MAAM;YACNC,MAAM;YACNE,OAAO;gBACLC,UAAU;YACZ;YACAC,OAAO;QACT;QACA;YACEL,MAAM;YACNC,MAAM;YACNE,OAAO;gBACLC,UAAU;YACZ;YACAC,OAAO;QACT;KACD;IAED,QAAIZ,uLAAAA,EAAiBI,SAAS;QAC5B,IAAID,OAAOU,YAAY,EAAE;YACvBP,OAAOQ,IAAI,CAACb,mLAAAA;YAEZK,OAAOQ,IAAI,CAAC;gBACVP,MAAM;gBACNC,MAAM;gBACNE,OAAO;oBACLK,iBAAiB;oBACjBJ,UAAU;gBACZ;gBACAC,OAAO;gBACPI,SAASb,OAAOU,YAAY,CAACI,OAAO,CAACC,GAAG,CAAC,CAACC;oBACxC,IAAI,OAAOA,WAAW,UAAU;wBAC9B,OAAOA;oBACT;oBAEA,OAAOA,OAAOC,IAAI;gBACpB;YACF;QACF;QAEAd,OAAOQ,IAAI,CAAC;YACVP,MAAM;YACNC,MAAM;YACNE,OAAO;gBACLC,UAAU;YACZ;YACAC,OAAO;QACT;QAEA,QAAIb,yLAAAA,EAAmBK,SAAS;YAC9BE,OAAOQ,IAAI,CAAC;gBACVP,MAAM;gBACNC,MAAM;gBACNI,OAAO;YACT;QACF;IACF;IAEA,OAAON;AACT,EAAC"}},
    {"offset": {"line": 3746, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/versions/getLatestGlobalVersion.ts"],"sourcesContent":["import type { SanitizedGlobalConfig } from '../globals/config/types.js'\nimport type { Document, Payload, PayloadRequest, Where } from '../types/index.js'\nimport type { TypeWithVersion } from './types.js'\n\nimport { hasDraftsEnabled } from '../utilities/getVersionsConfig.js'\n\ntype Args = {\n  config: SanitizedGlobalConfig\n  locale?: string\n  payload: Payload\n  published?: boolean\n  req?: PayloadRequest\n  slug: string\n  where: Where\n}\n\nexport const getLatestGlobalVersion = async ({\n  slug,\n  config,\n  locale,\n  payload,\n  published,\n  req,\n  where,\n}: Args): Promise<{ global: Document; globalExists: boolean }> => {\n  let latestVersion: TypeWithVersion<Document> | undefined\n\n  const whereQuery = published\n    ? { 'version._status': { equals: 'published' } }\n    : { latest: { equals: true } }\n\n  if (hasDraftsEnabled(config)) {\n    latestVersion = (\n      await payload.db.findGlobalVersions({\n        global: slug,\n        limit: 1,\n        locale: locale || req?.locale || undefined,\n        pagination: false,\n        req,\n        where: whereQuery as unknown as Where,\n      })\n    ).docs[0]\n  }\n\n  const global = await payload.db.findGlobal({\n    slug,\n    locale,\n    req,\n    where,\n  })\n  const globalExists = Boolean(global)\n\n  if (!latestVersion) {\n    return {\n      global,\n      globalExists,\n    }\n  }\n\n  if (!latestVersion.version.createdAt) {\n    latestVersion.version.createdAt = latestVersion.createdAt\n  }\n\n  if (!latestVersion.version.updatedAt) {\n    latestVersion.version.updatedAt = latestVersion.updatedAt\n  }\n\n  return {\n    global: latestVersion.version,\n    globalExists,\n  }\n}\n"],"names":["hasDraftsEnabled","getLatestGlobalVersion","slug","config","locale","payload","published","req","where","latestVersion","whereQuery","equals","latest","db","findGlobalVersions","global","limit","undefined","pagination","docs","findGlobal","globalExists","Boolean","version","createdAt","updatedAt"],"mappings":";;;;AAIA,SAASA,gBAAgB,QAAQ,oCAAmC;;AAY7D,MAAMC,yBAAyB,OAAO,EAC3CC,IAAI,EACJC,MAAM,EACNC,MAAM,EACNC,OAAO,EACPC,SAAS,EACTC,GAAG,EACHC,KAAK,EACA;IACL,IAAIC;IAEJ,MAAMC,aAAaJ,YACf;QAAE,mBAAmB;YAAEK,QAAQ;QAAY;IAAE,IAC7C;QAAEC,QAAQ;YAAED,QAAQ;QAAK;IAAE;IAE/B,QAAIX,uLAAAA,EAAiBG,SAAS;QAC5BM,gBACE,CAAA,MAAMJ,QAAQQ,EAAE,CAACC,kBAAkB,CAAC;YAClCC,QAAQb;YACRc,OAAO;YACPZ,QAAQA,UAAUG,KAAKH,UAAUa;YACjCC,YAAY;YACZX;YACAC,OAAOE;QACT,EAAC,EACDS,IAAI,CAAC,EAAE;IACX;IAEA,MAAMJ,SAAS,MAAMV,QAAQQ,EAAE,CAACO,UAAU,CAAC;QACzClB;QACAE;QACAG;QACAC;IACF;IACA,MAAMa,eAAeC,QAAQP;IAE7B,IAAI,CAACN,eAAe;QAClB,OAAO;YACLM;YACAM;QACF;IACF;IAEA,IAAI,CAACZ,cAAcc,OAAO,CAACC,SAAS,EAAE;QACpCf,cAAcc,OAAO,CAACC,SAAS,GAAGf,cAAce,SAAS;IAC3D;IAEA,IAAI,CAACf,cAAcc,OAAO,CAACE,SAAS,EAAE;QACpChB,cAAcc,OAAO,CAACE,SAAS,GAAGhB,cAAcgB,SAAS;IAC3D;IAEA,OAAO;QACLV,QAAQN,cAAcc,OAAO;QAC7BF;IACF;AACF,EAAC"}},
    {"offset": {"line": 3801, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/versions/payloadPackageList.ts"],"sourcesContent":["export const PAYLOAD_PACKAGE_LIST = [\n  'payload',\n  '@payloadcms/bundler-vite',\n  '@payloadcms/bundler-webpack',\n  '@payloadcms/db-d1-sqlite',\n  '@payloadcms/db-mongodb',\n  '@payloadcms/db-postgres',\n  '@payloadcms/db-sqlite',\n  '@payloadcms/db-vercel-postgres',\n  '@payloadcms/drizzle',\n  '@payloadcms/ecommerce',\n  '@payloadcms/email-nodemailer',\n  '@payloadcms/email-resend',\n  '@payloadcms/graphql',\n  '@payloadcms/live-preview',\n  '@payloadcms/live-preview-react',\n  '@payloadcms/live-preview-vue',\n  '@payloadcms/kv-redis',\n  '@payloadcms/next/utilities',\n  '@payloadcms/payload-cloud',\n  '@payloadcms/plugin-cloud-storage',\n  '@payloadcms/plugin-form-builder',\n  '@payloadcms/plugin-import-export',\n  '@payloadcms/plugin-mcp',\n  '@payloadcms/plugin-multi-tenant',\n  '@payloadcms/plugin-nested-docs',\n  '@payloadcms/plugin-redirects',\n  '@payloadcms/plugin-search',\n  '@payloadcms/plugin-seo',\n  '@payloadcms/plugin-stripe',\n  '@payloadcms/plugin-zapier',\n  '@payloadcms/richtext-lexical',\n  '@payloadcms/richtext-slate',\n  '@payloadcms/sdk',\n  '@payloadcms/storage-azure',\n  '@payloadcms/storage-gcs',\n  '@payloadcms/storage-r2',\n  '@payloadcms/storage-s3',\n  '@payloadcms/storage-uploadthing',\n  '@payloadcms/storage-vercel-blob',\n  '@payloadcms/translations',\n  '@payloadcms/ui/shared',\n]\n"],"names":["PAYLOAD_PACKAGE_LIST"],"mappings":";;;;AAAO,MAAMA,uBAAuB;IAClC;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;CACD,CAAA"}},
    {"offset": {"line": 3852, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/duplicateDocument/index.ts"],"sourcesContent":["import type { SanitizedCollectionConfig } from '../collections/config/types.js'\nimport type { FindOneArgs } from '../database/types.js'\nimport type { JsonObject, PayloadRequest } from '../types/index.js'\n\nimport { executeAccess } from '../auth/executeAccess.js'\nimport { hasWhereAccessResult } from '../auth/types.js'\nimport { combineQueries } from '../database/combineQueries.js'\nimport { Forbidden } from '../errors/Forbidden.js'\nimport { NotFound } from '../errors/NotFound.js'\nimport { afterRead } from '../fields/hooks/afterRead/index.js'\nimport { beforeDuplicate } from '../fields/hooks/beforeDuplicate/index.js'\nimport { deepCopyObjectSimple } from '../utilities/deepCopyObject.js'\nimport { filterDataToSelectedLocales } from '../utilities/filterDataToSelectedLocales.js'\nimport { getLatestCollectionVersion } from '../versions/getLatestCollectionVersion.js'\n\ntype GetDuplicateDocumentArgs = {\n  collectionConfig: SanitizedCollectionConfig\n  draftArg?: boolean\n  id: number | string\n  overrideAccess?: boolean\n  req: PayloadRequest\n  selectedLocales?: string[]\n}\nexport const getDuplicateDocumentData = async ({\n  id,\n  collectionConfig,\n  draftArg,\n  overrideAccess,\n  req,\n  selectedLocales,\n}: GetDuplicateDocumentArgs): Promise<{\n  duplicatedFromDoc: JsonObject\n  duplicatedFromDocWithLocales: JsonObject\n}> => {\n  const { payload } = req\n  // /////////////////////////////////////\n  // Read Access\n  // /////////////////////////////////////\n\n  const accessResults = !overrideAccess\n    ? await executeAccess({ id, req }, collectionConfig.access.read)\n    : true\n  const hasWherePolicy = hasWhereAccessResult(accessResults)\n\n  // /////////////////////////////////////\n  // Retrieve document\n  // /////////////////////////////////////\n  const findOneArgs: FindOneArgs = {\n    collection: collectionConfig.slug,\n    locale: req.locale!,\n    req,\n    where: combineQueries({ id: { equals: id } }, accessResults),\n  }\n\n  let duplicatedFromDocWithLocales = await getLatestCollectionVersion({\n    id,\n    config: collectionConfig,\n    payload,\n    query: findOneArgs,\n    req,\n  })\n\n  if (selectedLocales && selectedLocales.length > 0 && duplicatedFromDocWithLocales) {\n    duplicatedFromDocWithLocales = filterDataToSelectedLocales({\n      configBlockReferences: payload.config.blocks,\n      docWithLocales: duplicatedFromDocWithLocales,\n      fields: collectionConfig.fields,\n      selectedLocales,\n    })\n  }\n\n  if (!duplicatedFromDocWithLocales && !hasWherePolicy) {\n    throw new NotFound(req.t)\n  }\n  if (!duplicatedFromDocWithLocales && hasWherePolicy) {\n    throw new Forbidden(req.t)\n  }\n\n  // remove the createdAt timestamp and rely on the db to set it\n  if ('createdAt' in duplicatedFromDocWithLocales) {\n    delete duplicatedFromDocWithLocales.createdAt\n  }\n  // remove the id and rely on the db to set it\n  if ('id' in duplicatedFromDocWithLocales) {\n    delete duplicatedFromDocWithLocales.id\n  }\n\n  duplicatedFromDocWithLocales = await beforeDuplicate({\n    id,\n    collection: collectionConfig,\n    context: req.context,\n    doc: duplicatedFromDocWithLocales,\n    overrideAccess: overrideAccess!,\n    req,\n  })\n\n  const duplicatedFromDoc = await afterRead({\n    collection: collectionConfig,\n    context: req.context,\n    depth: 0,\n    doc: deepCopyObjectSimple(duplicatedFromDocWithLocales),\n    draft: draftArg!,\n    fallbackLocale: null,\n    global: null,\n    locale: req.locale!,\n    overrideAccess: true,\n    req,\n    showHiddenFields: true,\n  })\n\n  return { duplicatedFromDoc, duplicatedFromDocWithLocales }\n}\n"],"names":["executeAccess","hasWhereAccessResult","combineQueries","Forbidden","NotFound","afterRead","beforeDuplicate","deepCopyObjectSimple","filterDataToSelectedLocales","getLatestCollectionVersion","getDuplicateDocumentData","id","collectionConfig","draftArg","overrideAccess","req","selectedLocales","payload","accessResults","access","read","hasWherePolicy","findOneArgs","collection","slug","locale","where","equals","duplicatedFromDocWithLocales","config","query","length","configBlockReferences","blocks","docWithLocales","fields","t","createdAt","context","doc","duplicatedFromDoc","depth","draft","fallbackLocale","global","showHiddenFields"],"mappings":";;;;AAIA,SAASA,aAAa,QAAQ,2BAA0B;AACxD,SAASC,oBAAoB,QAAQ,mBAAkB;AACvD,SAASC,cAAc,QAAQ,gCAA+B;AAC9D,SAASC,SAAS,QAAQ,yBAAwB;AAClD,SAASC,QAAQ,QAAQ,wBAAuB;AAChD,SAASC,SAAS,QAAQ,qCAAoC;AAC9D,SAASC,eAAe,QAAQ,2CAA0C;AAC1E,SAASC,oBAAoB,QAAQ,iCAAgC;AACrE,SAASC,2BAA2B,QAAQ,8CAA6C;AACzF,SAASC,0BAA0B,QAAQ,4CAA2C;;;;;;;;;;;AAU/E,MAAMC,2BAA2B,OAAO,EAC7CC,EAAE,EACFC,gBAAgB,EAChBC,QAAQ,EACRC,cAAc,EACdC,GAAG,EACHC,eAAe,EACU;IAIzB,MAAM,EAAEC,OAAO,EAAE,GAAGF;IACpB,wCAAwC;IACxC,cAAc;IACd,wCAAwC;IAExC,MAAMG,gBAAgB,CAACJ,iBACnB,UAAMd,2KAAAA,EAAc;QAAEW;QAAII;IAAI,GAAGH,iBAAiBO,MAAM,CAACC,IAAI,IAC7D;IACJ,MAAMC,qBAAiBpB,0KAAAA,EAAqBiB;IAE5C,wCAAwC;IACxC,oBAAoB;IACpB,wCAAwC;IACxC,MAAMI,cAA2B;QAC/BC,YAAYX,iBAAiBY,IAAI;QACjCC,QAAQV,IAAIU,MAAM;QAClBV;QACAW,WAAOxB,iLAAAA,EAAe;YAAES,IAAI;gBAAEgB,QAAQhB;YAAG;QAAE,GAAGO;IAChD;IAEA,IAAIU,+BAA+B,UAAMnB,yMAAAA,EAA2B;QAClEE;QACAkB,QAAQjB;QACRK;QACAa,OAAOR;QACPP;IACF;IAEA,IAAIC,mBAAmBA,gBAAgBe,MAAM,GAAG,KAAKH,8BAA8B;QACjFA,mCAA+BpB,4MAAAA,EAA4B;YACzDwB,uBAAuBf,QAAQY,MAAM,CAACI,MAAM;YAC5CC,gBAAgBN;YAChBO,QAAQvB,iBAAiBuB,MAAM;YAC/BnB;QACF;IACF;IAEA,IAAI,CAACY,gCAAgC,CAACP,gBAAgB;QACpD,MAAM,IAAIjB,mKAAAA,CAASW,IAAIqB,CAAC;IAC1B;IACA,IAAI,CAACR,gCAAgCP,gBAAgB;QACnD,MAAM,IAAIlB,qKAAAA,CAAUY,IAAIqB,CAAC;IAC3B;IAEA,8DAA8D;IAC9D,IAAI,eAAeR,8BAA8B;QAC/C,OAAOA,6BAA6BS,SAAS;IAC/C;IACA,6CAA6C;IAC7C,IAAI,QAAQT,8BAA8B;QACxC,OAAOA,6BAA6BjB,EAAE;IACxC;IAEAiB,+BAA+B,UAAMtB,mMAAAA,EAAgB;QACnDK;QACAY,YAAYX;QACZ0B,SAASvB,IAAIuB,OAAO;QACpBC,KAAKX;QACLd,gBAAgBA;QAChBC;IACF;IAEA,MAAMyB,oBAAoB,UAAMnC,uLAAAA,EAAU;QACxCkB,YAAYX;QACZ0B,SAASvB,IAAIuB,OAAO;QACpBG,OAAO;QACPF,SAAKhC,wLAAAA,EAAqBqB;QAC1Bc,OAAO7B;QACP8B,gBAAgB;QAChBC,QAAQ;QACRnB,QAAQV,IAAIU,MAAM;QAClBX,gBAAgB;QAChBC;QACA8B,kBAAkB;IACpB;IAEA,OAAO;QAAEL;QAAmBZ;IAA6B;AAC3D,EAAC"}},
    {"offset": {"line": 3958, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/preferences/operations/delete.ts"],"sourcesContent":["import type { Document, Where } from '../../types/index.js'\nimport type { PreferenceRequest } from '../types.js'\n\nimport { NotFound } from '../../errors/NotFound.js'\nimport { UnauthorizedError } from '../../errors/UnauthorizedError.js'\nimport { preferencesCollectionSlug } from '../config.js'\n\nexport async function deleteOperation(args: PreferenceRequest): Promise<Document> {\n  const {\n    key,\n    req: { payload },\n    req,\n    user,\n  } = args\n\n  if (!user) {\n    throw new UnauthorizedError(req.t)\n  }\n\n  const where: Where = {\n    and: [\n      { key: { equals: key } },\n      { 'user.value': { equals: user.id } },\n      { 'user.relationTo': { equals: user.collection } },\n    ],\n  }\n\n  const result = await payload.db.deleteOne({\n    collection: preferencesCollectionSlug,\n    req,\n    where,\n  })\n\n  if (result) {\n    return result\n  }\n  throw new NotFound(req.t)\n}\n"],"names":["NotFound","UnauthorizedError","preferencesCollectionSlug","deleteOperation","args","key","req","payload","user","t","where","and","equals","id","collection","result","db","deleteOne"],"mappings":";;;;AAGA,SAASA,QAAQ,QAAQ,2BAA0B;AACnD,SAASC,iBAAiB,QAAQ,oCAAmC;AACrE,SAASC,yBAAyB,QAAQ,eAAc;;;;AAEjD,eAAeC,gBAAgBC,IAAuB;IAC3D,MAAM,EACJC,GAAG,EACHC,KAAK,EAAEC,OAAO,EAAE,EAChBD,GAAG,EACHE,IAAI,EACL,GAAGJ;IAEJ,IAAI,CAACI,MAAM;QACT,MAAM,IAAIP,qLAAAA,CAAkBK,IAAIG,CAAC;IACnC;IAEA,MAAMC,QAAe;QACnBC,KAAK;YACH;gBAAEN,KAAK;oBAAEO,QAAQP;gBAAI;YAAE;YACvB;gBAAE,cAAc;oBAAEO,QAAQJ,KAAKK,EAAE;gBAAC;YAAE;YACpC;gBAAE,mBAAmB;oBAAED,QAAQJ,KAAKM,UAAU;gBAAC;YAAE;SAClD;IACH;IAEA,MAAMC,SAAS,MAAMR,QAAQS,EAAE,CAACC,SAAS,CAAC;QACxCH,YAAYZ,uLAAAA;QACZI;QACAI;IACF;IAEA,IAAIK,QAAQ;QACV,OAAOA;IACT;IACA,MAAM,IAAIf,mKAAAA,CAASM,IAAIG,CAAC;AAC1B"}},
    {"offset": {"line": 4006, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/preferences/requestHandlers/delete.ts"],"sourcesContent":["import { status as httpStatus } from 'http-status'\n\nimport type { PayloadHandler } from '../../config/types.js'\nimport type { PayloadRequest } from '../../types/index.js'\n\nimport { deleteOperation } from '../operations/delete.js'\n\nexport const deleteHandler: PayloadHandler = async (incomingReq): Promise<Response> => {\n  // We cannot import the addDataAndFileToRequest utility here from the 'next' package because of dependency issues\n  // However that utility should be used where possible instead of manually appending the data\n  let data\n\n  try {\n    data = await incomingReq.json?.()\n  } catch (ignore) {\n    data = {}\n  }\n\n  const reqWithData: PayloadRequest = incomingReq\n\n  if (data) {\n    reqWithData.data = data\n    // @ts-expect-error\n    reqWithData.json = () => Promise.resolve(data)\n  }\n\n  const result = await deleteOperation({\n    key: reqWithData.routeParams?.key as string,\n    req: reqWithData,\n    user: reqWithData.user,\n  })\n\n  return Response.json(\n    {\n      ...result,\n      message: reqWithData.t('general:deletedSuccessfully'),\n    },\n    {\n      status: httpStatus.OK,\n    },\n  )\n}\n"],"names":["status","httpStatus","deleteOperation","deleteHandler","incomingReq","data","json","ignore","reqWithData","Promise","resolve","result","key","routeParams","req","user","Response","message","t","OK"],"mappings":";;;;;AAAA,SAASA,UAAUC,UAAU,QAAQ,cAAa;AAKlD,SAASC,eAAe,QAAQ,0BAAyB;;;AAElD,MAAMC,gBAAgC,OAAOC;IAClD,iHAAiH;IACjH,4FAA4F;IAC5F,IAAIC;IAEJ,IAAI;QACFA,OAAO,MAAMD,YAAYE,IAAI;IAC/B,EAAE,OAAOC,QAAQ;QACfF,OAAO,CAAC;IACV;IAEA,MAAMG,cAA8BJ;IAEpC,IAAIC,MAAM;QACRG,YAAYH,IAAI,GAAGA;QACnB,mBAAmB;QACnBG,YAAYF,IAAI,GAAG,IAAMG,QAAQC,OAAO,CAACL;IAC3C;IAEA,MAAMM,SAAS,UAAMT,2LAAAA,EAAgB;QACnCU,KAAKJ,YAAYK,WAAW,EAAED;QAC9BE,KAAKN;QACLO,MAAMP,YAAYO,IAAI;IACxB;IAEA,OAAOC,SAASV,IAAI,CAClB;QACE,GAAGK,MAAM;QACTM,SAAST,YAAYU,CAAC,CAAC;IACzB,GACA;QACElB,QAAQC,sMAAAA,CAAWkB,EAAE;IACvB;AAEJ,EAAC"}},
    {"offset": {"line": 4046, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/preferences/operations/findOne.ts"],"sourcesContent":["import type { TypedCollection } from '../../index.js'\nimport type { Where } from '../../types/index.js'\nimport type { PreferenceRequest } from '../types.js'\n\nimport { preferencesCollectionSlug } from '../config.js'\n\nexport async function findOne(args: PreferenceRequest): Promise<TypedCollection['_preference']> {\n  const {\n    key,\n    req: { payload },\n    req,\n    user,\n  } = args\n\n  if (!user) {\n    return null!\n  }\n\n  const where: Where = {\n    and: [\n      { key: { equals: key } },\n      { 'user.value': { equals: user.id } },\n      { 'user.relationTo': { equals: user.collection } },\n    ],\n  }\n\n  const { docs } = await payload.db.find({\n    collection: preferencesCollectionSlug,\n    limit: 1,\n    pagination: false,\n    req,\n    sort: '-updatedAt',\n    where,\n  })\n\n  return docs?.[0] || null!\n}\n"],"names":["preferencesCollectionSlug","findOne","args","key","req","payload","user","where","and","equals","id","collection","docs","db","find","limit","pagination","sort"],"mappings":";;;;AAIA,SAASA,yBAAyB,QAAQ,eAAc;;AAEjD,eAAeC,QAAQC,IAAuB;IACnD,MAAM,EACJC,GAAG,EACHC,KAAK,EAAEC,OAAO,EAAE,EAChBD,GAAG,EACHE,IAAI,EACL,GAAGJ;IAEJ,IAAI,CAACI,MAAM;QACT,OAAO;IACT;IAEA,MAAMC,QAAe;QACnBC,KAAK;YACH;gBAAEL,KAAK;oBAAEM,QAAQN;gBAAI;YAAE;YACvB;gBAAE,cAAc;oBAAEM,QAAQH,KAAKI,EAAE;gBAAC;YAAE;YACpC;gBAAE,mBAAmB;oBAAED,QAAQH,KAAKK,UAAU;gBAAC;YAAE;SAClD;IACH;IAEA,MAAM,EAAEC,IAAI,EAAE,GAAG,MAAMP,QAAQQ,EAAE,CAACC,IAAI,CAAC;QACrCH,YAAYX,uLAAAA;QACZe,OAAO;QACPC,YAAY;QACZZ;QACAa,MAAM;QACNV;IACF;IAEA,OAAOK,MAAM,CAAC,EAAE,IAAI;AACtB"}},
    {"offset": {"line": 4090, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/preferences/requestHandlers/findOne.ts"],"sourcesContent":["import { status as httpStatus } from 'http-status'\n\nimport type { PayloadHandler } from '../../config/types.js'\nimport type { PayloadRequest } from '../../types/index.js'\n\nimport { findOne } from '../operations/findOne.js'\n\nexport const findByIDHandler: PayloadHandler = async (incomingReq): Promise<Response> => {\n  // We cannot import the addDataAndFileToRequest utility here from the 'next' package because of dependency issues\n  // However that utility should be used where possible instead of manually appending the data\n  let data\n\n  try {\n    data = await incomingReq.json?.()\n  } catch (ignore) {\n    data = {}\n  }\n\n  const reqWithData: PayloadRequest = incomingReq\n\n  if (data) {\n    reqWithData.data = data\n    // @ts-expect-error\n    reqWithData.json = () => Promise.resolve(data)\n  }\n\n  const result = await findOne({\n    key: reqWithData.routeParams?.key as string,\n    req: reqWithData,\n    user: reqWithData.user,\n  })\n\n  return Response.json(\n    {\n      ...(result\n        ? result\n        : {\n            message: reqWithData.t('general:notFound'),\n            value: null,\n          }),\n    },\n    {\n      status: httpStatus.OK,\n    },\n  )\n}\n"],"names":["status","httpStatus","findOne","findByIDHandler","incomingReq","data","json","ignore","reqWithData","Promise","resolve","result","key","routeParams","req","user","Response","message","t","value","OK"],"mappings":";;;;;AAAA,SAASA,UAAUC,UAAU,QAAQ,cAAa;AAKlD,SAASC,OAAO,QAAQ,2BAA0B;;;AAE3C,MAAMC,kBAAkC,OAAOC;IACpD,iHAAiH;IACjH,4FAA4F;IAC5F,IAAIC;IAEJ,IAAI;QACFA,OAAO,MAAMD,YAAYE,IAAI;IAC/B,EAAE,OAAOC,QAAQ;QACfF,OAAO,CAAC;IACV;IAEA,MAAMG,cAA8BJ;IAEpC,IAAIC,MAAM;QACRG,YAAYH,IAAI,GAAGA;QACnB,mBAAmB;QACnBG,YAAYF,IAAI,GAAG,IAAMG,QAAQC,OAAO,CAACL;IAC3C;IAEA,MAAMM,SAAS,UAAMT,oLAAAA,EAAQ;QAC3BU,KAAKJ,YAAYK,WAAW,EAAED;QAC9BE,KAAKN;QACLO,MAAMP,YAAYO,IAAI;IACxB;IAEA,OAAOC,SAASV,IAAI,CAClB;QACE,GAAIK,SACAA,SACA;YACEM,SAAST,YAAYU,CAAC,CAAC;YACvBC,OAAO;QACT,CAAC;IACP,GACA;QACEnB,QAAQC,sMAAAA,CAAWmB,EAAE;IACvB;AAEJ,EAAC"}},
    {"offset": {"line": 4132, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/preferences/operations/update.ts"],"sourcesContent":["import type { Where } from '../../types/index.js'\nimport type { PreferenceUpdateRequest } from '../types.js'\n\nimport { UnauthorizedError } from '../../errors/UnauthorizedError.js'\nimport { preferencesCollectionSlug } from '../config.js'\n\nexport async function update(args: PreferenceUpdateRequest) {\n  const {\n    key,\n    req: { payload },\n    req,\n    user,\n    value,\n  } = args\n\n  if (!user) {\n    throw new UnauthorizedError(req.t)\n  }\n\n  const where: Where = {\n    and: [\n      { key: { equals: key } },\n      { 'user.value': { equals: user.id } },\n      { 'user.relationTo': { equals: user.collection } },\n    ],\n  }\n\n  const preference = {\n    key,\n    user: {\n      relationTo: user.collection,\n      value: user.id,\n    },\n    value,\n  }\n\n  return await payload.db.upsert({\n    collection: preferencesCollectionSlug,\n    data: preference,\n    req,\n    where,\n  })\n}\n"],"names":["UnauthorizedError","preferencesCollectionSlug","update","args","key","req","payload","user","value","t","where","and","equals","id","collection","preference","relationTo","db","upsert","data"],"mappings":";;;;AAGA,SAASA,iBAAiB,QAAQ,oCAAmC;AACrE,SAASC,yBAAyB,QAAQ,eAAc;;;AAEjD,eAAeC,OAAOC,IAA6B;IACxD,MAAM,EACJC,GAAG,EACHC,KAAK,EAAEC,OAAO,EAAE,EAChBD,GAAG,EACHE,IAAI,EACJC,KAAK,EACN,GAAGL;IAEJ,IAAI,CAACI,MAAM;QACT,MAAM,IAAIP,qLAAAA,CAAkBK,IAAII,CAAC;IACnC;IAEA,MAAMC,QAAe;QACnBC,KAAK;YACH;gBAAEP,KAAK;oBAAEQ,QAAQR;gBAAI;YAAE;YACvB;gBAAE,cAAc;oBAAEQ,QAAQL,KAAKM,EAAE;gBAAC;YAAE;YACpC;gBAAE,mBAAmB;oBAAED,QAAQL,KAAKO,UAAU;gBAAC;YAAE;SAClD;IACH;IAEA,MAAMC,aAAa;QACjBX;QACAG,MAAM;YACJS,YAAYT,KAAKO,UAAU;YAC3BN,OAAOD,KAAKM,EAAE;QAChB;QACAL;IACF;IAEA,OAAO,MAAMF,QAAQW,EAAE,CAACC,MAAM,CAAC;QAC7BJ,YAAYb,uLAAAA;QACZkB,MAAMJ;QACNV;QACAK;IACF;AACF"}},
    {"offset": {"line": 4183, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/preferences/requestHandlers/update.ts"],"sourcesContent":["import { status as httpStatus } from 'http-status'\n\nimport type { PayloadHandler } from '../../config/types.js'\nimport type { PayloadRequest } from '../../types/index.js'\n\nimport { update } from '../operations/update.js'\n\nexport const updateHandler: PayloadHandler = async (incomingReq) => {\n  // We cannot import the addDataAndFileToRequest utility here from the 'next' package because of dependency issues\n  // However that utility should be used where possible instead of manually appending the data\n  let data\n\n  try {\n    data = await incomingReq.json?.()\n  } catch (_err) {\n    data = {}\n  }\n\n  const reqWithData: PayloadRequest = incomingReq\n\n  if (data) {\n    reqWithData.data = data\n    // @ts-expect-error\n    reqWithData.json = () => Promise.resolve(data)\n  }\n\n  const doc = await update({\n    key: reqWithData.routeParams?.key as string,\n    req: reqWithData,\n    user: reqWithData?.user,\n    value: reqWithData.data?.value || reqWithData.data,\n  })\n\n  return Response.json(\n    {\n      doc,\n      message: reqWithData.t('general:updatedSuccessfully'),\n    },\n    {\n      status: httpStatus.OK,\n    },\n  )\n}\n"],"names":["status","httpStatus","update","updateHandler","incomingReq","data","json","_err","reqWithData","Promise","resolve","doc","key","routeParams","req","user","value","Response","message","t","OK"],"mappings":";;;;;AAAA,SAASA,UAAUC,UAAU,QAAQ,cAAa;AAKlD,SAASC,MAAM,QAAQ,0BAAyB;;;AAEzC,MAAMC,gBAAgC,OAAOC;IAClD,iHAAiH;IACjH,4FAA4F;IAC5F,IAAIC;IAEJ,IAAI;QACFA,OAAO,MAAMD,YAAYE,IAAI;IAC/B,EAAE,OAAOC,MAAM;QACbF,OAAO,CAAC;IACV;IAEA,MAAMG,cAA8BJ;IAEpC,IAAIC,MAAM;QACRG,YAAYH,IAAI,GAAGA;QACnB,mBAAmB;QACnBG,YAAYF,IAAI,GAAG,IAAMG,QAAQC,OAAO,CAACL;IAC3C;IAEA,MAAMM,MAAM,UAAMT,kLAAAA,EAAO;QACvBU,KAAKJ,YAAYK,WAAW,EAAED;QAC9BE,KAAKN;QACLO,MAAMP,aAAaO;QACnBC,OAAOR,YAAYH,IAAI,EAAEW,SAASR,YAAYH,IAAI;IACpD;IAEA,OAAOY,SAASX,IAAI,CAClB;QACEK;QACAO,SAASV,YAAYW,CAAC,CAAC;IACzB,GACA;QACEnB,QAAQC,sMAAAA,CAAWmB,EAAE;IACvB;AAEJ,EAAC"}},
    {"offset": {"line": 4224, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/preferences/config.ts"],"sourcesContent":["import type { CollectionConfig } from '../collections/config/types.js'\nimport type { Access, Config } from '../config/types.js'\nimport type { Where } from '../types/index.js'\n\nimport { deleteHandler } from './requestHandlers/delete.js'\nimport { findByIDHandler } from './requestHandlers/findOne.js'\nimport { updateHandler } from './requestHandlers/update.js'\n\nconst preferenceAccess: Access = ({ req }) => {\n  if (!req.user) {\n    return false\n  }\n\n  const userValueCondition: Where = {\n    'user.value': {\n      equals: req.user.id,\n    },\n  }\n\n  const userRelationCondition: Where = {\n    'user.relationTo': {\n      equals: req.user.collection,\n    },\n  }\n\n  return {\n    and: [userValueCondition, userRelationCondition],\n  }\n}\n\nexport const preferencesCollectionSlug = 'payload-preferences'\n\nexport const getPreferencesCollection = (config: Config): CollectionConfig => ({\n  slug: preferencesCollectionSlug,\n  access: {\n    delete: preferenceAccess,\n    read: preferenceAccess,\n  },\n  admin: {\n    hidden: true,\n  },\n  endpoints: [\n    {\n      handler: findByIDHandler,\n      method: 'get',\n      path: '/:key',\n    },\n    {\n      handler: deleteHandler,\n      method: 'delete',\n      path: '/:key',\n    },\n    {\n      handler: updateHandler,\n      method: 'post',\n      path: '/:key',\n    },\n  ],\n  fields: [\n    {\n      name: 'user',\n      type: 'relationship',\n      hooks: {\n        beforeValidate: [\n          ({ req }) => {\n            if (!req?.user) {\n              return null\n            }\n\n            return {\n              relationTo: req?.user.collection,\n              value: req?.user.id,\n            }\n          },\n        ],\n      },\n      index: true,\n      relationTo: config\n        .collections!.filter((collectionConfig) => collectionConfig.auth)\n        .map((collectionConfig) => collectionConfig.slug),\n      required: true,\n    },\n    {\n      name: 'key',\n      type: 'text',\n      index: true,\n    },\n    {\n      name: 'value',\n      type: 'json',\n      validate: (value) => {\n        if (value) {\n          try {\n            JSON.parse(JSON.stringify(value))\n          } catch {\n            return 'Invalid JSON'\n          }\n        }\n\n        return true\n      },\n    },\n  ],\n  lockDocuments: false,\n})\n"],"names":["deleteHandler","findByIDHandler","updateHandler","preferenceAccess","req","user","userValueCondition","equals","id","userRelationCondition","collection","and","preferencesCollectionSlug","getPreferencesCollection","config","slug","access","delete","read","admin","hidden","endpoints","handler","method","path","fields","name","type","hooks","beforeValidate","relationTo","value","index","collections","filter","collectionConfig","auth","map","required","validate","JSON","parse","stringify","lockDocuments"],"mappings":";;;;;;AAIA,SAASA,aAAa,QAAQ,8BAA6B;AAC3D,SAASC,eAAe,QAAQ,+BAA8B;AAC9D,SAASC,aAAa,QAAQ,8BAA6B;;;;AAE3D,MAAMC,mBAA2B,CAAC,EAAEC,GAAG,EAAE;IACvC,IAAI,CAACA,IAAIC,IAAI,EAAE;QACb,OAAO;IACT;IAEA,MAAMC,qBAA4B;QAChC,cAAc;YACZC,QAAQH,IAAIC,IAAI,CAACG,EAAE;QACrB;IACF;IAEA,MAAMC,wBAA+B;QACnC,mBAAmB;YACjBF,QAAQH,IAAIC,IAAI,CAACK,UAAU;QAC7B;IACF;IAEA,OAAO;QACLC,KAAK;YAACL;YAAoBG;SAAsB;IAClD;AACF;AAEO,MAAMG,4BAA4B,sBAAqB;AAEvD,MAAMC,2BAA2B,CAACC,SAAsC,CAAA;QAC7EC,MAAMH;QACNI,QAAQ;YACNC,QAAQd;YACRe,MAAMf;QACR;QACAgB,OAAO;YACLC,QAAQ;QACV;QACAC,WAAW;YACT;gBACEC,SAASrB,iMAAAA;gBACTsB,QAAQ;gBACRC,MAAM;YACR;YACA;gBACEF,SAAStB,8LAAAA;gBACTuB,QAAQ;gBACRC,MAAM;YACR;YACA;gBACEF,SAASpB,8LAAAA;gBACTqB,QAAQ;gBACRC,MAAM;YACR;SACD;QACDC,QAAQ;YACN;gBACEC,MAAM;gBACNC,MAAM;gBACNC,OAAO;oBACLC,gBAAgB;wBACd,CAAC,EAAEzB,GAAG,EAAE;4BACN,IAAI,CAACA,KAAKC,MAAM;gCACd,OAAO;4BACT;4BAEA,OAAO;gCACLyB,YAAY1B,KAAKC,KAAKK;gCACtBqB,OAAO3B,KAAKC,KAAKG;4BACnB;wBACF;qBACD;gBACH;gBACAwB,OAAO;gBACPF,YAAYhB,OACTmB,WAAW,CAAEC,MAAM,CAAC,CAACC,mBAAqBA,iBAAiBC,IAAI,EAC/DC,GAAG,CAAC,CAACF,mBAAqBA,iBAAiBpB,IAAI;gBAClDuB,UAAU;YACZ;YACA;gBACEZ,MAAM;gBACNC,MAAM;gBACNK,OAAO;YACT;YACA;gBACEN,MAAM;gBACNC,MAAM;gBACNY,UAAU,CAACR;oBACT,IAAIA,OAAO;wBACT,IAAI;4BACFS,KAAKC,KAAK,CAACD,KAAKE,SAAS,CAACX;wBAC5B,EAAE,OAAM;4BACN,OAAO;wBACT;oBACF;oBAEA,OAAO;gBACT;YACF;SACD;QACDY,eAAe;IACjB,CAAA,EAAE"}},
    {"offset": {"line": 4331, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/preferences/deleteUserPreferences.ts"],"sourcesContent":["import type { SanitizedCollectionConfig } from '../collections/config/types.js'\nimport type { Payload } from '../index.js'\nimport type { PayloadRequest } from '../types/index.js'\n\nimport { preferencesCollectionSlug } from './config.js'\n\ntype Args = {\n  collectionConfig: SanitizedCollectionConfig\n  /**\n   * User IDs to delete\n   */\n  ids: (number | string)[]\n  payload: Payload\n  req: PayloadRequest\n}\nexport const deleteUserPreferences = async ({ collectionConfig, ids, payload, req }: Args) => {\n  if (collectionConfig.auth) {\n    await payload.db.deleteMany({\n      collection: preferencesCollectionSlug,\n      req,\n      where: {\n        or: [\n          {\n            and: [\n              {\n                'user.value': { in: ids },\n              },\n              {\n                'user.relationTo': { equals: collectionConfig.slug },\n              },\n            ],\n          },\n          {\n            key: { in: ids.map((id) => `collection-${collectionConfig.slug}-${id}`) },\n          },\n        ],\n      },\n    })\n  } else {\n    await payload.db.deleteMany({\n      collection: preferencesCollectionSlug,\n      req,\n      where: {\n        key: { in: ids.map((id) => `collection-${collectionConfig.slug}-${id}`) },\n      },\n    })\n  }\n}\n"],"names":["preferencesCollectionSlug","deleteUserPreferences","collectionConfig","ids","payload","req","auth","db","deleteMany","collection","where","or","and","in","equals","slug","key","map","id"],"mappings":";;;;AAIA,SAASA,yBAAyB,QAAQ,cAAa;;AAWhD,MAAMC,wBAAwB,OAAO,EAAEC,gBAAgB,EAAEC,GAAG,EAAEC,OAAO,EAAEC,GAAG,EAAQ;IACvF,IAAIH,iBAAiBI,IAAI,EAAE;QACzB,MAAMF,QAAQG,EAAE,CAACC,UAAU,CAAC;YAC1BC,YAAYT,uLAAAA;YACZK;YACAK,OAAO;gBACLC,IAAI;oBACF;wBACEC,KAAK;4BACH;gCACE,cAAc;oCAAEC,IAAIV;gCAAI;4BAC1B;4BACA;gCACE,mBAAmB;oCAAEW,QAAQZ,iBAAiBa,IAAI;gCAAC;4BACrD;yBACD;oBACH;oBACA;wBACEC,KAAK;4BAAEH,IAAIV,IAAIc,GAAG,CAAC,CAACC,KAAO,CAAC,WAAW,EAAEhB,iBAAiBa,IAAI,CAAC,CAAC,EAAEG,IAAI;wBAAE;oBAC1E;iBACD;YACH;QACF;IACF,OAAO;QACL,MAAMd,QAAQG,EAAE,CAACC,UAAU,CAAC;YAC1BC,YAAYT,uLAAAA;YACZK;YACAK,OAAO;gBACLM,KAAK;oBAAEH,IAAIV,IAAIc,GAAG,CAAC,CAACC,KAAO,CAAC,WAAW,EAAEhB,iBAAiBa,IAAI,CAAC,CAAC,EAAEG,IAAI;gBAAE;YAC1E;QACF;IACF;AACF,EAAC"}},
    {"offset": {"line": 4382, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/locked-documents/config.ts"],"sourcesContent":["import type { CollectionConfig } from '../collections/config/types.js'\nimport type { Config } from '../config/types.js'\n\nimport { defaultAccess } from '../auth/defaultAccess.js'\n\nexport const lockedDocumentsCollectionSlug = 'payload-locked-documents'\n\nexport const getLockedDocumentsCollection = (config: Config): CollectionConfig | null => {\n  const lockableCollections = config\n    .collections!.filter((collectionConfig) => collectionConfig.lockDocuments !== false)\n    .map((collectionConfig) => collectionConfig.slug)\n\n  const lockableGlobals = config.globals\n    ? config.globals.filter((globalConfig) => globalConfig.lockDocuments !== false)\n    : []\n\n  const authCollections = config\n    .collections!.filter((collectionConfig) => collectionConfig.auth)\n    .map((collectionConfig) => collectionConfig.slug)\n\n  // If there are no lockable collections AND no lockable globals, don't create the collection\n  if (lockableCollections.length === 0 && lockableGlobals.length === 0) {\n    return null\n  }\n\n  // If there are no auth collections, we can't track who locked the document\n  // so we shouldn't create the locked-documents collection\n  if (authCollections.length === 0) {\n    return null\n  }\n\n  const fields: CollectionConfig['fields'] = []\n\n  // Only include the document field if there are lockable collections\n  if (lockableCollections.length > 0) {\n    fields.push({\n      name: 'document',\n      type: 'relationship',\n      index: true,\n      maxDepth: 0,\n      relationTo: lockableCollections,\n    })\n  }\n\n  // Always include globalSlug field for tracking global locks\n  fields.push({\n    name: 'globalSlug',\n    type: 'text',\n    index: true,\n  })\n\n  // Always include user field\n  fields.push({\n    name: 'user',\n    type: 'relationship',\n    maxDepth: 1,\n    relationTo: authCollections,\n    required: true,\n  })\n\n  return {\n    slug: lockedDocumentsCollectionSlug,\n    access: {\n      create: defaultAccess,\n      delete: defaultAccess,\n      read: defaultAccess,\n      update: defaultAccess,\n    },\n    admin: {\n      hidden: true,\n    },\n    fields,\n    lockDocuments: false,\n  }\n}\n"],"names":["defaultAccess","lockedDocumentsCollectionSlug","getLockedDocumentsCollection","config","lockableCollections","collections","filter","collectionConfig","lockDocuments","map","slug","lockableGlobals","globals","globalConfig","authCollections","auth","length","fields","push","name","type","index","maxDepth","relationTo","required","access","create","delete","read","update","admin","hidden"],"mappings":";;;;;;AAGA,SAASA,aAAa,QAAQ,2BAA0B;;AAEjD,MAAMC,gCAAgC,2BAA0B;AAEhE,MAAMC,+BAA+B,CAACC;IAC3C,MAAMC,sBAAsBD,OACzBE,WAAW,CAAEC,MAAM,CAAC,CAACC,mBAAqBA,iBAAiBC,aAAa,KAAK,OAC7EC,GAAG,CAAC,CAACF,mBAAqBA,iBAAiBG,IAAI;IAElD,MAAMC,kBAAkBR,OAAOS,OAAO,GAClCT,OAAOS,OAAO,CAACN,MAAM,CAAC,CAACO,eAAiBA,aAAaL,aAAa,KAAK,SACvE,EAAE;IAEN,MAAMM,kBAAkBX,OACrBE,WAAW,CAAEC,MAAM,CAAC,CAACC,mBAAqBA,iBAAiBQ,IAAI,EAC/DN,GAAG,CAAC,CAACF,mBAAqBA,iBAAiBG,IAAI;IAElD,4FAA4F;IAC5F,IAAIN,oBAAoBY,MAAM,KAAK,KAAKL,gBAAgBK,MAAM,KAAK,GAAG;QACpE,OAAO;IACT;IAEA,2EAA2E;IAC3E,yDAAyD;IACzD,IAAIF,gBAAgBE,MAAM,KAAK,GAAG;QAChC,OAAO;IACT;IAEA,MAAMC,SAAqC,EAAE;IAE7C,oEAAoE;IACpE,IAAIb,oBAAoBY,MAAM,GAAG,GAAG;QAClCC,OAAOC,IAAI,CAAC;YACVC,MAAM;YACNC,MAAM;YACNC,OAAO;YACPC,UAAU;YACVC,YAAYnB;QACd;IACF;IAEA,4DAA4D;IAC5Da,OAAOC,IAAI,CAAC;QACVC,MAAM;QACNC,MAAM;QACNC,OAAO;IACT;IAEA,4BAA4B;IAC5BJ,OAAOC,IAAI,CAAC;QACVC,MAAM;QACNC,MAAM;QACNE,UAAU;QACVC,YAAYT;QACZU,UAAU;IACZ;IAEA,OAAO;QACLd,MAAMT;QACNwB,QAAQ;YACNC,QAAQ1B,2KAAAA;YACR2B,QAAQ3B,2KAAAA;YACR4B,MAAM5B,2KAAAA;YACN6B,QAAQ7B,2KAAAA;QACV;QACA8B,OAAO;YACLC,QAAQ;QACV;QACAd;QACAT,eAAe;IACjB;AACF,EAAC"}},
    {"offset": {"line": 4448, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/queues/config/global.ts"],"sourcesContent":["import type { Config } from '../../config/types.js'\nimport type { GlobalConfig } from '../../globals/config/types.js'\nimport type { TaskType } from './types/taskTypes.js'\nimport type { WorkflowTypes } from './types/workflowTypes.js'\n\nexport const jobStatsGlobalSlug = 'payload-jobs-stats'\n\n/**\n * Type for data stored in the payload-jobs-stats global.\n */\nexport type JobStats = {\n  stats?: {\n    scheduledRuns?: {\n      queues?: {\n        [queueSlug: string]: {\n          tasks?: {\n            [taskSlug: TaskType]: {\n              lastScheduledRun: string\n            }\n          }\n          workflows?: {\n            [workflowSlug: WorkflowTypes]: {\n              lastScheduledRun: string\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\n/**\n * Global config for job statistics.\n */\nexport const getJobStatsGlobal: (config: Config) => GlobalConfig = (config) => {\n  return {\n    slug: jobStatsGlobalSlug,\n    admin: {\n      group: 'System',\n      hidden: true,\n    },\n    fields: [\n      {\n        name: 'stats',\n        type: 'json',\n      },\n    ],\n  }\n}\n"],"names":["jobStatsGlobalSlug","getJobStatsGlobal","config","slug","admin","group","hidden","fields","name","type"],"mappings":";;;;;;AAKO,MAAMA,qBAAqB,qBAAoB;AA6B/C,MAAMC,oBAAsD,CAACC;IAClE,OAAO;QACLC,MAAMH;QACNI,OAAO;YACLC,OAAO;YACPC,QAAQ;QACV;QACAC,QAAQ;YACN;gBACEC,MAAM;gBACNC,MAAM;YACR;SACD;IACH;AACF,EAAC"}},
    {"offset": {"line": 4474, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/queues/utilities/getCurrentDate.ts"],"sourcesContent":["/**\n * Globals that are used by our integration tests to modify the behavior of the job system during runtime.\n * This is useful to avoid having to wait for the cron jobs to run, or to pause auto-running jobs.\n */\nexport const _internal_jobSystemGlobals = {\n  getCurrentDate: () => {\n    return new Date()\n  },\n  shouldAutoRun: true,\n  shouldAutoSchedule: true,\n}\n\nexport function _internal_resetJobSystemGlobals() {\n  _internal_jobSystemGlobals.getCurrentDate = () => new Date()\n  _internal_jobSystemGlobals.shouldAutoRun = true\n  _internal_jobSystemGlobals.shouldAutoSchedule = true\n}\n\nexport const getCurrentDate: () => Date = () => {\n  return _internal_jobSystemGlobals.getCurrentDate()\n}\n"],"names":["_internal_jobSystemGlobals","getCurrentDate","Date","shouldAutoRun","shouldAutoSchedule","_internal_resetJobSystemGlobals"],"mappings":"AAAA;;;CAGC,GACD;;;;;;;;AAAO,MAAMA,6BAA6B;IACxCC,gBAAgB;QACd,OAAO,IAAIC;IACb;IACAC,eAAe;IACfC,oBAAoB;AACtB,EAAC;AAEM,SAASC;IACdL,2BAA2BC,cAAc,GAAG,IAAM,IAAIC;IACtDF,2BAA2BG,aAAa,GAAG;IAC3CH,2BAA2BI,kBAAkB,GAAG;AAClD;AAEO,MAAMH,iBAA6B;IACxC,OAAOD,2BAA2BC,cAAc;AAClD,EAAC"}},
    {"offset": {"line": 4504, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/queues/operations/handleSchedules/defaultAfterSchedule.ts"],"sourcesContent":["import type { AfterScheduleFn } from '../../config/types/index.js'\n\nimport { type JobStats, jobStatsGlobalSlug } from '../../config/global.js'\nimport { getCurrentDate } from '../../utilities/getCurrentDate.js'\n\ntype JobStatsScheduledRuns = NonNullable<\n  NonNullable<NonNullable<JobStats['stats']>['scheduledRuns']>['queues']\n>[string]\n\nexport const defaultAfterSchedule: AfterScheduleFn = async ({ jobStats, queueable, req }) => {\n  const existingQueuesConfig =\n    jobStats?.stats?.scheduledRuns?.queues?.[queueable.scheduleConfig.queue] || {}\n\n  const queueConfig: JobStatsScheduledRuns = {\n    ...existingQueuesConfig,\n  }\n  if (queueable.taskConfig) {\n    ;(queueConfig.tasks ??= {})[queueable.taskConfig.slug] = {\n      lastScheduledRun: getCurrentDate().toISOString(),\n    }\n  } else if (queueable.workflowConfig) {\n    ;(queueConfig.workflows ??= {})[queueable.workflowConfig.slug] = {\n      lastScheduledRun: getCurrentDate().toISOString(),\n    }\n  }\n\n  // Add to payload-jobs-stats global regardless of the status\n  if (jobStats) {\n    await req.payload.db.updateGlobal({\n      slug: jobStatsGlobalSlug,\n      data: {\n        ...(jobStats || {}),\n        stats: {\n          ...(jobStats?.stats || {}),\n          scheduledRuns: {\n            ...(jobStats?.stats?.scheduledRuns || {}),\n            queues: {\n              ...(jobStats?.stats?.scheduledRuns?.queues || {}),\n              [queueable.scheduleConfig.queue]: queueConfig,\n            },\n          },\n        },\n        updatedAt: new Date().toISOString(),\n      } as JobStats,\n      req,\n      returning: false,\n    })\n  } else {\n    await req.payload.db.createGlobal({\n      slug: jobStatsGlobalSlug,\n      data: {\n        createdAt: getCurrentDate().toISOString(),\n        stats: {\n          scheduledRuns: {\n            queues: {\n              [queueable.scheduleConfig.queue]: queueConfig,\n            },\n          },\n        },\n      } as JobStats,\n      req,\n      returning: false,\n    })\n  }\n}\n"],"names":["jobStatsGlobalSlug","getCurrentDate","defaultAfterSchedule","jobStats","queueable","req","existingQueuesConfig","stats","scheduledRuns","queues","scheduleConfig","queue","queueConfig","taskConfig","tasks","slug","lastScheduledRun","toISOString","workflowConfig","workflows","payload","db","updateGlobal","data","updatedAt","Date","returning","createGlobal","createdAt"],"mappings":";;;;AAEA,SAAwBA,kBAAkB,QAAQ,yBAAwB;AAC1E,SAASC,cAAc,QAAQ,oCAAmC;;;AAM3D,MAAMC,uBAAwC,OAAO,EAAEC,QAAQ,EAAEC,SAAS,EAAEC,GAAG,EAAE;IACtF,MAAMC,uBACJH,UAAUI,OAAOC,eAAeC,QAAQ,CAACL,UAAUM,cAAc,CAACC,KAAK,CAAC,IAAI,CAAC;IAE/E,MAAMC,cAAqC;QACzC,GAAGN,oBAAoB;IACzB;IACA,IAAIF,UAAUS,UAAU,EAAE;;QACtBD,CAAAA,YAAYE,KAAK,KAAK,CAAC,CAAA,CAAE,CAACV,UAAUS,UAAU,CAACE,IAAI,CAAC,GAAG;YACvDC,sBAAkBf,4LAAAA,IAAiBgB,WAAW;QAChD;IACF,OAAO,IAAIb,UAAUc,cAAc,EAAE;;QACjCN,CAAAA,YAAYO,SAAS,KAAK,CAAC,CAAA,CAAE,CAACf,UAAUc,cAAc,CAACH,IAAI,CAAC,GAAG;YAC/DC,sBAAkBf,4LAAAA,IAAiBgB,WAAW;QAChD;IACF;IAEA,4DAA4D;IAC5D,IAAId,UAAU;QACZ,MAAME,IAAIe,OAAO,CAACC,EAAE,CAACC,YAAY,CAAC;YAChCP,MAAMf,qLAAAA;YACNuB,MAAM;gBACJ,GAAIpB,YAAY,CAAC,CAAC;gBAClBI,OAAO;oBACL,GAAIJ,UAAUI,SAAS,CAAC,CAAC;oBACzBC,eAAe;wBACb,GAAIL,UAAUI,OAAOC,iBAAiB,CAAC,CAAC;wBACxCC,QAAQ;4BACN,GAAIN,UAAUI,OAAOC,eAAeC,UAAU,CAAC,CAAC;4BAChD,CAACL,UAAUM,cAAc,CAACC,KAAK,CAAC,EAAEC;wBACpC;oBACF;gBACF;gBACAY,WAAW,IAAIC,OAAOR,WAAW;YACnC;YACAZ;YACAqB,WAAW;QACb;IACF,OAAO;QACL,MAAMrB,IAAIe,OAAO,CAACC,EAAE,CAACM,YAAY,CAAC;YAChCZ,MAAMf,qLAAAA;YACNuB,MAAM;gBACJK,eAAW3B,4LAAAA,IAAiBgB,WAAW;gBACvCV,OAAO;oBACLC,eAAe;wBACbC,QAAQ;4BACN,CAACL,UAAUM,cAAc,CAACC,KAAK,CAAC,EAAEC;wBACpC;oBACF;gBACF;YACF;YACAP;YACAqB,WAAW;QACb;IACF;AACF,EAAC"}},
    {"offset": {"line": 4571, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/queues/operations/handleSchedules/countRunnableOrActiveJobsForQueue.ts"],"sourcesContent":["import type { PayloadRequest, Where } from '../../../types/index.js'\nimport type { TaskType } from '../../config/types/taskTypes.js'\nimport type { WorkflowTypes } from '../../config/types/workflowTypes.js'\n\n/**\n * Gets all queued jobs that can be run. This means they either:\n * - failed but do not have a definitive error => can be retried\n * - are currently processing\n * - have not been started yet\n */\nexport async function countRunnableOrActiveJobsForQueue({\n  onlyScheduled = false,\n  queue,\n  req,\n  taskSlug,\n  workflowSlug,\n}: {\n  /**\n   * If true, this counts only jobs that have been created through the scheduling system.\n   *\n   * @default false\n   */\n  onlyScheduled?: boolean\n  queue: string\n  req: PayloadRequest\n  taskSlug?: TaskType\n  workflowSlug?: WorkflowTypes\n}): Promise<number> {\n  const and: Where[] = [\n    {\n      queue: {\n        equals: queue,\n      },\n    },\n\n    {\n      completedAt: { exists: false },\n    },\n    {\n      error: { exists: false },\n    },\n  ]\n\n  if (taskSlug) {\n    and.push({\n      taskSlug: {\n        equals: taskSlug,\n      },\n    })\n  } else if (workflowSlug) {\n    and.push({\n      workflowSlug: {\n        equals: workflowSlug,\n      },\n    })\n  }\n  if (onlyScheduled) {\n    and.push({\n      'meta.scheduled': {\n        equals: true,\n      },\n    })\n  }\n\n  const runnableOrActiveJobsForQueue = await req.payload.db.count({\n    collection: 'payload-jobs',\n    req,\n    where: {\n      and,\n    },\n  })\n\n  return runnableOrActiveJobsForQueue.totalDocs\n}\n"],"names":["countRunnableOrActiveJobsForQueue","onlyScheduled","queue","req","taskSlug","workflowSlug","and","equals","completedAt","exists","error","push","runnableOrActiveJobsForQueue","payload","db","count","collection","where","totalDocs"],"mappings":"AAIA;;;;;CAKC,GACD;;;;AAAO,eAAeA,kCAAkC,EACtDC,gBAAgB,KAAK,EACrBC,KAAK,EACLC,GAAG,EACHC,QAAQ,EACRC,YAAY,EAYb;IACC,MAAMC,MAAe;QACnB;YACEJ,OAAO;gBACLK,QAAQL;YACV;QACF;QAEA;YACEM,aAAa;gBAAEC,QAAQ;YAAM;QAC/B;QACA;YACEC,OAAO;gBAAED,QAAQ;YAAM;QACzB;KACD;IAED,IAAIL,UAAU;QACZE,IAAIK,IAAI,CAAC;YACPP,UAAU;gBACRG,QAAQH;YACV;QACF;IACF,OAAO,IAAIC,cAAc;QACvBC,IAAIK,IAAI,CAAC;YACPN,cAAc;gBACZE,QAAQF;YACV;QACF;IACF;IACA,IAAIJ,eAAe;QACjBK,IAAIK,IAAI,CAAC;YACP,kBAAkB;gBAChBJ,QAAQ;YACV;QACF;IACF;IAEA,MAAMK,+BAA+B,MAAMT,IAAIU,OAAO,CAACC,EAAE,CAACC,KAAK,CAAC;QAC9DC,YAAY;QACZb;QACAc,OAAO;YACLX;QACF;IACF;IAEA,OAAOM,6BAA6BM,SAAS;AAC/C"}},
    {"offset": {"line": 4631, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/queues/operations/handleSchedules/defaultBeforeSchedule.ts"],"sourcesContent":["import type { BeforeScheduleFn } from '../../config/types/index.js'\n\nimport { countRunnableOrActiveJobsForQueue } from './countRunnableOrActiveJobsForQueue.js'\n\nexport const defaultBeforeSchedule: BeforeScheduleFn = async ({ queueable, req }) => {\n  // All tasks in that queue that are either currently processing or can be run\n  const runnableOrActiveJobsForQueue = await countRunnableOrActiveJobsForQueue({\n    onlyScheduled: true,\n    queue: queueable.scheduleConfig.queue,\n    req,\n    taskSlug: queueable.taskConfig?.slug,\n    workflowSlug: queueable.workflowConfig?.slug,\n  })\n\n  return {\n    input: {},\n    shouldSchedule: runnableOrActiveJobsForQueue === 0,\n    waitUntil: queueable.waitUntil,\n  }\n}\n"],"names":["countRunnableOrActiveJobsForQueue","defaultBeforeSchedule","queueable","req","runnableOrActiveJobsForQueue","onlyScheduled","queue","scheduleConfig","taskSlug","taskConfig","slug","workflowSlug","workflowConfig","input","shouldSchedule","waitUntil"],"mappings":";;;;AAEA,SAASA,iCAAiC,QAAQ,yCAAwC;;AAEnF,MAAMC,wBAA0C,OAAO,EAAEC,SAAS,EAAEC,GAAG,EAAE;IAC9E,6EAA6E;IAC7E,MAAMC,+BAA+B,UAAMJ,sPAAAA,EAAkC;QAC3EK,eAAe;QACfC,OAAOJ,UAAUK,cAAc,CAACD,KAAK;QACrCH;QACAK,UAAUN,UAAUO,UAAU,EAAEC;QAChCC,cAAcT,UAAUU,cAAc,EAAEF;IAC1C;IAEA,OAAO;QACLG,OAAO,CAAC;QACRC,gBAAgBV,iCAAiC;QACjDW,WAAWb,UAAUa,SAAS;IAChC;AACF,EAAC"}},
    {"offset": {"line": 4656, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/queues/operations/handleSchedules/getQueuesWithSchedules.ts"],"sourcesContent":["import type { SanitizedJobsConfig, ScheduleConfig } from '../../config/types/index.js'\nimport type { TaskConfig } from '../../config/types/taskTypes.js'\nimport type { WorkflowConfig } from '../../config/types/workflowTypes.js'\n\ntype QueuesWithSchedules = {\n  [queue: string]: {\n    schedules: {\n      scheduleConfig: ScheduleConfig\n      taskConfig?: TaskConfig\n      workflowConfig?: WorkflowConfig\n    }[]\n  }\n}\n\nexport const getQueuesWithSchedules = ({\n  jobsConfig,\n}: {\n  jobsConfig: SanitizedJobsConfig\n}): QueuesWithSchedules => {\n  const tasksWithSchedules =\n    jobsConfig.tasks?.filter((task) => {\n      return task.schedule?.length\n    }) ?? []\n\n  const workflowsWithSchedules =\n    jobsConfig.workflows?.filter((workflow) => {\n      return workflow.schedule?.length\n    }) ?? []\n\n  const queuesWithSchedules: QueuesWithSchedules = {}\n\n  for (const task of tasksWithSchedules) {\n    for (const schedule of task.schedule ?? []) {\n      ;(queuesWithSchedules[schedule.queue] ??= { schedules: [] }).schedules.push({\n        scheduleConfig: schedule,\n        taskConfig: task,\n      })\n    }\n  }\n  for (const workflow of workflowsWithSchedules) {\n    for (const schedule of workflow.schedule ?? []) {\n      ;(queuesWithSchedules[schedule.queue] ??= { schedules: [] }).schedules.push({\n        scheduleConfig: schedule,\n        workflowConfig: workflow,\n      })\n    }\n  }\n\n  return queuesWithSchedules\n}\n"],"names":["getQueuesWithSchedules","jobsConfig","tasksWithSchedules","tasks","filter","task","schedule","length","workflowsWithSchedules","workflows","workflow","queuesWithSchedules","queue","schedules","push","scheduleConfig","taskConfig","workflowConfig"],"mappings":";;;;AAcO,MAAMA,yBAAyB,CAAC,EACrCC,UAAU,EAGX;IACC,MAAMC,qBACJD,WAAWE,KAAK,EAAEC,OAAO,CAACC;QACxB,OAAOA,KAAKC,QAAQ,EAAEC;IACxB,MAAM,EAAE;IAEV,MAAMC,yBACJP,WAAWQ,SAAS,EAAEL,OAAO,CAACM;QAC5B,OAAOA,SAASJ,QAAQ,EAAEC;IAC5B,MAAM,EAAE;IAEV,MAAMI,sBAA2C,CAAC;IAElD,KAAK,MAAMN,QAAQH,mBAAoB;QACrC,KAAK,MAAMI,YAAYD,KAAKC,QAAQ,IAAI,EAAE,CAAE;;YACxCK,CAAAA,mBAAmB,CAACL,SAASM,KAAK,CAAC,KAAK;gBAAEC,WAAW,EAAE;YAAC,CAAA,EAAGA,SAAS,CAACC,IAAI,CAAC;gBAC1EC,gBAAgBT;gBAChBU,YAAYX;YACd;QACF;IACF;IACA,KAAK,MAAMK,YAAYF,uBAAwB;QAC7C,KAAK,MAAMF,YAAYI,SAASJ,QAAQ,IAAI,EAAE,CAAE;;YAC5CK,CAAAA,mBAAmB,CAACL,SAASM,KAAK,CAAC,KAAK;gBAAEC,WAAW,EAAE;YAAC,CAAA,EAAGA,SAAS,CAACC,IAAI,CAAC;gBAC1EC,gBAAgBT;gBAChBW,gBAAgBP;YAClB;QACF;IACF;IAEA,OAAOC;AACT,EAAC"}},
    {"offset": {"line": 4696, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/queues/operations/handleSchedules/index.ts"],"sourcesContent":["import { Cron } from 'croner'\n\nimport type { Job, TaskConfig, WorkflowConfig } from '../../../index.js'\nimport type { PayloadRequest } from '../../../types/index.js'\nimport type { BeforeScheduleFn, Queueable, ScheduleConfig } from '../../config/types/index.js'\n\nimport { type JobStats, jobStatsGlobalSlug } from '../../config/global.js'\nimport { defaultAfterSchedule } from './defaultAfterSchedule.js'\nimport { defaultBeforeSchedule } from './defaultBeforeSchedule.js'\nimport { getQueuesWithSchedules } from './getQueuesWithSchedules.js'\n\nexport type HandleSchedulesResult = {\n  errored: Queueable[]\n  queued: Queueable[]\n  skipped: Queueable[]\n}\n\n/**\n * On vercel, we cannot auto-schedule jobs using a Cron - instead, we'll use this same endpoint that can\n * also be called from Vercel Cron for auto-running jobs.\n *\n * The benefit of doing it like this instead of a separate endpoint is that we can run jobs immediately\n * after they are scheduled\n */\nexport async function handleSchedules({\n  allQueues = false,\n  queue: _queue,\n  req,\n}: {\n  /**\n   * If you want to schedule jobs from all queues, set this to true.\n   * If you set this to true, the `queue` property will be ignored.\n   *\n   * @default false\n   */\n  allQueues?: boolean\n  /**\n   * If you want to only schedule jobs that are set to schedule in a specific queue, set this to the queue name.\n   *\n   * @default jobs from the `default` queue will be executed.\n   */\n  queue?: string\n  req: PayloadRequest\n}): Promise<HandleSchedulesResult> {\n  const queue = _queue ?? 'default'\n  const jobsConfig = req.payload.config.jobs\n  const queuesWithSchedules = getQueuesWithSchedules({\n    jobsConfig,\n  })\n\n  if (Object.keys(queuesWithSchedules).length === 0) {\n    // No schedules defined => return early, before fetching jobsStatsGlobal, as the global may not even exist\n    return {\n      errored: [],\n      queued: [],\n      skipped: [],\n    }\n  }\n\n  const stats: JobStats = await req.payload.db.findGlobal({\n    slug: jobStatsGlobalSlug,\n    req,\n  })\n\n  /**\n   * Almost last step! Tasks and Workflows added here just need to be constraint-checked (e.g max. 1 running task etc.),\n   * before we can queue them\n   */\n  const queueables: Queueable[] = []\n\n  // Need to know when that particular job was last scheduled in that particular queue\n\n  for (const [queueName, { schedules }] of Object.entries(queuesWithSchedules)) {\n    if (!allQueues && queueName !== queue) {\n      // If a queue is specified, only schedule jobs for that queue\n      continue\n    }\n    for (const schedulable of schedules) {\n      const queuable = checkQueueableTimeConstraints({\n        queue: queueName,\n        scheduleConfig: schedulable.scheduleConfig,\n        stats,\n        taskConfig: schedulable.taskConfig,\n        workflowConfig: schedulable.workflowConfig,\n      })\n      if (queuable) {\n        queueables.push(queuable)\n      }\n    }\n  }\n\n  const queued: Queueable[] = []\n  const skipped: Queueable[] = []\n  const errored: Queueable[] = []\n\n  /**\n   * Now queue, but check for constraints (= beforeSchedule) first.\n   * Default constraint (= defaultBeforeSchedule): max. 1 running / scheduled task or workflow per queue\n   */\n  for (const queueable of queueables) {\n    const { status } = await scheduleQueueable({\n      queueable,\n      req,\n      stats,\n    })\n    switch (status) {\n      case 'error':\n        errored.push(queueable)\n        break\n      case 'skipped':\n        skipped.push(queueable)\n        break\n      case 'success':\n        queued.push(queueable)\n        break\n    }\n  }\n  return {\n    errored,\n    queued,\n    skipped,\n  }\n}\n\nexport function checkQueueableTimeConstraints({\n  queue,\n  scheduleConfig,\n  stats,\n  taskConfig,\n  workflowConfig,\n}: {\n  queue: string\n  scheduleConfig: ScheduleConfig\n  stats: JobStats\n  taskConfig?: TaskConfig\n  workflowConfig?: WorkflowConfig\n}): false | Queueable {\n  const queueScheduleStats = stats?.stats?.scheduledRuns?.queues?.[queue]\n\n  const lastScheduledRun = taskConfig\n    ? queueScheduleStats?.tasks?.[taskConfig.slug]?.lastScheduledRun\n    : queueScheduleStats?.workflows?.[workflowConfig?.slug ?? '']?.lastScheduledRun\n\n  const nextRun = new Cron(scheduleConfig.cron).nextRun(lastScheduledRun ?? undefined)\n\n  if (!nextRun) {\n    return false\n  }\n  return {\n    scheduleConfig,\n    taskConfig,\n    waitUntil: nextRun,\n    workflowConfig,\n  }\n}\n\nexport async function scheduleQueueable({\n  queueable,\n  req,\n  stats,\n}: {\n  queueable: Queueable\n  req: PayloadRequest\n  stats: JobStats\n}): Promise<{\n  job?: Job<false>\n  status: 'error' | 'skipped' | 'success'\n}> {\n  if (!queueable.taskConfig && !queueable.workflowConfig) {\n    return {\n      status: 'error',\n    }\n  }\n\n  const beforeScheduleFn = queueable.scheduleConfig.hooks?.beforeSchedule\n  const afterScheduleFN = queueable.scheduleConfig.hooks?.afterSchedule\n\n  try {\n    const beforeScheduleResult: Awaited<ReturnType<BeforeScheduleFn>> = await (\n      beforeScheduleFn ?? defaultBeforeSchedule\n    )({\n      // @ts-expect-error we know defaultBeforeSchedule will never call itself => pass null\n      defaultBeforeSchedule: beforeScheduleFn ? defaultBeforeSchedule : null,\n      jobStats: stats,\n      queueable,\n      req,\n    })\n\n    if (!beforeScheduleResult.shouldSchedule) {\n      await (afterScheduleFN ?? defaultAfterSchedule)({\n        // @ts-expect-error we know defaultAfterchedule will never call itself => pass null\n        defaultAfterSchedule: afterScheduleFN ? defaultAfterSchedule : null,\n        jobStats: stats,\n        queueable,\n        req,\n        status: 'skipped',\n      })\n      return {\n        status: 'skipped',\n      }\n    }\n\n    const job = (await req.payload.jobs.queue({\n      input: beforeScheduleResult.input ?? {},\n      meta: {\n        scheduled: true,\n      },\n      queue: queueable.scheduleConfig.queue,\n      req,\n      task: queueable?.taskConfig?.slug,\n      waitUntil: beforeScheduleResult.waitUntil,\n      workflow: queueable.workflowConfig?.slug,\n    } as Parameters<typeof req.payload.jobs.queue>[0])) as unknown as Job<false>\n\n    await (afterScheduleFN ?? defaultAfterSchedule)({\n      // @ts-expect-error we know defaultAfterchedule will never call itself => pass null\n      defaultAfterSchedule: afterScheduleFN ? defaultAfterSchedule : null,\n      job,\n      jobStats: stats,\n      queueable,\n      req,\n      status: 'success',\n    })\n    return {\n      status: 'success',\n    }\n  } catch (error) {\n    await (afterScheduleFN ?? defaultAfterSchedule)({\n      // @ts-expect-error we know defaultAfterchedule will never call itself => pass null\n      defaultAfterSchedule: afterScheduleFN ? defaultAfterSchedule : null,\n      error: error as Error,\n      jobStats: stats,\n      queueable,\n      req,\n      status: 'error',\n    })\n    return {\n      status: 'error',\n    }\n  }\n}\n"],"names":["Cron","jobStatsGlobalSlug","defaultAfterSchedule","defaultBeforeSchedule","getQueuesWithSchedules","handleSchedules","allQueues","queue","_queue","req","jobsConfig","payload","config","jobs","queuesWithSchedules","Object","keys","length","errored","queued","skipped","stats","db","findGlobal","slug","queueables","queueName","schedules","entries","schedulable","queuable","checkQueueableTimeConstraints","scheduleConfig","taskConfig","workflowConfig","push","queueable","status","scheduleQueueable","queueScheduleStats","scheduledRuns","queues","lastScheduledRun","tasks","workflows","nextRun","cron","undefined","waitUntil","beforeScheduleFn","hooks","beforeSchedule","afterScheduleFN","afterSchedule","beforeScheduleResult","jobStats","shouldSchedule","job","input","meta","scheduled","task","workflow","error"],"mappings":"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"}},
    {"offset": {"line": 4869, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/queues/errors/index.ts"],"sourcesContent":["import type { Job, SingleTaskStatus, WorkflowConfig } from '../../index.js'\nimport type { RetryConfig, TaskConfig } from '../config/types/taskTypes.js'\nimport type { TaskParent } from '../operations/runJobs/runJob/getRunTaskFunction.js'\n\nexport type TaskErrorArgs = {\n  executedAt: Date\n  input?: object\n  job: Job\n  message: string\n  output?: object\n  parent?: TaskParent\n  retriesConfig: RetryConfig\n  taskConfig?: TaskConfig<string>\n  taskID: string\n  taskSlug: string\n  taskStatus: null | SingleTaskStatus<string>\n  workflowConfig: WorkflowConfig\n}\n\nexport type WorkflowErrorArgs = {\n  job: Job\n  message: string\n  workflowConfig: WorkflowConfig\n}\n\nexport class TaskError extends Error {\n  args: TaskErrorArgs\n  constructor(args: TaskErrorArgs) {\n    super(args.message)\n    this.args = args\n  }\n}\nexport class WorkflowError extends Error {\n  args: WorkflowErrorArgs\n\n  constructor(args: WorkflowErrorArgs) {\n    super(args.message)\n    this.args = args\n  }\n}\n\n/**\n * Throw this error from within a task or workflow handler to cancel the job.\n * Unlike failing a job (e.g. by throwing any other error), a cancelled job will not be retried.\n */\nexport class JobCancelledError extends Error {\n  constructor(message: string) {\n    super(message)\n  }\n}\n"],"names":["TaskError","Error","args","message","WorkflowError","JobCancelledError"],"mappings":";;;;;;;;AAyBO,MAAMA,kBAAkBC;IAC7BC,KAAmB;IACnB,YAAYA,IAAmB,CAAE;QAC/B,KAAK,CAACA,KAAKC,OAAO;QAClB,IAAI,CAACD,IAAI,GAAGA;IACd;AACF;AACO,MAAME,sBAAsBH;IACjCC,KAAuB;IAEvB,YAAYA,IAAuB,CAAE;QACnC,KAAK,CAACA,KAAKC,OAAO;QAClB,IAAI,CAACD,IAAI,GAAGA;IACd;AACF;AAMO,MAAMG,0BAA0BJ;IACrC,YAAYE,OAAe,CAAE;QAC3B,KAAK,CAACA;IACR;AACF"}},
    {"offset": {"line": 4900, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/queues/utilities/updateJob.ts"],"sourcesContent":["import type { ManyOptions } from '../../collections/operations/local/update.js'\nimport type { UpdateJobsArgs } from '../../database/types.js'\nimport type { Job } from '../../index.js'\nimport type { PayloadRequest, Sort, Where } from '../../types/index.js'\n\nimport { jobAfterRead, jobsCollectionSlug } from '../config/collection.js'\n\ntype BaseArgs = {\n  data: Partial<Job>\n  depth?: number\n  disableTransaction?: boolean\n  limit?: number\n  req: PayloadRequest\n  returning?: boolean\n}\n\ntype ArgsByID = {\n  id: number | string\n  limit?: never\n  sort?: never\n  where?: never\n}\n\ntype ArgsWhere = {\n  id?: never\n  limit?: number\n  sort?: Sort\n  where: Where\n}\n\ntype RunJobsArgs = (ArgsByID | ArgsWhere) & BaseArgs\n\n/**\n * Convenience method for updateJobs by id\n */\nexport async function updateJob(args: ArgsByID & BaseArgs) {\n  const result = await updateJobs(args)\n  if (result) {\n    return result[0]\n  }\n}\n\n/**\n * Helper for updating jobs in the most performant way possible.\n * Handles deciding whether it can used direct db methods or not, and if so,\n * manually runs the afterRead hook that populates the `taskStatus` property.\n */\nexport async function updateJobs({\n  id,\n  data,\n  depth,\n  disableTransaction,\n  limit: limitArg,\n  req,\n  returning,\n  sort,\n  where: whereArg,\n}: RunJobsArgs): Promise<Job[] | null> {\n  const limit = id ? 1 : limitArg\n  const where = id ? { id: { equals: id } } : whereArg\n\n  if (depth || req.payload.config?.jobs?.runHooks) {\n    const result = await req.payload.update({\n      id,\n      collection: jobsCollectionSlug,\n      data,\n      depth,\n      disableTransaction,\n      limit,\n      req,\n      where,\n    } as ManyOptions<any, any>)\n    if (returning === false || !result) {\n      return null\n    }\n    return result.docs as Job[]\n  }\n\n  const jobReq = {\n    transactionID:\n      req.payload.db.name !== 'mongoose'\n        ? ((await req.payload.db.beginTransaction()) as string)\n        : undefined,\n  }\n\n  if (typeof data.updatedAt === 'undefined') {\n    // Ensure updatedAt date is always updated\n    data.updatedAt = new Date().toISOString()\n  }\n\n  const args: UpdateJobsArgs = id\n    ? {\n        id,\n        data,\n        req: jobReq,\n        returning,\n      }\n    : {\n        data,\n        limit,\n        req: jobReq,\n        returning,\n        sort,\n        where: where as Where,\n      }\n\n  const updatedJobs: Job[] | null = await req.payload.db.updateJobs(args)\n\n  if (req.payload.db.name !== 'mongoose' && jobReq.transactionID) {\n    await req.payload.db.commitTransaction(jobReq.transactionID)\n  }\n\n  if (returning === false || !updatedJobs?.length) {\n    return null\n  }\n\n  return updatedJobs.map((updatedJob) => {\n    return jobAfterRead({\n      config: req.payload.config,\n      doc: updatedJob,\n    })\n  })\n}\n"],"names":["jobAfterRead","jobsCollectionSlug","updateJob","args","result","updateJobs","id","data","depth","disableTransaction","limit","limitArg","req","returning","sort","where","whereArg","equals","payload","config","jobs","runHooks","update","collection","docs","jobReq","transactionID","db","name","beginTransaction","undefined","updatedAt","Date","toISOString","updatedJobs","commitTransaction","length","map","updatedJob","doc"],"mappings":";;;;;;AAKA,SAASA,YAAY,EAAEC,kBAAkB,QAAQ,0BAAyB;;AA8BnE,eAAeC,UAAUC,IAAyB;IACvD,MAAMC,SAAS,MAAMC,WAAWF;IAChC,IAAIC,QAAQ;QACV,OAAOA,MAAM,CAAC,EAAE;IAClB;AACF;AAOO,eAAeC,WAAW,EAC/BC,EAAE,EACFC,IAAI,EACJC,KAAK,EACLC,kBAAkB,EAClBC,OAAOC,QAAQ,EACfC,GAAG,EACHC,SAAS,EACTC,IAAI,EACJC,OAAOC,QAAQ,EACH;IACZ,MAAMN,QAAQJ,KAAK,IAAIK;IACvB,MAAMI,QAAQT,KAAK;QAAEA,IAAI;YAAEW,QAAQX;QAAG;IAAE,IAAIU;IAE5C,IAAIR,SAASI,IAAIM,OAAO,CAACC,MAAM,EAAEC,MAAMC,UAAU;QAC/C,MAAMjB,SAAS,MAAMQ,IAAIM,OAAO,CAACI,MAAM,CAAC;YACtChB;YACAiB,YAAYtB,yLAAAA;YACZM;YACAC;YACAC;YACAC;YACAE;YACAG;QACF;QACA,IAAIF,cAAc,SAAS,CAACT,QAAQ;YAClC,OAAO;QACT;QACA,OAAOA,OAAOoB,IAAI;IACpB;IAEA,MAAMC,SAAS;QACbC,eACEd,IAAIM,OAAO,CAACS,EAAE,CAACC,IAAI,KAAK,aAClB,MAAMhB,IAAIM,OAAO,CAACS,EAAE,CAACE,gBAAgB,KACvCC;IACR;IAEA,IAAI,OAAOvB,KAAKwB,SAAS,KAAK,aAAa;QACzC,0CAA0C;QAC1CxB,KAAKwB,SAAS,GAAG,IAAIC,OAAOC,WAAW;IACzC;IAEA,MAAM9B,OAAuBG,KACzB;QACEA;QACAC;QACAK,KAAKa;QACLZ;IACF,IACA;QACEN;QACAG;QACAE,KAAKa;QACLZ;QACAC;QACAC,OAAOA;IACT;IAEJ,MAAMmB,cAA4B,MAAMtB,IAAIM,OAAO,CAACS,EAAE,CAACtB,UAAU,CAACF;IAElE,IAAIS,IAAIM,OAAO,CAACS,EAAE,CAACC,IAAI,KAAK,cAAcH,OAAOC,aAAa,EAAE;QAC9D,MAAMd,IAAIM,OAAO,CAACS,EAAE,CAACQ,iBAAiB,CAACV,OAAOC,aAAa;IAC7D;IAEA,IAAIb,cAAc,SAAS,CAACqB,aAAaE,QAAQ;QAC/C,OAAO;IACT;IAEA,OAAOF,YAAYG,GAAG,CAAC,CAACC;QACtB,WAAOtC,mLAAAA,EAAa;YAClBmB,QAAQP,IAAIM,OAAO,CAACC,MAAM;YAC1BoB,KAAKD;QACP;IACF;AACF"}},
    {"offset": {"line": 4975, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/queues/operations/runJobs/runJob/getUpdateJobFunction.ts"],"sourcesContent":["import type { Job } from '../../../../index.js'\nimport type { PayloadRequest } from '../../../../types/index.js'\n\nimport { JobCancelledError } from '../../../errors/index.js'\nimport { updateJob } from '../../../utilities/updateJob.js'\n\nexport type UpdateJobFunction = (jobData: Partial<Job>) => Promise<Job>\n\n/**\n * Helper for updating a job that does the following, additionally to updating the job:\n * - Merges incoming data from the updated job into the original job object\n * - Handles job cancellation by throwing a `JobCancelledError` if the job was cancelled.\n */\nexport function getUpdateJobFunction(job: Job, req: PayloadRequest): UpdateJobFunction {\n  return async (jobData) => {\n    const updatedJob = await updateJob({\n      id: job.id,\n      data: jobData,\n      depth: req.payload.config.jobs.depth,\n      disableTransaction: true,\n      req,\n    })\n\n    if (!updatedJob) {\n      return job\n    }\n\n    // Update job object like this to modify the original object - that way, incoming changes (e.g. taskStatus field that will be re-generated through the hook) will be reflected in the calling function\n    for (const key in updatedJob) {\n      if (key === 'log') {\n        // Add all new log entries to the original job.log object. Do not delete any existing log entries.\n        // Do not update existing log entries, as existing log entries should be immutable.\n        for (const logEntry of updatedJob?.log ?? []) {\n          if (!job.log || !job.log.some((entry) => entry.id === logEntry.id)) {\n            ;(job.log ??= []).push(logEntry)\n          }\n        }\n      } else {\n        ;(job as any)[key] = updatedJob[key as keyof Job]\n      }\n    }\n\n    if ((updatedJob?.error as Record<string, unknown>)?.cancelled) {\n      throw new JobCancelledError(`Job ${job.id} was cancelled`)\n    }\n\n    return updatedJob\n  }\n}\n"],"names":["JobCancelledError","updateJob","getUpdateJobFunction","job","req","jobData","updatedJob","id","data","depth","payload","config","jobs","disableTransaction","key","logEntry","log","some","entry","push","error","cancelled"],"mappings":";;;;AAGA,SAASA,iBAAiB,QAAQ,2BAA0B;AAC5D,SAASC,SAAS,QAAQ,kCAAiC;;;AASpD,SAASC,qBAAqBC,GAAQ,EAAEC,GAAmB;IAChE,OAAO,OAAOC;QACZ,MAAMC,aAAa,UAAML,kLAAAA,EAAU;YACjCM,IAAIJ,IAAII,EAAE;YACVC,MAAMH;YACNI,OAAOL,IAAIM,OAAO,CAACC,MAAM,CAACC,IAAI,CAACH,KAAK;YACpCI,oBAAoB;YACpBT;QACF;QAEA,IAAI,CAACE,YAAY;YACf,OAAOH;QACT;QAEA,sMAAsM;QACtM,IAAK,MAAMW,OAAOR,WAAY;YAC5B,IAAIQ,QAAQ,OAAO;gBACjB,kGAAkG;gBAClG,mFAAmF;gBACnF,KAAK,MAAMC,YAAYT,YAAYU,OAAO,EAAE,CAAE;oBAC5C,IAAI,CAACb,IAAIa,GAAG,IAAI,CAACb,IAAIa,GAAG,CAACC,IAAI,CAAC,CAACC,QAAUA,MAAMX,EAAE,KAAKQ,SAASR,EAAE,GAAG;;wBAChEJ,CAAAA,IAAIa,GAAG,KAAK,EAAC,EAAGG,IAAI,CAACJ;oBACzB;gBACF;YACF,OAAO;;gBACHZ,GAAW,CAACW,IAAI,GAAGR,UAAU,CAACQ,IAAiB;YACnD;QACF;QAEA,IAAKR,YAAYc,OAAmCC,WAAW;YAC7D,MAAM,IAAIrB,mLAAAA,CAAkB,CAAC,IAAI,EAAEG,IAAII,EAAE,CAAC,cAAc,CAAC;QAC3D;QAEA,OAAOD;IACT;AACF"}},
    {"offset": {"line": 5021, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/queues/operations/runJobs/runJob/importHandlerPath.ts"],"sourcesContent":["import type { TaskConfig, TaskHandler, TaskType } from '../../../config/types/taskTypes.js'\n\nimport { dynamicImport } from '../../../../utilities/dynamicImport.js'\n\n/**\n * Imports a handler function from a given path.\n */\nexport async function importHandlerPath<T>(path: string): Promise<T> {\n  let runner!: T\n  const [runnerPath, runnerImportName] = path.split('#')\n\n  let runnerModule: Record<string, unknown>\n  try {\n    runnerModule = await dynamicImport<Record<string, unknown>>(runnerPath!)\n  } catch (e) {\n    throw new Error(\n      `Error importing job queue handler module for path ${path}. This is an advanced feature that may require a sophisticated build pipeline, especially when using it in production or within Next.js, e.g. by calling opening the /api/payload-jobs/run endpoint. You will have to transpile the handler files separately and ensure they are available in the same location when the job is run. If you're using an endpoint to execute your jobs, it's recommended to define your handlers as functions directly in your Payload Config, or use import paths handlers outside of Next.js. Import Error: \\n${e instanceof Error ? e.message : 'Unknown error'}`,\n    )\n  }\n\n  // If the path has indicated an #exportName, try to get it\n  if (runnerImportName && runnerModule[runnerImportName]) {\n    runner = runnerModule[runnerImportName] as T\n  }\n\n  // If there is a default export, use it\n  if (!runner && runnerModule.default) {\n    runner = runnerModule.default as T\n  }\n\n  // Finally, use whatever was imported\n  if (!runner) {\n    runner = runnerModule as T\n  }\n\n  return runner\n}\n\n/**\n * The `handler` property of a task config can either be a function or a path to a module that exports a function.\n * This function resolves the handler to a function, either by importing it from the path or returning the function directly\n * if it is already a function.\n */\nexport async function getTaskHandlerFromConfig(taskConfig?: TaskConfig) {\n  if (!taskConfig) {\n    throw new Error('Task config is required to get the task handler')\n  }\n  if (typeof taskConfig.handler === 'function') {\n    return taskConfig.handler\n  } else {\n    return await importHandlerPath<TaskHandler<TaskType>>(taskConfig.handler)\n  }\n}\n"],"names":["dynamicImport","importHandlerPath","path","runner","runnerPath","runnerImportName","split","runnerModule","e","Error","message","default","getTaskHandlerFromConfig","taskConfig","handler"],"mappings":";;;;;;AAEA,SAASA,aAAa,QAAQ,yCAAwC;;AAK/D,eAAeC,kBAAqBC,IAAY;IACrD,IAAIC;IACJ,MAAM,CAACC,YAAYC,iBAAiB,GAAGH,KAAKI,KAAK,CAAC;IAElD,IAAIC;IACJ,IAAI;QACFA,eAAe,UAAMP,gLAAAA,EAAuCI;IAC9D,EAAE,OAAOI,GAAG;QACV,MAAM,IAAIC,MACR,CAAC,kDAAkD,EAAEP,KAAK,+gBAA+gB,EAAEM,aAAaC,QAAQD,EAAEE,OAAO,GAAG,iBAAiB;IAEjoB;IAEA,0DAA0D;IAC1D,IAAIL,oBAAoBE,YAAY,CAACF,iBAAiB,EAAE;QACtDF,SAASI,YAAY,CAACF,iBAAiB;IACzC;IAEA,uCAAuC;IACvC,IAAI,CAACF,UAAUI,aAAaI,OAAO,EAAE;QACnCR,SAASI,aAAaI,OAAO;IAC/B;IAEA,qCAAqC;IACrC,IAAI,CAACR,QAAQ;QACXA,SAASI;IACX;IAEA,OAAOJ;AACT;AAOO,eAAeS,yBAAyBC,UAAuB;IACpE,IAAI,CAACA,YAAY;QACf,MAAM,IAAIJ,MAAM;IAClB;IACA,IAAI,OAAOI,WAAWC,OAAO,KAAK,YAAY;QAC5C,OAAOD,WAAWC,OAAO;IAC3B,OAAO;QACL,OAAO,MAAMb,kBAAyCY,WAAWC,OAAO;IAC1E;AACF"}},
    {"offset": {"line": 5066, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/queues/errors/calculateBackoffWaitUntil.ts"],"sourcesContent":["import type { RetryConfig } from '../config/types/taskTypes.js'\n\nimport { getCurrentDate } from '../utilities/getCurrentDate.js'\n\nexport function calculateBackoffWaitUntil({\n  retriesConfig,\n  totalTried,\n}: {\n  retriesConfig: number | RetryConfig\n  totalTried: number\n}): Date {\n  let waitUntil: Date = getCurrentDate()\n  if (typeof retriesConfig === 'object') {\n    if (retriesConfig.backoff) {\n      if (retriesConfig.backoff.type === 'fixed') {\n        waitUntil = retriesConfig.backoff.delay\n          ? new Date(getCurrentDate().getTime() + retriesConfig.backoff.delay)\n          : getCurrentDate()\n      } else if (retriesConfig.backoff.type === 'exponential') {\n        // 2 ^ (attempts - 1) * delay (current attempt is not included in totalTried, thus no need for -1)\n        const delay = retriesConfig.backoff.delay ? retriesConfig.backoff.delay : 0\n        waitUntil = new Date(getCurrentDate().getTime() + Math.pow(2, totalTried) * delay)\n      }\n    }\n  }\n\n  /*\n  const differenceInMSBetweenNowAndWaitUntil = waitUntil.getTime() - getCurrentDate().getTime()\n\n  const differenceInSBetweenNowAndWaitUntil = differenceInMSBetweenNowAndWaitUntil / 1000\n  console.log('Calculated backoff', {\n    differenceInMSBetweenNowAndWaitUntil,\n    differenceInSBetweenNowAndWaitUntil,\n    retriesConfig,\n    totalTried,\n  })*/\n  return waitUntil\n}\n"],"names":["getCurrentDate","calculateBackoffWaitUntil","retriesConfig","totalTried","waitUntil","backoff","type","delay","Date","getTime","Math","pow"],"mappings":";;;;AAEA,SAASA,cAAc,QAAQ,iCAAgC;;AAExD,SAASC,0BAA0B,EACxCC,aAAa,EACbC,UAAU,EAIX;IACC,IAAIC,gBAAkBJ,4LAAAA;IACtB,IAAI,OAAOE,kBAAkB,UAAU;QACrC,IAAIA,cAAcG,OAAO,EAAE;YACzB,IAAIH,cAAcG,OAAO,CAACC,IAAI,KAAK,SAAS;gBAC1CF,YAAYF,cAAcG,OAAO,CAACE,KAAK,GACnC,IAAIC,SAAKR,4LAAAA,IAAiBS,OAAO,KAAKP,cAAcG,OAAO,CAACE,KAAK,QACjEP,4LAAAA;YACN,OAAO,IAAIE,cAAcG,OAAO,CAACC,IAAI,KAAK,eAAe;gBACvD,kGAAkG;gBAClG,MAAMC,QAAQL,cAAcG,OAAO,CAACE,KAAK,GAAGL,cAAcG,OAAO,CAACE,KAAK,GAAG;gBAC1EH,YAAY,IAAII,SAAKR,4LAAAA,IAAiBS,OAAO,KAAKC,KAAKC,GAAG,CAAC,GAAGR,cAAcI;YAC9E;QACF;IACF;IAEA;;;;;;;;;IASE,GACF,OAAOH;AACT"}},
    {"offset": {"line": 5100, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/queues/errors/getWorkflowRetryBehavior.ts"],"sourcesContent":["import type { Job } from '../../index.js'\nimport type { RetryConfig } from '../config/types/taskTypes.js'\n\nimport { calculateBackoffWaitUntil } from './calculateBackoffWaitUntil.js'\n\n/**\n * Assuming there is no task that has already reached max retries,\n * this function determines if the workflow should retry the job\n * and if so, when it should retry.\n */\nexport function getWorkflowRetryBehavior({\n  job,\n  retriesConfig,\n}: {\n  job: Job\n  retriesConfig?: number | RetryConfig\n}):\n  | {\n      hasFinalError: false\n      maxWorkflowRetries?: number\n      waitUntil?: Date\n    }\n  | {\n      hasFinalError: true\n      maxWorkflowRetries?: number\n      waitUntil?: Date\n    } {\n  const maxWorkflowRetries = (\n    typeof retriesConfig === 'object' ? retriesConfig.attempts : retriesConfig\n  )!\n\n  if (\n    maxWorkflowRetries !== undefined &&\n    maxWorkflowRetries !== null &&\n    job.totalTried >= maxWorkflowRetries\n  ) {\n    return {\n      hasFinalError: true,\n      maxWorkflowRetries,\n    }\n  }\n\n  if (!retriesConfig) {\n    // No retries provided => assuming no task reached max retries, we can retry\n    return {\n      hasFinalError: false,\n      maxWorkflowRetries: undefined,\n      waitUntil: undefined,\n    }\n  }\n\n  // Job will retry. Let's determine when!\n  const waitUntil: Date = calculateBackoffWaitUntil({\n    retriesConfig,\n    totalTried: job.totalTried ?? 0,\n  })\n\n  return {\n    hasFinalError: false,\n    maxWorkflowRetries,\n    waitUntil,\n  }\n}\n"],"names":["calculateBackoffWaitUntil","getWorkflowRetryBehavior","job","retriesConfig","maxWorkflowRetries","attempts","undefined","totalTried","hasFinalError","waitUntil"],"mappings":";;;;AAGA,SAASA,yBAAyB,QAAQ,iCAAgC;;AAOnE,SAASC,yBAAyB,EACvCC,GAAG,EACHC,aAAa,EAId;IAWC,MAAMC,qBACJ,OAAOD,kBAAkB,WAAWA,cAAcE,QAAQ,GAAGF;IAG/D,IACEC,uBAAuBE,aACvBF,uBAAuB,QACvBF,IAAIK,UAAU,IAAIH,oBAClB;QACA,OAAO;YACLI,eAAe;YACfJ;QACF;IACF;IAEA,IAAI,CAACD,eAAe;QAClB,4EAA4E;QAC5E,OAAO;YACLK,eAAe;YACfJ,oBAAoBE;YACpBG,WAAWH;QACb;IACF;IAEA,wCAAwC;IACxC,MAAMG,gBAAkBT,+MAAAA,EAA0B;QAChDG;QACAI,YAAYL,IAAIK,UAAU,IAAI;IAChC;IAEA,OAAO;QACLC,eAAe;QACfJ;QACAK;IACF;AACF"}},
    {"offset": {"line": 5137, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/queues/errors/handleTaskError.ts"],"sourcesContent":["import ObjectIdImport from 'bson-objectid'\n\nimport type { JobLog, PayloadRequest } from '../../index.js'\nimport type { RunJobsSilent } from '../localAPI.js'\nimport type { UpdateJobFunction } from '../operations/runJobs/runJob/getUpdateJobFunction.js'\nimport type { TaskError } from './index.js'\n\nimport { getCurrentDate } from '../utilities/getCurrentDate.js'\nimport { calculateBackoffWaitUntil } from './calculateBackoffWaitUntil.js'\nimport { getWorkflowRetryBehavior } from './getWorkflowRetryBehavior.js'\n\nconst ObjectId = 'default' in ObjectIdImport ? ObjectIdImport.default : ObjectIdImport\n\nexport async function handleTaskError({\n  error,\n  req,\n  silent = false,\n  updateJob,\n}: {\n  error: TaskError\n  req: PayloadRequest\n  /**\n   * If set to true, the job system will not log any output to the console (for both info and error logs).\n   * Can be an option for more granular control over logging.\n   *\n   * This will not automatically affect user-configured logs (e.g. if you call `console.log` or `payload.logger.info` in your job code).\n   *\n   * @default false\n   */\n  silent?: RunJobsSilent\n  updateJob: UpdateJobFunction\n}): Promise<{\n  hasFinalError: boolean\n}> {\n  const {\n    executedAt,\n    input,\n    job,\n    output,\n    parent,\n    retriesConfig,\n    taskConfig,\n    taskID,\n    taskSlug,\n    taskStatus,\n    workflowConfig,\n  } = error.args\n\n  if (taskConfig?.onFail) {\n    await taskConfig.onFail({\n      input,\n      job,\n      req,\n      taskStatus,\n    })\n  }\n\n  const errorJSON = {\n    name: error.name,\n    cancelled: Boolean('cancelled' in error && error.cancelled),\n    message: error.message,\n    stack: error.stack,\n  }\n\n  const currentDate = getCurrentDate()\n\n  if (job.waitUntil) {\n    // Check if waitUntil is in the past\n    const waitUntil = new Date(job.waitUntil)\n    if (waitUntil < currentDate) {\n      // Outdated waitUntil, remove it\n      delete job.waitUntil\n    }\n  }\n\n  let maxRetries: number = 0\n\n  if (retriesConfig?.attempts === undefined || retriesConfig?.attempts === null) {\n    // Inherit retries from workflow config, if they are undefined and the workflow config has retries configured\n    if (workflowConfig.retries !== undefined && workflowConfig.retries !== null) {\n      maxRetries =\n        typeof workflowConfig.retries === 'object'\n          ? typeof workflowConfig.retries.attempts === 'number'\n            ? workflowConfig.retries.attempts\n            : 0\n          : workflowConfig.retries\n    } else {\n      maxRetries = 0\n    }\n  } else {\n    maxRetries = retriesConfig.attempts\n  }\n\n  const taskLogToPush: JobLog = {\n    id: new ObjectId().toHexString(),\n    completedAt: currentDate.toISOString(),\n    error: errorJSON,\n    executedAt: executedAt.toISOString(),\n    input,\n    output: output ?? {},\n    parent: req.payload.config.jobs.addParentToTaskLog ? parent : undefined,\n    state: 'failed',\n    taskID,\n    taskSlug,\n  }\n\n  if (!taskStatus?.complete && (taskStatus?.totalTried ?? 0) >= maxRetries) {\n    /**\n     * Task reached max retries => workflow will not retry\n     */\n\n    await updateJob({\n      error: errorJSON,\n      hasError: true,\n      log: {\n        $push: taskLogToPush,\n      } as any,\n      processing: false,\n      totalTried: (job.totalTried ?? 0) + 1,\n      waitUntil: job.waitUntil,\n    })\n\n    if (!silent || (typeof silent === 'object' && !silent.error)) {\n      req.payload.logger.error({\n        err: error,\n        job,\n        msg: `Error running task ${taskID}. Attempt ${job.totalTried} - max retries reached`,\n        taskSlug,\n      })\n    }\n    return {\n      hasFinalError: true,\n    }\n  }\n\n  /**\n   * Task can retry:\n   * - If workflow can retry, allow it to retry\n   * - If workflow reached max retries, do not retry and set final error\n   */\n\n  // First set task waitUntil - if the workflow waitUntil is later, it will be updated later\n  const taskWaitUntil: Date = calculateBackoffWaitUntil({\n    retriesConfig,\n    totalTried: taskStatus?.totalTried ?? 0,\n  })\n\n  // Update job's waitUntil only if this waitUntil is later than the current one\n  if (!job.waitUntil || taskWaitUntil > new Date(job.waitUntil)) {\n    job.waitUntil = taskWaitUntil.toISOString()\n  }\n\n  const { hasFinalError, maxWorkflowRetries, waitUntil } = getWorkflowRetryBehavior({\n    job,\n    retriesConfig: workflowConfig.retries,\n  })\n\n  if (!silent || (typeof silent === 'object' && !silent.error)) {\n    req.payload.logger.error({\n      err: error,\n      job,\n      msg: `Error running task ${taskID}. Attempt ${job.totalTried + 1}${maxWorkflowRetries !== undefined ? '/' + (maxWorkflowRetries + 1) : ''}`,\n      taskSlug,\n    })\n  }\n\n  // Update job's waitUntil only if this waitUntil is later than the current one\n  if (waitUntil && (!job.waitUntil || waitUntil > new Date(job.waitUntil))) {\n    job.waitUntil = waitUntil.toISOString()\n  }\n\n  // Tasks update the job if they error - but in case there is an unhandled error (e.g. in the workflow itself, not in a task)\n  // we need to ensure the job is updated to reflect the error\n  await updateJob({\n    error: hasFinalError ? errorJSON : undefined,\n    hasError: hasFinalError, // If reached max retries => final error. If hasError is true this job will not be retried\n    log: {\n      $push: taskLogToPush,\n    } as any,\n    processing: false,\n    totalTried: (job.totalTried ?? 0) + 1,\n    waitUntil: job.waitUntil,\n  })\n\n  return {\n    hasFinalError,\n  }\n}\n"],"names":["ObjectIdImport","getCurrentDate","calculateBackoffWaitUntil","getWorkflowRetryBehavior","ObjectId","default","handleTaskError","error","req","silent","updateJob","executedAt","input","job","output","parent","retriesConfig","taskConfig","taskID","taskSlug","taskStatus","workflowConfig","args","onFail","errorJSON","name","cancelled","Boolean","message","stack","currentDate","waitUntil","Date","maxRetries","attempts","undefined","retries","taskLogToPush","id","toHexString","completedAt","toISOString","payload","config","jobs","addParentToTaskLog","state","complete","totalTried","hasError","log","$push","processing","logger","err","msg","hasFinalError","taskWaitUntil","maxWorkflowRetries"],"mappings":"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"}},
    {"offset": {"line": 5272, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/queues/errors/handleWorkflowError.ts"],"sourcesContent":["import type { PayloadRequest } from '../../index.js'\nimport type { RunJobsSilent } from '../localAPI.js'\nimport type { UpdateJobFunction } from '../operations/runJobs/runJob/getUpdateJobFunction.js'\nimport type { WorkflowError } from './index.js'\n\nimport { getCurrentDate } from '../utilities/getCurrentDate.js'\nimport { getWorkflowRetryBehavior } from './getWorkflowRetryBehavior.js'\n\n/**\n * This is called if a workflow catches an error. It determines if it's a final error\n * or not and handles logging.\n * A Workflow error = error that happens anywhere in between running tasks.\n *\n * This function assumes that the error is not a TaskError, but a WorkflowError. If a task errors,\n * only a TaskError should be thrown, not a WorkflowError.\n */\nexport async function handleWorkflowError({\n  error,\n  req,\n  silent = false,\n  updateJob,\n}: {\n  error: WorkflowError\n  req: PayloadRequest\n  /**\n   * If set to true, the job system will not log any output to the console (for both info and error logs).\n   * Can be an option for more granular control over logging.\n   *\n   * This will not automatically affect user-configured logs (e.g. if you call `console.log` or `payload.logger.info` in your job code).\n   *\n   * @default false\n   */\n  silent?: RunJobsSilent\n  updateJob: UpdateJobFunction\n}): Promise<{\n  hasFinalError: boolean\n}> {\n  const { job, workflowConfig } = error.args\n\n  const errorJSON = {\n    name: error.name,\n    cancelled: Boolean('cancelled' in error && error.cancelled),\n    message: error.message,\n    stack: error.stack,\n  }\n\n  const { hasFinalError, maxWorkflowRetries, waitUntil } = getWorkflowRetryBehavior({\n    job,\n    retriesConfig: workflowConfig.retries!,\n  })\n\n  if (!hasFinalError) {\n    if (job.waitUntil) {\n      // Check if waitUntil is in the past\n      const waitUntil = new Date(job.waitUntil)\n      if (waitUntil < getCurrentDate()) {\n        // Outdated waitUntil, remove it\n        delete job.waitUntil\n      }\n    }\n\n    // Update job's waitUntil only if this waitUntil is later than the current one\n    if (waitUntil && (!job.waitUntil || waitUntil > new Date(job.waitUntil))) {\n      job.waitUntil = waitUntil.toISOString()\n    }\n  }\n\n  const jobLabel = job.workflowSlug || `Task: ${job.taskSlug}`\n\n  if (!silent || (typeof silent === 'object' && !silent.error)) {\n    req.payload.logger.error({\n      err: error,\n      msg: `Error running job ${jobLabel} id: ${job.id} attempt ${job.totalTried + 1}${maxWorkflowRetries !== undefined ? '/' + (maxWorkflowRetries + 1) : ''}`,\n    })\n  }\n\n  // Tasks update the job if they error - but in case there is an unhandled error (e.g. in the workflow itself, not in a task)\n  // we need to ensure the job is updated to reflect the error\n  await updateJob({\n    error: errorJSON,\n    hasError: hasFinalError, // If reached max retries => final error. If hasError is true this job will not be retried\n    processing: false,\n    totalTried: (job.totalTried ?? 0) + 1,\n    waitUntil: job.waitUntil,\n  })\n\n  return {\n    hasFinalError,\n  }\n}\n"],"names":["getCurrentDate","getWorkflowRetryBehavior","handleWorkflowError","error","req","silent","updateJob","job","workflowConfig","args","errorJSON","name","cancelled","Boolean","message","stack","hasFinalError","maxWorkflowRetries","waitUntil","retriesConfig","retries","Date","toISOString","jobLabel","workflowSlug","taskSlug","payload","logger","err","msg","id","totalTried","undefined","hasError","processing"],"mappings":";;;;AAKA,SAASA,cAAc,QAAQ,iCAAgC;AAC/D,SAASC,wBAAwB,QAAQ,gCAA+B;;;AAUjE,eAAeC,oBAAoB,EACxCC,KAAK,EACLC,GAAG,EACHC,SAAS,KAAK,EACdC,SAAS,EAcV;IAGC,MAAM,EAAEC,GAAG,EAAEC,cAAc,EAAE,GAAGL,MAAMM,IAAI;IAE1C,MAAMC,YAAY;QAChBC,MAAMR,MAAMQ,IAAI;QAChBC,WAAWC,QAAQ,eAAeV,SAASA,MAAMS,SAAS;QAC1DE,SAASX,MAAMW,OAAO;QACtBC,OAAOZ,MAAMY,KAAK;IACpB;IAEA,MAAM,EAAEC,aAAa,EAAEC,kBAAkB,EAAEC,SAAS,EAAE,OAAGjB,6MAAAA,EAAyB;QAChFM;QACAY,eAAeX,eAAeY,OAAO;IACvC;IAEA,IAAI,CAACJ,eAAe;QAClB,IAAIT,IAAIW,SAAS,EAAE;YACjB,oCAAoC;YACpC,MAAMA,YAAY,IAAIG,KAAKd,IAAIW,SAAS;YACxC,IAAIA,gBAAYlB,4LAAAA,KAAkB;gBAChC,gCAAgC;gBAChC,OAAOO,IAAIW,SAAS;YACtB;QACF;QAEA,8EAA8E;QAC9E,IAAIA,aAAc,CAAA,CAACX,IAAIW,SAAS,IAAIA,YAAY,IAAIG,KAAKd,IAAIW,SAAS,CAAA,GAAI;YACxEX,IAAIW,SAAS,GAAGA,UAAUI,WAAW;QACvC;IACF;IAEA,MAAMC,WAAWhB,IAAIiB,YAAY,IAAI,CAAC,MAAM,EAAEjB,IAAIkB,QAAQ,EAAE;IAE5D,IAAI,CAACpB,UAAW,OAAOA,WAAW,YAAY,CAACA,OAAOF,KAAK,EAAG;QAC5DC,IAAIsB,OAAO,CAACC,MAAM,CAACxB,KAAK,CAAC;YACvByB,KAAKzB;YACL0B,KAAK,CAAC,kBAAkB,EAAEN,SAAS,KAAK,EAAEhB,IAAIuB,EAAE,CAAC,SAAS,EAAEvB,IAAIwB,UAAU,GAAG,IAAId,uBAAuBe,YAAY,MAAOf,CAAAA,qBAAqB,CAAA,IAAK,IAAI;QAC3J;IACF;IAEA,4HAA4H;IAC5H,4DAA4D;IAC5D,MAAMX,UAAU;QACdH,OAAOO;QACPuB,UAAUjB;QACVkB,YAAY;QACZH,YAAaxB,CAAAA,IAAIwB,UAAU,IAAI,CAAA,IAAK;QACpCb,WAAWX,IAAIW,SAAS;IAC1B;IAEA,OAAO;QACLF;IACF;AACF"}},
    {"offset": {"line": 5330, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/queues/operations/runJobs/runJob/getRunTaskFunction.ts"],"sourcesContent":["import ObjectIdImport from 'bson-objectid'\n\nimport type { Job } from '../../../../index.js'\nimport type { JsonObject, PayloadRequest } from '../../../../types/index.js'\nimport type {\n  RetryConfig,\n  RunInlineTaskFunction,\n  RunTaskFunction,\n  RunTaskFunctions,\n  TaskConfig,\n  TaskHandler,\n  TaskHandlerResult,\n  TaskType,\n} from '../../../config/types/taskTypes.js'\nimport type {\n  JobLog,\n  SingleTaskStatus,\n  WorkflowConfig,\n  WorkflowTypes,\n} from '../../../config/types/workflowTypes.js'\nimport type { UpdateJobFunction } from './getUpdateJobFunction.js'\n\nimport { JobCancelledError, TaskError } from '../../../errors/index.js'\nimport { getCurrentDate } from '../../../utilities/getCurrentDate.js'\nimport { getTaskHandlerFromConfig } from './importHandlerPath.js'\n\nconst ObjectId = 'default' in ObjectIdImport ? ObjectIdImport.default : ObjectIdImport\n\nexport type TaskParent = {\n  taskID: string\n  taskSlug: string\n}\n\nexport const getRunTaskFunction = <TIsInline extends boolean>(\n  job: Job,\n  workflowConfig: WorkflowConfig,\n  req: PayloadRequest,\n  isInline: TIsInline,\n  updateJob: UpdateJobFunction,\n  parent?: TaskParent,\n): TIsInline extends true ? RunInlineTaskFunction : RunTaskFunctions => {\n  const jobConfig = req.payload.config.jobs\n\n  const runTask: <TTaskSlug extends string>(\n    taskSlug: TTaskSlug,\n  ) => TTaskSlug extends 'inline' ? RunInlineTaskFunction : RunTaskFunction<TTaskSlug> = (\n    taskSlug,\n  ) =>\n    (async (\n      taskID: Parameters<RunInlineTaskFunction>[0],\n      {\n        input,\n        retries,\n        // Only available for inline tasks:\n        task,\n      }: Parameters<RunInlineTaskFunction>[1] & Parameters<RunTaskFunction<string>>[1],\n    ) => {\n      const executedAt = getCurrentDate()\n\n      let taskConfig: TaskConfig | undefined\n      if (!isInline) {\n        taskConfig = (jobConfig.tasks?.length &&\n          jobConfig.tasks.find((t) => t.slug === taskSlug)) as TaskConfig<string>\n\n        if (!taskConfig) {\n          throw new Error(`Task ${taskSlug} not found in workflow ${job.workflowSlug}`)\n        }\n      }\n\n      const retriesConfigFromPropsNormalized =\n        retries == undefined || retries == null\n          ? {}\n          : typeof retries === 'number'\n            ? { attempts: retries }\n            : retries\n      const retriesConfigFromTaskConfigNormalized = taskConfig\n        ? typeof taskConfig.retries === 'number'\n          ? { attempts: taskConfig.retries }\n          : taskConfig.retries\n        : {}\n\n      const finalRetriesConfig: RetryConfig = {\n        ...retriesConfigFromTaskConfigNormalized,\n        ...retriesConfigFromPropsNormalized, // Retry config from props takes precedence\n      }\n\n      const taskStatus: null | SingleTaskStatus<string> = job?.taskStatus?.[taskSlug]\n        ? job.taskStatus[taskSlug][taskID]!\n        : null\n\n      // Handle restoration of task if it succeeded in a previous run\n      if (taskStatus && taskStatus.complete === true) {\n        let shouldRestore = true\n        if (finalRetriesConfig?.shouldRestore === false) {\n          shouldRestore = false\n        } else if (typeof finalRetriesConfig?.shouldRestore === 'function') {\n          shouldRestore = await finalRetriesConfig.shouldRestore({\n            input,\n            job,\n            req,\n            taskStatus,\n          })\n        }\n        if (shouldRestore) {\n          return taskStatus.output\n        }\n      }\n\n      const runner = isInline\n        ? (task as TaskHandler<TaskType>)\n        : await getTaskHandlerFromConfig(taskConfig)\n\n      if (!runner || typeof runner !== 'function') {\n        throw new TaskError({\n          executedAt,\n          input,\n          job,\n          message: isInline\n            ? `Inline task with ID ${taskID} does not have a valid handler.`\n            : `Task with slug ${taskSlug} in workflow ${job.workflowSlug} does not have a valid handler.`,\n          parent,\n          retriesConfig: finalRetriesConfig,\n          taskConfig,\n          taskID,\n          taskSlug,\n          taskStatus,\n          workflowConfig,\n        })\n      }\n\n      let taskHandlerResult: TaskHandlerResult<string>\n      let output: JsonObject | undefined = {}\n\n      try {\n        taskHandlerResult = await runner({\n          inlineTask: getRunTaskFunction(job, workflowConfig, req, true, updateJob, {\n            taskID,\n            taskSlug,\n          }),\n          input,\n          job: job as unknown as Job<WorkflowTypes>,\n          req,\n          tasks: getRunTaskFunction(job, workflowConfig, req, false, updateJob, {\n            taskID,\n            taskSlug,\n          }),\n        })\n      } catch (err: any) {\n        if (err instanceof JobCancelledError) {\n          // Re-throw JobCancelledError to be handled by the top-level error handler\n          throw err\n        }\n        throw new TaskError({\n          executedAt,\n          input: input!,\n          job,\n          message: err.message || 'Task handler threw an error',\n          output,\n          parent,\n          retriesConfig: finalRetriesConfig,\n          taskConfig,\n          taskID,\n          taskSlug,\n          taskStatus,\n          workflowConfig,\n        })\n      }\n\n      if (taskHandlerResult.state === 'failed') {\n        throw new TaskError({\n          executedAt,\n          input: input!,\n          job,\n          message: taskHandlerResult.errorMessage ?? 'Task handler returned a failed state',\n          output,\n          parent,\n          retriesConfig: finalRetriesConfig,\n          taskConfig,\n          taskID,\n          taskSlug,\n          taskStatus,\n          workflowConfig,\n        })\n      } else {\n        output = taskHandlerResult.output\n      }\n\n      if (taskConfig?.onSuccess) {\n        await taskConfig.onSuccess({\n          input,\n          job,\n          req,\n          taskStatus,\n        })\n      }\n\n      const newLogItem: JobLog = {\n        id: new ObjectId().toHexString(),\n        completedAt: getCurrentDate().toISOString(),\n        executedAt: executedAt.toISOString(),\n        input,\n        output,\n        parent: jobConfig.addParentToTaskLog ? parent : undefined,\n        state: 'succeeded',\n        taskID,\n        taskSlug,\n      }\n\n      await updateJob({\n        log: {\n          $push: newLogItem,\n        } as any,\n        // Set to null to skip main row update on postgres. 2 => 1 db round trips\n        updatedAt: null as any,\n      })\n\n      return output\n    }) as any\n\n  if (isInline) {\n    return runTask('inline') as TIsInline extends true ? RunInlineTaskFunction : RunTaskFunctions\n  } else {\n    const tasks: RunTaskFunctions = {}\n    for (const task of jobConfig.tasks ?? []) {\n      tasks[task.slug] = runTask(task.slug) as RunTaskFunction<string>\n    }\n    return tasks as TIsInline extends true ? RunInlineTaskFunction : RunTaskFunctions\n  }\n}\n"],"names":["ObjectIdImport","JobCancelledError","TaskError","getCurrentDate","getTaskHandlerFromConfig","ObjectId","default","getRunTaskFunction","job","workflowConfig","req","isInline","updateJob","parent","jobConfig","payload","config","jobs","runTask","taskSlug","taskID","input","retries","task","executedAt","taskConfig","tasks","length","find","t","slug","Error","workflowSlug","retriesConfigFromPropsNormalized","undefined","attempts","retriesConfigFromTaskConfigNormalized","finalRetriesConfig","taskStatus","complete","shouldRestore","output","runner","message","retriesConfig","taskHandlerResult","inlineTask","err","state","errorMessage","onSuccess","newLogItem","id","toHexString","completedAt","toISOString","addParentToTaskLog","log","$push","updatedAt"],"mappings":"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"}},
    {"offset": {"line": 5494, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/queues/operations/runJobs/runJob/index.ts"],"sourcesContent":["import type { Job } from '../../../../index.js'\nimport type { PayloadRequest } from '../../../../types/index.js'\nimport type { WorkflowConfig, WorkflowHandler } from '../../../config/types/workflowTypes.js'\nimport type { RunJobsSilent } from '../../../localAPI.js'\nimport type { UpdateJobFunction } from './getUpdateJobFunction.js'\n\nimport { handleTaskError } from '../../../errors/handleTaskError.js'\nimport { handleWorkflowError } from '../../../errors/handleWorkflowError.js'\nimport { JobCancelledError, TaskError, WorkflowError } from '../../../errors/index.js'\nimport { getCurrentDate } from '../../../utilities/getCurrentDate.js'\nimport { getRunTaskFunction } from './getRunTaskFunction.js'\n\ntype Args = {\n  job: Job\n  req: PayloadRequest\n  /**\n   * If set to true, the job system will not log any output to the console (for both info and error logs).\n   * Can be an option for more granular control over logging.\n   *\n   * This will not automatically affect user-configured logs (e.g. if you call `console.log` or `payload.logger.info` in your job code).\n   *\n   * @default false\n   */\n  silent?: RunJobsSilent\n  updateJob: UpdateJobFunction\n  workflowConfig: WorkflowConfig\n  workflowHandler: WorkflowHandler\n}\n\nexport type JobRunStatus = 'error' | 'error-reached-max-retries' | 'success'\n\nexport type RunJobResult = {\n  status: JobRunStatus\n}\n\nexport const runJob = async ({\n  job,\n  req,\n  silent,\n  updateJob,\n  workflowConfig,\n  workflowHandler,\n}: Args): Promise<RunJobResult> => {\n  // Run the job\n  try {\n    await workflowHandler({\n      inlineTask: getRunTaskFunction(job, workflowConfig, req, true, updateJob),\n      job,\n      req,\n      tasks: getRunTaskFunction(job, workflowConfig, req, false, updateJob),\n    })\n  } catch (error) {\n    if (error instanceof JobCancelledError) {\n      throw error // Job cancellation is handled in a top-level error handler, as higher up code may themselves throw this error\n    }\n    if (error instanceof TaskError) {\n      const { hasFinalError } = await handleTaskError({\n        error,\n        req,\n        silent,\n        updateJob,\n      })\n\n      return {\n        status: hasFinalError ? 'error-reached-max-retries' : 'error',\n      }\n    }\n\n    const { hasFinalError } = await handleWorkflowError({\n      error:\n        error instanceof WorkflowError\n          ? error\n          : new WorkflowError({\n              job,\n              message:\n                typeof error === 'object' && error && 'message' in error\n                  ? (error.message as string)\n                  : 'An unhandled error occurred',\n              workflowConfig,\n            }),\n      req,\n      silent,\n      updateJob,\n    })\n\n    return {\n      status: hasFinalError ? 'error-reached-max-retries' : 'error',\n    }\n  }\n\n  // Workflow has completed successfully\n  // Do not update the job log here, as that would result in unnecessary db calls when using postgres.\n  // Solely updating simple fields here will result in optimized db calls.\n  // Job log modifications are already updated at the end of the runTask function.\n  await updateJob({\n    completedAt: getCurrentDate().toISOString(),\n    processing: false,\n    totalTried: (job.totalTried ?? 0) + 1,\n  })\n\n  return {\n    status: 'success',\n  }\n}\n"],"names":["handleTaskError","handleWorkflowError","JobCancelledError","TaskError","WorkflowError","getCurrentDate","getRunTaskFunction","runJob","job","req","silent","updateJob","workflowConfig","workflowHandler","inlineTask","tasks","error","hasFinalError","status","message","completedAt","toISOString","processing","totalTried"],"mappings":";;;;AAMA,SAASA,eAAe,QAAQ,qCAAoC;AACpE,SAASC,mBAAmB,QAAQ,yCAAwC;AAC5E,SAASC,iBAAiB,EAAEC,SAAS,EAAEC,aAAa,QAAQ,2BAA0B;AACtF,SAASC,cAAc,QAAQ,uCAAsC;AACrE,SAASC,kBAAkB,QAAQ,0BAAyB;;;;;;AAyBrD,MAAMC,SAAS,OAAO,EAC3BC,GAAG,EACHC,GAAG,EACHC,MAAM,EACNC,SAAS,EACTC,cAAc,EACdC,eAAe,EACV;IACL,cAAc;IACd,IAAI;QACF,MAAMA,gBAAgB;YACpBC,gBAAYR,0NAAAA,EAAmBE,KAAKI,gBAAgBH,KAAK,MAAME;YAC/DH;YACAC;YACAM,WAAOT,0NAAAA,EAAmBE,KAAKI,gBAAgBH,KAAK,OAAOE;QAC7D;IACF,EAAE,OAAOK,OAAO;QACd,IAAIA,iBAAiBd,mLAAAA,EAAmB;YACtC,MAAMc,MAAM,8GAA8G;;QAC5H;QACA,IAAIA,iBAAiBb,2KAAAA,EAAW;YAC9B,MAAM,EAAEc,aAAa,EAAE,GAAG,UAAMjB,2LAAAA,EAAgB;gBAC9CgB;gBACAP;gBACAC;gBACAC;YACF;YAEA,OAAO;gBACLO,QAAQD,gBAAgB,8BAA8B;YACxD;QACF;QAEA,MAAM,EAAEA,aAAa,EAAE,GAAG,UAAMhB,mMAAAA,EAAoB;YAClDe,OACEA,iBAAiBZ,+KAAAA,GACbY,QACA,IAAIZ,+KAAAA,CAAc;gBAChBI;gBACAW,SACE,OAAOH,UAAU,YAAYA,SAAS,aAAaA,QAC9CA,MAAMG,OAAO,GACd;gBACNP;YACF;YACNH;YACAC;YACAC;QACF;QAEA,OAAO;YACLO,QAAQD,gBAAgB,8BAA8B;QACxD;IACF;IAEA,sCAAsC;IACtC,oGAAoG;IACpG,wEAAwE;IACxE,gFAAgF;IAChF,MAAMN,UAAU;QACdS,iBAAaf,4LAAAA,IAAiBgB,WAAW;QACzCC,YAAY;QACZC,YAAaf,CAAAA,IAAIe,UAAU,IAAI,CAAA,IAAK;IACtC;IAEA,OAAO;QACLL,QAAQ;IACV;AACF,EAAC"}},
    {"offset": {"line": 5564, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/queues/operations/runJobs/runJSONJob/index.ts"],"sourcesContent":["import type { Job } from '../../../../index.js'\nimport type { PayloadRequest } from '../../../../types/index.js'\nimport type { WorkflowJSON, WorkflowStep } from '../../../config/types/workflowJSONTypes.js'\nimport type { WorkflowConfig } from '../../../config/types/workflowTypes.js'\nimport type { RunJobsSilent } from '../../../localAPI.js'\nimport type { UpdateJobFunction } from '../runJob/getUpdateJobFunction.js'\nimport type { JobRunStatus } from '../runJob/index.js'\n\nimport { handleWorkflowError } from '../../../errors/handleWorkflowError.js'\nimport { WorkflowError } from '../../../errors/index.js'\nimport { getCurrentDate } from '../../../utilities/getCurrentDate.js'\nimport { getRunTaskFunction } from '../runJob/getRunTaskFunction.js'\n\ntype Args = {\n  job: Job\n  req: PayloadRequest\n  /**\n   * If set to true, the job system will not log any output to the console (for both info and error logs).\n   * Can be an option for more granular control over logging.\n   *\n   * This will not automatically affect user-configured logs (e.g. if you call `console.log` or `payload.logger.info` in your job code).\n   *\n   * @default false\n   */\n  silent?: RunJobsSilent\n  updateJob: UpdateJobFunction\n  workflowConfig: WorkflowConfig\n  workflowHandler: WorkflowJSON\n}\n\nexport type RunJSONJobResult = {\n  status: JobRunStatus\n}\n\nexport const runJSONJob = async ({\n  job,\n  req,\n  silent = false,\n  updateJob,\n  workflowConfig,\n  workflowHandler,\n}: Args): Promise<RunJSONJobResult> => {\n  const stepsToRun: WorkflowStep<string>[] = []\n\n  for (const step of workflowHandler) {\n    if ('task' in step) {\n      if (job?.taskStatus?.[step.task]?.[step.id]?.complete) {\n        continue\n      }\n    } else {\n      if (job?.taskStatus?.['inline']?.[step.id]?.complete) {\n        continue\n      }\n    }\n    if (step.condition && !step.condition({ job })) {\n      continue\n    }\n    stepsToRun.push(step)\n  }\n\n  const tasks = getRunTaskFunction(job, workflowConfig, req, false, updateJob)\n  const inlineTask = getRunTaskFunction(job, workflowConfig, req, true, updateJob)\n\n  // Run the job\n  try {\n    await Promise.all(\n      stepsToRun.map(async (step) => {\n        if ('task' in step) {\n          await tasks[step.task]!(step.id, {\n            input: step.input ? step.input({ job }) : {},\n            retries: step.retries,\n          })\n        } else {\n          await inlineTask(step.id, {\n            retries: step.retries,\n            task: step.inlineTask as any, // TODO: Fix type\n          })\n        }\n      }),\n    )\n  } catch (error) {\n    const { hasFinalError } = await handleWorkflowError({\n      error:\n        error instanceof WorkflowError\n          ? error\n          : new WorkflowError({\n              job,\n              message:\n                typeof error === 'object' && error && 'message' in error\n                  ? (error.message as string)\n                  : 'An unhandled error occurred',\n              workflowConfig,\n            }),\n      silent,\n\n      req,\n      updateJob,\n    })\n\n    return {\n      status: hasFinalError ? 'error-reached-max-retries' : 'error',\n    }\n  }\n\n  // Check if workflow has completed\n  let workflowCompleted = false\n  for (const [slug, map] of Object.entries(job.taskStatus)) {\n    for (const [id, taskStatus] of Object.entries(map)) {\n      if (taskStatus.complete) {\n        const step = workflowHandler.find((step) => {\n          if ('task' in step) {\n            return step.task === slug && step.id === id\n          } else {\n            return step.id === id && slug === 'inline'\n          }\n        })\n        if (step?.completesJob) {\n          workflowCompleted = true\n          break\n        }\n      }\n    }\n  }\n\n  if (workflowCompleted) {\n    await updateJob({\n      completedAt: getCurrentDate().toISOString(),\n      processing: false,\n      totalTried: (job.totalTried ?? 0) + 1,\n    })\n\n    return {\n      status: 'success',\n    }\n  } else {\n    // Retry the job - no need to bump processing or totalTried as this does not count as a retry. A condition of a different task might have just opened up!\n    return await runJSONJob({\n      job,\n      req,\n      updateJob,\n      workflowConfig,\n      workflowHandler,\n    })\n  }\n}\n"],"names":["handleWorkflowError","WorkflowError","getCurrentDate","getRunTaskFunction","runJSONJob","job","req","silent","updateJob","workflowConfig","workflowHandler","stepsToRun","step","taskStatus","task","id","complete","condition","push","tasks","inlineTask","Promise","all","map","input","retries","error","hasFinalError","message","status","workflowCompleted","slug","Object","entries","find","completesJob","completedAt","toISOString","processing","totalTried"],"mappings":";;;;AAQA,SAASA,mBAAmB,QAAQ,yCAAwC;AAC5E,SAASC,aAAa,QAAQ,2BAA0B;AACxD,SAASC,cAAc,QAAQ,uCAAsC;AACrE,SAASC,kBAAkB,QAAQ,kCAAiC;;;;;AAuB7D,MAAMC,aAAa,OAAO,EAC/BC,GAAG,EACHC,GAAG,EACHC,SAAS,KAAK,EACdC,SAAS,EACTC,cAAc,EACdC,eAAe,EACV;IACL,MAAMC,aAAqC,EAAE;IAE7C,KAAK,MAAMC,QAAQF,gBAAiB;QAClC,IAAI,UAAUE,MAAM;YAClB,IAAIP,KAAKQ,YAAY,CAACD,KAAKE,IAAI,CAAC,EAAE,CAACF,KAAKG,EAAE,CAAC,EAAEC,UAAU;gBACrD;YACF;QACF,OAAO;YACL,IAAIX,KAAKQ,YAAY,CAAC,SAAS,EAAE,CAACD,KAAKG,EAAE,CAAC,EAAEC,UAAU;gBACpD;YACF;QACF;QACA,IAAIJ,KAAKK,SAAS,IAAI,CAACL,KAAKK,SAAS,CAAC;YAAEZ;QAAI,IAAI;YAC9C;QACF;QACAM,WAAWO,IAAI,CAACN;IAClB;IAEA,MAAMO,YAAQhB,0NAAAA,EAAmBE,KAAKI,gBAAgBH,KAAK,OAAOE;IAClE,MAAMY,iBAAajB,0NAAAA,EAAmBE,KAAKI,gBAAgBH,KAAK,MAAME;IAEtE,cAAc;IACd,IAAI;QACF,MAAMa,QAAQC,GAAG,CACfX,WAAWY,GAAG,CAAC,OAAOX;YACpB,IAAI,UAAUA,MAAM;gBAClB,MAAMO,KAAK,CAACP,KAAKE,IAAI,CAAC,CAAEF,KAAKG,EAAE,EAAE;oBAC/BS,OAAOZ,KAAKY,KAAK,GAAGZ,KAAKY,KAAK,CAAC;wBAAEnB;oBAAI,KAAK,CAAC;oBAC3CoB,SAASb,KAAKa,OAAO;gBACvB;YACF,OAAO;gBACL,MAAML,WAAWR,KAAKG,EAAE,EAAE;oBACxBU,SAASb,KAAKa,OAAO;oBACrBX,MAAMF,KAAKQ,UAAU;gBACvB;YACF;QACF;IAEJ,EAAE,OAAOM,OAAO;QACd,MAAM,EAAEC,aAAa,EAAE,GAAG,UAAM3B,mMAAAA,EAAoB;YAClD0B,OACEA,iBAAiBzB,+KAAAA,GACbyB,QACA,IAAIzB,+KAAAA,CAAc;gBAChBI;gBACAuB,SACE,OAAOF,UAAU,YAAYA,SAAS,aAAaA,QAC9CA,MAAME,OAAO,GACd;gBACNnB;YACF;YACNF;YAEAD;YACAE;QACF;QAEA,OAAO;YACLqB,QAAQF,gBAAgB,8BAA8B;QACxD;IACF;IAEA,kCAAkC;IAClC,IAAIG,oBAAoB;IACxB,KAAK,MAAM,CAACC,MAAMR,IAAI,IAAIS,OAAOC,OAAO,CAAC5B,IAAIQ,UAAU,EAAG;QACxD,KAAK,MAAM,CAACE,IAAIF,WAAW,IAAImB,OAAOC,OAAO,CAACV,KAAM;YAClD,IAAIV,WAAWG,QAAQ,EAAE;gBACvB,MAAMJ,OAAOF,gBAAgBwB,IAAI,CAAC,CAACtB;oBACjC,IAAI,UAAUA,MAAM;wBAClB,OAAOA,KAAKE,IAAI,KAAKiB,QAAQnB,KAAKG,EAAE,KAAKA;oBAC3C,OAAO;wBACL,OAAOH,KAAKG,EAAE,KAAKA,MAAMgB,SAAS;oBACpC;gBACF;gBACA,IAAInB,MAAMuB,cAAc;oBACtBL,oBAAoB;oBACpB;gBACF;YACF;QACF;IACF;IAEA,IAAIA,mBAAmB;QACrB,MAAMtB,UAAU;YACd4B,iBAAalC,4LAAAA,IAAiBmC,WAAW;YACzCC,YAAY;YACZC,YAAalC,CAAAA,IAAIkC,UAAU,IAAI,CAAA,IAAK;QACtC;QAEA,OAAO;YACLV,QAAQ;QACV;IACF,OAAO;QACL,yJAAyJ;QACzJ,OAAO,MAAMzB,WAAW;YACtBC;YACAC;YACAE;YACAC;YACAC;QACF;IACF;AACF,EAAC"}},
    {"offset": {"line": 5672, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/queues/operations/runJobs/index.ts"],"sourcesContent":["import type { Job } from '../../../index.js'\nimport type { PayloadRequest, Sort, Where } from '../../../types/index.js'\nimport type { WorkflowJSON } from '../../config/types/workflowJSONTypes.js'\nimport type { WorkflowConfig, WorkflowHandler } from '../../config/types/workflowTypes.js'\nimport type { RunJobsSilent } from '../../localAPI.js'\nimport type { RunJobResult } from './runJob/index.js'\n\nimport { Forbidden } from '../../../errors/Forbidden.js'\nimport { isolateObjectProperty } from '../../../utilities/isolateObjectProperty.js'\nimport { jobsCollectionSlug } from '../../config/collection.js'\nimport { JobCancelledError } from '../../errors/index.js'\nimport { getCurrentDate } from '../../utilities/getCurrentDate.js'\nimport { updateJob, updateJobs } from '../../utilities/updateJob.js'\nimport { getUpdateJobFunction } from './runJob/getUpdateJobFunction.js'\nimport { importHandlerPath } from './runJob/importHandlerPath.js'\nimport { runJob } from './runJob/index.js'\nimport { runJSONJob } from './runJSONJob/index.js'\n\nexport type RunJobsArgs = {\n  /**\n   * If you want to run jobs from all queues, set this to true.\n   * If you set this to true, the `queue` property will be ignored.\n   *\n   * @default false\n   */\n  allQueues?: boolean\n  /**\n   * ID of the job to run\n   */\n  id?: number | string\n  /**\n   * The maximum number of jobs to run in this invocation\n   *\n   * @default 10\n   */\n  limit?: number\n  overrideAccess?: boolean\n  /**\n   * Adjust the job processing order\n   *\n   * FIFO would equal `createdAt` and LIFO would equal `-createdAt`.\n   *\n   * @default all jobs for all queues will be executed in FIFO order.\n   */\n  processingOrder?: Sort\n  /**\n   * If you want to run jobs from a specific queue, set this to the queue name.\n   *\n   * @default jobs from the `default` queue will be executed.\n   */\n  queue?: string\n  req: PayloadRequest\n  /**\n   * By default, jobs are run in parallel.\n   * If you want to run them in sequence, set this to true.\n   */\n  sequential?: boolean\n  /**\n   * If set to true, the job system will not log any output to the console (for both info and error logs).\n   * Can be an option for more granular control over logging.\n   *\n   * This will not automatically affect user-configured logs (e.g. if you call `console.log` or `payload.logger.info` in your job code).\n   *\n   * @default false\n   */\n  silent?: RunJobsSilent\n  where?: Where\n}\n\nexport type RunJobsResult = {\n  jobStatus?: Record<string, RunJobResult>\n  /**\n   * If this is true, there for sure are no jobs remaining, regardless of the limit\n   */\n  noJobsRemaining?: boolean\n  /**\n   * Out of the jobs that were queried & processed (within the set limit), how many are remaining and retryable?\n   */\n  remainingJobsFromQueried: number\n}\n\nexport const runJobs = async (args: RunJobsArgs): Promise<RunJobsResult> => {\n  const {\n    id,\n    allQueues = false,\n    limit = 10,\n    overrideAccess,\n    processingOrder,\n    queue = 'default',\n    req,\n    req: {\n      payload,\n      payload: {\n        config: { jobs: jobsConfig },\n      },\n    },\n    sequential,\n    silent = false,\n    where: whereFromProps,\n  } = args\n\n  if (!overrideAccess) {\n    /**\n     * By default, jobsConfig.access.run will be `defaultAccess` which is a function that returns `true` if the user is logged in.\n     */\n    const accessFn = jobsConfig?.access?.run ?? (() => true)\n    const hasAccess = await accessFn({ req })\n    if (!hasAccess) {\n      throw new Forbidden(req.t)\n    }\n  }\n  const and: Where[] = [\n    {\n      completedAt: {\n        exists: false,\n      },\n    },\n    {\n      hasError: {\n        not_equals: true,\n      },\n    },\n    {\n      processing: {\n        equals: false,\n      },\n    },\n    {\n      or: [\n        {\n          waitUntil: {\n            exists: false,\n          },\n        },\n        {\n          waitUntil: {\n            less_than: getCurrentDate().toISOString(),\n          },\n        },\n      ],\n    },\n  ]\n\n  if (allQueues !== true) {\n    and.push({\n      queue: {\n        equals: queue ?? 'default',\n      },\n    })\n  }\n\n  if (whereFromProps) {\n    and.push(whereFromProps)\n  }\n\n  // Only enforce concurrency controls if the feature is enabled\n  if (jobsConfig.enableConcurrencyControl) {\n    // Find currently running jobs with concurrency keys to enforce exclusive concurrency\n    // Jobs with the same concurrencyKey should not run in parallel\n    const runningJobsWithConcurrency = await payload.db.find({\n      collection: jobsCollectionSlug,\n      limit: 0,\n      pagination: false,\n      req: { transactionID: undefined },\n      select: {\n        concurrencyKey: true,\n      },\n      where: {\n        and: [{ processing: { equals: true } }, { concurrencyKey: { exists: true } }],\n      },\n    })\n\n    const runningConcurrencyKeys = new Set<string>()\n    if (runningJobsWithConcurrency?.docs) {\n      for (const doc of runningJobsWithConcurrency.docs) {\n        const concurrencyKey = (doc as Job).concurrencyKey\n        if (concurrencyKey) {\n          runningConcurrencyKeys.add(concurrencyKey)\n        }\n      }\n    }\n\n    // Exclude jobs whose concurrencyKey is already running\n    if (runningConcurrencyKeys.size > 0) {\n      and.push({\n        or: [\n          // Jobs without a concurrency key can always run\n          { concurrencyKey: { exists: false } },\n          // Jobs with a concurrency key that is not currently running can run\n          { concurrencyKey: { not_in: [...runningConcurrencyKeys] } },\n        ],\n      })\n    }\n  }\n\n  // Find all jobs and ensure we set job to processing: true as early as possible to reduce the chance of\n  // the same job being picked up by another worker\n  let jobs: Job[] = []\n\n  if (id) {\n    // Only one job to run\n    const job = await updateJob({\n      id,\n      data: {\n        processing: true,\n      },\n      depth: jobsConfig.depth,\n      disableTransaction: true,\n      req,\n      returning: true,\n    })\n    if (job) {\n      jobs = [job]\n    }\n  } else {\n    let defaultProcessingOrder: Sort =\n      payload.collections[jobsCollectionSlug]?.config.defaultSort ?? 'createdAt'\n\n    const processingOrderConfig = jobsConfig.processingOrder\n    if (typeof processingOrderConfig === 'function') {\n      defaultProcessingOrder = await processingOrderConfig(args)\n    } else if (typeof processingOrderConfig === 'object' && !Array.isArray(processingOrderConfig)) {\n      if (\n        !allQueues &&\n        queue &&\n        processingOrderConfig.queues &&\n        processingOrderConfig.queues[queue]\n      ) {\n        defaultProcessingOrder = processingOrderConfig.queues[queue]\n      } else if (processingOrderConfig.default) {\n        defaultProcessingOrder = processingOrderConfig.default\n      }\n    } else if (typeof processingOrderConfig === 'string') {\n      defaultProcessingOrder = processingOrderConfig\n    }\n    const updatedDocs = await updateJobs({\n      data: {\n        processing: true,\n      },\n      depth: jobsConfig.depth,\n      disableTransaction: true,\n      limit,\n      req,\n      returning: true,\n      sort: processingOrder ?? defaultProcessingOrder,\n      where: { and },\n    })\n\n    if (updatedDocs) {\n      jobs = updatedDocs\n    }\n  }\n\n  if (!jobs.length) {\n    return {\n      noJobsRemaining: true,\n      remainingJobsFromQueried: 0,\n    }\n  }\n\n  // Only handle concurrency deduplication if the feature is enabled\n  if (jobsConfig.enableConcurrencyControl) {\n    // Handle the case where multiple jobs with the same concurrencyKey were picked up in the same batch\n    // We should only run one job per concurrencyKey, release the others back to pending\n    const seenConcurrencyKeys = new Set<string>()\n    const jobsToRun: Job[] = []\n    const jobsToRelease: Job[] = []\n\n    for (const job of jobs) {\n      if (job.concurrencyKey) {\n        if (seenConcurrencyKeys.has(job.concurrencyKey)) {\n          // This job has the same concurrencyKey as another job we're already running\n          jobsToRelease.push(job)\n        } else {\n          seenConcurrencyKeys.add(job.concurrencyKey)\n          jobsToRun.push(job)\n        }\n      } else {\n        jobsToRun.push(job)\n      }\n    }\n\n    // Release duplicate concurrencyKey jobs back to pending state\n    if (jobsToRelease.length > 0) {\n      const releaseIds = jobsToRelease.map((job) => job.id)\n      await updateJobs({\n        data: { processing: false },\n        disableTransaction: true,\n        req,\n        returning: false,\n        where: { id: { in: releaseIds } },\n      })\n    }\n\n    // Use only the filtered jobs going forward\n    jobs = jobsToRun\n  }\n\n  if (!jobs.length) {\n    return {\n      noJobsRemaining: false,\n      remainingJobsFromQueried: 0,\n    }\n  }\n\n  /**\n   * Just for logging purposes, we want to know how many jobs are new and how many are existing (= already been tried).\n   * This is only for logs - in the end we still want to run all jobs, regardless of whether they are new or existing.\n   */\n  const { existingJobs, newJobs } = jobs.reduce(\n    (acc, job) => {\n      if (job.totalTried > 0) {\n        acc.existingJobs.push(job)\n      } else {\n        acc.newJobs.push(job)\n      }\n      return acc\n    },\n    { existingJobs: [] as Job[], newJobs: [] as Job[] },\n  )\n\n  if (!silent || (typeof silent === 'object' && !silent.info)) {\n    payload.logger.info({\n      msg: `Running ${jobs.length} jobs.`,\n      new: newJobs?.length,\n      retrying: existingJobs?.length,\n    })\n  }\n\n  const successfullyCompletedJobs: (number | string)[] = []\n\n  const runSingleJob = async (\n    job: Job,\n  ): Promise<{\n    id: number | string\n    result: RunJobResult\n  }> => {\n    if (!job.workflowSlug && !job.taskSlug) {\n      throw new Error('Job must have either a workflowSlug or a taskSlug')\n    }\n    const jobReq = isolateObjectProperty(req, 'transactionID')\n\n    const workflowConfig: WorkflowConfig =\n      job.workflowSlug && jobsConfig.workflows?.length\n        ? jobsConfig.workflows.find(({ slug }) => slug === job.workflowSlug)!\n        : {\n            slug: 'singleTask',\n            handler: async ({ job, tasks }) => {\n              await tasks[job.taskSlug as string]!('1', {\n                input: job.input,\n              })\n            },\n          }\n\n    if (!workflowConfig) {\n      return {\n        id: job.id,\n        result: {\n          status: 'error',\n        },\n      } // Skip jobs with no workflow configuration\n    }\n\n    try {\n      const updateJob = getUpdateJobFunction(job, jobReq)\n\n      // the runner will either be passed to the config\n      // OR it will be a path, which we will need to import via eval to avoid\n      // Next.js compiler dynamic import expression errors\n      let workflowHandler: WorkflowHandler | WorkflowJSON\n      if (\n        typeof workflowConfig.handler === 'function' ||\n        (typeof workflowConfig.handler === 'object' && Array.isArray(workflowConfig.handler))\n      ) {\n        workflowHandler = workflowConfig.handler\n      } else {\n        workflowHandler = await importHandlerPath<typeof workflowHandler>(workflowConfig.handler)\n\n        if (!workflowHandler) {\n          const jobLabel = job.workflowSlug || `Task: ${job.taskSlug}`\n          const errorMessage = `Can't find runner while importing with the path ${workflowConfig.handler} in job type ${jobLabel}.`\n          if (!silent || (typeof silent === 'object' && !silent.error)) {\n            payload.logger.error(errorMessage)\n          }\n\n          await updateJob({\n            error: {\n              error: errorMessage,\n            },\n            hasError: true,\n            processing: false,\n          })\n\n          return {\n            id: job.id,\n            result: {\n              status: 'error-reached-max-retries',\n            },\n          }\n        }\n      }\n\n      if (typeof workflowHandler === 'function') {\n        const result = await runJob({\n          job,\n          req: jobReq,\n          silent,\n          updateJob,\n          workflowConfig,\n          workflowHandler,\n        })\n\n        if (result.status === 'success') {\n          successfullyCompletedJobs.push(job.id)\n        }\n\n        return { id: job.id, result }\n      } else {\n        const result = await runJSONJob({\n          job,\n          req: jobReq,\n          silent,\n          updateJob,\n          workflowConfig,\n          workflowHandler,\n        })\n\n        if (result.status === 'success') {\n          successfullyCompletedJobs.push(job.id)\n        }\n\n        return { id: job.id, result }\n      }\n    } catch (error) {\n      if (error instanceof JobCancelledError) {\n        if (\n          !(job.error as Record<string, unknown> | undefined)?.cancelled ||\n          !job.hasError ||\n          job.processing ||\n          job.completedAt ||\n          job.waitUntil\n        ) {\n          // When using the local API to cancel jobs, the local API will update the job data for us to ensure the job is cancelled.\n          // But when throwing a JobCancelledError within a task or workflow handler, we are responsible for updating the job data ourselves.\n          await updateJob({\n            id: job.id,\n            data: {\n              completedAt: null,\n              error: {\n                cancelled: true,\n                message: error.message,\n              },\n              hasError: true,\n              processing: false,\n              waitUntil: null,\n            },\n            depth: 0,\n            disableTransaction: true,\n            req,\n            returning: false,\n          })\n        }\n\n        return {\n          id: job.id,\n          result: {\n            status: 'error-reached-max-retries',\n          },\n        }\n      }\n      throw error\n    }\n  }\n\n  let resultsArray: { id: number | string; result: RunJobResult }[] = []\n  if (sequential) {\n    for (const job of jobs) {\n      const result = await runSingleJob(job)\n      if (result) {\n        resultsArray.push(result)\n      }\n    }\n  } else {\n    const jobPromises = jobs.map(runSingleJob)\n    resultsArray = (await Promise.all(jobPromises)) as {\n      id: number | string\n      result: RunJobResult\n    }[]\n  }\n\n  if (jobsConfig.deleteJobOnComplete && successfullyCompletedJobs.length) {\n    try {\n      if (jobsConfig.runHooks) {\n        await payload.delete({\n          collection: jobsCollectionSlug,\n          depth: 0, // can be 0 since we're not returning anything\n          disableTransaction: true,\n          where: { id: { in: successfullyCompletedJobs } },\n        })\n      } else {\n        await payload.db.deleteMany({\n          collection: jobsCollectionSlug,\n          where: { id: { in: successfullyCompletedJobs } },\n        })\n      }\n    } catch (err) {\n      if (!silent || (typeof silent === 'object' && !silent.error)) {\n        payload.logger.error({\n          err,\n          msg: `Failed to delete jobs ${successfullyCompletedJobs.join(', ')} on complete`,\n        })\n      }\n    }\n  }\n\n  const resultsObject: RunJobsResult['jobStatus'] = resultsArray.reduce(\n    (acc, cur) => {\n      if (cur !== null) {\n        // Check if there's a valid result to include\n        acc[cur.id] = cur.result\n      }\n      return acc\n    },\n    {} as Record<string, RunJobResult>,\n  )\n\n  let remainingJobsFromQueried = 0\n  for (const jobID in resultsObject) {\n    const jobResult = resultsObject[jobID]\n    if (jobResult?.status === 'error') {\n      remainingJobsFromQueried++ // Can be retried\n    }\n  }\n\n  return {\n    jobStatus: resultsObject,\n    remainingJobsFromQueried,\n  }\n}\n"],"names":["Forbidden","isolateObjectProperty","jobsCollectionSlug","JobCancelledError","getCurrentDate","updateJob","updateJobs","getUpdateJobFunction","importHandlerPath","runJob","runJSONJob","runJobs","args","id","allQueues","limit","overrideAccess","processingOrder","queue","req","payload","config","jobs","jobsConfig","sequential","silent","where","whereFromProps","accessFn","access","run","hasAccess","t","and","completedAt","exists","hasError","not_equals","processing","equals","or","waitUntil","less_than","toISOString","push","enableConcurrencyControl","runningJobsWithConcurrency","db","find","collection","pagination","transactionID","undefined","select","concurrencyKey","runningConcurrencyKeys","Set","docs","doc","add","size","not_in","job","data","depth","disableTransaction","returning","defaultProcessingOrder","collections","defaultSort","processingOrderConfig","Array","isArray","queues","default","updatedDocs","sort","length","noJobsRemaining","remainingJobsFromQueried","seenConcurrencyKeys","jobsToRun","jobsToRelease","has","releaseIds","map","in","existingJobs","newJobs","reduce","acc","totalTried","info","logger","msg","new","retrying","successfullyCompletedJobs","runSingleJob","workflowSlug","taskSlug","Error","jobReq","workflowConfig","workflows","slug","handler","tasks","input","result","status","workflowHandler","jobLabel","errorMessage","error","cancelled","message","resultsArray","jobPromises","Promise","all","deleteJobOnComplete","runHooks","delete","deleteMany","err","join","resultsObject","cur","jobID","jobResult","jobStatus"],"mappings":"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"}},
    {"offset": {"line": 6122, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/queues/endpoints/run.ts"],"sourcesContent":["import type { Endpoint } from '../../config/types.js'\nimport type { SanitizedJobsConfig } from '../config/types/index.js'\n\nimport { runJobs, type RunJobsArgs } from '../operations/runJobs/index.js'\n\n/**\n * /api/payload-jobs/run endpoint\n *\n * This endpoint is GET instead of POST to allow it to be used in a Vercel Cron.\n */\nexport const runJobsEndpoint: Endpoint = {\n  handler: async (req) => {\n    const jobsConfig = req.payload.config.jobs\n\n    if (!configHasJobs(jobsConfig)) {\n      return Response.json(\n        {\n          message: 'No jobs to run.',\n        },\n        { status: 200 },\n      )\n    }\n\n    const accessFn = jobsConfig.access?.run ?? (() => true)\n\n    const hasAccess = await accessFn({ req })\n\n    if (!hasAccess) {\n      return Response.json(\n        {\n          message: req.i18n.t('error:unauthorized'),\n        },\n        { status: 401 },\n      )\n    }\n\n    const {\n      allQueues,\n      disableScheduling: disableSchedulingParam,\n      limit,\n      queue,\n      silent: silentParam,\n    } = req.query as {\n      allQueues?: 'false' | 'true'\n      disableScheduling?: 'false' | 'true'\n      limit?: number\n      queue?: string\n      silent?: string\n    }\n\n    const silent = silentParam === 'true'\n\n    const shouldHandleSchedules = disableSchedulingParam !== 'true'\n\n    const runAllQueues = allQueues && !(typeof allQueues === 'string' && allQueues === 'false')\n\n    if (shouldHandleSchedules && jobsConfig.scheduling) {\n      // If should handle schedules and schedules are defined\n      await req.payload.jobs.handleSchedules({ allQueues: runAllQueues, queue, req })\n    }\n\n    const runJobsArgs: RunJobsArgs = {\n      queue,\n      req,\n      // Access is validated above, so it's safe to override here\n      allQueues: runAllQueues,\n      overrideAccess: true,\n      silent,\n    }\n\n    if (typeof queue === 'string') {\n      runJobsArgs.queue = queue\n    }\n\n    const parsedLimit = Number(limit)\n    if (!isNaN(parsedLimit)) {\n      runJobsArgs.limit = parsedLimit\n    }\n\n    let noJobsRemaining = false\n    let remainingJobsFromQueried = 0\n    try {\n      const result = await runJobs(runJobsArgs)\n      noJobsRemaining = !!result.noJobsRemaining\n      remainingJobsFromQueried = result.remainingJobsFromQueried\n    } catch (err) {\n      req.payload.logger.error({\n        err,\n        msg: 'There was an error running jobs:',\n        queue: runJobsArgs.queue,\n      })\n\n      return Response.json(\n        {\n          message: req.i18n.t('error:unknown'),\n          noJobsRemaining: true,\n          remainingJobsFromQueried,\n        },\n        { status: 500 },\n      )\n    }\n\n    return Response.json(\n      {\n        message: req.i18n.t('general:success'),\n        noJobsRemaining,\n        remainingJobsFromQueried,\n      },\n      { status: 200 },\n    )\n  },\n  method: 'get',\n  path: '/run',\n}\n\nexport const configHasJobs = (jobsConfig: SanitizedJobsConfig): boolean => {\n  return Boolean(jobsConfig.tasks?.length || jobsConfig.workflows?.length)\n}\n"],"names":["runJobs","runJobsEndpoint","handler","req","jobsConfig","payload","config","jobs","configHasJobs","Response","json","message","status","accessFn","access","run","hasAccess","i18n","t","allQueues","disableScheduling","disableSchedulingParam","limit","queue","silent","silentParam","query","shouldHandleSchedules","runAllQueues","scheduling","handleSchedules","runJobsArgs","overrideAccess","parsedLimit","Number","isNaN","noJobsRemaining","remainingJobsFromQueried","result","err","logger","error","msg","method","path","Boolean","tasks","length","workflows"],"mappings":";;;;;;AAGA,SAASA,OAAO,QAA0B,iCAAgC;;AAOnE,MAAMC,kBAA4B;IACvCC,SAAS,OAAOC;QACd,MAAMC,aAAaD,IAAIE,OAAO,CAACC,MAAM,CAACC,IAAI;QAE1C,IAAI,CAACC,cAAcJ,aAAa;YAC9B,OAAOK,SAASC,IAAI,CAClB;gBACEC,SAAS;YACX,GACA;gBAAEC,QAAQ;YAAI;QAElB;QAEA,MAAMC,WAAWT,WAAWU,MAAM,EAAEC,OAAQ,CAAA,IAAM,IAAG;QAErD,MAAMC,YAAY,MAAMH,SAAS;YAAEV;QAAI;QAEvC,IAAI,CAACa,WAAW;YACd,OAAOP,SAASC,IAAI,CAClB;gBACEC,SAASR,IAAIc,IAAI,CAACC,CAAC,CAAC;YACtB,GACA;gBAAEN,QAAQ;YAAI;QAElB;QAEA,MAAM,EACJO,SAAS,EACTC,mBAAmBC,sBAAsB,EACzCC,KAAK,EACLC,KAAK,EACLC,QAAQC,WAAW,EACpB,GAAGtB,IAAIuB,KAAK;QAQb,MAAMF,SAASC,gBAAgB;QAE/B,MAAME,wBAAwBN,2BAA2B;QAEzD,MAAMO,eAAeT,aAAa,CAAE,CAAA,OAAOA,cAAc,YAAYA,cAAc,OAAM;QAEzF,IAAIQ,yBAAyBvB,WAAWyB,UAAU,EAAE;YAClD,uDAAuD;YACvD,MAAM1B,IAAIE,OAAO,CAACE,IAAI,CAACuB,eAAe,CAAC;gBAAEX,WAAWS;gBAAcL;gBAAOpB;YAAI;QAC/E;QAEA,MAAM4B,cAA2B;YAC/BR;YACApB;YACA,2DAA2D;YAC3DgB,WAAWS;YACXI,gBAAgB;YAChBR;QACF;QAEA,IAAI,OAAOD,UAAU,UAAU;YAC7BQ,YAAYR,KAAK,GAAGA;QACtB;QAEA,MAAMU,cAAcC,OAAOZ;QAC3B,IAAI,CAACa,MAAMF,cAAc;YACvBF,YAAYT,KAAK,GAAGW;QACtB;QAEA,IAAIG,kBAAkB;QACtB,IAAIC,2BAA2B;QAC/B,IAAI;YACF,MAAMC,SAAS,UAAMtC,wLAAAA,EAAQ+B;YAC7BK,kBAAkB,CAAC,CAACE,OAAOF,eAAe;YAC1CC,2BAA2BC,OAAOD,wBAAwB;QAC5D,EAAE,OAAOE,KAAK;YACZpC,IAAIE,OAAO,CAACmC,MAAM,CAACC,KAAK,CAAC;gBACvBF;gBACAG,KAAK;gBACLnB,OAAOQ,YAAYR,KAAK;YAC1B;YAEA,OAAOd,SAASC,IAAI,CAClB;gBACEC,SAASR,IAAIc,IAAI,CAACC,CAAC,CAAC;gBACpBkB,iBAAiB;gBACjBC;YACF,GACA;gBAAEzB,QAAQ;YAAI;QAElB;QAEA,OAAOH,SAASC,IAAI,CAClB;YACEC,SAASR,IAAIc,IAAI,CAACC,CAAC,CAAC;YACpBkB;YACAC;QACF,GACA;YAAEzB,QAAQ;QAAI;IAElB;IACA+B,QAAQ;IACRC,MAAM;AACR,EAAC;AAEM,MAAMpC,gBAAgB,CAACJ;IAC5B,OAAOyC,QAAQzC,WAAW0C,KAAK,EAAEC,UAAU3C,WAAW4C,SAAS,EAAED;AACnE,EAAC"}},
    {"offset": {"line": 6216, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/queues/endpoints/handleSchedules.ts"],"sourcesContent":["import type { Endpoint } from '../../config/types.js'\n\nimport { handleSchedules } from '../operations/handleSchedules/index.js'\nimport { configHasJobs } from './run.js'\n\n/**\n * GET /api/payload-jobs/handle-schedules endpoint\n *\n * This endpoint is GET instead of POST to allow it to be used in a Vercel Cron.\n */\nexport const handleSchedulesJobsEndpoint: Endpoint = {\n  handler: async (req) => {\n    const jobsConfig = req.payload.config.jobs\n\n    if (!configHasJobs(jobsConfig)) {\n      return Response.json(\n        {\n          message: 'No jobs to schedule.',\n        },\n        { status: 200 },\n      )\n    }\n\n    const accessFn = jobsConfig.access?.run ?? (() => true)\n\n    const hasAccess = await accessFn({ req })\n\n    if (!hasAccess) {\n      return Response.json(\n        {\n          message: req.i18n.t('error:unauthorized'),\n        },\n        { status: 401 },\n      )\n    }\n\n    if (!jobsConfig.scheduling) {\n      // There is no reason to call the handleSchedules endpoint if the stats global is not enabled (= no schedules defined)\n      return Response.json(\n        {\n          message:\n            'Cannot handle schedules because no tasks or workflows with schedules are defined.',\n        },\n        { status: 500 },\n      )\n    }\n\n    const { allQueues, queue } = req.query as {\n      allQueues?: 'false' | 'true'\n      queue?: string\n    }\n\n    const runAllQueues = allQueues && !(typeof allQueues === 'string' && allQueues === 'false')\n\n    const { errored, queued, skipped } = await handleSchedules({\n      allQueues: runAllQueues,\n      queue,\n      req,\n    })\n\n    return Response.json(\n      {\n        errored,\n        message: req.i18n.t('general:success'),\n        queued,\n        skipped,\n      },\n      { status: 200 },\n    )\n  },\n  method: 'get',\n  path: '/handle-schedules',\n}\n"],"names":["handleSchedules","configHasJobs","handleSchedulesJobsEndpoint","handler","req","jobsConfig","payload","config","jobs","Response","json","message","status","accessFn","access","run","hasAccess","i18n","t","scheduling","allQueues","queue","query","runAllQueues","errored","queued","skipped","method","path"],"mappings":";;;;AAEA,SAASA,eAAe,QAAQ,yCAAwC;AACxE,SAASC,aAAa,QAAQ,WAAU;;;AAOjC,MAAMC,8BAAwC;IACnDC,SAAS,OAAOC;QACd,MAAMC,aAAaD,IAAIE,OAAO,CAACC,MAAM,CAACC,IAAI;QAE1C,IAAI,KAACP,gLAAAA,EAAcI,aAAa;YAC9B,OAAOI,SAASC,IAAI,CAClB;gBACEC,SAAS;YACX,GACA;gBAAEC,QAAQ;YAAI;QAElB;QAEA,MAAMC,WAAWR,WAAWS,MAAM,EAAEC,OAAQ,CAAA,IAAM,IAAG;QAErD,MAAMC,YAAY,MAAMH,SAAS;YAAET;QAAI;QAEvC,IAAI,CAACY,WAAW;YACd,OAAOP,SAASC,IAAI,CAClB;gBACEC,SAASP,IAAIa,IAAI,CAACC,CAAC,CAAC;YACtB,GACA;gBAAEN,QAAQ;YAAI;QAElB;QAEA,IAAI,CAACP,WAAWc,UAAU,EAAE;YAC1B,sHAAsH;YACtH,OAAOV,SAASC,IAAI,CAClB;gBACEC,SACE;YACJ,GACA;gBAAEC,QAAQ;YAAI;QAElB;QAEA,MAAM,EAAEQ,SAAS,EAAEC,KAAK,EAAE,GAAGjB,IAAIkB,KAAK;QAKtC,MAAMC,eAAeH,aAAa,CAAE,CAAA,OAAOA,cAAc,YAAYA,cAAc,OAAM;QAEzF,MAAM,EAAEI,OAAO,EAAEC,MAAM,EAAEC,OAAO,EAAE,GAAG,UAAM1B,wMAAAA,EAAgB;YACzDoB,WAAWG;YACXF;YACAjB;QACF;QAEA,OAAOK,SAASC,IAAI,CAClB;YACEc;YACAb,SAASP,IAAIa,IAAI,CAACC,CAAC,CAAC;YACpBO;YACAC;QACF,GACA;YAAEd,QAAQ;QAAI;IAElB;IACAe,QAAQ;IACRC,MAAM;AACR,EAAC"}},
    {"offset": {"line": 6276, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/queues/utilities/getJobTaskStatus.ts"],"sourcesContent":["import type { Job } from '../../index.js'\nimport type { JobTaskStatus } from '../config/types/workflowTypes.js'\n\ntype Args = {\n  jobLog: Job['log']\n}\n\nexport const getJobTaskStatus = ({ jobLog }: Args): JobTaskStatus => {\n  const taskStatus: JobTaskStatus = {}\n\n  if (!jobLog || !Array.isArray(jobLog)) {\n    return taskStatus\n  }\n\n  // First, add (in order) the steps from the config to\n  // our status map\n  for (const loggedJob of jobLog) {\n    if (!taskStatus[loggedJob.taskSlug]) {\n      taskStatus[loggedJob.taskSlug] = {}\n    }\n    if (!taskStatus[loggedJob.taskSlug]?.[loggedJob.taskID]) {\n      taskStatus[loggedJob.taskSlug]![loggedJob.taskID] = {\n        complete: loggedJob.state === 'succeeded',\n        input: loggedJob.input,\n        output: loggedJob.output,\n        taskSlug: loggedJob.taskSlug,\n        totalTried: 1,\n      }\n    } else {\n      const newTaskStatus = taskStatus[loggedJob.taskSlug]![loggedJob.taskID]!\n      newTaskStatus.totalTried += 1\n\n      if (loggedJob.state === 'succeeded') {\n        newTaskStatus.complete = true\n        // As the task currently saved in taskStatus has likely failed and thus has no\n        // Output data, we need to update it with the new data from the successful task\n        newTaskStatus.output = loggedJob.output\n        newTaskStatus.input = loggedJob.input\n        newTaskStatus.taskSlug = loggedJob.taskSlug\n      }\n      taskStatus[loggedJob.taskSlug]![loggedJob.taskID] = newTaskStatus\n    }\n  }\n\n  return taskStatus\n}\n"],"names":["getJobTaskStatus","jobLog","taskStatus","Array","isArray","loggedJob","taskSlug","taskID","complete","state","input","output","totalTried","newTaskStatus"],"mappings":";;;;AAOO,MAAMA,mBAAmB,CAAC,EAAEC,MAAM,EAAQ;IAC/C,MAAMC,aAA4B,CAAC;IAEnC,IAAI,CAACD,UAAU,CAACE,MAAMC,OAAO,CAACH,SAAS;QACrC,OAAOC;IACT;IAEA,qDAAqD;IACrD,iBAAiB;IACjB,KAAK,MAAMG,aAAaJ,OAAQ;QAC9B,IAAI,CAACC,UAAU,CAACG,UAAUC,QAAQ,CAAC,EAAE;YACnCJ,UAAU,CAACG,UAAUC,QAAQ,CAAC,GAAG,CAAC;QACpC;QACA,IAAI,CAACJ,UAAU,CAACG,UAAUC,QAAQ,CAAC,EAAE,CAACD,UAAUE,MAAM,CAAC,EAAE;YACvDL,UAAU,CAACG,UAAUC,QAAQ,CAAE,CAACD,UAAUE,MAAM,CAAC,GAAG;gBAClDC,UAAUH,UAAUI,KAAK,KAAK;gBAC9BC,OAAOL,UAAUK,KAAK;gBACtBC,QAAQN,UAAUM,MAAM;gBACxBL,UAAUD,UAAUC,QAAQ;gBAC5BM,YAAY;YACd;QACF,OAAO;YACL,MAAMC,gBAAgBX,UAAU,CAACG,UAAUC,QAAQ,CAAE,CAACD,UAAUE,MAAM,CAAC;YACvEM,cAAcD,UAAU,IAAI;YAE5B,IAAIP,UAAUI,KAAK,KAAK,aAAa;gBACnCI,cAAcL,QAAQ,GAAG;gBACzB,8EAA8E;gBAC9E,+EAA+E;gBAC/EK,cAAcF,MAAM,GAAGN,UAAUM,MAAM;gBACvCE,cAAcH,KAAK,GAAGL,UAAUK,KAAK;gBACrCG,cAAcP,QAAQ,GAAGD,UAAUC,QAAQ;YAC7C;YACAJ,UAAU,CAACG,UAAUC,QAAQ,CAAE,CAACD,UAAUE,MAAM,CAAC,GAAGM;QACtD;IACF;IAEA,OAAOX;AACT,EAAC"}},
    {"offset": {"line": 6319, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/queues/config/collection.ts"],"sourcesContent":["import type { CollectionConfig } from '../../collections/config/types.js'\nimport type { SanitizedConfig } from '../../config/types.js'\nimport type { Field } from '../../fields/config/types.js'\nimport type { Job } from '../../index.js'\n\nimport { handleSchedulesJobsEndpoint } from '../endpoints/handleSchedules.js'\nimport { runJobsEndpoint } from '../endpoints/run.js'\nimport { getJobTaskStatus } from '../utilities/getJobTaskStatus.js'\n\nexport const jobsCollectionSlug = 'payload-jobs'\n\nexport const getDefaultJobsCollection: (jobsConfig: SanitizedConfig['jobs']) => CollectionConfig = (\n  jobsConfig,\n) => {\n  const workflowSlugs: Set<string> = new Set()\n  const taskSlugs: Set<string> = new Set(['inline'])\n\n  if (jobsConfig.workflows?.length) {\n    jobsConfig.workflows.forEach((workflow) => {\n      workflowSlugs.add(workflow.slug)\n\n      // Validate concurrency config requires enableConcurrencyControl flag\n      if (workflow.concurrency && !jobsConfig.enableConcurrencyControl) {\n        throw new Error(\n          `Workflow \"${workflow.slug}\" uses concurrency controls but \"jobs.enableConcurrencyControl\" is not enabled. ` +\n            `Set \"jobs.enableConcurrencyControl: true\" in your Payload config to use concurrency controls. ` +\n            `Note: This adds a new indexed field to the jobs collection schema and may require a database migration.`,\n        )\n      }\n    })\n  }\n\n  if (jobsConfig.tasks?.length) {\n    jobsConfig.tasks.forEach((task) => {\n      if (workflowSlugs.has(task.slug)) {\n        throw new Error(\n          `Task slug \"${task.slug}\" is already used by a workflow. No tasks are allowed to have the same slug as a workflow.`,\n        )\n      }\n\n      // Validate concurrency config requires enableConcurrencyControl flag\n      if (task.concurrency && !jobsConfig.enableConcurrencyControl) {\n        throw new Error(\n          `Task \"${task.slug}\" uses concurrency controls but \"jobs.enableConcurrencyControl\" is not enabled. ` +\n            `Set \"jobs.enableConcurrencyControl: true\" in your Payload config to use concurrency controls. ` +\n            `Note: This adds a new indexed field to the jobs collection schema and may require a database migration.`,\n        )\n      }\n\n      taskSlugs.add(task.slug)\n    })\n  }\n\n  const logFields: Field[] = [\n    {\n      name: 'executedAt',\n      type: 'date',\n      required: true,\n    },\n    {\n      name: 'completedAt',\n      type: 'date',\n      required: true,\n    },\n    {\n      name: 'taskSlug',\n      type: 'select',\n      options: [...taskSlugs],\n      required: true,\n    },\n    {\n      name: 'taskID',\n      type: 'text',\n      required: true,\n    },\n    /**\n     * @todo make required in 4.0\n     */\n    {\n      name: 'input',\n      type: 'json',\n    },\n    {\n      name: 'output',\n      type: 'json',\n    },\n    {\n      name: 'state',\n      type: 'radio',\n      options: ['failed', 'succeeded'],\n      required: true,\n    },\n    {\n      name: 'error',\n      type: 'json',\n      admin: {\n        condition: (_, data) => data.state === 'failed',\n      },\n      required: true,\n    },\n  ]\n\n  if (jobsConfig.addParentToTaskLog) {\n    logFields.push({\n      name: 'parent',\n      type: 'group',\n      fields: [\n        {\n          name: 'taskSlug',\n          type: 'select',\n          options: [...taskSlugs],\n        },\n        {\n          name: 'taskID',\n          type: 'text',\n        },\n      ],\n    })\n  }\n\n  const jobsCollection: CollectionConfig = {\n    slug: jobsCollectionSlug,\n    admin: {\n      group: 'System',\n      hidden: true,\n    },\n    endpoints: [runJobsEndpoint, handleSchedulesJobsEndpoint],\n    fields: [\n      {\n        name: 'input',\n        type: 'json',\n        admin: {\n          description: 'Input data provided to the job',\n        },\n      },\n      {\n        name: 'taskStatus',\n        type: 'json',\n        virtual: true,\n      },\n      {\n        type: 'tabs',\n        tabs: [\n          {\n            fields: [\n              {\n                name: 'completedAt',\n                type: 'date',\n                index: true,\n              },\n              {\n                name: 'totalTried',\n                type: 'number',\n                defaultValue: 0,\n                index: true,\n              },\n              {\n                name: 'hasError',\n                type: 'checkbox',\n                admin: {\n                  description: 'If hasError is true this job will not be retried',\n                },\n                defaultValue: false,\n                index: true,\n              },\n              {\n                name: 'error',\n                type: 'json',\n                admin: {\n                  condition: (data) => data.hasError,\n                  description: 'If hasError is true, this is the error that caused it',\n                },\n              },\n              {\n                name: 'log',\n                type: 'array',\n                admin: {\n                  description: 'Task execution log',\n                },\n                fields: logFields,\n              },\n            ],\n            label: 'Status',\n          },\n        ],\n      },\n      // only include the workflowSlugs field if workflows exist\n      ...((workflowSlugs.size > 0\n        ? [\n            {\n              name: 'workflowSlug',\n              type: 'select',\n              admin: {\n                position: 'sidebar',\n              },\n              index: true,\n              options: [...workflowSlugs],\n            },\n          ]\n        : []) as Field[]),\n      {\n        name: 'taskSlug',\n        type: 'select',\n        admin: {\n          position: 'sidebar',\n        },\n        index: true,\n        options: [...taskSlugs],\n        required: false,\n      },\n      {\n        name: 'queue',\n        type: 'text',\n        admin: {\n          position: 'sidebar',\n        },\n        defaultValue: 'default',\n        index: true,\n      },\n      {\n        name: 'waitUntil',\n        type: 'date',\n        admin: {\n          date: { pickerAppearance: 'dayAndTime' },\n        },\n        index: true,\n      },\n      {\n        name: 'processing',\n        type: 'checkbox',\n        admin: {\n          position: 'sidebar',\n        },\n        defaultValue: false,\n        index: true,\n      },\n      // Only add concurrencyKey field if concurrency control is enabled\n      ...(jobsConfig.enableConcurrencyControl\n        ? [\n            {\n              name: 'concurrencyKey',\n              type: 'text',\n              admin: {\n                description:\n                  'Used for concurrency control. Jobs with the same key are subject to exclusive/supersedes rules.',\n                position: 'sidebar',\n                readOnly: true,\n              },\n              index: true,\n            } as Field,\n          ]\n        : []),\n    ],\n    hooks: {\n      afterRead: [\n        ({ doc, req }) => {\n          // This hook is used to add the virtual `tasks` field to the document, that is computed from the `log` field\n\n          return jobAfterRead({ config: req.payload.config, doc })\n        },\n      ],\n      /**\n       * If another update comes in after a job as already been cancelled, we need to make sure that update doesn't\n       * change the state of the job.\n       */\n      beforeChange: [\n        ({ data, originalDoc }) => {\n          if (originalDoc?.error?.cancelled) {\n            data.processing = false\n            data.hasError = true\n            delete data.completedAt\n            delete data.waitUntil\n          }\n          return data\n        },\n      ],\n    },\n    lockDocuments: false,\n  }\n\n  if (jobsConfig.stats) {\n    // TODO: In 4.0, this should be added by default.\n    // The meta field can be used to store arbitrary data about the job. The scheduling system uses this to store\n    // `scheduled: true` to indicate that the job was queued by the scheduling system.\n    jobsCollection.fields.push({\n      name: 'meta',\n      type: 'json',\n    })\n  }\n  return jobsCollection\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport function jobAfterRead({ config, doc }: { config: SanitizedConfig; doc: Job }): Job {\n  doc.taskStatus = getJobTaskStatus({\n    jobLog: doc.log || [],\n  })\n  doc.input = doc.input || {}\n  doc.taskStatus = doc.taskStatus || {}\n  return doc\n}\n"],"names":["handleSchedulesJobsEndpoint","runJobsEndpoint","getJobTaskStatus","jobsCollectionSlug","getDefaultJobsCollection","jobsConfig","workflowSlugs","Set","taskSlugs","workflows","length","forEach","workflow","add","slug","concurrency","enableConcurrencyControl","Error","tasks","task","has","logFields","name","type","required","options","admin","condition","_","data","state","addParentToTaskLog","push","fields","jobsCollection","group","hidden","endpoints","description","virtual","tabs","index","defaultValue","hasError","label","size","position","date","pickerAppearance","readOnly","hooks","afterRead","doc","req","jobAfterRead","config","payload","beforeChange","originalDoc","error","cancelled","processing","completedAt","waitUntil","lockDocuments","stats","taskStatus","jobLog","log","input"],"mappings":"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"}},
    {"offset": {"line": 6618, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/queues/localAPI.ts"],"sourcesContent":["import type { BaseJob, RunningJobFromTask } from './config/types/workflowTypes.js'\n\nimport {\n  createLocalReq,\n  Forbidden,\n  type Job,\n  type Payload,\n  type PayloadRequest,\n  type Sort,\n  type TypedJobs,\n  type Where,\n} from '../index.js'\nimport { jobAfterRead, jobsCollectionSlug } from './config/collection.js'\nimport { handleSchedules, type HandleSchedulesResult } from './operations/handleSchedules/index.js'\nimport { runJobs } from './operations/runJobs/index.js'\nimport { updateJob, updateJobs } from './utilities/updateJob.js'\n\nexport type RunJobsSilent =\n  | {\n      error?: boolean\n      info?: boolean\n    }\n  | boolean\nexport const getJobsLocalAPI = (payload: Payload) => ({\n  handleSchedules: async (args?: {\n    /**\n     * If you want to schedule jobs from all queues, set this to true.\n     * If you set this to true, the `queue` property will be ignored.\n     *\n     * @default false\n     */\n    allQueues?: boolean\n    // By default, schedule all queues - only scheduling jobs scheduled to be added to the `default` queue would not make sense\n    // here, as you'd usually specify a different queue than `default` here, especially if this is used in combination with autorun.\n    // The `queue` property for setting up schedules is required, and not optional.\n    /**\n     * If you want to only schedule jobs that are set to schedule in a specific queue, set this to the queue name.\n     *\n     * @default jobs from the `default` queue will be executed.\n     */\n    queue?: string\n    req?: PayloadRequest\n  }): Promise<HandleSchedulesResult> => {\n    const newReq: PayloadRequest = args?.req ?? (await createLocalReq({}, payload))\n\n    return await handleSchedules({\n      allQueues: args?.allQueues,\n      queue: args?.queue,\n      req: newReq,\n    })\n  },\n  queue: async <\n    // eslint-disable-next-line @typescript-eslint/no-duplicate-type-constituents\n    TTaskOrWorkflowSlug extends keyof TypedJobs['tasks'] | keyof TypedJobs['workflows'],\n  >(\n    args:\n      | {\n          input: TypedJobs['tasks'][TTaskOrWorkflowSlug]['input']\n          meta?: BaseJob['meta']\n          /**\n           * If set to false, access control as defined in jobsConfig.access.queue will be run.\n           * By default, this is true and no access control will be run.\n           * If you set this to false and do not have jobsConfig.access.queue defined, the default access control will be\n           * run (which is a function that returns `true` if the user is logged in).\n           *\n           * @default true\n           */\n          overrideAccess?: boolean\n          /**\n           * The queue to add the job to.\n           * If not specified, the job will be added to the default queue.\n           *\n           * @default 'default'\n           */\n          queue?: string\n          req?: PayloadRequest\n          task: TTaskOrWorkflowSlug extends keyof TypedJobs['tasks'] ? TTaskOrWorkflowSlug : never\n          waitUntil?: Date\n          workflow?: never\n        }\n      | {\n          input: TypedJobs['workflows'][TTaskOrWorkflowSlug]['input']\n          meta?: BaseJob['meta']\n          /**\n           * If set to false, access control as defined in jobsConfig.access.queue will be run.\n           * By default, this is true and no access control will be run.\n           * If you set this to false and do not have jobsConfig.access.queue defined, the default access control will be\n           * run (which is a function that returns `true` if the user is logged in).\n           *\n           * @default true\n           */\n          overrideAccess?: boolean\n          /**\n           * The queue to add the job to.\n           * If not specified, the job will be added to the default queue.\n           *\n           * @default 'default'\n           */\n          queue?: string\n          req?: PayloadRequest\n          task?: never\n          waitUntil?: Date\n          workflow: TTaskOrWorkflowSlug extends keyof TypedJobs['workflows']\n            ? TTaskOrWorkflowSlug\n            : never\n        },\n  ): Promise<\n    TTaskOrWorkflowSlug extends keyof TypedJobs['workflows']\n      ? Job<TTaskOrWorkflowSlug>\n      : RunningJobFromTask<TTaskOrWorkflowSlug>\n  > => {\n    const overrideAccess = args?.overrideAccess !== false\n    const req: PayloadRequest = args.req ?? (await createLocalReq({}, payload))\n\n    if (!overrideAccess) {\n      /**\n       * By default, jobsConfig.access.queue will be `defaultAccess` which is a function that returns `true` if the user is logged in.\n       */\n      const accessFn = payload.config.jobs?.access?.queue ?? (() => true)\n      const hasAccess = await accessFn({ req })\n      if (!hasAccess) {\n        throw new Forbidden(req.t)\n      }\n    }\n\n    let queue: string | undefined = undefined\n\n    // If user specifies queue, use that\n    if (args.queue) {\n      queue = args.queue\n    } else if (args.workflow) {\n      // Otherwise, if there is a workflow specified, and it has a default queue to use,\n      // use that\n      const workflow = payload.config.jobs?.workflows?.find(({ slug }) => slug === args.workflow)\n      if (workflow?.queue) {\n        queue = workflow.queue\n      }\n    }\n\n    const data: Partial<Job> = {\n      input: args.input,\n    }\n\n    if (queue) {\n      data.queue = queue\n    }\n    if (args.waitUntil) {\n      data.waitUntil = args.waitUntil?.toISOString()\n    }\n    if (args.workflow) {\n      data.workflowSlug = args.workflow as string\n    }\n    if (args.task) {\n      data.taskSlug = args.task as string\n    }\n\n    if (args.meta) {\n      data.meta = args.meta\n    }\n\n    // Compute concurrency key from workflow or task config (only if feature is enabled)\n    if (payload.config.jobs?.enableConcurrencyControl) {\n      let concurrencyKey: null | string = null\n      let supersedes = false\n      const queueName = queue || 'default'\n\n      if (args.workflow) {\n        const workflow = payload.config.jobs?.workflows?.find(({ slug }) => slug === args.workflow)\n        if (workflow?.concurrency) {\n          const concurrencyConfig = workflow.concurrency\n          if (typeof concurrencyConfig === 'function') {\n            concurrencyKey = concurrencyConfig({ input: args.input, queue: queueName })\n          } else {\n            concurrencyKey = concurrencyConfig.key({ input: args.input, queue: queueName })\n            supersedes = concurrencyConfig.supersedes ?? false\n          }\n        }\n      } else if (args.task) {\n        const task = payload.config.jobs?.tasks?.find(({ slug }) => slug === args.task)\n        if (task?.concurrency) {\n          const concurrencyConfig = task.concurrency\n          if (typeof concurrencyConfig === 'function') {\n            concurrencyKey = concurrencyConfig({ input: args.input, queue: queueName })\n          } else {\n            concurrencyKey = concurrencyConfig.key({ input: args.input, queue: queueName })\n            supersedes = concurrencyConfig.supersedes ?? false\n          }\n        }\n      }\n\n      if (concurrencyKey) {\n        data.concurrencyKey = concurrencyKey\n\n        // If supersedes is enabled, delete older pending jobs with the same key\n        if (supersedes) {\n          if (payload.config.jobs.runHooks) {\n            await payload.delete({\n              collection: jobsCollectionSlug,\n              depth: 0,\n              disableTransaction: true,\n              where: {\n                and: [\n                  { concurrencyKey: { equals: concurrencyKey } },\n                  { processing: { equals: false } },\n                  { completedAt: { exists: false } },\n                ],\n              },\n            })\n          } else {\n            await payload.db.deleteMany({\n              collection: jobsCollectionSlug,\n              req,\n              where: {\n                and: [\n                  { concurrencyKey: { equals: concurrencyKey } },\n                  { processing: { equals: false } },\n                  { completedAt: { exists: false } },\n                ],\n              },\n            })\n          }\n        }\n      }\n    }\n\n    type ReturnType = TTaskOrWorkflowSlug extends keyof TypedJobs['workflows']\n      ? Job<TTaskOrWorkflowSlug>\n      : RunningJobFromTask<TTaskOrWorkflowSlug> // Type assertion is still needed here\n\n    if (payload?.config?.jobs?.depth || payload?.config?.jobs?.runHooks) {\n      return (await payload.create({\n        collection: jobsCollectionSlug,\n        data,\n        depth: payload.config.jobs.depth ?? 0,\n        overrideAccess,\n        req,\n      })) as ReturnType\n    } else {\n      return jobAfterRead({\n        config: payload.config,\n        doc: await payload.db.create({\n          collection: jobsCollectionSlug,\n          data,\n          req,\n        }),\n      }) as unknown as ReturnType\n    }\n  },\n\n  run: async (args?: {\n    /**\n     * If you want to run jobs from all queues, set this to true.\n     * If you set this to true, the `queue` property will be ignored.\n     *\n     * @default false\n     */\n    allQueues?: boolean\n    /**\n     * The maximum number of jobs to run in this invocation\n     *\n     * @default 10\n     */\n    limit?: number\n    /**\n     * If set to false, access control as defined in jobsConfig.access.run will be run.\n     * By default, this is true and no access control will be run.\n     * If you set this to false and do not have jobsConfig.access.run defined, the default access control will be\n     * run (which is a function that returns `true` if the user is logged in).\n     *\n     * @default true\n     */\n    overrideAccess?: boolean\n    /**\n     * Adjust the job processing order using a Payload sort string.\n     *\n     * FIFO would equal `createdAt` and LIFO would equal `-createdAt`.\n     */\n    processingOrder?: Sort\n    /**\n     * If you want to run jobs from a specific queue, set this to the queue name.\n     *\n     * @default jobs from the `default` queue will be executed.\n     */\n    queue?: string\n    req?: PayloadRequest\n    /**\n     * By default, jobs are run in parallel.\n     * If you want to run them in sequence, set this to true.\n     */\n    sequential?: boolean\n    /**\n     * If set to true, the job system will not log any output to the console (for both info and error logs).\n     * Can be an option for more granular control over logging.\n     *\n     * This will not automatically affect user-configured logs (e.g. if you call `console.log` or `payload.logger.info` in your job code).\n     *\n     * @default false\n     */\n    silent?: RunJobsSilent\n    where?: Where\n  }): Promise<ReturnType<typeof runJobs>> => {\n    const newReq: PayloadRequest = args?.req ?? (await createLocalReq({}, payload))\n\n    return await runJobs({\n      allQueues: args?.allQueues,\n      limit: args?.limit,\n      overrideAccess: args?.overrideAccess !== false,\n      processingOrder: args?.processingOrder,\n      queue: args?.queue,\n      req: newReq,\n      sequential: args?.sequential,\n      silent: args?.silent,\n      where: args?.where,\n    })\n  },\n\n  runByID: async (args: {\n    id: number | string\n    /**\n     * If set to false, access control as defined in jobsConfig.access.run will be run.\n     * By default, this is true and no access control will be run.\n     * If you set this to false and do not have jobsConfig.access.run defined, the default access control will be\n     * run (which is a function that returns `true` if the user is logged in).\n     *\n     * @default true\n     */\n    overrideAccess?: boolean\n    req?: PayloadRequest\n    /**\n     * If set to true, the job system will not log any output to the console (for both info and error logs).\n     * Can be an option for more granular control over logging.\n     *\n     * This will not automatically affect user-configured logs (e.g. if you call `console.log` or `payload.logger.info` in your job code).\n     *\n     * @default false\n     */\n    silent?: RunJobsSilent\n  }): Promise<ReturnType<typeof runJobs>> => {\n    const newReq: PayloadRequest = args.req ?? (await createLocalReq({}, payload))\n\n    return await runJobs({\n      id: args.id,\n      overrideAccess: args.overrideAccess !== false,\n      req: newReq,\n      silent: args.silent,\n    })\n  },\n\n  cancel: async (args: {\n    /**\n     * If set to false, access control as defined in jobsConfig.access.cancel will be run.\n     * By default, this is true and no access control will be run.\n     * If you set this to false and do not have jobsConfig.access.cancel defined, the default access control will be\n     * run (which is a function that returns `true` if the user is logged in).\n     *\n     * @default true\n     */\n    overrideAccess?: boolean\n    queue?: string\n    req?: PayloadRequest\n    where: Where\n  }): Promise<void> => {\n    const req: PayloadRequest = args.req ?? (await createLocalReq({}, payload))\n\n    const overrideAccess = args.overrideAccess !== false\n    if (!overrideAccess) {\n      /**\n       * By default, jobsConfig.access.cancel will be `defaultAccess` which is a function that returns `true` if the user is logged in.\n       */\n      const accessFn = payload.config.jobs?.access?.cancel ?? (() => true)\n      const hasAccess = await accessFn({ req })\n      if (!hasAccess) {\n        throw new Forbidden(req.t)\n      }\n    }\n\n    const and: Where[] = [\n      args.where,\n      {\n        completedAt: {\n          exists: false,\n        },\n      },\n      {\n        hasError: {\n          not_equals: true,\n        },\n      },\n    ]\n\n    if (args.queue) {\n      and.push({\n        queue: {\n          equals: args.queue,\n        },\n      })\n    }\n\n    await updateJobs({\n      data: {\n        completedAt: null,\n        error: {\n          cancelled: true,\n        },\n        hasError: true,\n        processing: false,\n        waitUntil: null,\n      },\n      depth: 0, // No depth, since we're not returning\n      disableTransaction: true,\n      req,\n      returning: false,\n      where: { and },\n    })\n  },\n\n  cancelByID: async (args: {\n    id: number | string\n    /**\n     * If set to false, access control as defined in jobsConfig.access.cancel will be run.\n     * By default, this is true and no access control will be run.\n     * If you set this to false and do not have jobsConfig.access.cancel defined, the default access control will be\n     * run (which is a function that returns `true` if the user is logged in).\n     *\n     * @default true\n     */\n    overrideAccess?: boolean\n    req?: PayloadRequest\n  }): Promise<void> => {\n    const req: PayloadRequest = args.req ?? (await createLocalReq({}, payload))\n\n    const overrideAccess = args.overrideAccess !== false\n    if (!overrideAccess) {\n      /**\n       * By default, jobsConfig.access.cancel will be `defaultAccess` which is a function that returns `true` if the user is logged in.\n       */\n      const accessFn = payload.config.jobs?.access?.cancel ?? (() => true)\n      const hasAccess = await accessFn({ req })\n      if (!hasAccess) {\n        throw new Forbidden(req.t)\n      }\n    }\n\n    await updateJob({\n      id: args.id,\n      data: {\n        completedAt: null,\n        error: {\n          cancelled: true,\n        },\n        hasError: true,\n        processing: false,\n        waitUntil: null,\n      },\n      depth: 0, // No depth, since we're not returning\n      disableTransaction: true,\n      req,\n      returning: false,\n    })\n  },\n})\n"],"names":["createLocalReq","Forbidden","jobAfterRead","jobsCollectionSlug","handleSchedules","runJobs","updateJob","updateJobs","getJobsLocalAPI","payload","args","newReq","req","allQueues","queue","overrideAccess","accessFn","config","jobs","access","hasAccess","t","undefined","workflow","workflows","find","slug","data","input","waitUntil","toISOString","workflowSlug","task","taskSlug","meta","enableConcurrencyControl","concurrencyKey","supersedes","queueName","concurrency","concurrencyConfig","key","tasks","runHooks","delete","collection","depth","disableTransaction","where","and","equals","processing","completedAt","exists","db","deleteMany","create","doc","run","limit","processingOrder","sequential","silent","runByID","id","cancel","hasError","not_equals","push","error","cancelled","returning","cancelByID"],"mappings":"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"}},
    {"offset": {"line": 6915, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/globals/operations/countGlobalVersions.ts"],"sourcesContent":["import type { AccessResult } from '../../config/types.js'\nimport type { PayloadRequest, Where } from '../../types/index.js'\n\nimport { executeAccess } from '../../auth/executeAccess.js'\nimport { combineQueries } from '../../database/combineQueries.js'\nimport { validateQueryPaths } from '../../database/queryValidation/validateQueryPaths.js'\nimport {\n  buildVersionGlobalFields,\n  type GlobalSlug,\n  type SanitizedGlobalConfig,\n} from '../../index.js'\nimport { killTransaction } from '../../utilities/killTransaction.js'\n\nexport type Arguments = {\n  disableErrors?: boolean\n  global: SanitizedGlobalConfig\n  overrideAccess?: boolean\n  req?: PayloadRequest\n  where?: Where\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport const countGlobalVersionsOperation = async <TSlug extends GlobalSlug>(\n  args: Arguments,\n): Promise<{ totalDocs: number }> => {\n  try {\n    const { disableErrors, global, overrideAccess, where } = args\n    const req = args.req!\n    const { payload } = req\n\n    // /////////////////////////////////////\n    // beforeOperation - Global\n    // /////////////////////////////////////\n\n    if (global.hooks?.beforeOperation?.length) {\n      for (const hook of global.hooks.beforeOperation) {\n        args =\n          (await hook({\n            args,\n            context: req.context,\n            global,\n            operation: 'countVersions',\n            overrideAccess,\n            req,\n          })) || args\n      }\n    }\n\n    // /////////////////////////////////////\n    // Access\n    // /////////////////////////////////////\n\n    let accessResult: AccessResult\n\n    if (!overrideAccess) {\n      accessResult = await executeAccess({ disableErrors, req }, global.access.readVersions)\n\n      // If errors are disabled, and access returns false, return empty results\n      if (accessResult === false) {\n        return {\n          totalDocs: 0,\n        }\n      }\n    }\n\n    const fullWhere = combineQueries(where!, accessResult!)\n\n    const versionFields = buildVersionGlobalFields(payload.config, global, true)\n\n    await validateQueryPaths({\n      globalConfig: global,\n      overrideAccess: overrideAccess!,\n      req,\n      versionFields,\n      where: where!,\n    })\n\n    const result = await payload.db.countGlobalVersions({\n      global: global.slug,\n      req,\n      where: fullWhere,\n    })\n\n    // /////////////////////////////////////\n    // Return results\n    // /////////////////////////////////////\n\n    return result\n  } catch (error: unknown) {\n    await killTransaction(args.req!)\n    throw error\n  }\n}\n"],"names":["executeAccess","combineQueries","validateQueryPaths","buildVersionGlobalFields","killTransaction","countGlobalVersionsOperation","args","disableErrors","global","overrideAccess","where","req","payload","hooks","beforeOperation","length","hook","context","operation","accessResult","access","readVersions","totalDocs","fullWhere","versionFields","config","globalConfig","result","db","countGlobalVersions","slug","error"],"mappings":";;;;AAGA,SAASA,aAAa,QAAQ,8BAA6B;AAC3D,SAASC,cAAc,QAAQ,mCAAkC;AACjE,SAASC,kBAAkB,QAAQ,uDAAsD;AACzF,SACEC,wBAAwB,QAGnB,iBAAgB;AACvB,SAASC,eAAe,QAAQ,qCAAoC;;;;;;AAW7D,MAAMC,+BAA+B,OAC1CC;IAEA,IAAI;QACF,MAAM,EAAEC,aAAa,EAAEC,MAAM,EAAEC,cAAc,EAAEC,KAAK,EAAE,GAAGJ;QACzD,MAAMK,MAAML,KAAKK,GAAG;QACpB,MAAM,EAAEC,OAAO,EAAE,GAAGD;QAEpB,wCAAwC;QACxC,2BAA2B;QAC3B,wCAAwC;QAExC,IAAIH,OAAOK,KAAK,EAAEC,iBAAiBC,QAAQ;YACzC,KAAK,MAAMC,QAAQR,OAAOK,KAAK,CAACC,eAAe,CAAE;gBAC/CR,OACG,MAAMU,KAAK;oBACVV;oBACAW,SAASN,IAAIM,OAAO;oBACpBT;oBACAU,WAAW;oBACXT;oBACAE;gBACF,MAAOL;YACX;QACF;QAEA,wCAAwC;QACxC,SAAS;QACT,wCAAwC;QAExC,IAAIa;QAEJ,IAAI,CAACV,gBAAgB;YACnBU,eAAe,UAAMnB,2KAAAA,EAAc;gBAAEO;gBAAeI;YAAI,GAAGH,OAAOY,MAAM,CAACC,YAAY;YAErF,yEAAyE;YACzE,IAAIF,iBAAiB,OAAO;gBAC1B,OAAO;oBACLG,WAAW;gBACb;YACF;QACF;QAEA,MAAMC,gBAAYtB,iLAAAA,EAAeS,OAAQS;QAEzC,MAAMK,oBAAgBrB,8LAAAA,EAAyBS,QAAQa,MAAM,EAAEjB,QAAQ;QAEvE,UAAMN,4MAAAA,EAAmB;YACvBwB,cAAclB;YACdC,gBAAgBA;YAChBE;YACAa;YACAd,OAAOA;QACT;QAEA,MAAMiB,SAAS,MAAMf,QAAQgB,EAAE,CAACC,mBAAmB,CAAC;YAClDrB,QAAQA,OAAOsB,IAAI;YACnBnB;YACAD,OAAOa;QACT;QAEA,wCAAwC;QACxC,iBAAiB;QACjB,wCAAwC;QAExC,OAAOI;IACT,EAAE,OAAOI,OAAgB;QACvB,UAAM3B,oLAAAA,EAAgBE,KAAKK,GAAG;QAC9B,MAAMoB;IACR;AACF,EAAC"}},
    {"offset": {"line": 6992, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/globals/operations/local/countVersions.ts"],"sourcesContent":["import type { GlobalSlug, Payload, RequestContext, TypedLocale } from '../../../index.js'\nimport type { Document, PayloadRequest, Where } from '../../../types/index.js'\nimport type { CreateLocalReqOptions } from '../../../utilities/createLocalReq.js'\n\nimport { APIError } from '../../../errors/index.js'\nimport { createLocalReq } from '../../../utilities/createLocalReq.js'\nimport { countGlobalVersionsOperation } from '../countGlobalVersions.js'\n\nexport type CountGlobalVersionsOptions<TSlug extends GlobalSlug> = {\n  /**\n   * [Context](https://payloadcms.com/docs/hooks/context), which will then be passed to `context` and `req.context`,\n   * which can be read by hooks. Useful if you want to pass additional information to the hooks which\n   * shouldn't be necessarily part of the document, for example a `triggerBeforeChange` option which can be read by the BeforeChange hook\n   * to determine if it should run or not.\n   */\n  context?: RequestContext\n  /**\n   * When set to `true`, errors will not be thrown.\n   */\n  disableErrors?: boolean\n  /**\n   * the Global slug to operate against.\n   */\n  global: TSlug\n  /**\n   * Specify [locale](https://payloadcms.com/docs/configuration/localization) for any returned documents.\n   */\n  locale?: TypedLocale\n  /**\n   * Skip access control.\n   * Set to `false` if you want to respect Access Control for the operation, for example when fetching data for the front-end.\n   * @default true\n   */\n  overrideAccess?: boolean\n  /**\n   * The `PayloadRequest` object. You can pass it to thread the current [transaction](https://payloadcms.com/docs/database/transactions), user and locale to the operation.\n   * Recommended to pass when using the Local API from hooks, as usually you want to execute the operation within the current transaction.\n   */\n  req?: Partial<PayloadRequest>\n  /**\n   * If you set `overrideAccess` to `false`, you can pass a user to use against the access control checks.\n   */\n  user?: Document\n  /**\n   * A filter [query](https://payloadcms.com/docs/queries/overview)\n   */\n  where?: Where\n}\n\nexport async function countGlobalVersionsLocal<TSlug extends GlobalSlug>(\n  payload: Payload,\n  options: CountGlobalVersionsOptions<TSlug>,\n): Promise<{ totalDocs: number }> {\n  const { disableErrors, global: globalSlug, overrideAccess = true, where } = options\n\n  const global = payload.globals.config.find(({ slug }) => slug === globalSlug)\n\n  if (!global) {\n    throw new APIError(\n      `The global with slug ${String(globalSlug)} can't be found. Count Global Versions Operation.`,\n    )\n  }\n\n  return countGlobalVersionsOperation<TSlug>({\n    disableErrors,\n    global,\n    overrideAccess,\n    req: await createLocalReq(options as CreateLocalReqOptions, payload),\n    where,\n  })\n}\n"],"names":["APIError","createLocalReq","countGlobalVersionsOperation","countGlobalVersionsLocal","payload","options","disableErrors","global","globalSlug","overrideAccess","where","globals","config","find","slug","String","req"],"mappings":";;;;AAIA,SAASA,QAAQ,QAAQ,2BAA0B;AACnD,SAASC,cAAc,QAAQ,uCAAsC;AACrE,SAASC,4BAA4B,QAAQ,4BAA2B;;;;AA2CjE,eAAeC,yBACpBC,OAAgB,EAChBC,OAA0C;IAE1C,MAAM,EAAEC,aAAa,EAAEC,QAAQC,UAAU,EAAEC,iBAAiB,IAAI,EAAEC,KAAK,EAAE,GAAGL;IAE5E,MAAME,SAASH,QAAQO,OAAO,CAACC,MAAM,CAACC,IAAI,CAAC,CAAC,EAAEC,IAAI,EAAE,GAAKA,SAASN;IAElE,IAAI,CAACD,QAAQ;QACX,MAAM,IAAIP,mKAAAA,CACR,CAAC,qBAAqB,EAAEe,OAAOP,YAAY,iDAAiD,CAAC;IAEjG;IAEA,WAAON,iNAAAA,EAAoC;QACzCI;QACAC;QACAE;QACAO,KAAK,UAAMf,kLAAAA,EAAeI,SAAkCD;QAC5DM;IACF;AACF"}},
    {"offset": {"line": 7020, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/globals/operations/findOne.ts"],"sourcesContent":["import { ar } from '@payloadcms/translations/languages/ar'\n\nimport type { FindOptions } from '../../collections/operations/local/find.js'\nimport type { AccessResult } from '../../config/types.js'\nimport type {\n  JsonObject,\n  PayloadRequest,\n  PopulateType,\n  SelectType,\n  Where,\n} from '../../types/index.js'\nimport type { SanitizedGlobalConfig } from '../config/types.js'\n\nimport { executeAccess } from '../../auth/executeAccess.js'\nimport { NotFound } from '../../errors/NotFound.js'\nimport { afterRead, type AfterReadArgs } from '../../fields/hooks/afterRead/index.js'\nimport { lockedDocumentsCollectionSlug } from '../../locked-documents/config.js'\nimport { getSelectMode } from '../../utilities/getSelectMode.js'\nimport { hasDraftsEnabled } from '../../utilities/getVersionsConfig.js'\nimport { killTransaction } from '../../utilities/killTransaction.js'\nimport { sanitizeSelect } from '../../utilities/sanitizeSelect.js'\nimport { replaceWithDraftIfAvailable } from '../../versions/drafts/replaceWithDraftIfAvailable.js'\n\nexport type GlobalFindOneArgs = {\n  /**\n   * You may pass the document data directly which will skip the `db.findOne` database query.\n   * This is useful if you want to use this endpoint solely for running hooks and populating data.\n   */\n  data?: Record<string, unknown>\n  depth?: number\n  draft?: boolean\n  globalConfig: SanitizedGlobalConfig\n  includeLockStatus?: boolean\n  overrideAccess?: boolean\n  populate?: PopulateType\n  req: PayloadRequest\n  showHiddenFields?: boolean\n  slug: string\n} & Pick<AfterReadArgs<JsonObject>, 'flattenLocales'> &\n  Pick<FindOptions<string, SelectType>, 'select'>\n\nexport const findOneOperation = async <T extends Record<string, unknown>>(\n  args: GlobalFindOneArgs,\n): Promise<T> => {\n  const {\n    slug,\n    depth,\n    draft: replaceWithVersion = false,\n    flattenLocales,\n    globalConfig,\n    includeLockStatus: includeLockStatusFromArgs,\n    overrideAccess = false,\n    populate,\n    req: { fallbackLocale, locale },\n    req,\n    select: incomingSelect,\n    showHiddenFields,\n  } = args\n\n  const includeLockStatus =\n    includeLockStatusFromArgs && req.payload.collections?.[lockedDocumentsCollectionSlug]\n\n  try {\n    // /////////////////////////////////////\n    // beforeOperation - Global\n    // /////////////////////////////////////\n\n    if (globalConfig.hooks?.beforeOperation?.length) {\n      for (const hook of globalConfig.hooks.beforeOperation) {\n        args =\n          (await hook({\n            args,\n            context: args.req.context,\n            global: globalConfig,\n            operation: 'read',\n            overrideAccess,\n            req: args.req,\n          })) || args\n      }\n    }\n\n    // /////////////////////////////////////\n    // Retrieve and execute access\n    // /////////////////////////////////////\n\n    let accessResult!: AccessResult\n\n    if (!overrideAccess) {\n      accessResult = await executeAccess({ req }, globalConfig.access.read)\n    }\n\n    if (accessResult === false) {\n      throw new NotFound(req.t)\n    }\n\n    const select = sanitizeSelect({\n      fields: globalConfig.flattenedFields,\n      forceSelect: globalConfig.forceSelect,\n      select: incomingSelect,\n    })\n\n    // /////////////////////////////////////\n    // Perform database operation\n    // /////////////////////////////////////\n\n    let dbSelect = select\n\n    if (\n      globalConfig.versions?.drafts &&\n      replaceWithVersion &&\n      select &&\n      getSelectMode(select) === 'include'\n    ) {\n      dbSelect = { ...select, createdAt: true, updatedAt: true }\n    }\n    const docFromDB = await req.payload.db.findGlobal({\n      slug,\n      locale: locale!,\n      req,\n      select: dbSelect,\n      where: overrideAccess ? undefined : (accessResult as Where),\n    })\n\n    // Check if no document was returned (Postgres returns {} instead of null)\n    const hasDoc = docFromDB && Object.keys(docFromDB).length > 0\n\n    if (!hasDoc && !args.data && !overrideAccess && accessResult !== true) {\n      return {} as any\n    }\n\n    let doc = (args.data as any) ?? (hasDoc ? docFromDB : null) ?? {}\n\n    // /////////////////////////////////////\n    // Include Lock Status if required\n    // /////////////////////////////////////\n    if (includeLockStatus && slug) {\n      let lockStatus: JsonObject | null = null\n\n      try {\n        const lockDocumentsProp = globalConfig?.lockDocuments\n\n        const lockDurationDefault = 300 // Default 5 minutes in seconds\n        const lockDuration =\n          typeof lockDocumentsProp === 'object' ? lockDocumentsProp.duration : lockDurationDefault\n        const lockDurationInMilliseconds = lockDuration * 1000\n\n        const lockedDocument = await req.payload.find({\n          collection: lockedDocumentsCollectionSlug,\n          depth: 1,\n          limit: 1,\n          overrideAccess: false,\n          pagination: false,\n          req,\n          where: {\n            and: [\n              {\n                globalSlug: {\n                  equals: slug,\n                },\n              },\n              {\n                updatedAt: {\n                  greater_than: new Date(new Date().getTime() - lockDurationInMilliseconds),\n                },\n              },\n            ],\n          },\n        })\n\n        if (lockedDocument && lockedDocument.docs.length > 0) {\n          lockStatus = lockedDocument.docs[0]!\n        }\n      } catch {\n        // swallow error\n      }\n\n      doc._isLocked = !!lockStatus\n      doc._userEditing = lockStatus?.user?.value ?? null\n    }\n\n    // /////////////////////////////////////\n    // Replace document with draft if available\n    // /////////////////////////////////////\n\n    if (replaceWithVersion && hasDraftsEnabled(globalConfig)) {\n      doc = await replaceWithDraftIfAvailable({\n        accessResult,\n        doc,\n        entity: globalConfig,\n        entityType: 'global',\n        overrideAccess,\n        req,\n        select,\n      })\n    }\n\n    // /////////////////////////////////////\n    // Execute before global hook\n    // /////////////////////////////////////\n\n    if (globalConfig.hooks?.beforeRead?.length) {\n      for (const hook of globalConfig.hooks.beforeRead) {\n        doc =\n          (await hook({\n            context: req.context,\n            doc,\n            global: globalConfig,\n            overrideAccess,\n            req,\n          })) || doc\n      }\n    }\n\n    // /////////////////////////////////////\n    // Execute globalType field if not selected\n    // /////////////////////////////////////\n    if (select && doc.globalType) {\n      const selectMode = getSelectMode(select)\n      if (\n        (selectMode === 'include' && !select['globalType']) ||\n        (selectMode === 'exclude' && select['globalType'] === false)\n      ) {\n        delete doc['globalType']\n      }\n    }\n\n    // /////////////////////////////////////\n    // Execute field-level hooks and access\n    // /////////////////////////////////////\n\n    doc = await afterRead({\n      collection: null,\n      context: req.context,\n      depth: depth!,\n      doc,\n      draft: replaceWithVersion,\n      fallbackLocale: fallbackLocale!,\n      flattenLocales,\n      global: globalConfig,\n      locale: locale!,\n      overrideAccess,\n      populate,\n      req,\n      select,\n      showHiddenFields: showHiddenFields!,\n    })\n\n    // /////////////////////////////////////\n    // Execute after global hook\n    // /////////////////////////////////////\n\n    if (globalConfig.hooks?.afterRead?.length) {\n      for (const hook of globalConfig.hooks.afterRead) {\n        doc =\n          (await hook({\n            context: req.context,\n            doc,\n            global: globalConfig,\n            overrideAccess,\n            req,\n          })) || doc\n      }\n    }\n\n    // /////////////////////////////////////\n    // Return results\n    // /////////////////////////////////////\n\n    return doc\n  } catch (error: unknown) {\n    await killTransaction(req)\n    throw error\n  }\n}\n"],"names":["executeAccess","NotFound","afterRead","lockedDocumentsCollectionSlug","getSelectMode","hasDraftsEnabled","killTransaction","sanitizeSelect","replaceWithDraftIfAvailable","findOneOperation","args","slug","depth","draft","replaceWithVersion","flattenLocales","globalConfig","includeLockStatus","includeLockStatusFromArgs","overrideAccess","populate","req","fallbackLocale","locale","select","incomingSelect","showHiddenFields","payload","collections","hooks","beforeOperation","length","hook","context","global","operation","accessResult","access","read","t","fields","flattenedFields","forceSelect","dbSelect","versions","drafts","createdAt","updatedAt","docFromDB","db","findGlobal","where","undefined","hasDoc","Object","keys","data","doc","lockStatus","lockDocumentsProp","lockDocuments","lockDurationDefault","lockDuration","duration","lockDurationInMilliseconds","lockedDocument","find","collection","limit","pagination","and","globalSlug","equals","greater_than","Date","getTime","docs","_isLocked","_userEditing","user","value","entity","entityType","beforeRead","globalType","selectMode","error"],"mappings":"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"}},
    {"offset": {"line": 7227, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/globals/operations/local/findOne.ts"],"sourcesContent":["import type { FindOptions } from '../../../collections/operations/local/find.js'\nimport type {\n  GlobalSlug,\n  Payload,\n  RequestContext,\n  TypedFallbackLocale,\n  TypedLocale,\n} from '../../../index.js'\nimport type {\n  Document,\n  PayloadRequest,\n  PopulateType,\n  SelectType,\n  TransformGlobalWithSelect,\n} from '../../../types/index.js'\nimport type { CreateLocalReqOptions } from '../../../utilities/createLocalReq.js'\nimport type {\n  DraftFlagFromGlobalSlug,\n  SelectFromGlobalSlug,\n} from '../../config/types.js'\n\nimport { APIError } from '../../../errors/index.js'\nimport { createLocalReq } from '../../../utilities/createLocalReq.js'\nimport { findOneOperation, type GlobalFindOneArgs } from '../findOne.js'\n\ntype BaseFindOneOptions<TSlug extends GlobalSlug, TSelect extends SelectType> = {\n  /**\n   * [Context](https://payloadcms.com/docs/hooks/context), which will then be passed to `context` and `req.context`,\n   * which can be read by hooks. Useful if you want to pass additional information to the hooks which\n   * shouldn't be necessarily part of the document, for example a `triggerBeforeChange` option which can be read by the BeforeChange hook\n   * to determine if it should run or not.\n   */\n  context?: RequestContext\n  /**\n   * You may pass the document data directly which will skip the `db.findOne` database query.\n   * This is useful if you want to use this endpoint solely for running hooks and populating data.\n   */\n  data?: Record<string, unknown>\n  /**\n   * [Control auto-population](https://payloadcms.com/docs/queries/depth) of nested relationship and upload fields.\n   */\n  depth?: number\n  /**\n   * Specify a [fallback locale](https://payloadcms.com/docs/configuration/localization) to use for any returned documents.\n   */\n  fallbackLocale?: TypedFallbackLocale\n  /**\n   * Include info about the lock status to the result with fields: `_isLocked` and `_userEditing`\n   */\n  includeLockStatus?: boolean\n  /**\n   * Specify [locale](https://payloadcms.com/docs/configuration/localization) for any returned documents.\n   */\n  locale?: 'all' | TypedLocale\n  /**\n   * Skip access control.\n   * Set to `false` if you want to respect Access Control for the operation, for example when fetching data for the front-end.\n   * @default true\n   */\n  overrideAccess?: boolean\n  /**\n   * Specify [populate](https://payloadcms.com/docs/queries/select#populate) to control which fields to include to the result from populated documents.\n   */\n  populate?: PopulateType\n  /**\n   * The `PayloadRequest` object. You can pass it to thread the current [transaction](https://payloadcms.com/docs/database/transactions), user and locale to the operation.\n   * Recommended to pass when using the Local API from hooks, as usually you want to execute the operation within the current transaction.\n   */\n  req?: Partial<PayloadRequest>\n  /**\n   * Opt-in to receiving hidden fields. By default, they are hidden from returned documents in accordance to your config.\n   * @default false\n   */\n  showHiddenFields?: boolean\n  /**\n   * the Global slug to operate against.\n   */\n  slug: TSlug\n  /**\n   * If you set `overrideAccess` to `false`, you can pass a user to use against the access control checks.\n   */\n  user?: Document\n} & Pick<FindOptions<string, SelectType>, 'select'> &\n  Pick<GlobalFindOneArgs, 'flattenLocales'>\n\nexport type Options<TSlug extends GlobalSlug, TSelect extends SelectType> =\n  BaseFindOneOptions<TSlug, TSelect> & DraftFlagFromGlobalSlug<TSlug>\n\nexport async function findOneGlobalLocal<\n  TSlug extends GlobalSlug,\n  TSelect extends SelectFromGlobalSlug<TSlug>,\n>(\n  payload: Payload,\n  options: Options<TSlug, TSelect>,\n): Promise<TransformGlobalWithSelect<TSlug, TSelect>> {\n  const {\n    slug: globalSlug,\n    data,\n    depth,\n    draft = false,\n    flattenLocales,\n    includeLockStatus,\n    overrideAccess = true,\n    populate,\n    select,\n    showHiddenFields,\n  } = options\n\n  const globalConfig = payload.globals.config.find((config) => config.slug === globalSlug)\n\n  if (!globalConfig) {\n    throw new APIError(`The global with slug ${String(globalSlug)} can't be found.`)\n  }\n\n  return findOneOperation({\n    slug: globalSlug as string,\n    data,\n    depth,\n    draft,\n    flattenLocales,\n    globalConfig,\n    includeLockStatus,\n    overrideAccess,\n    populate,\n    req: await createLocalReq(options as CreateLocalReqOptions, payload),\n    select,\n    showHiddenFields,\n  })\n}\n"],"names":["APIError","createLocalReq","findOneOperation","findOneGlobalLocal","payload","options","slug","globalSlug","data","depth","draft","flattenLocales","includeLockStatus","overrideAccess","populate","select","showHiddenFields","globalConfig","globals","config","find","String","req"],"mappings":";;;;AAqBA,SAASA,QAAQ,QAAQ,2BAA0B;AACnD,SAASC,cAAc,QAAQ,uCAAsC;AACrE,SAASC,gBAAgB,QAAgC,gBAAe;;;;AAiEjE,eAAeC,mBAIpBC,OAAgB,EAChBC,OAAgC;IAEhC,MAAM,EACJC,MAAMC,UAAU,EAChBC,IAAI,EACJC,KAAK,EACLC,QAAQ,KAAK,EACbC,cAAc,EACdC,iBAAiB,EACjBC,iBAAiB,IAAI,EACrBC,QAAQ,EACRC,MAAM,EACNC,gBAAgB,EACjB,GAAGX;IAEJ,MAAMY,eAAeb,QAAQc,OAAO,CAACC,MAAM,CAACC,IAAI,CAAC,CAACD,SAAWA,OAAOb,IAAI,KAAKC;IAE7E,IAAI,CAACU,cAAc;QACjB,MAAM,IAAIjB,mKAAAA,CAAS,CAAC,qBAAqB,EAAEqB,OAAOd,YAAY,gBAAgB,CAAC;IACjF;IAEA,WAAOL,yLAAAA,EAAiB;QACtBI,MAAMC;QACNC;QACAC;QACAC;QACAC;QACAM;QACAL;QACAC;QACAC;QACAQ,KAAK,UAAMrB,kLAAAA,EAAeI,SAAkCD;QAC5DW;QACAC;IACF;AACF"}},
    {"offset": {"line": 7262, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/globals/operations/findVersionByID.ts"],"sourcesContent":["import type { FindOptions } from '../../collections/operations/local/find.js'\nimport type { FindGlobalVersionsArgs } from '../../database/types.js'\nimport type { PayloadRequest, PopulateType, SelectType } from '../../types/index.js'\nimport type { TypeWithVersion } from '../../versions/types.js'\nimport type { SanitizedGlobalConfig } from '../config/types.js'\n\nimport { executeAccess } from '../../auth/executeAccess.js'\nimport { combineQueries } from '../../database/combineQueries.js'\nimport { Forbidden, NotFound } from '../../errors/index.js'\nimport { afterRead } from '../../fields/hooks/afterRead/index.js'\nimport { deepCopyObjectSimple } from '../../utilities/deepCopyObject.js'\nimport { killTransaction } from '../../utilities/killTransaction.js'\nimport { sanitizeSelect } from '../../utilities/sanitizeSelect.js'\nimport { buildVersionGlobalFields } from '../../versions/buildGlobalFields.js'\nimport { getQueryDraftsSelect } from '../../versions/drafts/getQueryDraftsSelect.js'\n\nexport type Arguments = {\n  currentDepth?: number\n  depth?: number\n  disableErrors?: boolean\n  globalConfig: SanitizedGlobalConfig\n  id: number | string\n  overrideAccess?: boolean\n  populate?: PopulateType\n  req: PayloadRequest\n  showHiddenFields?: boolean\n} & Pick<FindOptions<string, SelectType>, 'select'>\n\nexport const findVersionByIDOperation = async <T extends TypeWithVersion<T> = any>(\n  args: Arguments,\n): Promise<T> => {\n  const {\n    id,\n    currentDepth,\n    depth,\n    disableErrors,\n    globalConfig,\n    overrideAccess,\n    populate,\n    req: { fallbackLocale, locale, payload },\n    req,\n    select: incomingSelect,\n    showHiddenFields,\n  } = args\n\n  try {\n    // /////////////////////////////////////\n    // Access\n    // /////////////////////////////////////\n\n    const accessResults = !overrideAccess\n      ? await executeAccess({ id, disableErrors, req }, globalConfig.access.readVersions)\n      : true\n\n    // If errors are disabled, and access returns false, return null\n    if (accessResults === false) {\n      return null!\n    }\n\n    const hasWhereAccess = typeof accessResults === 'object'\n\n    const select = sanitizeSelect({\n      fields: buildVersionGlobalFields(payload.config, globalConfig, true),\n      forceSelect: getQueryDraftsSelect({ select: globalConfig.forceSelect }),\n      select: incomingSelect,\n      versions: true,\n    })\n\n    const findGlobalVersionsArgs: FindGlobalVersionsArgs = {\n      global: globalConfig.slug,\n      limit: 1,\n      locale: locale!,\n      req,\n      select,\n      where: combineQueries({ id: { equals: id } }, accessResults),\n    }\n\n    // /////////////////////////////////////\n    // Find by ID\n    // /////////////////////////////////////\n\n    if (!findGlobalVersionsArgs.where?.and?.[0]?.id) {\n      throw new NotFound(req.t)\n    }\n\n    const { docs: results } = await payload.db.findGlobalVersions(findGlobalVersionsArgs)\n    if (!results || results?.length === 0) {\n      if (!disableErrors) {\n        if (!hasWhereAccess) {\n          throw new NotFound(req.t)\n        }\n        if (hasWhereAccess) {\n          throw new Forbidden(req.t)\n        }\n      }\n\n      return null!\n    }\n\n    // Clone the result - it may have come back memoized\n    let result: any = deepCopyObjectSimple(results[0])\n\n    if (!result.version) {\n      result.version = {}\n    }\n\n    // Patch globalType onto version doc\n    result.version.globalType = globalConfig.slug\n\n    // /////////////////////////////////////\n    // beforeRead - Collection\n    // /////////////////////////////////////\n\n    if (globalConfig.hooks?.beforeRead?.length) {\n      for (const hook of globalConfig.hooks.beforeRead) {\n        result =\n          (await hook({\n            context: req.context,\n            doc: result.version,\n            global: globalConfig,\n            overrideAccess,\n            req,\n          })) || result.version\n      }\n    }\n\n    // /////////////////////////////////////\n    // afterRead - Fields\n    // /////////////////////////////////////\n\n    result.version = await afterRead({\n      collection: null,\n      context: req.context,\n      currentDepth,\n      depth: depth!,\n      doc: result.version,\n      draft: undefined!,\n      fallbackLocale: fallbackLocale!,\n      global: globalConfig,\n      locale: locale!,\n      overrideAccess: overrideAccess!,\n      populate,\n      req,\n      select: typeof select?.version === 'object' ? select.version : undefined,\n      showHiddenFields: showHiddenFields!,\n    })\n\n    // /////////////////////////////////////\n    // afterRead - Global\n    // /////////////////////////////////////\n\n    if (globalConfig.hooks?.afterRead?.length) {\n      for (const hook of globalConfig.hooks.afterRead) {\n        result.version =\n          (await hook({\n            context: req.context,\n            doc: result.version,\n            global: globalConfig,\n            overrideAccess,\n            query: findGlobalVersionsArgs.where,\n            req,\n          })) || result.version\n      }\n    }\n\n    return result\n  } catch (error: unknown) {\n    await killTransaction(req)\n    throw error\n  }\n}\n"],"names":["executeAccess","combineQueries","Forbidden","NotFound","afterRead","deepCopyObjectSimple","killTransaction","sanitizeSelect","buildVersionGlobalFields","getQueryDraftsSelect","findVersionByIDOperation","args","id","currentDepth","depth","disableErrors","globalConfig","overrideAccess","populate","req","fallbackLocale","locale","payload","select","incomingSelect","showHiddenFields","accessResults","access","readVersions","hasWhereAccess","fields","config","forceSelect","versions","findGlobalVersionsArgs","global","slug","limit","where","equals","and","t","docs","results","db","findGlobalVersions","length","result","version","globalType","hooks","beforeRead","hook","context","doc","collection","draft","undefined","query","error"],"mappings":"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"}},
    {"offset": {"line": 7404, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/globals/operations/local/findVersionByID.ts"],"sourcesContent":["import type {\n  FindOptions,\n  GlobalSlug,\n  Payload,\n  RequestContext,\n  TypedLocale,\n} from '../../../index.js'\nimport type { Document, PayloadRequest, PopulateType, SelectType } from '../../../types/index.js'\nimport type { CreateLocalReqOptions } from '../../../utilities/createLocalReq.js'\nimport type { TypeWithVersion } from '../../../versions/types.js'\nimport type { DataFromGlobalSlug } from '../../config/types.js'\n\nimport { APIError } from '../../../errors/index.js'\nimport { createLocalReq } from '../../../utilities/createLocalReq.js'\nimport { findVersionByIDOperation } from '../findVersionByID.js'\n\nexport type Options<TSlug extends GlobalSlug> = {\n  /**\n   * [Context](https://payloadcms.com/docs/hooks/context), which will then be passed to `context` and `req.context`,\n   * which can be read by hooks. Useful if you want to pass additional information to the hooks which\n   * shouldn't be necessarily part of the document, for example a `triggerBeforeChange` option which can be read by the BeforeChange hook\n   * to determine if it should run or not.\n   */\n  context?: RequestContext\n  /**\n   * [Control auto-population](https://payloadcms.com/docs/queries/depth) of nested relationship and upload fields.\n   */\n  depth?: number\n  /**\n   * When set to `true`, errors will not be thrown.\n   * `null` will be returned instead, if the document on this ID was not found.\n   */\n  disableErrors?: boolean\n  /**\n   * Specify a [fallback locale](https://payloadcms.com/docs/configuration/localization) to use for any returned documents.\n   */\n  fallbackLocale?: false | TypedLocale\n  /**\n   * The ID of the version to find.\n   */\n  id: number | string\n  /**\n   * Specify [locale](https://payloadcms.com/docs/configuration/localization) for any returned documents.\n   */\n  locale?: 'all' | TypedLocale\n  /**\n   * Skip access control.\n   * Set to `false` if you want to respect Access Control for the operation, for example when fetching data for the front-end.\n   * @default true\n   */\n  overrideAccess?: boolean\n  /**\n   * Specify [populate](https://payloadcms.com/docs/queries/select#populate) to control which fields to include to the result from populated documents.\n   */\n  populate?: PopulateType\n  /**\n   * The `PayloadRequest` object. You can pass it to thread the current [transaction](https://payloadcms.com/docs/database/transactions), user and locale to the operation.\n   * Recommended to pass when using the Local API from hooks, as usually you want to execute the operation within the current transaction.\n   */\n  req?: Partial<PayloadRequest>\n\n  /**\n   * Opt-in to receiving hidden fields. By default, they are hidden from returned documents in accordance to your config.\n   * @default false\n   */\n  showHiddenFields?: boolean\n  /**\n   * the Global slug to operate against.\n   */\n  slug: TSlug\n  /**\n   * If you set `overrideAccess` to `false`, you can pass a user to use against the access control checks.\n   */\n  user?: Document\n} & Pick<FindOptions<string, SelectType>, 'select'>\n\nexport async function findGlobalVersionByIDLocal<TSlug extends GlobalSlug>(\n  payload: Payload,\n  options: Options<TSlug>,\n): Promise<TypeWithVersion<DataFromGlobalSlug<TSlug>>> {\n  const {\n    id,\n    slug: globalSlug,\n    depth,\n    disableErrors = false,\n    overrideAccess = true,\n    populate,\n    select,\n    showHiddenFields,\n  } = options\n\n  const globalConfig = payload.globals.config.find((config) => config.slug === globalSlug)\n\n  if (!globalConfig) {\n    throw new APIError(`The global with slug ${String(globalSlug)} can't be found.`)\n  }\n\n  return findVersionByIDOperation({\n    id,\n    depth,\n    disableErrors,\n    globalConfig,\n    overrideAccess,\n    populate,\n    req: await createLocalReq(options as CreateLocalReqOptions, payload),\n    select,\n    showHiddenFields,\n  })\n}\n"],"names":["APIError","createLocalReq","findVersionByIDOperation","findGlobalVersionByIDLocal","payload","options","id","slug","globalSlug","depth","disableErrors","overrideAccess","populate","select","showHiddenFields","globalConfig","globals","config","find","String","req"],"mappings":";;;;AAYA,SAASA,QAAQ,QAAQ,2BAA0B;AACnD,SAASC,cAAc,QAAQ,uCAAsC;AACrE,SAASC,wBAAwB,QAAQ,wBAAuB;;;;AA8DzD,eAAeC,2BACpBC,OAAgB,EAChBC,OAAuB;IAEvB,MAAM,EACJC,EAAE,EACFC,MAAMC,UAAU,EAChBC,KAAK,EACLC,gBAAgB,KAAK,EACrBC,iBAAiB,IAAI,EACrBC,QAAQ,EACRC,MAAM,EACNC,gBAAgB,EACjB,GAAGT;IAEJ,MAAMU,eAAeX,QAAQY,OAAO,CAACC,MAAM,CAACC,IAAI,CAAC,CAACD,SAAWA,OAAOV,IAAI,KAAKC;IAE7E,IAAI,CAACO,cAAc;QACjB,MAAM,IAAIf,mKAAAA,CAAS,CAAC,qBAAqB,EAAEmB,OAAOX,YAAY,gBAAgB,CAAC;IACjF;IAEA,WAAON,yMAAAA,EAAyB;QAC9BI;QACAG;QACAC;QACAK;QACAJ;QACAC;QACAQ,KAAK,UAAMnB,kLAAAA,EAAeI,SAAkCD;QAC5DS;QACAC;IACF;AACF"}},
    {"offset": {"line": 7436, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/globals/operations/findVersions.ts"],"sourcesContent":["import type { FindOptions } from '../../collections/operations/local/find.js'\nimport type { PaginatedDocs } from '../../database/types.js'\nimport type { PayloadRequest, PopulateType, SelectType, Sort, Where } from '../../types/index.js'\nimport type { TypeWithVersion } from '../../versions/types.js'\nimport type { SanitizedGlobalConfig } from '../config/types.js'\n\nimport { executeAccess } from '../../auth/executeAccess.js'\nimport { combineQueries } from '../../database/combineQueries.js'\nimport { validateQueryPaths } from '../../database/queryValidation/validateQueryPaths.js'\nimport { afterRead } from '../../fields/hooks/afterRead/index.js'\nimport { killTransaction } from '../../utilities/killTransaction.js'\nimport { sanitizeInternalFields } from '../../utilities/sanitizeInternalFields.js'\nimport { sanitizeSelect } from '../../utilities/sanitizeSelect.js'\nimport { buildVersionGlobalFields } from '../../versions/buildGlobalFields.js'\nimport { getQueryDraftsSelect } from '../../versions/drafts/getQueryDraftsSelect.js'\n\nexport type Arguments = {\n  depth?: number\n  globalConfig: SanitizedGlobalConfig\n  limit?: number\n  overrideAccess?: boolean\n  page?: number\n  pagination?: boolean\n  populate?: PopulateType\n  req?: PayloadRequest\n  showHiddenFields?: boolean\n  sort?: Sort\n  where?: Where\n} & Pick<FindOptions<string, SelectType>, 'select'>\n\nexport const findVersionsOperation = async <T extends TypeWithVersion<T>>(\n  args: Arguments,\n): Promise<PaginatedDocs<T>> => {\n  const {\n    depth,\n    globalConfig,\n    limit,\n    overrideAccess,\n    page,\n    pagination = true,\n    populate,\n    select: incomingSelect,\n    showHiddenFields,\n    sort,\n    where,\n  } = args\n  const req = args.req!\n  const { fallbackLocale, locale, payload } = req\n\n  const versionFields = buildVersionGlobalFields(payload.config, globalConfig, true)\n\n  try {\n    // /////////////////////////////////////\n    // Access\n    // /////////////////////////////////////\n\n    const accessResults = !overrideAccess\n      ? await executeAccess({ req }, globalConfig.access.readVersions)\n      : true\n\n    await validateQueryPaths({\n      globalConfig,\n      overrideAccess: overrideAccess!,\n      req,\n      versionFields,\n      where: where!,\n    })\n\n    const fullWhere = combineQueries(where!, accessResults)\n\n    const select = sanitizeSelect({\n      fields: buildVersionGlobalFields(payload.config, globalConfig, true),\n      forceSelect: getQueryDraftsSelect({ select: globalConfig.forceSelect }),\n      select: incomingSelect,\n      versions: true,\n    })\n\n    // /////////////////////////////////////\n    // Find\n    // /////////////////////////////////////\n\n    const usePagination = pagination && limit !== 0\n    const sanitizedLimit = limit ?? (usePagination ? 10 : 0)\n    const sanitizedPage = page || 1\n\n    const paginatedDocs = await payload.db.findGlobalVersions<T>({\n      global: globalConfig.slug,\n      limit: sanitizedLimit,\n      locale: locale!,\n      page: sanitizedPage,\n      pagination,\n      req,\n      select,\n      sort,\n      where: fullWhere,\n    })\n\n    // /////////////////////////////////////\n    // afterRead - Fields\n    // /////////////////////////////////////\n\n    let result = {\n      ...paginatedDocs,\n      docs: await Promise.all(\n        paginatedDocs.docs.map(async (data) => {\n          if (!data.version) {\n            // Fallback if not selected\n            ;(data as any).version = {}\n          }\n          return {\n            ...data,\n            version: await afterRead<T>({\n              collection: null,\n              context: req.context,\n              depth: depth!,\n              doc: {\n                ...data.version,\n                // Patch globalType onto version doc\n                globalType: globalConfig.slug,\n              },\n              draft: undefined!,\n              fallbackLocale: fallbackLocale!,\n              findMany: true,\n              global: globalConfig,\n              locale: locale!,\n              overrideAccess: overrideAccess!,\n              populate,\n              req,\n              select,\n              showHiddenFields: showHiddenFields!,\n            }),\n          }\n        }),\n      ),\n    } as PaginatedDocs<T>\n\n    // /////////////////////////////////////\n    // afterRead - Global\n    // /////////////////////////////////////\n\n    if (globalConfig.hooks?.afterRead?.length) {\n      result.docs = await Promise.all(\n        result.docs.map(async (doc) => {\n          const docRef = doc\n\n          for (const hook of globalConfig.hooks.afterRead) {\n            docRef.version =\n              (await hook({\n                context: req.context,\n                doc: doc.version,\n                findMany: true,\n                global: globalConfig,\n                overrideAccess,\n                query: fullWhere,\n                req,\n              })) || doc.version\n          }\n\n          return docRef\n        }),\n      )\n    }\n\n    // /////////////////////////////////////\n    // Return results\n    // /////////////////////////////////////\n\n    result = {\n      ...result,\n      docs: result.docs.map((doc) => sanitizeInternalFields<T>(doc)),\n    }\n\n    return result\n  } catch (error: unknown) {\n    await killTransaction(req)\n    throw error\n  }\n}\n"],"names":["executeAccess","combineQueries","validateQueryPaths","afterRead","killTransaction","sanitizeInternalFields","sanitizeSelect","buildVersionGlobalFields","getQueryDraftsSelect","findVersionsOperation","args","depth","globalConfig","limit","overrideAccess","page","pagination","populate","select","incomingSelect","showHiddenFields","sort","where","req","fallbackLocale","locale","payload","versionFields","config","accessResults","access","readVersions","fullWhere","fields","forceSelect","versions","usePagination","sanitizedLimit","sanitizedPage","paginatedDocs","db","findGlobalVersions","global","slug","result","docs","Promise","all","map","data","version","collection","context","doc","globalType","draft","undefined","findMany","hooks","length","docRef","hook","query","error"],"mappings":"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"}},
    {"offset": {"line": 7576, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/globals/operations/local/findVersions.ts"],"sourcesContent":["import type { PaginatedDocs } from '../../../database/types.js'\nimport type {\n  FindOptions,\n  GlobalSlug,\n  Payload,\n  RequestContext,\n  TypedLocale,\n} from '../../../index.js'\nimport type {\n  Document,\n  PayloadRequest,\n  PopulateType,\n  SelectType,\n  Sort,\n  Where,\n} from '../../../types/index.js'\nimport type { CreateLocalReqOptions } from '../../../utilities/createLocalReq.js'\nimport type { TypeWithVersion } from '../../../versions/types.js'\nimport type { DataFromGlobalSlug } from '../../config/types.js'\n\nimport { APIError } from '../../../errors/index.js'\nimport { createLocalReq } from '../../../utilities/createLocalReq.js'\nimport { findVersionsOperation } from '../findVersions.js'\n\nexport type Options<TSlug extends GlobalSlug> = {\n  /**\n   * [Context](https://payloadcms.com/docs/hooks/context), which will then be passed to `context` and `req.context`,\n   * which can be read by hooks. Useful if you want to pass additional information to the hooks which\n   * shouldn't be necessarily part of the document, for example a `triggerBeforeChange` option which can be read by the BeforeChange hook\n   * to determine if it should run or not.\n   */\n  context?: RequestContext\n  /**\n   * [Control auto-population](https://payloadcms.com/docs/queries/depth) of nested relationship and upload fields.\n   */\n  depth?: number\n  /**\n   * Specify a [fallback locale](https://payloadcms.com/docs/configuration/localization) to use for any returned documents.\n   */\n  fallbackLocale?: false | TypedLocale\n  /**\n   * The maximum related documents to be returned.\n   * Defaults unless `defaultLimit` is specified for the collection config\n   * @default 10\n   */\n  limit?: number\n  /**\n   * Specify [locale](https://payloadcms.com/docs/configuration/localization) for any returned documents.\n   */\n  locale?: 'all' | TypedLocale\n  /**\n   * Skip access control.\n   * Set to `false` if you want to respect Access Control for the operation, for example when fetching data for the front-end.\n   * @default true\n   */\n  overrideAccess?: boolean\n  /**\n   * Get a specific page number\n   * @default 1\n   */\n  page?: number\n  /**\n   * Set to `false` to return all documents and avoid querying for document counts which introduces some overhead.\n   * You can also combine that property with a specified `limit` to limit documents but avoid the count query.\n   */\n  pagination?: boolean\n  /**\n   * Specify [populate](https://payloadcms.com/docs/queries/select#populate) to control which fields to include to the result from populated documents.\n   */\n  populate?: PopulateType\n  /**\n   * The `PayloadRequest` object. You can pass it to thread the current [transaction](https://payloadcms.com/docs/database/transactions), user and locale to the operation.\n   * Recommended to pass when using the Local API from hooks, as usually you want to execute the operation within the current transaction.\n   */\n  req?: Partial<PayloadRequest>\n  /**\n   * Opt-in to receiving hidden fields. By default, they are hidden from returned documents in accordance to your config.\n   * @default false\n   */\n  showHiddenFields?: boolean\n  /**\n   * the Global slug to operate against.\n   */\n  slug: TSlug\n  /**\n   * Sort the documents, can be a string or an array of strings\n   * @example '-version.createdAt' // Sort DESC by createdAt\n   * @example ['version.group', '-version.createdAt'] // sort by 2 fields, ASC group and DESC createdAt\n   */\n  sort?: Sort\n  /**\n   * If you set `overrideAccess` to `false`, you can pass a user to use against the access control checks.\n   */\n  user?: Document\n  /**\n   * A filter [query](https://payloadcms.com/docs/queries/overview)\n   */\n  where?: Where\n} & Pick<FindOptions<string, SelectType>, 'select'>\n\nexport async function findGlobalVersionsLocal<TSlug extends GlobalSlug>(\n  payload: Payload,\n  options: Options<TSlug>,\n): Promise<PaginatedDocs<TypeWithVersion<DataFromGlobalSlug<TSlug>>>> {\n  const {\n    slug: globalSlug,\n    depth,\n    limit,\n    overrideAccess = true,\n    page,\n    pagination = true,\n    populate,\n    select,\n    showHiddenFields,\n    sort,\n    where,\n  } = options\n\n  const globalConfig = payload.globals.config.find((config) => config.slug === globalSlug)\n\n  if (!globalConfig) {\n    throw new APIError(`The global with slug ${String(globalSlug)} can't be found.`)\n  }\n\n  return findVersionsOperation({\n    depth,\n    globalConfig,\n    limit,\n    overrideAccess,\n    page,\n    pagination,\n    populate,\n    req: await createLocalReq(options as CreateLocalReqOptions, payload),\n    select,\n    showHiddenFields,\n    sort,\n    where,\n  })\n}\n"],"names":["APIError","createLocalReq","findVersionsOperation","findGlobalVersionsLocal","payload","options","slug","globalSlug","depth","limit","overrideAccess","page","pagination","populate","select","showHiddenFields","sort","where","globalConfig","globals","config","find","String","req"],"mappings":";;;;AAoBA,SAASA,QAAQ,QAAQ,2BAA0B;AACnD,SAASC,cAAc,QAAQ,uCAAsC;AACrE,SAASC,qBAAqB,QAAQ,qBAAoB;;;;AA8EnD,eAAeC,wBACpBC,OAAgB,EAChBC,OAAuB;IAEvB,MAAM,EACJC,MAAMC,UAAU,EAChBC,KAAK,EACLC,KAAK,EACLC,iBAAiB,IAAI,EACrBC,IAAI,EACJC,aAAa,IAAI,EACjBC,QAAQ,EACRC,MAAM,EACNC,gBAAgB,EAChBC,IAAI,EACJC,KAAK,EACN,GAAGZ;IAEJ,MAAMa,eAAed,QAAQe,OAAO,CAACC,MAAM,CAACC,IAAI,CAAC,CAACD,SAAWA,OAAOd,IAAI,KAAKC;IAE7E,IAAI,CAACW,cAAc;QACjB,MAAM,IAAIlB,mKAAAA,CAAS,CAAC,qBAAqB,EAAEsB,OAAOf,YAAY,gBAAgB,CAAC;IACjF;IAEA,WAAOL,mMAAAA,EAAsB;QAC3BM;QACAU;QACAT;QACAC;QACAC;QACAC;QACAC;QACAU,KAAK,UAAMtB,kLAAAA,EAAeI,SAAkCD;QAC5DU;QACAC;QACAC;QACAC;IACF;AACF"}},
    {"offset": {"line": 7611, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/globals/operations/restoreVersion.ts"],"sourcesContent":["import type { PayloadRequest, PopulateType } from '../../types/index.js'\nimport type { TypeWithVersion } from '../../versions/types.js'\nimport type { SanitizedGlobalConfig } from '../config/types.js'\n\nimport { executeAccess } from '../../auth/executeAccess.js'\nimport { NotFound } from '../../errors/index.js'\nimport { afterChange } from '../../fields/hooks/afterChange/index.js'\nimport { afterRead } from '../../fields/hooks/afterRead/index.js'\nimport { commitTransaction } from '../../utilities/commitTransaction.js'\nimport { initTransaction } from '../../utilities/initTransaction.js'\nimport { killTransaction } from '../../utilities/killTransaction.js'\n\nexport type Arguments = {\n  depth?: number\n  draft?: boolean\n  globalConfig: SanitizedGlobalConfig\n  id: number | string\n  overrideAccess?: boolean\n  populate?: PopulateType\n  req?: PayloadRequest\n  showHiddenFields?: boolean\n}\n\nexport const restoreVersionOperation = async <T extends TypeWithVersion<T> = any>(\n  args: Arguments,\n): Promise<T> => {\n  const { id, depth, draft, globalConfig, overrideAccess, populate, showHiddenFields } = args\n  const req = args.req!\n  const { fallbackLocale, locale, payload } = req\n\n  try {\n    const shouldCommit = await initTransaction(req)\n\n    // /////////////////////////////////////\n    // beforeOperation - Global\n    // /////////////////////////////////////\n\n    if (globalConfig.hooks?.beforeOperation?.length) {\n      for (const hook of globalConfig.hooks.beforeOperation) {\n        args =\n          (await hook({\n            args,\n            context: req.context,\n            global: globalConfig,\n            operation: 'restoreVersion',\n            overrideAccess,\n            req,\n          })) || args\n      }\n    }\n\n    // /////////////////////////////////////\n    // Access\n    // /////////////////////////////////////\n\n    if (!overrideAccess) {\n      await executeAccess({ req }, globalConfig.access.update)\n    }\n\n    // /////////////////////////////////////\n    // Retrieve original raw version\n    // /////////////////////////////////////\n\n    const { docs: versionDocs } = await payload.db.findGlobalVersions<any>({\n      global: globalConfig.slug,\n      limit: 1,\n      req,\n      where: { id: { equals: id } },\n    })\n\n    if (!versionDocs || versionDocs.length === 0) {\n      throw new NotFound(req.t)\n    }\n\n    const rawVersion = versionDocs[0]!\n\n    // Patch globalType onto version doc\n    rawVersion.version.globalType = globalConfig.slug\n\n    // Overwrite draft status if draft is true\n\n    if (draft) {\n      rawVersion.version._status = 'draft'\n    }\n    // /////////////////////////////////////\n    // fetch previousDoc\n    // /////////////////////////////////////\n\n    const previousDoc = await payload.findGlobal({\n      slug: globalConfig.slug,\n      depth,\n      req,\n    })\n\n    // /////////////////////////////////////\n    // Update global\n    // /////////////////////////////////////\n\n    const global = await payload.db.findGlobal({\n      slug: globalConfig.slug,\n      req,\n    })\n\n    let result = rawVersion.version\n\n    if (global) {\n      // Ensure updatedAt date is always updated\n      result.updatedAt = new Date().toISOString()\n      result = await payload.db.updateGlobal({\n        slug: globalConfig.slug,\n        data: result,\n        req,\n      })\n\n      const now = new Date().toISOString()\n\n      result = await payload.db.createGlobalVersion({\n        autosave: false,\n        createdAt: result.createdAt ? new Date(result.createdAt).toISOString() : now,\n        globalSlug: globalConfig.slug,\n        req,\n        updatedAt: draft ? now : new Date(result.updatedAt).toISOString(),\n        versionData: result,\n      })\n    } else {\n      result = await payload.db.createGlobal({\n        slug: globalConfig.slug,\n        data: result,\n        req,\n      })\n    }\n\n    // /////////////////////////////////////\n    // afterRead - Fields\n    // /////////////////////////////////////\n\n    result = await afterRead({\n      collection: null,\n      context: req.context,\n      depth: depth!,\n      doc: result,\n      draft: undefined!,\n      fallbackLocale: fallbackLocale!,\n      global: globalConfig,\n      locale: locale!,\n      overrideAccess: overrideAccess!,\n      populate,\n      req,\n      showHiddenFields: showHiddenFields!,\n    })\n\n    // /////////////////////////////////////\n    // afterRead - Global\n    // /////////////////////////////////////\n\n    if (globalConfig.hooks?.afterRead?.length) {\n      for (const hook of globalConfig.hooks.afterRead) {\n        result =\n          (await hook({\n            context: req.context,\n            doc: result,\n            global: globalConfig,\n            overrideAccess,\n            req,\n          })) || result\n      }\n    }\n\n    // /////////////////////////////////////\n    // afterChange - Fields\n    // /////////////////////////////////////\n\n    result = await afterChange({\n      collection: null,\n      context: req.context,\n      data: result,\n      doc: result,\n      global: globalConfig,\n      operation: 'update',\n      previousDoc,\n      req,\n    })\n\n    // /////////////////////////////////////\n    // afterChange - Global\n    // /////////////////////////////////////\n\n    if (globalConfig.hooks?.afterChange?.length) {\n      for (const hook of globalConfig.hooks.afterChange) {\n        result =\n          (await hook({\n            context: req.context,\n            data: result,\n            doc: result,\n            global: globalConfig,\n            overrideAccess,\n            previousDoc,\n            req,\n          })) || result\n      }\n    }\n\n    if (shouldCommit) {\n      await commitTransaction(req)\n    }\n\n    return result\n  } catch (error: unknown) {\n    await killTransaction(req)\n    throw error\n  }\n}\n"],"names":["executeAccess","NotFound","afterChange","afterRead","commitTransaction","initTransaction","killTransaction","restoreVersionOperation","args","id","depth","draft","globalConfig","overrideAccess","populate","showHiddenFields","req","fallbackLocale","locale","payload","shouldCommit","hooks","beforeOperation","length","hook","context","global","operation","access","update","docs","versionDocs","db","findGlobalVersions","slug","limit","where","equals","t","rawVersion","version","globalType","_status","previousDoc","findGlobal","result","updatedAt","Date","toISOString","updateGlobal","data","now","createGlobalVersion","autosave","createdAt","globalSlug","versionData","createGlobal","collection","doc","undefined","error"],"mappings":"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"}},
    {"offset": {"line": 7794, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/globals/operations/local/restoreVersion.ts"],"sourcesContent":["import type { GlobalSlug, Payload, RequestContext, TypedLocale } from '../../../index.js'\nimport type { Document, PayloadRequest, PopulateType } from '../../../types/index.js'\nimport type { CreateLocalReqOptions } from '../../../utilities/createLocalReq.js'\nimport type { DataFromGlobalSlug } from '../../config/types.js'\n\nimport { APIError } from '../../../errors/index.js'\nimport { createLocalReq } from '../../../utilities/createLocalReq.js'\nimport { restoreVersionOperation } from '../restoreVersion.js'\n\nexport type Options<TSlug extends GlobalSlug> = {\n  /**\n   * [Context](https://payloadcms.com/docs/hooks/context), which will then be passed to `context` and `req.context`,\n   * which can be read by hooks. Useful if you want to pass additional information to the hooks which\n   * shouldn't be necessarily part of the document, for example a `triggerBeforeChange` option which can be read by the BeforeChange hook\n   * to determine if it should run or not.\n   */\n  context?: RequestContext\n  /**\n   * [Control auto-population](https://payloadcms.com/docs/queries/depth) of nested relationship and upload fields.\n   */\n  depth?: number\n  /**\n   * Specify a [fallback locale](https://payloadcms.com/docs/configuration/localization) to use for any returned documents.\n   */\n  fallbackLocale?: false | TypedLocale\n  /**\n   * The ID of the version to restore.\n   */\n  id: string\n  /**\n   * Specify [locale](https://payloadcms.com/docs/configuration/localization) for any returned documents.\n   */\n  locale?: TypedLocale\n  /**\n   * Skip access control.\n   * Set to `false` if you want to respect Access Control for the operation, for example when fetching data for the front-end.\n   * @default true\n   */\n  overrideAccess?: boolean\n  /**\n   * Specify [populate](https://payloadcms.com/docs/queries/select#populate) to control which fields to include to the result from populated documents.\n   */\n  populate?: PopulateType\n  /**\n   * The `PayloadRequest` object. You can pass it to thread the current [transaction](https://payloadcms.com/docs/database/transactions), user and locale to the operation.\n   * Recommended to pass when using the Local API from hooks, as usually you want to execute the operation within the current transaction.\n   */\n  req?: Partial<PayloadRequest>\n  /**\n   * Opt-in to receiving hidden fields. By default, they are hidden from returned documents in accordance to your config.\n   * @default false\n   */\n  showHiddenFields?: boolean\n  /**\n   * the Global slug to operate against.\n   */\n  slug: TSlug\n  /**\n   * If you set `overrideAccess` to `false`, you can pass a user to use against the access control checks.\n   */\n  user?: Document\n}\n\nexport async function restoreGlobalVersionLocal<TSlug extends GlobalSlug>(\n  payload: Payload,\n  options: Options<TSlug>,\n): Promise<DataFromGlobalSlug<TSlug>> {\n  const { id, slug: globalSlug, depth, overrideAccess = true, populate, showHiddenFields } = options\n\n  const globalConfig = payload.globals.config.find((config) => config.slug === globalSlug)\n\n  if (!globalConfig) {\n    throw new APIError(`The global with slug ${String(globalSlug)} can't be found.`)\n  }\n\n  return restoreVersionOperation({\n    id,\n    depth,\n    globalConfig,\n    overrideAccess,\n    populate,\n    req: await createLocalReq(options as CreateLocalReqOptions, payload),\n    showHiddenFields,\n  })\n}\n"],"names":["APIError","createLocalReq","restoreVersionOperation","restoreGlobalVersionLocal","payload","options","id","slug","globalSlug","depth","overrideAccess","populate","showHiddenFields","globalConfig","globals","config","find","String","req"],"mappings":";;;;AAKA,SAASA,QAAQ,QAAQ,2BAA0B;AACnD,SAASC,cAAc,QAAQ,uCAAsC;AACrE,SAASC,uBAAuB,QAAQ,uBAAsB;;;;AAwDvD,eAAeC,0BACpBC,OAAgB,EAChBC,OAAuB;IAEvB,MAAM,EAAEC,EAAE,EAAEC,MAAMC,UAAU,EAAEC,KAAK,EAAEC,iBAAiB,IAAI,EAAEC,QAAQ,EAAEC,gBAAgB,EAAE,GAAGP;IAE3F,MAAMQ,eAAeT,QAAQU,OAAO,CAACC,MAAM,CAACC,IAAI,CAAC,CAACD,SAAWA,OAAOR,IAAI,KAAKC;IAE7E,IAAI,CAACK,cAAc;QACjB,MAAM,IAAIb,mKAAAA,CAAS,CAAC,qBAAqB,EAAEiB,OAAOT,YAAY,gBAAgB,CAAC;IACjF;IAEA,WAAON,uMAAAA,EAAwB;QAC7BI;QACAG;QACAI;QACAH;QACAC;QACAO,KAAK,UAAMjB,kLAAAA,EAAeI,SAAkCD;QAC5DQ;IACF;AACF"}},
    {"offset": {"line": 7824, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/globals/operations/update.ts"],"sourcesContent":["import type { DeepPartial } from 'ts-essentials'\n\nimport type { FindOptions } from '../../collections/operations/local/find.js'\nimport type { GlobalSlug, JsonObject } from '../../index.js'\nimport type {\n  Operation,\n  PayloadRequest,\n  PopulateType,\n  SelectType,\n  TransformGlobalWithSelect,\n  Where,\n} from '../../types/index.js'\nimport type {\n  DataFromGlobalSlug,\n  SanitizedGlobalConfig,\n  SelectFromGlobalSlug,\n} from '../config/types.js'\n\nimport { executeAccess } from '../../auth/executeAccess.js'\nimport { afterChange } from '../../fields/hooks/afterChange/index.js'\nimport { afterRead } from '../../fields/hooks/afterRead/index.js'\nimport { beforeChange } from '../../fields/hooks/beforeChange/index.js'\nimport { beforeValidate } from '../../fields/hooks/beforeValidate/index.js'\nimport { deepCopyObjectSimple } from '../../index.js'\nimport { checkDocumentLockStatus } from '../../utilities/checkDocumentLockStatus.js'\nimport { commitTransaction } from '../../utilities/commitTransaction.js'\nimport { getSelectMode } from '../../utilities/getSelectMode.js'\nimport {\n  hasDraftsEnabled,\n  hasDraftValidationEnabled,\n  hasLocalizeStatusEnabled,\n} from '../../utilities/getVersionsConfig.js'\nimport { initTransaction } from '../../utilities/initTransaction.js'\nimport { killTransaction } from '../../utilities/killTransaction.js'\nimport { mergeLocalizedData } from '../../utilities/mergeLocalizedData.js'\nimport { sanitizeSelect } from '../../utilities/sanitizeSelect.js'\nimport { getLatestGlobalVersion } from '../../versions/getLatestGlobalVersion.js'\nimport { saveVersion } from '../../versions/saveVersion.js'\ntype Args<TSlug extends GlobalSlug> = {\n  autosave?: boolean\n  data: DeepPartial<Omit<DataFromGlobalSlug<TSlug>, 'id'>>\n  depth?: number\n  disableTransaction?: boolean\n  draft?: boolean\n  globalConfig: SanitizedGlobalConfig\n  overrideAccess?: boolean\n  overrideLock?: boolean\n  populate?: PopulateType\n  publishAllLocales?: boolean\n  publishSpecificLocale?: string\n  req: PayloadRequest\n  showHiddenFields?: boolean\n  slug: string\n  unpublishAllLocales?: boolean\n} & Pick<FindOptions<string, SelectType>, 'select'>\n\nexport const updateOperation = async <\n  TSlug extends GlobalSlug,\n  TSelect extends SelectFromGlobalSlug<TSlug>,\n>(\n  args: Args<TSlug>,\n): Promise<TransformGlobalWithSelect<TSlug, TSelect>> => {\n  if (args.publishSpecificLocale) {\n    args.req.locale = args.publishSpecificLocale\n  }\n\n  const {\n    slug,\n    autosave,\n    depth,\n    disableTransaction,\n    draft: draftArg,\n    globalConfig,\n    overrideAccess,\n    overrideLock,\n    populate,\n    publishAllLocales: publishAllLocalesArg,\n    publishSpecificLocale,\n    req: { fallbackLocale, locale, payload, payload: { config } = {} },\n    req,\n    select: incomingSelect,\n    showHiddenFields,\n    unpublishAllLocales: unpublishAllLocalesArg,\n  } = args\n\n  try {\n    const shouldCommit = !disableTransaction && (await initTransaction(req))\n\n    // /////////////////////////////////////\n    // beforeOperation - Global\n    // /////////////////////////////////////\n\n    if (globalConfig.hooks?.beforeOperation?.length) {\n      for (const hook of globalConfig.hooks.beforeOperation) {\n        args =\n          (await hook({\n            args,\n            context: args.req.context,\n            global: globalConfig,\n            operation: 'update',\n            overrideAccess,\n            req: args.req,\n          })) || args\n      }\n    }\n\n    let { data } = args\n\n    const publishAllLocales =\n      !draftArg && (publishAllLocalesArg ?? (hasLocalizeStatusEnabled(globalConfig) ? false : true))\n    const unpublishAllLocales =\n      typeof unpublishAllLocalesArg === 'string'\n        ? unpublishAllLocalesArg === 'true'\n        : !!unpublishAllLocalesArg\n    const isSavingDraft =\n      Boolean(draftArg && hasDraftsEnabled(globalConfig)) &&\n      data._status !== 'published' &&\n      !publishAllLocales\n\n    if (isSavingDraft) {\n      data._status = 'draft'\n    }\n\n    // /////////////////////////////////////\n    // 1. Retrieve and execute access\n    // /////////////////////////////////////\n\n    const accessResults = !overrideAccess\n      ? await executeAccess(\n          {\n            data,\n            req,\n          },\n          globalConfig.access.update,\n        )\n      : true\n\n    // /////////////////////////////////////\n    // Retrieve document\n    // /////////////////////////////////////\n\n    const query: Where = overrideAccess ? undefined! : (accessResults as Where)\n\n    // /////////////////////////////////////\n    // 2. Retrieve document\n    // /////////////////////////////////////\n    const globalVersionResult = await getLatestGlobalVersion({\n      slug,\n      config: globalConfig,\n      locale: locale!,\n      payload,\n      req,\n      where: query,\n    })\n    const { global, globalExists } = globalVersionResult || {}\n\n    let globalJSON: JsonObject = {}\n\n    if (globalVersionResult && globalVersionResult.global) {\n      globalJSON = deepCopyObjectSimple(global)\n\n      if (globalJSON._id) {\n        delete globalJSON._id\n      }\n    }\n\n    const originalDoc = await afterRead({\n      collection: null,\n      context: req.context,\n      depth: 0,\n      doc: deepCopyObjectSimple(globalJSON),\n      draft: draftArg!,\n      fallbackLocale: fallbackLocale!,\n      global: globalConfig,\n      locale: locale!,\n      overrideAccess: true,\n      req,\n      showHiddenFields: showHiddenFields!,\n    })\n\n    // ///////////////////////////////////////////\n    // Handle potentially locked global documents\n    // ///////////////////////////////////////////\n\n    await checkDocumentLockStatus({\n      globalSlug: slug,\n      lockErrorMessage: `Global with slug \"${slug}\" is currently locked by another user and cannot be updated.`,\n      overrideLock,\n      req,\n    })\n\n    // /////////////////////////////////////\n    // beforeValidate - Fields\n    // /////////////////////////////////////\n\n    data = await beforeValidate({\n      collection: null,\n      context: req.context,\n      data,\n      doc: originalDoc,\n      global: globalConfig,\n      operation: 'update',\n      overrideAccess: overrideAccess!,\n      req,\n    })\n\n    // /////////////////////////////////////\n    // beforeValidate - Global\n    // /////////////////////////////////////\n\n    if (globalConfig.hooks?.beforeValidate?.length) {\n      for (const hook of globalConfig.hooks.beforeValidate) {\n        data =\n          (await hook({\n            context: req.context,\n            data,\n            global: globalConfig,\n            originalDoc,\n            overrideAccess,\n            req,\n          })) || data\n      }\n    }\n\n    // /////////////////////////////////////\n    // beforeChange - Global\n    // /////////////////////////////////////\n\n    if (globalConfig.hooks?.beforeChange?.length) {\n      for (const hook of globalConfig.hooks.beforeChange) {\n        data =\n          (await hook({\n            context: req.context,\n            data,\n            global: globalConfig,\n            originalDoc,\n            overrideAccess,\n            req,\n          })) || data\n      }\n    }\n\n    // /////////////////////////////////////\n    // beforeChange - Fields\n    // /////////////////////////////////////\n\n    const beforeChangeArgs = {\n      collection: null,\n      context: req.context,\n      data,\n      doc: originalDoc,\n      docWithLocales: globalJSON,\n      global: globalConfig,\n      operation: 'update' as Operation,\n      req,\n      skipValidation: isSavingDraft && !hasDraftValidationEnabled(globalConfig),\n    }\n\n    let result: JsonObject = await beforeChange(beforeChangeArgs)\n    let snapshotToSave: JsonObject | undefined\n\n    // /////////////////////////////////////\n    // Handle Localized Data Merging\n    // /////////////////////////////////////\n\n    if (config && config.localization && globalConfig.versions) {\n      let currentGlobal: JsonObject | null = null\n      let snapshotData: JsonObject | undefined\n\n      if (globalConfig.versions.drafts && globalConfig.versions.drafts.localizeStatus) {\n        if (publishAllLocales || unpublishAllLocales) {\n          let accessibleLocaleCodes = config.localization.localeCodes\n\n          if (config.localization.filterAvailableLocales) {\n            const filteredLocales = await config.localization.filterAvailableLocales({\n              locales: config.localization.locales,\n              req,\n            })\n            accessibleLocaleCodes = filteredLocales.map((locale) =>\n              typeof locale === 'string' ? locale : locale.code,\n            )\n          }\n\n          if (typeof result._status !== 'object' || result._status === null) {\n            result._status = {}\n          }\n\n          for (const localeCode of accessibleLocaleCodes) {\n            result._status[localeCode] = unpublishAllLocales ? 'draft' : 'published'\n          }\n        } else if (!isSavingDraft) {\n          // publishing a single locale\n          currentGlobal = await payload.db.findGlobal({\n            slug: globalConfig.slug,\n            req,\n            where: query,\n          })\n          snapshotData = result\n        }\n      } else if (publishSpecificLocale) {\n        // previous way of publishing a single locale\n        currentGlobal = (\n          await getLatestGlobalVersion({\n            slug,\n            config: globalConfig,\n            payload,\n            published: true,\n            req,\n            where: query,\n          })\n        ).global\n        snapshotData = {\n          ...result,\n          _status: 'draft',\n        }\n      }\n\n      if (snapshotData) {\n        snapshotToSave = deepCopyObjectSimple(snapshotData)\n\n        result = mergeLocalizedData({\n          configBlockReferences: config.blocks,\n          dataWithLocales: result || {},\n          docWithLocales: currentGlobal || {},\n          fields: globalConfig.fields,\n          selectedLocales: [locale!],\n        })\n      }\n    }\n    // /////////////////////////////////////\n    // Update\n    // /////////////////////////////////////\n\n    const select = sanitizeSelect({\n      fields: globalConfig.flattenedFields,\n      forceSelect: globalConfig.forceSelect,\n      select: incomingSelect,\n    })\n\n    if (!isSavingDraft) {\n      const now = new Date().toISOString()\n      // Ensure global has createdAt\n      if (!result.createdAt) {\n        result.createdAt = now\n      }\n\n      // Ensure updatedAt date is always updated\n      result.updatedAt = now\n\n      if (globalExists) {\n        result = await payload.db.updateGlobal({\n          slug,\n          data: result,\n          req,\n          select,\n        })\n      } else {\n        result = await payload.db.createGlobal({\n          slug,\n          data: result,\n          req,\n        })\n      }\n    }\n\n    // /////////////////////////////////////\n    // Create version\n    // /////////////////////////////////////\n    if (globalConfig.versions) {\n      const { globalType } = result\n      result = await saveVersion({\n        autosave,\n        docWithLocales: result,\n        draft: isSavingDraft,\n        global: globalConfig,\n        operation: 'update',\n        payload,\n        publishSpecificLocale,\n        req,\n        select,\n        snapshot: snapshotToSave,\n      })\n\n      result = {\n        ...result,\n        globalType,\n      }\n    }\n\n    // /////////////////////////////////////\n    // Execute globalType field if not selected\n    // /////////////////////////////////////\n    if (select && result.globalType) {\n      const selectMode = getSelectMode(select)\n      if (\n        (selectMode === 'include' && !select['globalType']) ||\n        (selectMode === 'exclude' && select['globalType'] === false)\n      ) {\n        delete result['globalType']\n      }\n    }\n\n    // /////////////////////////////////////\n    // afterRead - Fields\n    // /////////////////////////////////////\n\n    result = await afterRead({\n      collection: null,\n      context: req.context,\n      depth: depth!,\n      doc: result,\n      draft: draftArg!,\n      fallbackLocale: null,\n      global: globalConfig,\n      locale: locale!,\n      overrideAccess: overrideAccess!,\n      populate,\n      req,\n      select,\n      showHiddenFields: showHiddenFields!,\n    })\n\n    // /////////////////////////////////////\n    // afterRead - Global\n    // /////////////////////////////////////\n\n    if (globalConfig.hooks?.afterRead?.length) {\n      for (const hook of globalConfig.hooks.afterRead) {\n        result =\n          (await hook({\n            context: req.context,\n            doc: result,\n            global: globalConfig,\n            overrideAccess,\n            req,\n          })) || result\n      }\n    }\n\n    // /////////////////////////////////////\n    // afterChange - Fields\n    // /////////////////////////////////////\n\n    result = await afterChange({\n      collection: null,\n      context: req.context,\n      data,\n      doc: result,\n      global: globalConfig,\n      operation: 'update',\n      previousDoc: originalDoc,\n      req,\n    })\n\n    // /////////////////////////////////////\n    // afterChange - Global\n    // /////////////////////////////////////\n\n    if (globalConfig.hooks?.afterChange?.length) {\n      for (const hook of globalConfig.hooks.afterChange) {\n        result =\n          (await hook({\n            context: req.context,\n            data,\n            doc: result,\n            global: globalConfig,\n            overrideAccess,\n            previousDoc: originalDoc,\n            req,\n          })) || result\n      }\n    }\n\n    // /////////////////////////////////////\n    // Return results\n    // /////////////////////////////////////\n\n    if (shouldCommit) {\n      await commitTransaction(req)\n    }\n\n    return result as TransformGlobalWithSelect<TSlug, TSelect>\n  } catch (error: unknown) {\n    await killTransaction(req)\n    throw error\n  }\n}\n"],"names":["executeAccess","afterChange","afterRead","beforeChange","beforeValidate","deepCopyObjectSimple","checkDocumentLockStatus","commitTransaction","getSelectMode","hasDraftsEnabled","hasDraftValidationEnabled","hasLocalizeStatusEnabled","initTransaction","killTransaction","mergeLocalizedData","sanitizeSelect","getLatestGlobalVersion","saveVersion","updateOperation","args","publishSpecificLocale","req","locale","slug","autosave","depth","disableTransaction","draft","draftArg","globalConfig","overrideAccess","overrideLock","populate","publishAllLocales","publishAllLocalesArg","fallbackLocale","payload","config","select","incomingSelect","showHiddenFields","unpublishAllLocales","unpublishAllLocalesArg","shouldCommit","hooks","beforeOperation","length","hook","context","global","operation","data","isSavingDraft","Boolean","_status","accessResults","access","update","query","undefined","globalVersionResult","where","globalExists","globalJSON","_id","originalDoc","collection","doc","globalSlug","lockErrorMessage","beforeChangeArgs","docWithLocales","skipValidation","result","snapshotToSave","localization","versions","currentGlobal","snapshotData","drafts","localizeStatus","accessibleLocaleCodes","localeCodes","filterAvailableLocales","filteredLocales","locales","map","code","localeCode","db","findGlobal","published","configBlockReferences","blocks","dataWithLocales","fields","selectedLocales","flattenedFields","forceSelect","now","Date","toISOString","createdAt","updatedAt","updateGlobal","createGlobal","globalType","snapshot","selectMode","previousDoc","error"],"mappings":"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"}},
    {"offset": {"line": 8198, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/globals/operations/local/update.ts"],"sourcesContent":["import type { DeepPartial } from 'ts-essentials'\n\nimport type {\n  Document,\n  PayloadRequest,\n  PopulateType,\n  SelectType,\n  TransformGlobalWithSelect,\n} from '../../../types/index.js'\nimport type { CreateLocalReqOptions } from '../../../utilities/createLocalReq.js'\nimport type {\n  DataFromGlobalSlug,\n  DraftFlagFromGlobalSlug,\n  SelectFromGlobalSlug,\n} from '../../config/types.js'\n\nimport { APIError } from '../../../errors/index.js'\nimport {\n  deepCopyObjectSimple,\n  type FindOptions,\n  type GlobalSlug,\n  type Payload,\n  type RequestContext,\n  type TypedLocale,\n} from '../../../index.js'\nimport { createLocalReq } from '../../../utilities/createLocalReq.js'\nimport { updateOperation } from '../update.js'\n\ntype BaseOptions<TSlug extends GlobalSlug, TSelect extends SelectType> = {\n  /**\n   * [Context](https://payloadcms.com/docs/hooks/context), which will then be passed to `context` and `req.context`,\n   * which can be read by hooks. Useful if you want to pass additional information to the hooks which\n   * shouldn't be necessarily part of the document, for example a `triggerBeforeChange` option which can be read by the BeforeChange hook\n   * to determine if it should run or not.\n   */\n  context?: RequestContext\n  /**\n   * The global data to update.\n   */\n  data: DeepPartial<Omit<DataFromGlobalSlug<TSlug>, 'id'>>\n  /**\n   * [Control auto-population](https://payloadcms.com/docs/queries/depth) of nested relationship and upload fields.\n   */\n  depth?: number\n  /**\n   * Specify a [fallback locale](https://payloadcms.com/docs/configuration/localization) to use for any returned documents.\n   */\n  fallbackLocale?: false | TypedLocale\n  /**\n   * Specify [locale](https://payloadcms.com/docs/configuration/localization) for any returned documents.\n   */\n  locale?: 'all' | TypedLocale\n  /**\n   * Skip access control.\n   * Set to `false` if you want to respect Access Control for the operation, for example when fetching data for the front-end.\n   * @default true\n   */\n  overrideAccess?: boolean\n  /**\n   * If you are uploading a file and would like to replace\n   * the existing file instead of generating a new filename,\n   * you can set the following property to `true`\n   */\n  overrideLock?: boolean\n  /**\n   * Specify [populate](https://payloadcms.com/docs/queries/select#populate) to control which fields to include to the result from populated documents.\n   */\n  populate?: PopulateType\n  /**\n   * Publish the document / documents in all locales. Requires `versions.drafts.localizeStatus` to be enabled.\n   *\n   * @default undefined\n   */\n  publishAllLocales?: boolean\n  /**\n   * Publish the document / documents with a specific locale.\n   */\n  publishSpecificLocale?: TypedLocale\n  /**\n   * The `PayloadRequest` object. You can pass it to thread the current [transaction](https://payloadcms.com/docs/database/transactions), user and locale to the operation.\n   * Recommended to pass when using the Local API from hooks, as usually you want to execute the operation within the current transaction.\n   */\n  req?: Partial<PayloadRequest>\n  /**\n   * Opt-in to receiving hidden fields. By default, they are hidden from returned documents in accordance to your config.\n   * @default false\n   */\n  showHiddenFields?: boolean\n  /**\n   * the Global slug to operate against.\n   */\n  slug: TSlug\n  /**\n   * Unpublish the document / documents in all locales. Requires `versions.drafts.localizeStatus` to be enabled.\n   */\n  unpublishAllLocales?: boolean\n  /**\n   * If you set `overrideAccess` to `false`, you can pass a user to use against the access control checks.\n   */\n  user?: Document\n} & Pick<FindOptions<string, SelectType>, 'select'>\n\nexport type Options<TSlug extends GlobalSlug, TSelect extends SelectType> =\n  BaseOptions<TSlug, TSelect> & DraftFlagFromGlobalSlug<TSlug>\n\nexport async function updateGlobalLocal<\n  TSlug extends GlobalSlug,\n  TSelect extends SelectFromGlobalSlug<TSlug>,\n>(\n  payload: Payload,\n  options: Options<TSlug, TSelect>,\n): Promise<TransformGlobalWithSelect<TSlug, TSelect>> {\n  const {\n    slug: globalSlug,\n    data,\n    depth,\n    draft,\n    overrideAccess = true,\n    overrideLock,\n    populate,\n    publishAllLocales,\n    publishSpecificLocale,\n    select,\n    showHiddenFields,\n    unpublishAllLocales,\n  } = options\n\n  const globalConfig = payload.globals.config.find((config) => config.slug === globalSlug)\n\n  if (!globalConfig) {\n    throw new APIError(`The global with slug ${String(globalSlug)} can't be found.`)\n  }\n\n  return updateOperation<TSlug, TSelect>({\n    slug: globalSlug as string,\n    data: deepCopyObjectSimple(data), // Ensure mutation of data in create operation hooks doesn't affect the original data\n    depth,\n    draft,\n    globalConfig,\n    overrideAccess,\n    overrideLock,\n    populate,\n    publishAllLocales,\n    publishSpecificLocale: publishSpecificLocale!,\n    req: await createLocalReq(options as CreateLocalReqOptions, payload),\n    select,\n    showHiddenFields,\n    unpublishAllLocales,\n  })\n}\n"],"names":["APIError","deepCopyObjectSimple","createLocalReq","updateOperation","updateGlobalLocal","payload","options","slug","globalSlug","data","depth","draft","overrideAccess","overrideLock","populate","publishAllLocales","publishSpecificLocale","select","showHiddenFields","unpublishAllLocales","globalConfig","globals","config","find","String","req"],"mappings":";;;;AAgBA,SAASA,QAAQ,QAAQ,2BAA0B;AACnD,SACEC,oBAAoB,QAMf,oBAAmB;AAC1B,SAASC,cAAc,QAAQ,uCAAsC;AACrE,SAASC,eAAe,QAAQ,eAAc;;;;;AA+EvC,eAAeC,kBAIpBC,OAAgB,EAChBC,OAAgC;IAEhC,MAAM,EACJC,MAAMC,UAAU,EAChBC,IAAI,EACJC,KAAK,EACLC,KAAK,EACLC,iBAAiB,IAAI,EACrBC,YAAY,EACZC,QAAQ,EACRC,iBAAiB,EACjBC,qBAAqB,EACrBC,MAAM,EACNC,gBAAgB,EAChBC,mBAAmB,EACpB,GAAGb;IAEJ,MAAMc,eAAef,QAAQgB,OAAO,CAACC,MAAM,CAACC,IAAI,CAAC,CAACD,SAAWA,OAAOf,IAAI,KAAKC;IAE7E,IAAI,CAACY,cAAc;QACjB,MAAM,IAAIpB,mKAAAA,CAAS,CAAC,qBAAqB,EAAEwB,OAAOhB,YAAY,gBAAgB,CAAC;IACjF;IAEA,WAAOL,uLAAAA,EAAgC;QACrCI,MAAMC;QACNC,UAAMR,wLAAAA,EAAqBQ;QAC3BC;QACAC;QACAS;QACAR;QACAC;QACAC;QACAC;QACAC,uBAAuBA;QACvBS,KAAK,UAAMvB,kLAAAA,EAAeI,SAAkCD;QAC5DY;QACAC;QACAC;IACF;AACF"}},
    {"offset": {"line": 8237, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/bin/generateImportMap/iterateFields.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-unused-expressions */\nimport type { PayloadComponent, SanitizedConfig } from '../../config/types.js'\nimport type { Block, Field, Tab } from '../../fields/config/types.js'\nimport type { AddToImportMap, Imports, InternalImportMap } from './index.js'\n\nfunction hasKey<T, K extends string>(\n  obj: null | T | undefined,\n  key: K,\n): obj is { [P in K]: PayloadComponent | PayloadComponent[] } & T {\n  return obj != null && Object.prototype.hasOwnProperty.call(obj, key)\n}\n\nconst defaultUIFieldComponentKeys: Array<'Cell' | 'Description' | 'Field' | 'Filter'> = [\n  'Cell',\n  'Description',\n  'Field',\n  'Filter',\n]\nexport function genImportMapIterateFields({\n  addToImportMap,\n  baseDir,\n  config,\n  fields,\n  importMap,\n  imports,\n}: {\n  addToImportMap: AddToImportMap\n  baseDir: string\n  config: SanitizedConfig\n  fields: Block[] | Field[] | Tab[]\n  importMap: InternalImportMap\n  imports: Imports\n}) {\n  for (const field of fields) {\n    if ('fields' in field) {\n      genImportMapIterateFields({\n        addToImportMap,\n        baseDir,\n        config,\n        fields: field.fields,\n        importMap,\n        imports,\n      })\n    } else if (field.type === 'blocks') {\n      genImportMapIterateFields({\n        addToImportMap,\n        baseDir,\n        config,\n        fields: field.blocks.filter((block) => typeof block !== 'string'),\n        importMap,\n        imports,\n      })\n    } else if (field.type === 'tabs') {\n      genImportMapIterateFields({\n        addToImportMap,\n        baseDir,\n        config,\n        fields: field.tabs,\n        importMap,\n        imports,\n      })\n    } else if (field.type === 'richText') {\n      if (\n        field?.editor &&\n        typeof field.editor === 'object' &&\n        field.editor.generateImportMap &&\n        typeof field.editor.generateImportMap === 'function'\n      ) {\n        field.editor.generateImportMap({\n          addToImportMap,\n          baseDir,\n          config,\n          importMap,\n          imports,\n        })\n      }\n    } else if (field.type === 'ui') {\n      if (field?.admin?.components) {\n        // Render any extra, untyped components\n        for (const key in field.admin.components) {\n          if (key in defaultUIFieldComponentKeys) {\n            continue\n          }\n          addToImportMap(field.admin.components[key])\n        }\n      }\n    }\n\n    hasKey(field?.admin, 'jsx') && addToImportMap(field.admin.jsx) // For Blocks\n\n    hasKey(field?.admin?.components, 'Label') && addToImportMap(field.admin.components.Label)\n\n    hasKey(field?.admin?.components, 'Block') && addToImportMap(field.admin.components.Block)\n\n    hasKey(field?.admin?.components, 'Cell') && addToImportMap(field?.admin?.components?.Cell)\n\n    hasKey(field?.admin?.components, 'Description') &&\n      addToImportMap(field?.admin?.components?.Description)\n\n    hasKey(field?.admin?.components, 'Field') && addToImportMap(field?.admin?.components?.Field)\n    hasKey(field?.admin?.components, 'Filter') && addToImportMap(field?.admin?.components?.Filter)\n\n    hasKey(field?.admin?.components, 'Error') && addToImportMap(field?.admin?.components?.Error)\n\n    hasKey(field?.admin?.components, 'afterInput') &&\n      addToImportMap(field?.admin?.components?.afterInput)\n\n    hasKey(field?.admin?.components, 'beforeInput') &&\n      addToImportMap(field?.admin?.components?.beforeInput)\n\n    hasKey(field?.admin?.components, 'RowLabel') &&\n      addToImportMap(field?.admin?.components?.RowLabel)\n\n    hasKey(field?.admin?.components, 'Diff') && addToImportMap(field?.admin?.components?.Diff)\n  }\n}\n"],"names":["hasKey","obj","key","Object","prototype","hasOwnProperty","call","defaultUIFieldComponentKeys","genImportMapIterateFields","addToImportMap","baseDir","config","fields","importMap","imports","field","type","blocks","filter","block","tabs","editor","generateImportMap","admin","components","jsx","Label","Block","Cell","Description","Field","Filter","Error","afterInput","beforeInput","RowLabel","Diff"],"mappings":";;;;AAAA,2DAA2D,GAK3D,SAASA,OACPC,GAAyB,EACzBC,GAAM;IAEN,OAAOD,OAAO,QAAQE,OAAOC,SAAS,CAACC,cAAc,CAACC,IAAI,CAACL,KAAKC;AAClE;AAEA,MAAMK,8BAAkF;IACtF;IACA;IACA;IACA;CACD;AACM,SAASC,0BAA0B,EACxCC,cAAc,EACdC,OAAO,EACPC,MAAM,EACNC,MAAM,EACNC,SAAS,EACTC,OAAO,EAQR;IACC,KAAK,MAAMC,SAASH,OAAQ;QAC1B,IAAI,YAAYG,OAAO;YACrBP,0BAA0B;gBACxBC;gBACAC;gBACAC;gBACAC,QAAQG,MAAMH,MAAM;gBACpBC;gBACAC;YACF;QACF,OAAO,IAAIC,MAAMC,IAAI,KAAK,UAAU;YAClCR,0BAA0B;gBACxBC;gBACAC;gBACAC;gBACAC,QAAQG,MAAME,MAAM,CAACC,MAAM,CAAC,CAACC,QAAU,OAAOA,UAAU;gBACxDN;gBACAC;YACF;QACF,OAAO,IAAIC,MAAMC,IAAI,KAAK,QAAQ;YAChCR,0BAA0B;gBACxBC;gBACAC;gBACAC;gBACAC,QAAQG,MAAMK,IAAI;gBAClBP;gBACAC;YACF;QACF,OAAO,IAAIC,MAAMC,IAAI,KAAK,YAAY;YACpC,IACED,OAAOM,UACP,OAAON,MAAMM,MAAM,KAAK,YACxBN,MAAMM,MAAM,CAACC,iBAAiB,IAC9B,OAAOP,MAAMM,MAAM,CAACC,iBAAiB,KAAK,YAC1C;gBACAP,MAAMM,MAAM,CAACC,iBAAiB,CAAC;oBAC7Bb;oBACAC;oBACAC;oBACAE;oBACAC;gBACF;YACF;QACF,OAAO,IAAIC,MAAMC,IAAI,KAAK,MAAM;YAC9B,IAAID,OAAOQ,OAAOC,YAAY;gBAC5B,uCAAuC;gBACvC,IAAK,MAAMtB,OAAOa,MAAMQ,KAAK,CAACC,UAAU,CAAE;oBACxC,IAAItB,OAAOK,6BAA6B;wBACtC;oBACF;oBACAE,eAAeM,MAAMQ,KAAK,CAACC,UAAU,CAACtB,IAAI;gBAC5C;YACF;QACF;QAEAF,OAAOe,OAAOQ,OAAO,UAAUd,eAAeM,MAAMQ,KAAK,CAACE,GAAG,GAAE,aAAa;QAE5EzB,OAAOe,OAAOQ,OAAOC,YAAY,YAAYf,eAAeM,MAAMQ,KAAK,CAACC,UAAU,CAACE,KAAK;QAExF1B,OAAOe,OAAOQ,OAAOC,YAAY,YAAYf,eAAeM,MAAMQ,KAAK,CAACC,UAAU,CAACG,KAAK;QAExF3B,OAAOe,OAAOQ,OAAOC,YAAY,WAAWf,eAAeM,OAAOQ,OAAOC,YAAYI;QAErF5B,OAAOe,OAAOQ,OAAOC,YAAY,kBAC/Bf,eAAeM,OAAOQ,OAAOC,YAAYK;QAE3C7B,OAAOe,OAAOQ,OAAOC,YAAY,YAAYf,eAAeM,OAAOQ,OAAOC,YAAYM;QACtF9B,OAAOe,OAAOQ,OAAOC,YAAY,aAAaf,eAAeM,OAAOQ,OAAOC,YAAYO;QAEvF/B,OAAOe,OAAOQ,OAAOC,YAAY,YAAYf,eAAeM,OAAOQ,OAAOC,YAAYQ;QAEtFhC,OAAOe,OAAOQ,OAAOC,YAAY,iBAC/Bf,eAAeM,OAAOQ,OAAOC,YAAYS;QAE3CjC,OAAOe,OAAOQ,OAAOC,YAAY,kBAC/Bf,eAAeM,OAAOQ,OAAOC,YAAYU;QAE3ClC,OAAOe,OAAOQ,OAAOC,YAAY,eAC/Bf,eAAeM,OAAOQ,OAAOC,YAAYW;QAE3CnC,OAAOe,OAAOQ,OAAOC,YAAY,WAAWf,eAAeM,OAAOQ,OAAOC,YAAYY;IACvF;AACF"}},
    {"offset": {"line": 8318, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/bin/generateImportMap/iterateCollections.ts"],"sourcesContent":["import type { SanitizedCollectionConfig } from '../../collections/config/types.js'\nimport type { SanitizedConfig } from '../../config/types.js'\nimport type { AddToImportMap, Imports, InternalImportMap } from './index.js'\n\nimport { genImportMapIterateFields } from './iterateFields.js'\n\nexport function iterateCollections({\n  addToImportMap,\n  baseDir,\n  collections,\n  config,\n  importMap,\n  imports,\n}: {\n  addToImportMap: AddToImportMap\n  baseDir: string\n  collections: SanitizedCollectionConfig[]\n  config: SanitizedConfig\n  importMap: InternalImportMap\n  imports: Imports\n}) {\n  for (const collection of collections) {\n    genImportMapIterateFields({\n      addToImportMap,\n      baseDir,\n      config,\n      fields: collection.fields,\n      importMap,\n      imports,\n    })\n\n    addToImportMap(collection.admin?.components?.afterList)\n    addToImportMap(collection.admin?.components?.listMenuItems)\n    addToImportMap(collection.admin?.components?.afterListTable)\n    addToImportMap(collection.admin?.components?.beforeList)\n    addToImportMap(collection.admin?.components?.beforeListTable)\n    addToImportMap(collection.admin?.components?.Description)\n\n    addToImportMap(collection.admin?.components?.edit?.beforeDocumentControls)\n    addToImportMap(collection.admin?.components?.edit?.editMenuItems)\n    addToImportMap(collection.admin?.components?.edit?.PreviewButton)\n    addToImportMap(collection.admin?.components?.edit?.PublishButton)\n    addToImportMap(collection.admin?.components?.edit?.SaveButton)\n    addToImportMap(collection.admin?.components?.edit?.SaveDraftButton)\n    addToImportMap(collection.admin?.components?.edit?.Status)\n    addToImportMap(collection.admin?.components?.edit?.UnpublishButton)\n    addToImportMap(collection.admin?.components?.edit?.Upload)\n\n    if (collection.upload?.admin?.components?.controls) {\n      addToImportMap(collection.upload?.admin?.components?.controls)\n    }\n\n    if (collection.admin?.components?.views?.edit) {\n      for (const editViewConfig of Object.values(collection.admin?.components?.views?.edit)) {\n        if ('Component' in editViewConfig) {\n          addToImportMap(editViewConfig?.Component)\n        }\n\n        if ('actions' in editViewConfig) {\n          addToImportMap(editViewConfig?.actions)\n        }\n\n        if ('tab' in editViewConfig) {\n          addToImportMap(editViewConfig?.tab?.Component)\n          addToImportMap(editViewConfig?.tab?.Pill)\n        }\n      }\n    }\n\n    addToImportMap(collection.admin?.components?.views?.list?.Component)\n    addToImportMap(collection.admin?.components?.views?.list?.actions)\n  }\n}\n"],"names":["genImportMapIterateFields","iterateCollections","addToImportMap","baseDir","collections","config","importMap","imports","collection","fields","admin","components","afterList","listMenuItems","afterListTable","beforeList","beforeListTable","Description","edit","beforeDocumentControls","editMenuItems","PreviewButton","PublishButton","SaveButton","SaveDraftButton","Status","UnpublishButton","Upload","upload","controls","views","editViewConfig","Object","values","Component","actions","tab","Pill","list"],"mappings":";;;;AAIA,SAASA,yBAAyB,QAAQ,qBAAoB;;AAEvD,SAASC,mBAAmB,EACjCC,cAAc,EACdC,OAAO,EACPC,WAAW,EACXC,MAAM,EACNC,SAAS,EACTC,OAAO,EAQR;IACC,KAAK,MAAMC,cAAcJ,YAAa;YACpCJ,2MAAAA,EAA0B;YACxBE;YACAC;YACAE;YACAI,QAAQD,WAAWC,MAAM;YACzBH;YACAC;QACF;QAEAL,eAAeM,WAAWE,KAAK,EAAEC,YAAYC;QAC7CV,eAAeM,WAAWE,KAAK,EAAEC,YAAYE;QAC7CX,eAAeM,WAAWE,KAAK,EAAEC,YAAYG;QAC7CZ,eAAeM,WAAWE,KAAK,EAAEC,YAAYI;QAC7Cb,eAAeM,WAAWE,KAAK,EAAEC,YAAYK;QAC7Cd,eAAeM,WAAWE,KAAK,EAAEC,YAAYM;QAE7Cf,eAAeM,WAAWE,KAAK,EAAEC,YAAYO,MAAMC;QACnDjB,eAAeM,WAAWE,KAAK,EAAEC,YAAYO,MAAME;QACnDlB,eAAeM,WAAWE,KAAK,EAAEC,YAAYO,MAAMG;QACnDnB,eAAeM,WAAWE,KAAK,EAAEC,YAAYO,MAAMI;QACnDpB,eAAeM,WAAWE,KAAK,EAAEC,YAAYO,MAAMK;QACnDrB,eAAeM,WAAWE,KAAK,EAAEC,YAAYO,MAAMM;QACnDtB,eAAeM,WAAWE,KAAK,EAAEC,YAAYO,MAAMO;QACnDvB,eAAeM,WAAWE,KAAK,EAAEC,YAAYO,MAAMQ;QACnDxB,eAAeM,WAAWE,KAAK,EAAEC,YAAYO,MAAMS;QAEnD,IAAInB,WAAWoB,MAAM,EAAElB,OAAOC,YAAYkB,UAAU;YAClD3B,eAAeM,WAAWoB,MAAM,EAAElB,OAAOC,YAAYkB;QACvD;QAEA,IAAIrB,WAAWE,KAAK,EAAEC,YAAYmB,OAAOZ,MAAM;YAC7C,KAAK,MAAMa,kBAAkBC,OAAOC,MAAM,CAACzB,WAAWE,KAAK,EAAEC,YAAYmB,OAAOZ,MAAO;gBACrF,IAAI,eAAea,gBAAgB;oBACjC7B,eAAe6B,gBAAgBG;gBACjC;gBAEA,IAAI,aAAaH,gBAAgB;oBAC/B7B,eAAe6B,gBAAgBI;gBACjC;gBAEA,IAAI,SAASJ,gBAAgB;oBAC3B7B,eAAe6B,gBAAgBK,KAAKF;oBACpChC,eAAe6B,gBAAgBK,KAAKC;gBACtC;YACF;QACF;QAEAnC,eAAeM,WAAWE,KAAK,EAAEC,YAAYmB,OAAOQ,MAAMJ;QAC1DhC,eAAeM,WAAWE,KAAK,EAAEC,YAAYmB,OAAOQ,MAAMH;IAC5D;AACF"}},
    {"offset": {"line": 8374, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/bin/generateImportMap/iterateGlobals.ts"],"sourcesContent":["import type { SanitizedConfig } from '../../config/types.js'\nimport type { SanitizedGlobalConfig } from '../../globals/config/types.js'\nimport type { AddToImportMap, Imports, InternalImportMap } from './index.js'\n\nimport { genImportMapIterateFields } from './iterateFields.js'\n\nexport function iterateGlobals({\n  addToImportMap,\n  baseDir,\n  config,\n  globals,\n  importMap,\n  imports,\n}: {\n  addToImportMap: AddToImportMap\n  baseDir: string\n  config: SanitizedConfig\n  globals: SanitizedGlobalConfig[]\n  importMap: InternalImportMap\n  imports: Imports\n}) {\n  for (const global of globals) {\n    genImportMapIterateFields({\n      addToImportMap,\n      baseDir,\n      config,\n      fields: global.fields,\n      importMap,\n      imports,\n    })\n\n    addToImportMap(global.admin?.components?.elements?.beforeDocumentControls)\n    addToImportMap(global.admin?.components?.elements?.Description)\n    addToImportMap(global.admin?.components?.elements?.PreviewButton)\n    addToImportMap(global.admin?.components?.elements?.PublishButton)\n    addToImportMap(global.admin?.components?.elements?.SaveButton)\n    addToImportMap(global.admin?.components?.elements?.SaveDraftButton)\n    addToImportMap(global.admin?.components?.elements?.Status)\n    addToImportMap(global.admin?.components?.elements?.UnpublishButton)\n\n    if (global.admin?.components?.views?.edit) {\n      for (const editViewConfig of Object.values(global.admin?.components?.views?.edit)) {\n        if ('Component' in editViewConfig) {\n          addToImportMap(editViewConfig?.Component)\n        }\n\n        if ('actions' in editViewConfig) {\n          addToImportMap(editViewConfig?.actions)\n        }\n\n        if ('tab' in editViewConfig) {\n          addToImportMap(editViewConfig?.tab?.Component)\n          addToImportMap(editViewConfig?.tab?.Pill)\n        }\n      }\n    }\n  }\n}\n"],"names":["genImportMapIterateFields","iterateGlobals","addToImportMap","baseDir","config","globals","importMap","imports","global","fields","admin","components","elements","beforeDocumentControls","Description","PreviewButton","PublishButton","SaveButton","SaveDraftButton","Status","UnpublishButton","views","edit","editViewConfig","Object","values","Component","actions","tab","Pill"],"mappings":";;;;AAIA,SAASA,yBAAyB,QAAQ,qBAAoB;;AAEvD,SAASC,eAAe,EAC7BC,cAAc,EACdC,OAAO,EACPC,MAAM,EACNC,OAAO,EACPC,SAAS,EACTC,OAAO,EAQR;IACC,KAAK,MAAMC,UAAUH,QAAS;YAC5BL,2MAAAA,EAA0B;YACxBE;YACAC;YACAC;YACAK,QAAQD,OAAOC,MAAM;YACrBH;YACAC;QACF;QAEAL,eAAeM,OAAOE,KAAK,EAAEC,YAAYC,UAAUC;QACnDX,eAAeM,OAAOE,KAAK,EAAEC,YAAYC,UAAUE;QACnDZ,eAAeM,OAAOE,KAAK,EAAEC,YAAYC,UAAUG;QACnDb,eAAeM,OAAOE,KAAK,EAAEC,YAAYC,UAAUI;QACnDd,eAAeM,OAAOE,KAAK,EAAEC,YAAYC,UAAUK;QACnDf,eAAeM,OAAOE,KAAK,EAAEC,YAAYC,UAAUM;QACnDhB,eAAeM,OAAOE,KAAK,EAAEC,YAAYC,UAAUO;QACnDjB,eAAeM,OAAOE,KAAK,EAAEC,YAAYC,UAAUQ;QAEnD,IAAIZ,OAAOE,KAAK,EAAEC,YAAYU,OAAOC,MAAM;YACzC,KAAK,MAAMC,kBAAkBC,OAAOC,MAAM,CAACjB,OAAOE,KAAK,EAAEC,YAAYU,OAAOC,MAAO;gBACjF,IAAI,eAAeC,gBAAgB;oBACjCrB,eAAeqB,gBAAgBG;gBACjC;gBAEA,IAAI,aAAaH,gBAAgB;oBAC/BrB,eAAeqB,gBAAgBI;gBACjC;gBAEA,IAAI,SAASJ,gBAAgB;oBAC3BrB,eAAeqB,gBAAgBK,KAAKF;oBACpCxB,eAAeqB,gBAAgBK,KAAKC;gBACtC;YACF;QACF;IACF;AACF"}},
    {"offset": {"line": 8418, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/bin/generateImportMap/iterateConfig.ts"],"sourcesContent":["import type { SanitizedConfig } from '../../config/types.js'\nimport type { AddToImportMap, Imports, InternalImportMap } from './index.js'\n\nimport { iterateCollections } from './iterateCollections.js'\nimport { genImportMapIterateFields } from './iterateFields.js'\nimport { iterateGlobals } from './iterateGlobals.js'\n\nexport function iterateConfig({\n  addToImportMap,\n  baseDir,\n  config,\n  importMap,\n  imports,\n}: {\n  addToImportMap: AddToImportMap\n  baseDir: string\n  config: SanitizedConfig\n  importMap: InternalImportMap\n  imports: Imports\n}) {\n  iterateCollections({\n    addToImportMap,\n    baseDir,\n    collections: config.collections,\n    config,\n    importMap,\n    imports,\n  })\n\n  iterateGlobals({\n    addToImportMap,\n    baseDir,\n    config,\n    globals: config.globals,\n    importMap,\n    imports,\n  })\n\n  if (config?.blocks) {\n    const blocks = Object.values(config.blocks)\n    if (blocks?.length) {\n      genImportMapIterateFields({\n        addToImportMap,\n        baseDir,\n        config,\n        fields: blocks,\n        importMap,\n        imports,\n      })\n    }\n  }\n\n  if (typeof config.admin?.avatar === 'object') {\n    addToImportMap(config.admin?.avatar?.Component)\n  }\n\n  addToImportMap(config.admin?.components?.Nav)\n  addToImportMap(config.admin?.components?.header)\n  addToImportMap(config.admin?.components?.logout?.Button)\n  addToImportMap(config.admin?.components?.settingsMenu)\n  addToImportMap(config.admin?.components?.graphics?.Icon)\n  addToImportMap(config.admin?.components?.graphics?.Logo)\n\n  addToImportMap(config.admin?.components?.actions)\n  addToImportMap(config.admin?.components?.afterDashboard)\n  addToImportMap(config.admin?.components?.afterLogin)\n  addToImportMap(config.admin?.components?.afterNavLinks)\n  addToImportMap(config.admin?.components?.beforeDashboard)\n  addToImportMap(config.admin?.components?.beforeLogin)\n  addToImportMap(config.admin?.components?.beforeNavLinks)\n\n  addToImportMap(config.admin?.components?.providers)\n\n  if (config.admin?.components?.views) {\n    if (Object.keys(config.admin?.components?.views)?.length) {\n      for (const key in config.admin?.components?.views) {\n        const adminViewConfig = config.admin?.components?.views[key]\n        addToImportMap(adminViewConfig?.Component)\n      }\n    }\n  }\n\n  if (config.admin?.dashboard?.widgets?.length) {\n    for (const dashboardWidget of config.admin.dashboard.widgets) {\n      addToImportMap(dashboardWidget.ComponentPath)\n    }\n  }\n\n  if (config?.admin?.importMap?.generators?.length) {\n    for (const generator of config.admin.importMap.generators) {\n      generator({\n        addToImportMap,\n        baseDir,\n        config,\n        importMap,\n        imports,\n      })\n    }\n  }\n\n  if (config?.admin?.dependencies) {\n    for (const dependency of Object.values(config.admin.dependencies)) {\n      addToImportMap(dependency.path)\n    }\n  }\n\n  /*\n  if (\n    config?.editor &&\n    typeof config.editor === 'object' &&\n    config.editor.generateImportMap &&\n    typeof config.editor.generateImportMap === 'function'\n  ) {\n    config.editor.generateImportMap({\n      addToImportMap,\n      baseDir,\n      componentMap,\n      config,\n      importMap,\n    })\n  }*/ // No need to do that here since in the sanitized editor config, this root editor is already added to the field editor - and we already process that in iterateFields\n}\n"],"names":["iterateCollections","genImportMapIterateFields","iterateGlobals","iterateConfig","addToImportMap","baseDir","config","importMap","imports","collections","globals","blocks","Object","values","length","fields","admin","avatar","Component","components","Nav","header","logout","Button","settingsMenu","graphics","Icon","Logo","actions","afterDashboard","afterLogin","afterNavLinks","beforeDashboard","beforeLogin","beforeNavLinks","providers","views","keys","key","adminViewConfig","dashboard","widgets","dashboardWidget","ComponentPath","generators","generator","dependencies","dependency","path"],"mappings":";;;;AAGA,SAASA,kBAAkB,QAAQ,0BAAyB;AAC5D,SAASC,yBAAyB,QAAQ,qBAAoB;AAC9D,SAASC,cAAc,QAAQ,sBAAqB;;;;AAE7C,SAASC,cAAc,EAC5BC,cAAc,EACdC,OAAO,EACPC,MAAM,EACNC,SAAS,EACTC,OAAO,EAOR;QACCR,yMAAAA,EAAmB;QACjBI;QACAC;QACAI,aAAaH,OAAOG,WAAW;QAC/BH;QACAC;QACAC;IACF;QAEAN,iMAAAA,EAAe;QACbE;QACAC;QACAC;QACAI,SAASJ,OAAOI,OAAO;QACvBH;QACAC;IACF;IAEA,IAAIF,QAAQK,QAAQ;QAClB,MAAMA,SAASC,OAAOC,MAAM,CAACP,OAAOK,MAAM;QAC1C,IAAIA,QAAQG,QAAQ;gBAClBb,2MAAAA,EAA0B;gBACxBG;gBACAC;gBACAC;gBACAS,QAAQJ;gBACRJ;gBACAC;YACF;QACF;IACF;IAEA,IAAI,OAAOF,OAAOU,KAAK,EAAEC,WAAW,UAAU;QAC5Cb,eAAeE,OAAOU,KAAK,EAAEC,QAAQC;IACvC;IAEAd,eAAeE,OAAOU,KAAK,EAAEG,YAAYC;IACzChB,eAAeE,OAAOU,KAAK,EAAEG,YAAYE;IACzCjB,eAAeE,OAAOU,KAAK,EAAEG,YAAYG,QAAQC;IACjDnB,eAAeE,OAAOU,KAAK,EAAEG,YAAYK;IACzCpB,eAAeE,OAAOU,KAAK,EAAEG,YAAYM,UAAUC;IACnDtB,eAAeE,OAAOU,KAAK,EAAEG,YAAYM,UAAUE;IAEnDvB,eAAeE,OAAOU,KAAK,EAAEG,YAAYS;IACzCxB,eAAeE,OAAOU,KAAK,EAAEG,YAAYU;IACzCzB,eAAeE,OAAOU,KAAK,EAAEG,YAAYW;IACzC1B,eAAeE,OAAOU,KAAK,EAAEG,YAAYY;IACzC3B,eAAeE,OAAOU,KAAK,EAAEG,YAAYa;IACzC5B,eAAeE,OAAOU,KAAK,EAAEG,YAAYc;IACzC7B,eAAeE,OAAOU,KAAK,EAAEG,YAAYe;IAEzC9B,eAAeE,OAAOU,KAAK,EAAEG,YAAYgB;IAEzC,IAAI7B,OAAOU,KAAK,EAAEG,YAAYiB,OAAO;QACnC,IAAIxB,OAAOyB,IAAI,CAAC/B,OAAOU,KAAK,EAAEG,YAAYiB,QAAQtB,QAAQ;YACxD,IAAK,MAAMwB,OAAOhC,OAAOU,KAAK,EAAEG,YAAYiB,MAAO;gBACjD,MAAMG,kBAAkBjC,OAAOU,KAAK,EAAEG,YAAYiB,KAAK,CAACE,IAAI;gBAC5DlC,eAAemC,iBAAiBrB;YAClC;QACF;IACF;IAEA,IAAIZ,OAAOU,KAAK,EAAEwB,WAAWC,SAAS3B,QAAQ;QAC5C,KAAK,MAAM4B,mBAAmBpC,OAAOU,KAAK,CAACwB,SAAS,CAACC,OAAO,CAAE;YAC5DrC,eAAesC,gBAAgBC,aAAa;QAC9C;IACF;IAEA,IAAIrC,QAAQU,OAAOT,WAAWqC,YAAY9B,QAAQ;QAChD,KAAK,MAAM+B,aAAavC,OAAOU,KAAK,CAACT,SAAS,CAACqC,UAAU,CAAE;YACzDC,UAAU;gBACRzC;gBACAC;gBACAC;gBACAC;gBACAC;YACF;QACF;IACF;IAEA,IAAIF,QAAQU,OAAO8B,cAAc;QAC/B,KAAK,MAAMC,cAAcnC,OAAOC,MAAM,CAACP,OAAOU,KAAK,CAAC8B,YAAY,EAAG;YACjE1C,eAAe2C,WAAWC,IAAI;QAChC;IACF;AAEA;;;;;;;;;;;;;;GAcC,GAAG,qKAAqK;AAC3K"}},
    {"offset": {"line": 8524, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/bin/generateImportMap/utilities/parsePayloadComponent.ts"],"sourcesContent":["import type { PayloadComponent } from '../../../config/types.js'\n\nexport function parsePayloadComponent(PayloadComponent: PayloadComponent): {\n  exportName: string\n  path: string\n} {\n  if (!PayloadComponent) {\n    return null!\n  }\n\n  const pathAndMaybeExport =\n    typeof PayloadComponent === 'string' ? PayloadComponent : PayloadComponent.path\n\n  let path: string\n  let exportName: string\n\n  if (pathAndMaybeExport.includes('#')) {\n    ;[path, exportName] = pathAndMaybeExport.split('#', 2) as [string, string]\n  } else {\n    path = pathAndMaybeExport\n    exportName = 'default'\n  }\n\n  if (typeof PayloadComponent === 'object' && PayloadComponent.exportName) {\n    exportName = PayloadComponent.exportName\n  }\n\n  return { exportName, path }\n}\n"],"names":["parsePayloadComponent","PayloadComponent","pathAndMaybeExport","path","exportName","includes","split"],"mappings":";;;;AAEO,SAASA,sBAAsBC,gBAAkC;IAItE,IAAI,CAACA,kBAAkB;QACrB,OAAO;IACT;IAEA,MAAMC,qBACJ,OAAOD,qBAAqB,WAAWA,mBAAmBA,iBAAiBE,IAAI;IAEjF,IAAIA;IACJ,IAAIC;IAEJ,IAAIF,mBAAmBG,QAAQ,CAAC,MAAM;;QACnC,CAACF,MAAMC,WAAW,GAAGF,mBAAmBI,KAAK,CAAC,KAAK;IACtD,OAAO;QACLH,OAAOD;QACPE,aAAa;IACf;IAEA,IAAI,OAAOH,qBAAqB,YAAYA,iBAAiBG,UAAU,EAAE;QACvEA,aAAaH,iBAAiBG,UAAU;IAC1C;IAEA,OAAO;QAAEA;QAAYD;IAAK;AAC5B"}},
    {"offset": {"line": 8554, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/bin/generateImportMap/utilities/addPayloadComponentToImportMap.ts"],"sourcesContent":["import crypto from 'crypto'\nimport path from 'path'\n\nimport type { PayloadComponent } from '../../../config/types.js'\nimport type { Imports, InternalImportMap } from '../index.js'\n\nimport { parsePayloadComponent } from './parsePayloadComponent.js'\n\n/**\n * Normalizes the component path based on the import map's base directory path.\n */\nfunction getAdjustedComponentPath(importMapToBaseDirPath: string, componentPath: string): string {\n  // Normalize input paths to use forward slashes\n  const normalizedBasePath = importMapToBaseDirPath.replace(/\\\\/g, '/')\n  const normalizedComponentPath = componentPath.replace(/\\\\/g, '/')\n\n  // Base path starts with './' - preserve the './' prefix\n  // => import map is in a subdirectory of the base directory, or in the same directory as the base directory\n  if (normalizedBasePath.startsWith('./')) {\n    // Remove './' from component path if it exists\n    const cleanComponentPath = normalizedComponentPath.startsWith('./')\n      ? normalizedComponentPath.substring(2)\n      : normalizedComponentPath\n\n    // Join the paths to preserve the './' prefix\n    return `${normalizedBasePath}${cleanComponentPath}`\n  }\n\n  return path.posix.join(normalizedBasePath, normalizedComponentPath)\n}\n\n/**\n * Adds a payload component to the import map.\n */\nexport function addPayloadComponentToImportMap({\n  importMap,\n  importMapToBaseDirPath,\n  imports,\n  payloadComponent,\n}: {\n  importMap: InternalImportMap\n  importMapToBaseDirPath: string\n  imports: Imports\n  payloadComponent: PayloadComponent\n}): {\n  path: string\n  specifier: string\n} | null {\n  if (!payloadComponent) {\n    return null\n  }\n  const { exportName, path: componentPath } = parsePayloadComponent(payloadComponent)\n\n  if (importMap[componentPath + '#' + exportName]) {\n    return null\n  }\n\n  const importIdentifier =\n    exportName + '_' + crypto.createHash('md5').update(componentPath).digest('hex')\n\n  importMap[componentPath + '#' + exportName] = importIdentifier\n\n  const isRelativePath = componentPath.startsWith('.') || componentPath.startsWith('/')\n\n  if (isRelativePath) {\n    const adjustedComponentPath = getAdjustedComponentPath(importMapToBaseDirPath, componentPath)\n\n    imports[importIdentifier] = {\n      path: adjustedComponentPath,\n      specifier: exportName,\n    }\n    return {\n      path: adjustedComponentPath,\n      specifier: exportName,\n    }\n  } else {\n    // Tsconfig alias or package import, e.g. '@payloadcms/ui' or '@/components/MyComponent'\n    imports[importIdentifier] = {\n      path: componentPath,\n      specifier: exportName,\n    }\n    return {\n      path: componentPath,\n      specifier: exportName,\n    }\n  }\n}\n"],"names":["crypto","path","parsePayloadComponent","getAdjustedComponentPath","importMapToBaseDirPath","componentPath","normalizedBasePath","replace","normalizedComponentPath","startsWith","cleanComponentPath","substring","posix","join","addPayloadComponentToImportMap","importMap","imports","payloadComponent","exportName","importIdentifier","createHash","update","digest","isRelativePath","adjustedComponentPath","specifier"],"mappings":";;;;AAAA,OAAOA,YAAY,SAAQ;AAC3B,OAAOC,UAAU,OAAM;AAKvB,SAASC,qBAAqB,QAAQ,6BAA4B;;;;AAElE;;CAEC,GACD,SAASC,yBAAyBC,sBAA8B,EAAEC,aAAqB;IACrF,+CAA+C;IAC/C,MAAMC,qBAAqBF,uBAAuBG,OAAO,CAAC,OAAO;IACjE,MAAMC,0BAA0BH,cAAcE,OAAO,CAAC,OAAO;IAE7D,wDAAwD;IACxD,2GAA2G;IAC3G,IAAID,mBAAmBG,UAAU,CAAC,OAAO;QACvC,+CAA+C;QAC/C,MAAMC,qBAAqBF,wBAAwBC,UAAU,CAAC,QAC1DD,wBAAwBG,SAAS,CAAC,KAClCH;QAEJ,6CAA6C;QAC7C,OAAO,GAAGF,qBAAqBI,oBAAoB;IACrD;IAEA,OAAOT,4GAAAA,CAAKW,KAAK,CAACC,IAAI,CAACP,oBAAoBE;AAC7C;AAKO,SAASM,+BAA+B,EAC7CC,SAAS,EACTX,sBAAsB,EACtBY,OAAO,EACPC,gBAAgB,EAMjB;IAIC,IAAI,CAACA,kBAAkB;QACrB,OAAO;IACT;IACA,MAAM,EAAEC,UAAU,EAAEjB,MAAMI,aAAa,EAAE,OAAGH,4NAAAA,EAAsBe;IAElE,IAAIF,SAAS,CAACV,gBAAgB,MAAMa,WAAW,EAAE;QAC/C,OAAO;IACT;IAEA,MAAMC,mBACJD,aAAa,MAAMlB,gHAAAA,CAAOoB,UAAU,CAAC,OAAOC,MAAM,CAAChB,eAAeiB,MAAM,CAAC;IAE3EP,SAAS,CAACV,gBAAgB,MAAMa,WAAW,GAAGC;IAE9C,MAAMI,iBAAiBlB,cAAcI,UAAU,CAAC,QAAQJ,cAAcI,UAAU,CAAC;IAEjF,IAAIc,gBAAgB;QAClB,MAAMC,wBAAwBrB,yBAAyBC,wBAAwBC;QAE/EW,OAAO,CAACG,iBAAiB,GAAG;YAC1BlB,MAAMuB;YACNC,WAAWP;QACb;QACA,OAAO;YACLjB,MAAMuB;YACNC,WAAWP;QACb;IACF,OAAO;QACL,wFAAwF;QACxFF,OAAO,CAACG,iBAAiB,GAAG;YAC1BlB,MAAMI;YACNoB,WAAWP;QACb;QACA,OAAO;YACLjB,MAAMI;YACNoB,WAAWP;QACb;IACF;AACF"}},
    {"offset": {"line": 8617, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/bin/generateImportMap/utilities/getImportMapToBaseDirPath.ts"],"sourcesContent":["import path from 'path'\n\n/**\n * Returns the path that navigates from the import map file to the base directory.\n * This can then be prepended to relative paths in the import map to get the full, absolute path.\n */\nexport function getImportMapToBaseDirPath({\n  baseDir,\n  importMapPath,\n}: {\n  /**\n   * Absolute path to the base directory\n   */\n  baseDir: string\n  /**\n   * Absolute path to the import map file\n   */\n  importMapPath: string\n}): string {\n  const importMapDir = path.dirname(importMapPath)\n\n  // 1. Direct relative path from `importMapDir` -> `baseDir`\n  let relativePath = path.relative(importMapDir, baseDir).replace(/\\\\/g, '/')\n\n  // 2. If they're the same directory, path.relative will be \"\", so use \"./\"\n  if (!relativePath) {\n    relativePath = './'\n  } // Add ./ prefix for subdirectories of the current directory\n  else if (!relativePath.startsWith('.') && !relativePath.startsWith('/')) {\n    relativePath = `./${relativePath}`\n  }\n\n  // 3. For consistency ensure a trailing slash\n  if (!relativePath.endsWith('/')) {\n    relativePath += '/'\n  }\n\n  return relativePath\n}\n"],"names":["path","getImportMapToBaseDirPath","baseDir","importMapPath","importMapDir","dirname","relativePath","relative","replace","startsWith","endsWith"],"mappings":";;;;AAAA,OAAOA,UAAU,OAAM;;AAMhB,SAASC,0BAA0B,EACxCC,OAAO,EACPC,aAAa,EAUd;IACC,MAAMC,eAAeJ,4GAAAA,CAAKK,OAAO,CAACF;IAElC,2DAA2D;IAC3D,IAAIG,eAAeN,4GAAAA,CAAKO,QAAQ,CAACH,cAAcF,SAASM,OAAO,CAAC,OAAO;IAEvE,0EAA0E;IAC1E,IAAI,CAACF,cAAc;QACjBA,eAAe;IACjB,OACK,IAAI,CAACA,aAAaG,UAAU,CAAC,QAAQ,CAACH,aAAaG,UAAU,CAAC,MAAM;QACvEH,eAAe,CAAC,EAAE,EAAEA,cAAc;IACpC;IAEA,6CAA6C;IAC7C,IAAI,CAACA,aAAaI,QAAQ,CAAC,MAAM;QAC/BJ,gBAAgB;IAClB;IAEA,OAAOA;AACT"}},
    {"offset": {"line": 8643, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/bin/generateImportMap/utilities/resolveImportMapFilePath.ts"],"sourcesContent":["import fs from 'fs/promises'\nimport path from 'path'\n\nasync function pathOrFileExists(path: string): Promise<boolean> {\n  try {\n    await fs.access(path)\n    return true\n  } catch {\n    return false\n  }\n}\n\n/**\n * Returns the path to the import map file. If the import map file is not found, it throws an error.\n */\nexport async function resolveImportMapFilePath({\n  adminRoute = '/admin',\n  importMapFile,\n  rootDir,\n}: {\n  adminRoute?: string\n  importMapFile?: string\n  rootDir: string\n}): Promise<Error | string> {\n  let importMapFilePath: string | undefined = undefined\n\n  if (importMapFile?.length) {\n    if (!(await pathOrFileExists(importMapFile))) {\n      try {\n        await fs.writeFile(importMapFile, '', { flag: 'wx' })\n      } catch (err) {\n        return new Error(\n          `Could not find the import map file at ${importMapFile}${err instanceof Error && err?.message ? `: ${err.message}` : ''}`,\n        )\n      }\n    }\n    importMapFilePath = importMapFile\n  } else {\n    const appLocation = path.resolve(rootDir, `app/(payload)${adminRoute}/`)\n    const srcAppLocation = path.resolve(rootDir, `src/app/(payload)${adminRoute}/`)\n\n    if (appLocation && (await pathOrFileExists(appLocation))) {\n      importMapFilePath = path.resolve(appLocation, 'importMap.js')\n      if (!(await pathOrFileExists(importMapFilePath))) {\n        await fs.writeFile(importMapFilePath, '', { flag: 'wx' })\n      }\n    } else if (srcAppLocation && (await pathOrFileExists(srcAppLocation))) {\n      importMapFilePath = path.resolve(srcAppLocation, 'importMap.js')\n      if (!(await pathOrFileExists(importMapFilePath))) {\n        await fs.writeFile(importMapFilePath, '', { flag: 'wx' })\n      }\n    } else {\n      return new Error(\n        `Could not find Payload import map folder. Looked in ${appLocation} and ${srcAppLocation}`,\n      )\n    }\n  }\n  return importMapFilePath\n}\n"],"names":["fs","path","pathOrFileExists","access","resolveImportMapFilePath","adminRoute","importMapFile","rootDir","importMapFilePath","undefined","length","writeFile","flag","err","Error","message","appLocation","resolve","srcAppLocation"],"mappings":";;;;AAAA,OAAOA,QAAQ,cAAa;AAC5B,OAAOC,UAAU,OAAM;;;AAEvB,eAAeC,iBAAiBD,IAAY;IAC1C,IAAI;QACF,MAAMD,gIAAAA,CAAGG,MAAM,CAACF;QAChB,OAAO;IACT,EAAE,OAAM;QACN,OAAO;IACT;AACF;AAKO,eAAeG,yBAAyB,EAC7CC,aAAa,QAAQ,EACrBC,aAAa,EACbC,OAAO,EAKR;IACC,IAAIC,oBAAwCC;IAE5C,IAAIH,eAAeI,QAAQ;QACzB,IAAI,CAAE,MAAMR,iBAAiBI,gBAAiB;YAC5C,IAAI;gBACF,MAAMN,gIAAAA,CAAGW,SAAS,CAACL,eAAe,IAAI;oBAAEM,MAAM;gBAAK;YACrD,EAAE,OAAOC,KAAK;gBACZ,OAAO,IAAIC,MACT,CAAC,sCAAsC,EAAER,gBAAgBO,eAAeC,SAASD,KAAKE,UAAU,CAAC,EAAE,EAAEF,IAAIE,OAAO,EAAE,GAAG,IAAI;YAE7H;QACF;QACAP,oBAAoBF;IACtB,OAAO;QACL,MAAMU,cAAcf,4GAAAA,CAAKgB,OAAO,CAACV,SAAS,CAAC,aAAa,EAAEF,WAAW,CAAC,CAAC;QACvE,MAAMa,iBAAiBjB,4GAAAA,CAAKgB,OAAO,CAACV,SAAS,CAAC,iBAAiB,EAAEF,WAAW,CAAC,CAAC;QAE9E,IAAIW,eAAgB,MAAMd,iBAAiBc,cAAe;YACxDR,oBAAoBP,4GAAAA,CAAKgB,OAAO,CAACD,aAAa;YAC9C,IAAI,CAAE,MAAMd,iBAAiBM,oBAAqB;gBAChD,MAAMR,gIAAAA,CAAGW,SAAS,CAACH,mBAAmB,IAAI;oBAAEI,MAAM;gBAAK;YACzD;QACF,OAAO,IAAIM,kBAAmB,MAAMhB,iBAAiBgB,iBAAkB;YACrEV,oBAAoBP,4GAAAA,CAAKgB,OAAO,CAACC,gBAAgB;YACjD,IAAI,CAAE,MAAMhB,iBAAiBM,oBAAqB;gBAChD,MAAMR,gIAAAA,CAAGW,SAAS,CAACH,mBAAmB,IAAI;oBAAEI,MAAM;gBAAK;YACzD;QACF,OAAO;YACL,OAAO,IAAIE,MACT,CAAC,oDAAoD,EAAEE,YAAY,KAAK,EAAEE,gBAAgB;QAE9F;IACF;IACA,OAAOV;AACT"}},
    {"offset": {"line": 8699, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/bin/generateImportMap/index.ts"],"sourcesContent":["/* eslint-disable no-console */\nimport fs from 'fs/promises'\nimport process from 'node:process'\n\nimport type { PayloadComponent, SanitizedConfig } from '../../config/types.js'\n\nimport { iterateConfig } from './iterateConfig.js'\nimport { addPayloadComponentToImportMap } from './utilities/addPayloadComponentToImportMap.js'\nimport { getImportMapToBaseDirPath } from './utilities/getImportMapToBaseDirPath.js'\nimport { resolveImportMapFilePath } from './utilities/resolveImportMapFilePath.js'\n\ntype ImportIdentifier = string\ntype ImportSpecifier = string\ntype ImportPath = string\ntype UserImportPath = string\n\n/**\n * Import Map before being written to the file. Only contains all paths\n */\nexport type InternalImportMap = {\n  [path: UserImportPath]: ImportIdentifier\n}\n\n/**\n * Imports of the import map.\n */\nexport type Imports = {\n  [identifier: ImportIdentifier]: {\n    path: ImportPath\n    specifier: ImportSpecifier\n  }\n}\n\n/**\n * Import Map after being imported from the actual import map. Contains all the actual imported components\n */\nexport type ImportMap = {\n  [path: UserImportPath]: any\n}\n\nexport type AddToImportMap = (payloadComponent?: PayloadComponent | PayloadComponent[]) => void\n\nexport async function generateImportMap(\n  config: SanitizedConfig,\n  options?: {\n    force?: boolean /**\n     * If true, will not throw an error if the import map file path cannot be resolved\n    Instead, it will return silently.\n     */\n    ignoreResolveError?: boolean\n    log: boolean\n  },\n): Promise<void> {\n  const shouldLog = options?.log ?? true\n\n  if (shouldLog) {\n    console.log('Generating import map')\n  }\n\n  const importMap: InternalImportMap = {}\n  const imports: Imports = {}\n\n  // Determine the root directory of the project - usually the directory where the src or app folder is located\n  const rootDir = process.env.ROOT_DIR ?? process.cwd()\n\n  const baseDir = config.admin.importMap.baseDir ?? process.cwd()\n\n  const importMapFilePath = await resolveImportMapFilePath({\n    adminRoute: config.routes.admin,\n    importMapFile: config?.admin?.importMap?.importMapFile,\n    rootDir,\n  })\n\n  if (importMapFilePath instanceof Error) {\n    if (options?.ignoreResolveError) {\n      return\n    } else {\n      throw importMapFilePath\n    }\n  }\n\n  const importMapToBaseDirPath = getImportMapToBaseDirPath({\n    baseDir,\n    importMapPath: importMapFilePath,\n  })\n\n  const addToImportMap: AddToImportMap = (payloadComponent) => {\n    if (!payloadComponent) {\n      return\n    }\n\n    if (typeof payloadComponent !== 'object' && typeof payloadComponent !== 'string') {\n      console.error(payloadComponent)\n      throw new Error('addToImportMap > Payload component must be an object or a string')\n    }\n\n    if (Array.isArray(payloadComponent)) {\n      for (const component of payloadComponent) {\n        addPayloadComponentToImportMap({\n          importMap,\n          importMapToBaseDirPath,\n          imports,\n          payloadComponent: component,\n        })\n      }\n    } else {\n      addPayloadComponentToImportMap({\n        importMap,\n        importMapToBaseDirPath,\n        imports,\n        payloadComponent,\n      })\n    }\n  }\n\n  iterateConfig({\n    addToImportMap,\n    baseDir: config.admin.importMap.baseDir,\n    config,\n    importMap,\n    imports,\n  })\n\n  await writeImportMap({\n    componentMap: importMap,\n    force: options?.force,\n    importMap: imports,\n    importMapFilePath,\n    log: shouldLog,\n  })\n}\n\nexport async function writeImportMap({\n  componentMap,\n  force,\n  importMap,\n  importMapFilePath,\n  log,\n}: {\n  componentMap: InternalImportMap\n  force?: boolean\n  importMap: Imports\n  importMapFilePath: string\n  log?: boolean\n}) {\n  const imports: string[] = []\n  for (const [identifier, { path, specifier }] of Object.entries(importMap)) {\n    imports.push(`import { ${specifier} as ${identifier} } from '${path}'`)\n  }\n\n  const mapKeys: string[] = []\n  for (const [userPath, identifier] of Object.entries(componentMap)) {\n    mapKeys.push(`  \"${userPath}\": ${identifier}`)\n  }\n\n  const importMapOutputFile = `${imports.join('\\n')}\n\nexport const importMap = {\n${mapKeys.join(',\\n')}\n}\n`\n\n  if (!force) {\n    // Read current import map and check in the IMPORTS if there are any new imports. If not, don't write the file.\n    const currentImportMap = await fs.readFile(importMapFilePath, 'utf-8')\n\n    if (currentImportMap?.trim() === importMapOutputFile?.trim()) {\n      if (log) {\n        console.log('No new imports found, skipping writing import map')\n      }\n      return\n    }\n  }\n\n  if (log) {\n    console.log('Writing import map to', importMapFilePath)\n  }\n\n  await fs.writeFile(importMapFilePath, importMapOutputFile)\n}\n"],"names":["fs","process","iterateConfig","addPayloadComponentToImportMap","getImportMapToBaseDirPath","resolveImportMapFilePath","generateImportMap","config","options","shouldLog","log","console","importMap","imports","rootDir","env","ROOT_DIR","cwd","baseDir","admin","importMapFilePath","adminRoute","routes","importMapFile","Error","ignoreResolveError","importMapToBaseDirPath","importMapPath","addToImportMap","payloadComponent","error","Array","isArray","component","writeImportMap","componentMap","force","identifier","path","specifier","Object","entries","push","mapKeys","userPath","importMapOutputFile","join","currentImportMap","readFile","trim","writeFile"],"mappings":"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"}},
    {"offset": {"line": 8818, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/checkPayloadDependencies.ts"],"sourcesContent":["import { checkDependencies } from './utilities/dependencies/dependencyChecker.js'\nimport { PAYLOAD_PACKAGE_LIST } from './versions/payloadPackageList.js'\n\nexport function checkPayloadDependencies() {\n  const dependencies = [...PAYLOAD_PACKAGE_LIST]\n\n  if (process.env.PAYLOAD_CI_DEPENDENCY_CHECKER !== 'true') {\n    dependencies.push('@payloadcms/plugin-sentry')\n  }\n\n  // First load. First check if there are mismatching dependency versions of payload packages\n  void checkDependencies({\n    dependencyGroups: [\n      {\n        name: 'payload',\n        dependencies,\n        targetVersionDependency: 'payload',\n      },\n    ],\n  })\n}\n"],"names":["checkDependencies","PAYLOAD_PACKAGE_LIST","checkPayloadDependencies","dependencies","process","env","PAYLOAD_CI_DEPENDENCY_CHECKER","push","dependencyGroups","name","targetVersionDependency"],"mappings":";;;;AAAA,SAASA,iBAAiB,QAAQ,gDAA+C;AACjF,SAASC,oBAAoB,QAAQ,mCAAkC;;;AAEhE,SAASC;IACd,MAAMC,eAAe;WAAIF,2LAAAA;KAAqB;IAE9C,IAAIG,QAAQC,GAAG,CAACC,6BAA6B,KAAK,QAAQ;QACxDH,aAAaI,IAAI,CAAC;IACpB;IAEA,2FAA2F;IAC3F,SAAKP,wMAAAA,EAAkB;QACrBQ,kBAAkB;YAChB;gBACEC,MAAM;gBACNN;gBACAO,yBAAyB;YAC3B;SACD;IACH;AACF"}},
    {"offset": {"line": 8848, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/email/defaults.ts"],"sourcesContent":["import type { InitializedEmailAdapter } from './types.js'\n\nexport const emailDefaults: Pick<\n  InitializedEmailAdapter,\n  'defaultFromAddress' | 'defaultFromName'\n> = {\n  defaultFromAddress: 'info@payloadcms.com',\n  defaultFromName: 'Payload',\n}\n"],"names":["emailDefaults","defaultFromAddress","defaultFromName"],"mappings":";;;;AAEO,MAAMA,gBAGT;IACFC,oBAAoB;IACpBC,iBAAiB;AACnB,EAAC"}},
    {"offset": {"line": 8860, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/email/getStringifiedToAddress.ts"],"sourcesContent":["import type { SendEmailOptions } from './types.js'\n\nexport const getStringifiedToAddress = (message: SendEmailOptions): string | undefined => {\n  let stringifiedTo: string | undefined\n\n  if (typeof message.to === 'string') {\n    stringifiedTo = message.to\n  } else if (Array.isArray(message.to)) {\n    stringifiedTo = message.to\n      .map((to) => {\n        if (typeof to === 'string') {\n          return to\n        } else if (to.address) {\n          return to.address\n        }\n        return ''\n      })\n      .join(', ')\n  } else if (message.to?.address) {\n    stringifiedTo = message.to.address\n  }\n  return stringifiedTo\n}\n"],"names":["getStringifiedToAddress","message","stringifiedTo","to","Array","isArray","map","address","join"],"mappings":";;;;AAEO,MAAMA,0BAA0B,CAACC;IACtC,IAAIC;IAEJ,IAAI,OAAOD,QAAQE,EAAE,KAAK,UAAU;QAClCD,gBAAgBD,QAAQE,EAAE;IAC5B,OAAO,IAAIC,MAAMC,OAAO,CAACJ,QAAQE,EAAE,GAAG;QACpCD,gBAAgBD,QAAQE,EAAE,CACvBG,GAAG,CAAC,CAACH;YACJ,IAAI,OAAOA,OAAO,UAAU;gBAC1B,OAAOA;YACT,OAAO,IAAIA,GAAGI,OAAO,EAAE;gBACrB,OAAOJ,GAAGI,OAAO;YACnB;YACA,OAAO;QACT,GACCC,IAAI,CAAC;IACV,OAAO,IAAIP,QAAQE,EAAE,EAAEI,SAAS;QAC9BL,gBAAgBD,QAAQE,EAAE,CAACI,OAAO;IACpC;IACA,OAAOL;AACT,EAAC"}},
    {"offset": {"line": 8886, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/email/consoleEmailAdapter.ts"],"sourcesContent":["import type { EmailAdapter } from './types.js'\n\nimport { emailDefaults } from './defaults.js'\nimport { getStringifiedToAddress } from './getStringifiedToAddress.js'\n\nexport const consoleEmailAdapter: EmailAdapter<void> = ({ payload }) => ({\n  name: 'console',\n  defaultFromAddress: emailDefaults.defaultFromAddress,\n  defaultFromName: emailDefaults.defaultFromName,\n  sendEmail: async (message) => {\n    const stringifiedTo = getStringifiedToAddress(message)\n    const res = `Email attempted without being configured. To: '${stringifiedTo}', Subject: '${message.subject}'`\n    payload.logger.info({ msg: res })\n    return Promise.resolve()\n  },\n})\n"],"names":["emailDefaults","getStringifiedToAddress","consoleEmailAdapter","payload","name","defaultFromAddress","defaultFromName","sendEmail","message","stringifiedTo","res","subject","logger","info","msg","Promise","resolve"],"mappings":";;;;AAEA,SAASA,aAAa,QAAQ,gBAAe;AAC7C,SAASC,uBAAuB,QAAQ,+BAA8B;;;AAE/D,MAAMC,sBAA0C,CAAC,EAAEC,OAAO,EAAE,GAAM,CAAA;QACvEC,MAAM;QACNC,oBAAoBL,uKAAAA,CAAcK,kBAAkB;QACpDC,iBAAiBN,uKAAAA,CAAcM,eAAe;QAC9CC,WAAW,OAAOC;YAChB,MAAMC,oBAAgBR,gMAAAA,EAAwBO;YAC9C,MAAME,MAAM,CAAC,+CAA+C,EAAED,cAAc,aAAa,EAAED,QAAQG,OAAO,CAAC,CAAC,CAAC;YAC7GR,QAAQS,MAAM,CAACC,IAAI,CAAC;gBAAEC,KAAKJ;YAAI;YAC/B,OAAOK,QAAQC,OAAO;QACxB;IACF,CAAA,EAAE"}},
    {"offset": {"line": 8911, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/index.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\nimport type { ExecutionResult, GraphQLSchema, ValidationRule } from 'graphql'\nimport type { Request as graphQLRequest, OperationArgs } from 'graphql-http'\nimport type { Logger } from 'pino'\nimport type { NonNever } from 'ts-essentials'\n\nimport { spawn } from 'child_process'\nimport crypto from 'crypto'\nimport { fileURLToPath } from 'node:url'\nimport path from 'path'\nimport WebSocket from 'ws'\n\nimport type { AuthArgs } from './auth/operations/auth.js'\nimport type { Result as ForgotPasswordResult } from './auth/operations/forgotPassword.js'\nimport type { Result as LoginResult } from './auth/operations/login.js'\nimport type { Result as ResetPasswordResult } from './auth/operations/resetPassword.js'\nimport type { AuthStrategy, UntypedUser } from './auth/types.js'\nimport type {\n  BulkOperationResult,\n  Collection,\n  DataFromCollectionSlug,\n  SelectFromCollectionSlug,\n  TypeWithID,\n} from './collections/config/types.js'\n\nimport {\n  forgotPasswordLocal,\n  type Options as ForgotPasswordOptions,\n} from './auth/operations/local/forgotPassword.js'\nimport { loginLocal, type Options as LoginOptions } from './auth/operations/local/login.js'\nimport {\n  resetPasswordLocal,\n  type Options as ResetPasswordOptions,\n} from './auth/operations/local/resetPassword.js'\nimport { unlockLocal, type Options as UnlockOptions } from './auth/operations/local/unlock.js'\nimport {\n  verifyEmailLocal,\n  type Options as VerifyEmailOptions,\n} from './auth/operations/local/verifyEmail.js'\nexport type { FieldState } from './admin/forms/Form.js'\nimport type { InitOptions, SanitizedConfig } from './config/types.js'\nimport type { BaseDatabaseAdapter, PaginatedDistinctDocs, PaginatedDocs } from './database/types.js'\nimport type { InitializedEmailAdapter } from './email/types.js'\nimport type { DataFromGlobalSlug, Globals, SelectFromGlobalSlug } from './globals/config/types.js'\nimport type {\n  ApplyDisableErrors,\n  DraftTransformCollectionWithSelect,\n  JsonObject,\n  SelectType,\n  TransformCollectionWithSelect,\n  TransformGlobalWithSelect,\n} from './types/index.js'\nimport type { TraverseFieldsCallback } from './utilities/traverseFields.js'\n\nimport { countLocal, type CountOptions } from './collections/operations/local/count.js'\nimport {\n  createLocal,\n  type Options as CreateOptions,\n} from './collections/operations/local/create.js'\nimport {\n  type ByIDOptions as DeleteByIDOptions,\n  deleteLocal,\n  type ManyOptions as DeleteManyOptions,\n  type Options as DeleteOptions,\n} from './collections/operations/local/delete.js'\nimport {\n  duplicateLocal,\n  type Options as DuplicateOptions,\n} from './collections/operations/local/duplicate.js'\nimport { findLocal, type FindOptions } from './collections/operations/local/find.js'\nexport type { FindOptions }\nimport {\n  findByIDLocal,\n  type Options as FindByIDOptions,\n} from './collections/operations/local/findByID.js'\nimport {\n  findDistinct as findDistinctLocal,\n  type Options as FindDistinctOptions,\n} from './collections/operations/local/findDistinct.js'\nimport {\n  findVersionByIDLocal,\n  type Options as FindVersionByIDOptions,\n} from './collections/operations/local/findVersionByID.js'\nimport {\n  findVersionsLocal,\n  type Options as FindVersionsOptions,\n} from './collections/operations/local/findVersions.js'\nimport {\n  restoreVersionLocal,\n  type Options as RestoreVersionOptions,\n} from './collections/operations/local/restoreVersion.js'\nimport {\n  type ByIDOptions as UpdateByIDOptions,\n  updateLocal,\n  type ManyOptions as UpdateManyOptions,\n  type Options as UpdateOptions,\n} from './collections/operations/local/update.js'\nimport {\n  countGlobalVersionsLocal,\n  type CountGlobalVersionsOptions,\n} from './globals/operations/local/countVersions.js'\nimport {\n  type Options as FindGlobalOptions,\n  findOneGlobalLocal,\n} from './globals/operations/local/findOne.js'\nimport {\n  findGlobalVersionByIDLocal,\n  type Options as FindGlobalVersionByIDOptions,\n} from './globals/operations/local/findVersionByID.js'\nimport {\n  findGlobalVersionsLocal,\n  type Options as FindGlobalVersionsOptions,\n} from './globals/operations/local/findVersions.js'\nimport {\n  restoreGlobalVersionLocal,\n  type Options as RestoreGlobalVersionOptions,\n} from './globals/operations/local/restoreVersion.js'\nimport {\n  updateGlobalLocal,\n  type Options as UpdateGlobalOptions,\n} from './globals/operations/local/update.js'\nexport type * from './admin/types.js'\nexport { EntityType } from './admin/views/dashboard.js'\nimport type { SupportedLanguages } from '@payloadcms/translations'\n\nimport { Cron } from 'croner'\n\nimport type { ClientConfig } from './config/client.js'\nimport type { KVAdapter } from './kv/index.js'\nimport type { BaseJob } from './queues/config/types/workflowTypes.js'\nimport type { TypeWithVersion } from './versions/types.js'\n\nimport { decrypt, encrypt } from './auth/crypto.js'\nimport { authLocal } from './auth/operations/local/auth.js'\nimport { APIKeyAuthentication } from './auth/strategies/apiKey.js'\nimport { JWTAuthentication } from './auth/strategies/jwt.js'\nimport { generateImportMap, type ImportMap } from './bin/generateImportMap/index.js'\nimport { checkPayloadDependencies } from './checkPayloadDependencies.js'\nimport {\n  countVersionsLocal,\n  type CountVersionsOptions,\n} from './collections/operations/local/countVersions.js'\nimport { consoleEmailAdapter } from './email/consoleEmailAdapter.js'\nimport { fieldAffectsData, type FlattenedBlock } from './fields/config/types.js'\nimport { getJobsLocalAPI } from './queues/localAPI.js'\nimport { _internal_jobSystemGlobals } from './queues/utilities/getCurrentDate.js'\nimport { formatAdminURL } from './utilities/formatAdminURL.js'\nimport { isNextBuild } from './utilities/isNextBuild.js'\nimport { getLogger } from './utilities/logger.js'\nimport { serverInit as serverInitTelemetry } from './utilities/telemetry/events/serverInit.js'\nimport { traverseFields } from './utilities/traverseFields.js'\n\n/**\n * Export of all base fields that could potentially be\n * useful as users wish to extend built-in fields with custom logic\n */\nexport { accountLockFields as baseAccountLockFields } from './auth/baseFields/accountLock.js'\nexport { apiKeyFields as baseAPIKeyFields } from './auth/baseFields/apiKey.js'\nexport { baseAuthFields } from './auth/baseFields/auth.js'\nexport { emailFieldConfig as baseEmailField } from './auth/baseFields/email.js'\nexport { sessionsFieldConfig as baseSessionsField } from './auth/baseFields/sessions.js'\nexport { usernameFieldConfig as baseUsernameField } from './auth/baseFields/username.js'\n\nexport { verificationFields as baseVerificationFields } from './auth/baseFields/verification.js'\nexport { executeAccess } from './auth/executeAccess.js'\nexport { executeAuthStrategies } from './auth/executeAuthStrategies.js'\nexport { extractAccessFromPermission } from './auth/extractAccessFromPermission.js'\nexport { getAccessResults } from './auth/getAccessResults.js'\nexport { getFieldsToSign } from './auth/getFieldsToSign.js'\nexport { getLoginOptions } from './auth/getLoginOptions.js'\n\n/**\n * Shape constraint for PayloadTypes.\n * Matches the structure of generated Config types.\n *\n * By defining the actual shape, we can use simple property access (T['collections'])\n * instead of conditional types throughout the codebase.\n */\nexport interface PayloadTypesShape {\n  auth: Record<string, unknown>\n  blocks: Record<string, unknown>\n  collections: Record<string, unknown>\n  collectionsJoins: Record<string, unknown>\n  collectionsSelect: Record<string, unknown>\n  db: { defaultIDType: unknown }\n  fallbackLocale: unknown\n  globals: Record<string, unknown>\n  globalsSelect: Record<string, unknown>\n  jobs: unknown\n  locale: unknown\n  user: unknown\n}\n\n/**\n * Untyped fallback types. Uses the SAME property names as generated types.\n * PayloadTypes merges GeneratedTypes with these fallbacks.\n */\nexport interface UntypedPayloadTypes {\n  auth: {\n    [slug: string]: {\n      forgotPassword: {\n        email: string\n      }\n      login: {\n        email: string\n        password: string\n      }\n      registerFirstUser: {\n        email: string\n        password: string\n      }\n      unlock: {\n        email: string\n      }\n    }\n  }\n  blocks: {\n    [slug: string]: JsonObject\n  }\n  collections: {\n    [slug: string]: JsonObject & TypeWithID\n  }\n  collectionsJoins: {\n    [slug: string]: {\n      [schemaPath: string]: string\n    }\n  }\n  collectionsSelect: {\n    [slug: string]: SelectType\n  }\n  db: {\n    defaultIDType: number | string\n  }\n  fallbackLocale: 'false' | 'none' | 'null' | ({} & string)[] | ({} & string) | false | null\n  globals: {\n    [slug: string]: JsonObject\n  }\n  globalsSelect: {\n    [slug: string]: SelectType\n  }\n  jobs: {\n    tasks: {\n      [slug: string]: {\n        input?: JsonObject\n        output?: JsonObject\n      }\n    }\n    workflows: {\n      [slug: string]: {\n        input: JsonObject\n      }\n    }\n  }\n  locale: null | string\n  user: UntypedUser\n}\n\n/**\n * Interface to be module-augmented by the `payload-types.ts` file.\n * When augmented, its properties take precedence over UntypedPayloadTypes.\n */\nexport interface GeneratedTypes {}\n\n/**\n * Check if GeneratedTypes has been augmented (has any keys).\n */\ntype IsAugmented = keyof GeneratedTypes extends never ? false : true\n\n/**\n * PayloadTypes merges GeneratedTypes with UntypedPayloadTypes.\n * - When augmented: uses augmented properties, fills gaps with untyped fallbacks\n * - When not augmented: uses only UntypedPayloadTypes\n */\nexport type PayloadTypes = IsAugmented extends true\n  ? GeneratedTypes & Omit<UntypedPayloadTypes, keyof GeneratedTypes>\n  : UntypedPayloadTypes\n\nexport type TypedCollection<T extends PayloadTypesShape = PayloadTypes> = T['collections']\n\nexport type TypedBlock = PayloadTypes['blocks']\n\nexport type TypedUploadCollection<T extends PayloadTypesShape = PayloadTypes> = NonNever<{\n  [TSlug in keyof T['collections']]:\n    | 'filename'\n    | 'filesize'\n    | 'mimeType'\n    | 'url' extends keyof T['collections'][TSlug]\n    ? T['collections'][TSlug]\n    : never\n}>\n\nexport type TypedCollectionSelect<T extends PayloadTypesShape = PayloadTypes> =\n  T['collectionsSelect']\n\nexport type TypedCollectionJoins<T extends PayloadTypesShape = PayloadTypes> = T['collectionsJoins']\n\nexport type TypedGlobal<T extends PayloadTypesShape = PayloadTypes> = T['globals']\n\nexport type TypedGlobalSelect<T extends PayloadTypesShape = PayloadTypes> = T['globalsSelect']\n\n// Extract string keys from the type\nexport type StringKeyOf<T> = Extract<keyof T, string>\n\n// Define the types for slugs using the appropriate collections and globals\nexport type CollectionSlug<T extends PayloadTypesShape = PayloadTypes> = StringKeyOf<\n  T['collections']\n>\n\nexport type BlockSlug = StringKeyOf<TypedBlock>\n\nexport type UploadCollectionSlug<T extends PayloadTypesShape = PayloadTypes> = StringKeyOf<\n  TypedUploadCollection<T>\n>\n\nexport type DefaultDocumentIDType = PayloadTypes['db']['defaultIDType']\n\nexport type GlobalSlug<T extends PayloadTypesShape = PayloadTypes> = StringKeyOf<T['globals']>\n\nexport type TypedLocale<T extends PayloadTypesShape = PayloadTypes> = T['locale']\n\nexport type TypedFallbackLocale = PayloadTypes['fallbackLocale']\n\n/**\n * @todo rename to `User` in 4.0\n */\nexport type TypedUser = PayloadTypes['user']\n\nexport type TypedAuthOperations<T extends PayloadTypesShape = PayloadTypes> = T['auth']\n\nexport type AuthCollectionSlug<T extends PayloadTypesShape> = StringKeyOf<T['auth']>\n\nexport type TypedJobs = PayloadTypes['jobs']\n\n// Check if payload-jobs exists in the AUGMENTED types (not the fallback with index signature)\ntype HasPayloadJobsType = GeneratedTypes extends { collections: infer C }\n  ? 'payload-jobs' extends keyof C\n    ? true\n    : false\n  : false\n\n/**\n * Represents a job in the `payload-jobs` collection, referencing a queued workflow or task (= Job).\n * If a generated type for the `payload-jobs` collection is not available, falls back to the BaseJob type.\n *\n * `input` and `taksStatus` are always present here, as the job afterRead hook will always populate them.\n */\nexport type Job<\n  TWorkflowSlugOrInput extends false | keyof TypedJobs['workflows'] | object = false,\n> = HasPayloadJobsType extends true\n  ? {\n      input: BaseJob<TWorkflowSlugOrInput>['input']\n      taskStatus: BaseJob<TWorkflowSlugOrInput>['taskStatus']\n    } & Omit<TypedCollection['payload-jobs'], 'input' | 'taskStatus'>\n  : BaseJob<TWorkflowSlugOrInput>\n\nconst filename = fileURLToPath(import.meta.url)\nconst dirname = path.dirname(filename)\n\nlet checkedDependencies = false\n\n/**\n * @description Payload\n */\nexport class BasePayload {\n  /**\n   * @description Authorization and Authentication using headers and cookies to run auth user strategies\n   * @returns permissions: Permissions\n   * @returns user: User\n   */\n  auth = async (options: AuthArgs) => {\n    return authLocal(this, options)\n  }\n\n  authStrategies!: AuthStrategy[]\n\n  blocks: Record<BlockSlug, FlattenedBlock> = {}\n\n  collections: Record<CollectionSlug, Collection> = {}\n\n  config!: SanitizedConfig\n  /**\n   * @description Performs count operation\n   * @param options\n   * @returns count of documents satisfying query\n   */\n  count = async <T extends CollectionSlug>(\n    options: CountOptions<T>,\n  ): Promise<{ totalDocs: number }> => {\n    return countLocal(this, options)\n  }\n\n  /**\n   * @description Performs countGlobalVersions operation\n   * @param options\n   * @returns count of global document versions satisfying query\n   */\n  countGlobalVersions = async <T extends GlobalSlug>(\n    options: CountGlobalVersionsOptions<T>,\n  ): Promise<{ totalDocs: number }> => {\n    return countGlobalVersionsLocal(this, options)\n  }\n\n  /**\n   * @description Performs countVersions operation\n   * @param options\n   * @returns count of document versions satisfying query\n   */\n  countVersions = async <T extends CollectionSlug>(\n    options: CountVersionsOptions<T>,\n  ): Promise<{ totalDocs: number }> => {\n    return countVersionsLocal(this, options)\n  }\n\n  /**\n   * @description Performs create operation\n   * @param options\n   * @returns created document\n   */\n  create = async <TSlug extends CollectionSlug, TSelect extends SelectFromCollectionSlug<TSlug>>(\n    options: CreateOptions<TSlug, TSelect>,\n  ): Promise<TransformCollectionWithSelect<TSlug, TSelect>> => {\n    return createLocal<TSlug, TSelect>(this, options)\n  }\n\n  crons: Cron[] = []\n  db!: DatabaseAdapter\n\n  decrypt = decrypt\n\n  destroy = async () => {\n    if (this.crons.length) {\n      // Remove all crons from the list before stopping them\n      const cronsToStop = this.crons.splice(0, this.crons.length)\n      await Promise.all(cronsToStop.map((cron) => cron.stop()))\n    }\n\n    if (this.db?.destroy && typeof this.db.destroy === 'function') {\n      await this.db.destroy()\n    }\n  }\n\n  duplicate = async <TSlug extends CollectionSlug, TSelect extends SelectFromCollectionSlug<TSlug>>(\n    options: DuplicateOptions<TSlug, TSelect>,\n  ): Promise<TransformCollectionWithSelect<TSlug, TSelect>> => {\n    return duplicateLocal<TSlug, TSelect>(this, options)\n  }\n\n  email!: InitializedEmailAdapter\n\n  // TODO: re-implement or remove?\n  // errorHandler: ErrorHandler\n\n  encrypt = encrypt\n\n  extensions!: (args: {\n    args: OperationArgs<any>\n    req: graphQLRequest<unknown, unknown>\n    result: ExecutionResult\n  }) => Promise<any>\n\n  /**\n   * @description Find documents with criteria\n   * @param options\n   * @returns documents satisfying query\n   */\n  find = async <\n    TSlug extends CollectionSlug,\n    TSelect extends SelectFromCollectionSlug<TSlug>,\n    TDraft extends boolean = false,\n  >(\n    options: { draft?: TDraft } & FindOptions<TSlug, TSelect>,\n  ): Promise<\n    PaginatedDocs<\n      TDraft extends true\n        ? PayloadTypes extends { strictDraftTypes: true }\n          ? DraftTransformCollectionWithSelect<TSlug, TSelect>\n          : TransformCollectionWithSelect<TSlug, TSelect>\n        : TransformCollectionWithSelect<TSlug, TSelect>\n    >\n  > => {\n    return findLocal<TSlug, TSelect, TDraft>(this, options)\n  }\n\n  /**\n   * @description Find document by ID\n   * @param options\n   * @returns document with specified ID\n   */\n  findByID = async <\n    TSlug extends CollectionSlug,\n    TDisableErrors extends boolean,\n    TSelect extends SelectFromCollectionSlug<TSlug>,\n  >(\n    options: FindByIDOptions<TSlug, TDisableErrors, TSelect>,\n  ): Promise<ApplyDisableErrors<TransformCollectionWithSelect<TSlug, TSelect>, TDisableErrors>> => {\n    return findByIDLocal<TSlug, TDisableErrors, TSelect>(this, options)\n  }\n\n  /**\n   * @description Find distinct field values\n   * @param options\n   * @returns result with distinct field values\n   */\n  findDistinct = async <\n    TSlug extends CollectionSlug,\n    TField extends keyof DataFromCollectionSlug<TSlug> & string,\n  >(\n    options: FindDistinctOptions<TSlug, TField>,\n  ): Promise<PaginatedDistinctDocs<Record<TField, DataFromCollectionSlug<TSlug>[TField]>>> => {\n    return findDistinctLocal(this, options)\n  }\n\n  findGlobal = async <TSlug extends GlobalSlug, TSelect extends SelectFromGlobalSlug<TSlug>>(\n    options: FindGlobalOptions<TSlug, TSelect>,\n  ): Promise<TransformGlobalWithSelect<TSlug, TSelect>> => {\n    return findOneGlobalLocal<TSlug, TSelect>(this, options)\n  }\n\n  /**\n   * @description Find global version by ID\n   * @param options\n   * @returns global version with specified ID\n   */\n  findGlobalVersionByID = async <TSlug extends GlobalSlug>(\n    options: FindGlobalVersionByIDOptions<TSlug>,\n  ): Promise<TypeWithVersion<DataFromGlobalSlug<TSlug>>> => {\n    return findGlobalVersionByIDLocal<TSlug>(this, options)\n  }\n\n  /**\n   * @description Find global versions with criteria\n   * @param options\n   * @returns versions satisfying query\n   */\n  findGlobalVersions = async <TSlug extends GlobalSlug>(\n    options: FindGlobalVersionsOptions<TSlug>,\n  ): Promise<PaginatedDocs<TypeWithVersion<DataFromGlobalSlug<TSlug>>>> => {\n    return findGlobalVersionsLocal<TSlug>(this, options)\n  }\n\n  /**\n   * @description Find version by ID\n   * @param options\n   * @returns version with specified ID\n   */\n  findVersionByID = async <TSlug extends CollectionSlug>(\n    options: FindVersionByIDOptions<TSlug>,\n  ): Promise<TypeWithVersion<DataFromCollectionSlug<TSlug>>> => {\n    return findVersionByIDLocal<TSlug>(this, options)\n  }\n\n  /**\n   * @description Find versions with criteria\n   * @param options\n   * @returns versions satisfying query\n   */\n  findVersions = async <TSlug extends CollectionSlug>(\n    options: FindVersionsOptions<TSlug>,\n  ): Promise<PaginatedDocs<TypeWithVersion<DataFromCollectionSlug<TSlug>>>> => {\n    return findVersionsLocal<TSlug>(this, options)\n  }\n\n  forgotPassword = async <TSlug extends CollectionSlug>(\n    options: ForgotPasswordOptions<TSlug>,\n  ): Promise<ForgotPasswordResult> => {\n    return forgotPasswordLocal<TSlug>(this, options)\n  }\n\n  getAdminURL = (): string =>\n    formatAdminURL({\n      adminRoute: this.config.routes.admin,\n      path: '',\n      serverURL: this.config.serverURL,\n    })\n\n  getAPIURL = (): string =>\n    formatAdminURL({\n      apiRoute: this.config.routes.api,\n      path: '',\n      serverURL: this.config.serverURL,\n    })\n\n  globals!: Globals\n\n  importMap!: ImportMap\n\n  jobs = getJobsLocalAPI(this)\n\n  /**\n   * Key Value storage\n   */\n  kv!: KVAdapter\n\n  logger!: Logger\n\n  login = async <TSlug extends CollectionSlug>(\n    options: LoginOptions<TSlug>,\n  ): Promise<{ user: DataFromCollectionSlug<TSlug> } & LoginResult> => {\n    return loginLocal<TSlug>(this, options)\n  }\n\n  resetPassword = async <TSlug extends CollectionSlug>(\n    options: ResetPasswordOptions<TSlug>,\n  ): Promise<ResetPasswordResult> => {\n    return resetPasswordLocal<TSlug>(this, options)\n  }\n\n  /**\n   * @description Restore global version by ID\n   * @param options\n   * @returns version with specified ID\n   */\n  restoreGlobalVersion = async <TSlug extends GlobalSlug>(\n    options: RestoreGlobalVersionOptions<TSlug>,\n  ): Promise<DataFromGlobalSlug<TSlug>> => {\n    return restoreGlobalVersionLocal<TSlug>(this, options)\n  }\n\n  /**\n   * @description Restore version by ID\n   * @param options\n   * @returns version with specified ID\n   */\n  restoreVersion = async <TSlug extends CollectionSlug>(\n    options: RestoreVersionOptions<TSlug>,\n  ): Promise<DataFromCollectionSlug<TSlug>> => {\n    return restoreVersionLocal<TSlug>(this, options)\n  }\n\n  schema!: GraphQLSchema\n\n  secret!: string\n\n  sendEmail!: InitializedEmailAdapter['sendEmail']\n\n  types!: {\n    arrayTypes: any\n    blockInputTypes: any\n    blockTypes: any\n    fallbackLocaleInputType?: any\n    groupTypes: any\n    localeInputType?: any\n    tabTypes: any\n  }\n\n  unlock = async <TSlug extends CollectionSlug>(\n    options: UnlockOptions<TSlug>,\n  ): Promise<boolean> => {\n    return unlockLocal<TSlug>(this, options)\n  }\n\n  updateGlobal = async <TSlug extends GlobalSlug, TSelect extends SelectFromGlobalSlug<TSlug>>(\n    options: UpdateGlobalOptions<TSlug, TSelect>,\n  ): Promise<TransformGlobalWithSelect<TSlug, TSelect>> => {\n    return updateGlobalLocal<TSlug, TSelect>(this, options)\n  }\n\n  validationRules!: (args: OperationArgs<any>) => ValidationRule[]\n\n  verifyEmail = async <TSlug extends CollectionSlug>(\n    options: VerifyEmailOptions<TSlug>,\n  ): Promise<boolean> => {\n    return verifyEmailLocal(this, options)\n  }\n\n  versions: {\n    [slug: string]: any // TODO: Type this\n  } = {}\n\n  async _initializeCrons() {\n    if (this.config.jobs.enabled && this.config.jobs.autoRun && !isNextBuild()) {\n      const DEFAULT_CRON = '* * * * *'\n      const DEFAULT_LIMIT = 10\n\n      const cronJobs =\n        typeof this.config.jobs.autoRun === 'function'\n          ? await this.config.jobs.autoRun(this)\n          : this.config.jobs.autoRun\n\n      await Promise.all(\n        cronJobs.map((cronConfig) => {\n          const jobAutorunCron = new Cron(\n            cronConfig.cron ?? DEFAULT_CRON,\n            async () => {\n              if (\n                _internal_jobSystemGlobals.shouldAutoSchedule &&\n                !cronConfig.disableScheduling &&\n                this.config.jobs.scheduling\n              ) {\n                await this.jobs.handleSchedules({\n                  allQueues: cronConfig.allQueues,\n                  queue: cronConfig.queue,\n                })\n              }\n\n              if (!_internal_jobSystemGlobals.shouldAutoRun) {\n                return\n              }\n\n              if (typeof this.config.jobs.shouldAutoRun === 'function') {\n                const shouldAutoRun = await this.config.jobs.shouldAutoRun(this)\n\n                if (!shouldAutoRun) {\n                  jobAutorunCron.stop()\n                  return\n                }\n              }\n\n              await this.jobs.run({\n                allQueues: cronConfig.allQueues,\n                limit: cronConfig.limit ?? DEFAULT_LIMIT,\n                queue: cronConfig.queue,\n                silent: cronConfig.silent,\n              })\n            },\n            {\n              // Do not run consecutive crons if previous crons still ongoing\n              protect: true,\n            },\n          )\n\n          this.crons.push(jobAutorunCron)\n        }),\n      )\n    }\n  }\n\n  async bin({\n    args,\n    cwd,\n    log,\n  }: {\n    args: string[]\n    cwd?: string\n    log?: boolean\n  }): Promise<{ code: number }> {\n    return new Promise((resolve, reject) => {\n      const spawned = spawn('node', [path.resolve(dirname, '../bin.js'), ...args], {\n        cwd,\n        stdio: log || log === undefined ? 'inherit' : 'ignore',\n      })\n\n      spawned.on('exit', (code) => {\n        resolve({ code: code! })\n      })\n\n      spawned.on('error', (error) => {\n        reject(error)\n      })\n    })\n  }\n\n  /**\n   * @description delete one or more documents\n   * @param options\n   * @returns Updated document(s)\n   */\n  delete<TSlug extends CollectionSlug, TSelect extends SelectFromCollectionSlug<TSlug>>(\n    options: DeleteByIDOptions<TSlug, TSelect>,\n  ): Promise<TransformCollectionWithSelect<TSlug, TSelect>>\n\n  delete<TSlug extends CollectionSlug, TSelect extends SelectFromCollectionSlug<TSlug>>(\n    options: DeleteManyOptions<TSlug, TSelect>,\n  ): Promise<BulkOperationResult<TSlug, TSelect>>\n\n  delete<TSlug extends CollectionSlug, TSelect extends SelectFromCollectionSlug<TSlug>>(\n    options: DeleteOptions<TSlug, TSelect>,\n  ): Promise<BulkOperationResult<TSlug, TSelect> | TransformCollectionWithSelect<TSlug, TSelect>> {\n    return deleteLocal<TSlug, TSelect>(this, options)\n  }\n\n  /**\n   * @description Initializes Payload\n   * @param options\n   */\n  async init(options: InitOptions): Promise<Payload> {\n    if (\n      process.env.NODE_ENV !== 'production' &&\n      process.env.PAYLOAD_DISABLE_DEPENDENCY_CHECKER !== 'true' &&\n      !checkedDependencies\n    ) {\n      checkedDependencies = true\n      void checkPayloadDependencies()\n    }\n\n    this.importMap = options.importMap!\n\n    if (!options?.config) {\n      throw new Error('Error: the payload config is required to initialize payload.')\n    }\n\n    this.config = await options.config\n    this.logger = getLogger('payload', this.config.logger)\n\n    if (!this.config.secret) {\n      throw new Error('Error: missing secret key. A secret key is needed to secure Payload.')\n    }\n\n    this.secret = crypto.createHash('sha256').update(this.config.secret).digest('hex').slice(0, 32)\n\n    this.globals = {\n      config: this.config.globals,\n    }\n\n    for (const collection of this.config.collections) {\n      let customIDType: string | undefined = undefined\n      const findCustomID: TraverseFieldsCallback = ({ field }) => {\n        if (\n          ['array', 'blocks', 'group'].includes(field.type) ||\n          (field.type === 'tab' && 'name' in field)\n        ) {\n          return true\n        }\n\n        if (!fieldAffectsData(field)) {\n          return\n        }\n\n        if (field.name === 'id') {\n          customIDType = field.type\n          return true\n        }\n      }\n\n      traverseFields({\n        callback: findCustomID,\n        config: this.config,\n        fields: collection.fields,\n        parentIsLocalized: false,\n      })\n\n      this.collections[collection.slug] = {\n        config: collection,\n        customIDType,\n      }\n    }\n\n    this.blocks = this.config.blocks!.reduce(\n      (blocks, block) => {\n        blocks[block.slug] = block\n        return blocks\n      },\n      {} as Record<string, FlattenedBlock>,\n    )\n\n    // Generate types on startup\n    if (process.env.NODE_ENV !== 'production' && this.config.typescript.autoGenerate !== false) {\n      // We cannot run it directly here, as generate-types imports json-schema-to-typescript, which breaks on turbopack.\n      // see: https://github.com/vercel/next.js/issues/66723\n      void this.bin({\n        args: ['generate:types'],\n        log: false,\n      })\n    }\n\n    this.db = this.config.db.init({ payload: this })\n    this.db.payload = this\n\n    this.kv = this.config.kv.init({ payload: this })\n\n    if (this.db?.init) {\n      await this.db.init()\n    }\n\n    if (!options.disableDBConnect && this.db.connect) {\n      await this.db.connect()\n    }\n\n    // Load email adapter\n    if (this.config.email instanceof Promise) {\n      const awaitedAdapter = await this.config.email\n      this.email = awaitedAdapter({ payload: this })\n    } else if (this.config.email) {\n      this.email = this.config.email({ payload: this })\n    } else {\n      if (process.env.NEXT_PHASE !== 'phase-production-build') {\n        this.logger.warn(\n          `No email adapter provided. Email will be written to console. More info at https://payloadcms.com/docs/email/overview.`,\n        )\n      }\n\n      this.email = consoleEmailAdapter({ payload: this })\n    }\n\n    // Warn if image resizing is enabled but sharp is not installed\n    if (\n      !this.config.sharp &&\n      this.config.collections.some((c) => c.upload.imageSizes || c.upload.formatOptions)\n    ) {\n      this.logger.warn(\n        `Image resizing is enabled for one or more collections, but sharp not installed. Please install 'sharp' and pass into the config.`,\n      )\n    }\n\n    // Warn if user is deploying to Vercel, and any upload collection is missing a storage adapter\n    if (process.env.VERCEL) {\n      const uploadCollWithoutAdapter = this.config.collections.filter(\n        (c) => c.upload && c.upload.adapter === undefined, // Uploads enabled, but no storage adapter provided\n      )\n\n      if (uploadCollWithoutAdapter.length) {\n        const slugs = uploadCollWithoutAdapter.map((c) => c.slug).join(', ')\n        this.logger.warn(\n          `Collections with uploads enabled require a storage adapter when deploying to Vercel. Collection(s) without storage adapters: ${slugs}. See https://payloadcms.com/docs/upload/storage-adapters for more info.`,\n        )\n      }\n    }\n\n    this.sendEmail = this.email['sendEmail']\n\n    serverInitTelemetry(this)\n\n    // 1. loop over collections, if collection has auth strategy, initialize and push to array\n    let jwtStrategyEnabled = false\n    this.authStrategies = this.config.collections.reduce((authStrategies, collection) => {\n      if (collection?.auth) {\n        if (collection.auth.strategies.length > 0) {\n          authStrategies.push(...collection.auth.strategies)\n        }\n\n        // 2. if api key enabled, push api key strategy into the array\n        if (collection.auth?.useAPIKey) {\n          authStrategies.push({\n            name: `${collection.slug}-api-key`,\n            authenticate: APIKeyAuthentication(collection),\n          })\n        }\n\n        // 3. if localStrategy flag is true\n        if (!collection.auth.disableLocalStrategy && !jwtStrategyEnabled) {\n          jwtStrategyEnabled = true\n        }\n      }\n\n      return authStrategies\n    }, [] as AuthStrategy[])\n\n    // 4. if enabled, push jwt strategy into authStrategies last\n    if (jwtStrategyEnabled) {\n      this.authStrategies.push({\n        name: 'local-jwt',\n        authenticate: JWTAuthentication,\n      })\n    }\n\n    try {\n      if (!options.disableOnInit) {\n        if (typeof options.onInit === 'function') {\n          await options.onInit(this)\n        }\n        if (typeof this.config.onInit === 'function') {\n          await this.config.onInit(this)\n        }\n      }\n    } catch (error) {\n      this.logger.error({ err: error }, 'Error running onInit function')\n      throw error\n    }\n\n    if (options.cron) {\n      await this._initializeCrons()\n    }\n\n    return this\n  }\n\n  update<TSlug extends CollectionSlug, TSelect extends SelectFromCollectionSlug<TSlug>>(\n    options: UpdateManyOptions<TSlug, TSelect>,\n  ): Promise<BulkOperationResult<TSlug, TSelect>>\n\n  /**\n   * @description Update one or more documents\n   * @param options\n   * @returns Updated document(s)\n   */\n  update<TSlug extends CollectionSlug, TSelect extends SelectFromCollectionSlug<TSlug>>(\n    options: UpdateByIDOptions<TSlug, TSelect>,\n  ): Promise<TransformCollectionWithSelect<TSlug, TSelect>>\n\n  update<TSlug extends CollectionSlug, TSelect extends SelectFromCollectionSlug<TSlug>>(\n    options: UpdateOptions<TSlug, TSelect>,\n  ): Promise<BulkOperationResult<TSlug, TSelect> | TransformCollectionWithSelect<TSlug, TSelect>> {\n    return updateLocal<TSlug, TSelect>(this, options)\n  }\n}\n\nconst initialized = new BasePayload()\n\n// eslint-disable-next-line no-restricted-exports\nexport default initialized\n\nexport const reload = async (\n  config: SanitizedConfig,\n  payload: Payload,\n  skipImportMapGeneration?: boolean,\n  options?: InitOptions,\n): Promise<void> => {\n  if (typeof payload.db.destroy === 'function') {\n    // Only destroy db, as we then later only call payload.db.init and not payload.init\n    await payload.db.destroy()\n  }\n  payload.config = config\n\n  payload.collections = config.collections.reduce(\n    (collections, collection) => {\n      collections[collection.slug] = {\n        config: collection,\n        customIDType: payload.collections[collection.slug]?.customIDType,\n      }\n      return collections\n    },\n    {} as Record<string, any>,\n  )\n\n  payload.blocks = config.blocks!.reduce(\n    (blocks, block) => {\n      blocks[block.slug] = block\n      return blocks\n    },\n    {} as Record<string, FlattenedBlock>,\n  )\n\n  payload.globals = {\n    config: config.globals,\n  }\n\n  // TODO: support HMR for other props in the future (see payload/src/index init()) that may change on Payload singleton\n\n  // Generate types\n  if (config.typescript.autoGenerate !== false) {\n    // We cannot run it directly here, as generate-types imports json-schema-to-typescript, which breaks on turbopack.\n    // see: https://github.com/vercel/next.js/issues/66723\n    void payload.bin({\n      args: ['generate:types'],\n      log: false,\n    })\n  }\n\n  // Generate import map\n  if (skipImportMapGeneration !== true && config.admin?.importMap?.autoGenerate !== false) {\n    // This may run outside of the admin panel, e.g. in the user's frontend, where we don't have an import map file.\n    // We don't want to throw an error in this case, as it would break the user's frontend.\n    // => just skip it => ignoreResolveError: true\n    await generateImportMap(config, {\n      ignoreResolveError: true,\n      log: true,\n    })\n  }\n\n  if (payload.db?.init) {\n    await payload.db.init()\n  }\n\n  if (!options?.disableDBConnect && payload.db.connect) {\n    await payload.db.connect({ hotReload: true })\n  }\n\n  ;(global as any)._payload_clientConfigs = {} as Record<keyof SupportedLanguages, ClientConfig>\n  ;(global as any)._payload_schemaMap = null\n  ;(global as any)._payload_clientSchemaMap = null\n  ;(global as any)._payload_doNotCacheClientConfig = true // This will help refreshing the client config cache more reliably. If you remove this, please test HMR + client config refreshing (do new fields appear in the document?)\n  ;(global as any)._payload_doNotCacheSchemaMap = true\n  ;(global as any)._payload_doNotCacheClientSchemaMap = true\n}\n\nlet _cached: Map<\n  string,\n  {\n    initializedCrons: boolean\n    payload: null | Payload\n    promise: null | Promise<Payload>\n    reload: boolean | Promise<void>\n    ws: null | WebSocket\n  }\n> = (global as any)._payload\n\nif (!_cached) {\n  _cached = (global as any)._payload = new Map()\n}\n\n/**\n * Get a payload instance.\n * This function is a wrapper around new BasePayload().init() that adds the following functionality on top of that:\n *\n * - smartly caches Payload instance on the module scope. That way, we prevent unnecessarily initializing Payload over and over again\n * when calling getPayload multiple times or from multiple locations.\n * - adds HMR support and reloads the payload instance when the config changes.\n */\nexport const getPayload = async (\n  options: {\n    /**\n     * A unique key to identify the payload instance. You can pass your own key if you want to cache this payload instance separately.\n     * This is useful if you pass a different payload config for each instance.\n     *\n     * @default 'default'\n     */\n    key?: string\n  } & InitOptions,\n): Promise<Payload> => {\n  if (!options?.config) {\n    throw new Error('Error: the payload config is required for getPayload to work.')\n  }\n\n  let alreadyCachedSameConfig = false\n\n  let cached = _cached.get(options.key ?? 'default')\n  if (!cached) {\n    cached = {\n      initializedCrons: Boolean(options.cron),\n      payload: null,\n      promise: null,\n      reload: false,\n      ws: null,\n    }\n    _cached.set(options.key ?? 'default', cached)\n  } else {\n    alreadyCachedSameConfig = true\n  }\n\n  if (alreadyCachedSameConfig) {\n    // alreadyCachedSameConfig => already called onInit once, but same config => no need to call onInit again.\n    // calling onInit again would only make sense if a different config was passed.\n    options.disableOnInit = true\n  }\n\n  if (cached.payload) {\n    if (options.cron && !cached.initializedCrons) {\n      // getPayload called with crons enabled, but existing cached version does not have crons initialized. => Initialize crons in existing cached version\n      cached.initializedCrons = true\n      await cached.payload._initializeCrons()\n    }\n\n    if (cached.reload === true) {\n      let resolve!: () => void\n\n      // getPayload is called multiple times, in parallel. However, we only want to run `await reload` once. By immediately setting cached.reload to a promise,\n      // we can ensure that all subsequent calls will wait for the first reload to finish. So if we set it here, the 2nd call of getPayload\n      // will reach `if (cached.reload instanceof Promise) {` which then waits for the first reload to finish.\n      cached.reload = new Promise((res) => (resolve = res))\n      const config = await options.config\n\n      // Reload the payload instance after a config change (triggered by HMR in development).\n      // The second parameter (false) forces import map regeneration rather than deciding based on options.importMap.\n      //\n      // Why we always regenerate import map: getPayload() may be called from multiple sources (admin panel, frontend, etc.)\n      // that share the same cache but may pass different importMap values. Since call order is unpredictable,\n      // we cannot rely on options.importMap to determine if regeneration is needed.\n      //\n      // Example scenario: If the frontend calls getPayload() without importMap first, followed by the admin\n      // panel calling it with importMap, we'd incorrectly skip generation for the admin panel's needs.\n      // By always regenerating on reload, we ensure the import map stays in sync with the updated config.\n      await reload(config, cached.payload, false, options)\n\n      resolve()\n      cached.reload = false\n    }\n\n    if (cached.reload instanceof Promise) {\n      await cached.reload\n    }\n    if (options?.importMap) {\n      cached.payload.importMap = options.importMap\n    }\n    return cached.payload\n  }\n\n  try {\n    if (!cached.promise) {\n      // no need to await options.config here, as it's already awaited in the BasePayload.init\n      cached.promise = new BasePayload().init(options)\n    }\n\n    cached.payload = await cached.promise\n\n    if (\n      !cached.ws &&\n      process.env.NODE_ENV !== 'production' &&\n      process.env.NODE_ENV !== 'test' &&\n      process.env.DISABLE_PAYLOAD_HMR !== 'true'\n    ) {\n      try {\n        const port = process.env.PORT || '3000'\n        const hasHTTPS =\n          process.env.USE_HTTPS === 'true' || process.argv.includes('--experimental-https')\n        const protocol = hasHTTPS ? 'wss' : 'ws'\n\n        const path = '/_next/webpack-hmr'\n        // The __NEXT_ASSET_PREFIX env variable is set for both assetPrefix and basePath (tested in Next.js 15.1.6)\n        const prefix = process.env.__NEXT_ASSET_PREFIX ?? ''\n\n        cached.ws = new WebSocket(\n          process.env.PAYLOAD_HMR_URL_OVERRIDE ?? `${protocol}://localhost:${port}${prefix}${path}`,\n        )\n\n        cached.ws.onmessage = (event) => {\n          if (cached.reload instanceof Promise) {\n            // If there is an in-progress reload in the same getPayload\n            // cache instance, do not set reload to true again, which would\n            // trigger another reload.\n            // Instead, wait for the in-progress reload to finish.\n            return\n          }\n\n          if (typeof event.data === 'string') {\n            const data = JSON.parse(event.data)\n\n            if (\n              // On Next.js 15, we need to check for data.action. On Next.js 16, we need to check for data.type.\n              data.type === 'serverComponentChanges' ||\n              data.action === 'serverComponentChanges'\n            ) {\n              cached.reload = true\n            }\n          }\n        }\n\n        cached.ws.onerror = (_) => {\n          // swallow any websocket connection error\n        }\n      } catch (_) {\n        // swallow e\n      }\n    }\n  } catch (e) {\n    cached.promise = null\n    // add identifier to error object, so that our error logger in routeError.ts does not attempt to re-initialize getPayload\n    ;(e as { payloadInitError?: boolean }).payloadInitError = true\n    throw e\n  }\n\n  if (options?.importMap) {\n    cached.payload.importMap = options.importMap\n  }\n\n  return cached.payload\n}\n\ntype Payload = BasePayload\n\ninterface RequestContext {\n  [key: string]: unknown\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-object-type\nexport interface DatabaseAdapter extends BaseDatabaseAdapter {}\nexport type { Payload, RequestContext }\nexport * from './auth/index.js'\nexport { jwtSign } from './auth/jwt.js'\nexport { accessOperation } from './auth/operations/access.js'\nexport { forgotPasswordOperation } from './auth/operations/forgotPassword.js'\nexport { initOperation } from './auth/operations/init.js'\nexport { checkLoginPermission } from './auth/operations/login.js'\nexport { loginOperation } from './auth/operations/login.js'\nexport { logoutOperation } from './auth/operations/logout.js'\nexport type { MeOperationResult } from './auth/operations/me.js'\nexport { meOperation } from './auth/operations/me.js'\nexport { refreshOperation } from './auth/operations/refresh.js'\nexport { registerFirstUserOperation } from './auth/operations/registerFirstUser.js'\nexport { resetPasswordOperation } from './auth/operations/resetPassword.js'\nexport { unlockOperation } from './auth/operations/unlock.js'\nexport { verifyEmailOperation } from './auth/operations/verifyEmail.js'\nexport { JWTAuthentication } from './auth/strategies/jwt.js'\nexport { incrementLoginAttempts } from './auth/strategies/local/incrementLoginAttempts.js'\nexport { resetLoginAttempts } from './auth/strategies/local/resetLoginAttempts.js'\nexport type {\n  AuthStrategyFunction,\n  AuthStrategyFunctionArgs,\n  AuthStrategyResult,\n  CollectionPermission,\n  DocumentPermissions,\n  FieldPermissions,\n  GlobalPermission,\n  IncomingAuthType,\n  Permission,\n  Permissions,\n  SanitizedCollectionPermission,\n  SanitizedDocumentPermissions,\n  SanitizedFieldPermissions,\n  SanitizedGlobalPermission,\n  SanitizedPermissions,\n  UntypedUser as User,\n  VerifyConfig,\n} from './auth/types.js'\nexport { generateImportMap } from './bin/generateImportMap/index.js'\n\nexport type { ImportMap } from './bin/generateImportMap/index.js'\nexport { genImportMapIterateFields } from './bin/generateImportMap/iterateFields.js'\nexport { migrate as migrateCLI } from './bin/migrate.js'\n\nexport {\n  type ClientCollectionConfig,\n  createClientCollectionConfig,\n  createClientCollectionConfigs,\n  type ServerOnlyCollectionAdminProperties,\n  type ServerOnlyCollectionProperties,\n  type ServerOnlyUploadProperties,\n} from './collections/config/client.js'\n\nexport type {\n  AfterChangeHook as CollectionAfterChangeHook,\n  AfterDeleteHook as CollectionAfterDeleteHook,\n  AfterErrorHook as CollectionAfterErrorHook,\n  AfterForgotPasswordHook as CollectionAfterForgotPasswordHook,\n  AfterLoginHook as CollectionAfterLoginHook,\n  AfterLogoutHook as CollectionAfterLogoutHook,\n  AfterMeHook as CollectionAfterMeHook,\n  AfterOperationHook as CollectionAfterOperationHook,\n  AfterReadHook as CollectionAfterReadHook,\n  AfterRefreshHook as CollectionAfterRefreshHook,\n  AuthCollection,\n  AuthOperationsFromCollectionSlug,\n  BaseFilter,\n  BaseListFilter,\n  BeforeChangeHook as CollectionBeforeChangeHook,\n  BeforeDeleteHook as CollectionBeforeDeleteHook,\n  BeforeLoginHook as CollectionBeforeLoginHook,\n  BeforeOperationHook as CollectionBeforeOperationHook,\n  BeforeReadHook as CollectionBeforeReadHook,\n  BeforeValidateHook as CollectionBeforeValidateHook,\n  BulkOperationResult,\n  Collection,\n  CollectionAdminOptions,\n  CollectionConfig,\n  DataFromCollectionSlug,\n  HookOperationType,\n  MeHook as CollectionMeHook,\n  RefreshHook as CollectionRefreshHook,\n  RequiredDataFromCollection,\n  RequiredDataFromCollectionSlug,\n  SanitizedCollectionConfig,\n  SanitizedJoins,\n  TypeWithID,\n  TypeWithTimestamps,\n} from './collections/config/types.js'\n\nexport type { CompoundIndex } from './collections/config/types.js'\nexport type { SanitizedCompoundIndex } from './collections/config/types.js'\n\nexport { createDataloaderCacheKey, getDataLoader } from './collections/dataloader.js'\nexport { countOperation } from './collections/operations/count.js'\nexport { createOperation } from './collections/operations/create.js'\nexport { deleteOperation } from './collections/operations/delete.js'\nexport { deleteByIDOperation } from './collections/operations/deleteByID.js'\nexport { docAccessOperation } from './collections/operations/docAccess.js'\nexport { duplicateOperation } from './collections/operations/duplicate.js'\nexport { findOperation } from './collections/operations/find.js'\nexport { findByIDOperation } from './collections/operations/findByID.js'\nexport { findVersionByIDOperation } from './collections/operations/findVersionByID.js'\nexport { findVersionsOperation } from './collections/operations/findVersions.js'\nexport { restoreVersionOperation } from './collections/operations/restoreVersion.js'\nexport { updateOperation } from './collections/operations/update.js'\nexport { updateByIDOperation } from './collections/operations/updateByID.js'\nexport { buildConfig } from './config/build.js'\nexport {\n  type ClientConfig,\n  createClientConfig,\n  type CreateClientConfigArgs,\n  createUnauthenticatedClientConfig,\n  serverOnlyAdminConfigProperties,\n  serverOnlyConfigProperties,\n  type UnauthenticatedClientConfig,\n} from './config/client.js'\nexport { defaults } from './config/defaults.js'\n\nexport { type OrderableEndpointBody } from './config/orderable/index.js'\nexport { sanitizeConfig } from './config/sanitize.js'\nexport type * from './config/types.js'\nexport { combineQueries } from './database/combineQueries.js'\nexport { createDatabaseAdapter } from './database/createDatabaseAdapter.js'\nexport { defaultBeginTransaction } from './database/defaultBeginTransaction.js'\nexport { flattenWhereToOperators } from './database/flattenWhereToOperators.js'\nexport { getLocalizedPaths } from './database/getLocalizedPaths.js'\nexport { createMigration } from './database/migrations/createMigration.js'\nexport { findMigrationDir } from './database/migrations/findMigrationDir.js'\nexport { getMigrations } from './database/migrations/getMigrations.js'\nexport { getPredefinedMigration } from './database/migrations/getPredefinedMigration.js'\nexport { migrate } from './database/migrations/migrate.js'\nexport { migrateDown } from './database/migrations/migrateDown.js'\nexport { migrateRefresh } from './database/migrations/migrateRefresh.js'\nexport { migrateReset } from './database/migrations/migrateReset.js'\nexport { migrateStatus } from './database/migrations/migrateStatus.js'\nexport { migrationsCollection } from './database/migrations/migrationsCollection.js'\nexport { migrationTemplate } from './database/migrations/migrationTemplate.js'\nexport { readMigrationFiles } from './database/migrations/readMigrationFiles.js'\nexport { writeMigrationIndex } from './database/migrations/writeMigrationIndex.js'\nexport type * from './database/queryValidation/types.js'\nexport type { EntityPolicies, PathToQuery } from './database/queryValidation/types.js'\nexport { validateQueryPaths } from './database/queryValidation/validateQueryPaths.js'\nexport { validateSearchParam } from './database/queryValidation/validateSearchParams.js'\nexport type {\n  BaseDatabaseAdapter,\n  BeginTransaction,\n  CommitTransaction,\n  Connect,\n  Count,\n  CountArgs,\n  CountGlobalVersionArgs,\n  CountGlobalVersions,\n  CountVersions,\n  Create,\n  CreateArgs,\n  CreateGlobal,\n  CreateGlobalArgs,\n  CreateGlobalVersion,\n  CreateGlobalVersionArgs,\n  CreateMigration,\n  CreateVersion,\n  CreateVersionArgs,\n  DatabaseAdapterResult as DatabaseAdapterObj,\n  DBIdentifierName,\n  DeleteMany,\n  DeleteManyArgs,\n  DeleteOne,\n  DeleteOneArgs,\n  DeleteVersions,\n  DeleteVersionsArgs,\n  Destroy,\n  Find,\n  FindArgs,\n  FindDistinct,\n  FindGlobal,\n  FindGlobalArgs,\n  FindGlobalVersions,\n  FindGlobalVersionsArgs,\n  FindOne,\n  FindOneArgs,\n  FindVersions,\n  FindVersionsArgs,\n  GenerateSchema,\n  Init,\n  Migration,\n  MigrationData,\n  MigrationTemplateArgs,\n  PaginatedDistinctDocs,\n  PaginatedDocs,\n  QueryDrafts,\n  QueryDraftsArgs,\n  RollbackTransaction,\n  Transaction,\n  UpdateGlobal,\n  UpdateGlobalArgs,\n  UpdateGlobalVersion,\n  UpdateGlobalVersionArgs,\n  UpdateJobs,\n  UpdateJobsArgs,\n  UpdateMany,\n  UpdateManyArgs,\n  UpdateOne,\n  UpdateOneArgs,\n  UpdateVersion,\n  UpdateVersionArgs,\n  Upsert,\n  UpsertArgs,\n} from './database/types.js'\nexport type { DynamicMigrationTemplate } from './database/types.js'\nexport type { EmailAdapter as PayloadEmailAdapter, SendEmailOptions } from './email/types.js'\n\nexport {\n  APIError,\n  APIErrorName,\n  AuthenticationError,\n  DuplicateCollection,\n  DuplicateFieldName,\n  DuplicateGlobal,\n  ErrorDeletingFile,\n  FileRetrievalError,\n  FileUploadError,\n  Forbidden,\n  InvalidConfiguration,\n  InvalidFieldName,\n  InvalidFieldRelationship,\n  Locked,\n  LockedAuth,\n  MissingCollectionLabel,\n  MissingEditorProp,\n  MissingFieldInputOptions,\n  MissingFieldType,\n  MissingFile,\n  NotFound,\n  QueryError,\n  UnauthorizedError,\n  UnverifiedEmail,\n  ValidationError,\n  ValidationErrorName,\n} from './errors/index.js'\nexport type { ValidationFieldError } from './errors/index.js'\n\nexport { baseBlockFields } from './fields/baseFields/baseBlockFields.js'\n\nexport { baseIDField } from './fields/baseFields/baseIDField.js'\nexport { slugField, type SlugFieldClientProps } from './fields/baseFields/slug/index.js'\n\nexport { type SlugField } from './fields/baseFields/slug/index.js'\n\nexport {\n  createClientField,\n  createClientFields,\n  type ServerOnlyFieldAdminProperties,\n  type ServerOnlyFieldProperties,\n} from './fields/config/client.js'\n\nexport interface FieldCustom extends Record<string, any> {}\n\nexport interface CollectionCustom extends Record<string, any> {}\n\nexport interface CollectionAdminCustom extends Record<string, any> {}\n\nexport interface GlobalCustom extends Record<string, any> {}\n\nexport interface GlobalAdminCustom extends Record<string, any> {}\n\nexport { sanitizeFields } from './fields/config/sanitize.js'\n\nexport type {\n  AdminClient,\n  ArrayField,\n  ArrayFieldClient,\n  BaseValidateOptions,\n  Block,\n  BlockJSX,\n  BlocksField,\n  BlocksFieldClient,\n  CheckboxField,\n  CheckboxFieldClient,\n  ClientBlock,\n  ClientField,\n  ClientFieldProps,\n  CodeField,\n  CodeFieldClient,\n  CollapsibleField,\n  CollapsibleFieldClient,\n  Condition,\n  DateField,\n  DateFieldClient,\n  EmailField,\n  EmailFieldClient,\n  Field,\n  FieldAccess,\n  FieldAffectingData,\n  FieldAffectingDataClient,\n  FieldBase,\n  FieldBaseClient,\n  FieldHook,\n  FieldHookArgs,\n  FieldPresentationalOnly,\n  FieldPresentationalOnlyClient,\n  FieldTypes,\n  FieldWithMany,\n  FieldWithManyClient,\n  FieldWithMaxDepth,\n  FieldWithMaxDepthClient,\n  FieldWithPath,\n  FieldWithPathClient,\n  FieldWithSubFields,\n  FieldWithSubFieldsClient,\n  FilterOptions,\n  FilterOptionsProps,\n  FlattenedArrayField,\n  FlattenedBlock,\n  FlattenedBlocksField,\n  FlattenedField,\n  FlattenedGroupField,\n  FlattenedJoinField,\n  FlattenedTabAsField,\n  GroupField,\n  GroupFieldClient,\n  HookName,\n  JoinField,\n  JoinFieldClient,\n  JSONField,\n  JSONFieldClient,\n  Labels,\n  LabelsClient,\n  NamedGroupField,\n  NamedGroupFieldClient,\n  NamedTab,\n  NonPresentationalField,\n  NonPresentationalFieldClient,\n  NumberField,\n  NumberFieldClient,\n  Option,\n  OptionLabel,\n  OptionObject,\n  PointField,\n  PointFieldClient,\n  PolymorphicRelationshipField,\n  PolymorphicRelationshipFieldClient,\n  RadioField,\n  RadioFieldClient,\n  RelationshipField,\n  RelationshipFieldClient,\n  RelationshipValue,\n  RichTextField,\n  RichTextFieldClient,\n  RowField,\n  RowFieldClient,\n  SelectField,\n  SelectFieldClient,\n  SingleRelationshipField,\n  SingleRelationshipFieldClient,\n  Tab,\n  TabAsField,\n  TabAsFieldClient,\n  TabsField,\n  TabsFieldClient,\n  TextareaField,\n  TextareaFieldClient,\n  TextField,\n  TextFieldClient,\n  UIField,\n  UIFieldClient,\n  UnnamedGroupField,\n  UnnamedGroupFieldClient,\n  UnnamedTab,\n  UploadField,\n  UploadFieldClient,\n  Validate,\n  ValidateOptions,\n  ValueWithRelation,\n} from './fields/config/types.js'\n\nexport { getDefaultValue } from './fields/getDefaultValue.js'\nexport { traverseFields as afterChangeTraverseFields } from './fields/hooks/afterChange/traverseFields.js'\n\nexport { promise as afterReadPromise } from './fields/hooks/afterRead/promise.js'\nexport { traverseFields as afterReadTraverseFields } from './fields/hooks/afterRead/traverseFields.js'\nexport { traverseFields as beforeChangeTraverseFields } from './fields/hooks/beforeChange/traverseFields.js'\nexport { traverseFields as beforeValidateTraverseFields } from './fields/hooks/beforeValidate/traverseFields.js'\n\nexport { sortableFieldTypes } from './fields/sortableFieldTypes.js'\nexport { validateBlocksFilterOptions, validations } from './fields/validations.js'\n\nexport type {\n  ArrayFieldValidation,\n  BlocksFieldValidation,\n  CheckboxFieldValidation,\n  CodeFieldValidation,\n  ConfirmPasswordFieldValidation,\n  DateFieldValidation,\n  EmailFieldValidation,\n  JSONFieldValidation,\n  NumberFieldManyValidation,\n  NumberFieldSingleValidation,\n  NumberFieldValidation,\n  PasswordFieldValidation,\n  PointFieldValidation,\n  RadioFieldValidation,\n  RelationshipFieldManyValidation,\n  RelationshipFieldSingleValidation,\n  RelationshipFieldValidation,\n  RichTextFieldValidation,\n  SelectFieldManyValidation,\n  SelectFieldSingleValidation,\n  SelectFieldValidation,\n  TextareaFieldValidation,\n  TextFieldManyValidation,\n  TextFieldSingleValidation,\n  TextFieldValidation,\n  UploadFieldManyValidation,\n  UploadFieldSingleValidation,\n  UploadFieldValidation,\n  UsernameFieldValidation,\n} from './fields/validations.js'\nexport type { FolderSortKeys } from './folders/types.js'\nexport { getFolderData } from './folders/utils/getFolderData.js'\nexport {\n  type ClientGlobalConfig,\n  createClientGlobalConfig,\n  createClientGlobalConfigs,\n  type ServerOnlyGlobalAdminProperties,\n  type ServerOnlyGlobalProperties,\n} from './globals/config/client.js'\nexport type {\n  AfterChangeHook as GlobalAfterChangeHook,\n  AfterReadHook as GlobalAfterReadHook,\n  BeforeChangeHook as GlobalBeforeChangeHook,\n  BeforeOperationHook as GlobalBeforeOperationHook,\n  BeforeReadHook as GlobalBeforeReadHook,\n  BeforeValidateHook as GlobalBeforeValidateHook,\n  DataFromGlobalSlug,\n  GlobalAdminOptions,\n  GlobalConfig,\n  SanitizedGlobalConfig,\n} from './globals/config/types.js'\nexport { docAccessOperation as docAccessOperationGlobal } from './globals/operations/docAccess.js'\nexport { findOneOperation } from './globals/operations/findOne.js'\n\nexport { findVersionByIDOperation as findVersionByIDOperationGlobal } from './globals/operations/findVersionByID.js'\n\nexport { findVersionsOperation as findVersionsOperationGlobal } from './globals/operations/findVersions.js'\nexport { restoreVersionOperation as restoreVersionOperationGlobal } from './globals/operations/restoreVersion.js'\nexport { updateOperation as updateOperationGlobal } from './globals/operations/update.js'\nexport * from './kv/adapters/DatabaseKVAdapter.js'\nexport * from './kv/adapters/InMemoryKVAdapter.js'\nexport * from './kv/index.js'\nexport type {\n  CollapsedPreferences,\n  CollectionPreferences,\n  /**\n   * @deprecated Use `CollectionPreferences` instead.\n   */\n  CollectionPreferences as ListPreferences,\n  ColumnPreference,\n  DocumentPreferences,\n  FieldsPreferences,\n  InsideFieldsPreferences,\n  PreferenceRequest,\n  PreferenceUpdateRequest,\n  TabsPreferences,\n} from './preferences/types.js'\nexport type { QueryPreset } from './query-presets/types.js'\nexport { jobAfterRead } from './queues/config/collection.js'\nexport type { JobsConfig, RunJobAccess, RunJobAccessArgs } from './queues/config/types/index.js'\nexport type {\n  RunInlineTaskFunction,\n  RunTaskFunction,\n  RunTaskFunctions,\n  TaskConfig,\n  TaskHandler,\n  TaskHandlerArgs,\n  TaskHandlerResult,\n  TaskHandlerResults,\n  TaskInput,\n  TaskOutput,\n  TaskType,\n} from './queues/config/types/taskTypes.js'\nexport type {\n  BaseJob,\n  ConcurrencyConfig,\n  JobLog,\n  JobTaskStatus,\n  RunningJob,\n  SingleTaskStatus,\n  WorkflowConfig,\n  WorkflowHandler,\n  WorkflowTypes,\n} from './queues/config/types/workflowTypes.js'\n\nexport { JobCancelledError } from './queues/errors/index.js'\nexport { countRunnableOrActiveJobsForQueue } from './queues/operations/handleSchedules/countRunnableOrActiveJobsForQueue.js'\nexport { importHandlerPath } from './queues/operations/runJobs/runJob/importHandlerPath.js'\n\nexport {\n  _internal_jobSystemGlobals,\n  _internal_resetJobSystemGlobals,\n  getCurrentDate,\n} from './queues/utilities/getCurrentDate.js'\nexport { getLocalI18n } from './translations/getLocalI18n.js'\nexport * from './types/index.js'\nexport { getFileByPath } from './uploads/getFileByPath.js'\nexport { _internal_safeFetchGlobal } from './uploads/safeFetch.js'\n\nexport type * from './uploads/types.js'\nexport { addDataAndFileToRequest } from './utilities/addDataAndFileToRequest.js'\nexport { addLocalesToRequestFromData, sanitizeLocales } from './utilities/addLocalesToRequest.js'\nexport { canAccessAdmin } from './utilities/canAccessAdmin.js'\nexport { commitTransaction } from './utilities/commitTransaction.js'\nexport {\n  configToJSONSchema,\n  entityToJSONSchema,\n  fieldsToJSONSchema,\n  withNullableJSONSchemaType,\n} from './utilities/configToJSONSchema.js'\nexport { createArrayFromCommaDelineated } from './utilities/createArrayFromCommaDelineated.js'\nexport { createLocalReq } from './utilities/createLocalReq.js'\nexport { createPayloadRequest } from './utilities/createPayloadRequest.js'\nexport {\n  deepCopyObject,\n  deepCopyObjectComplex,\n  deepCopyObjectSimple,\n} from './utilities/deepCopyObject.js'\nexport {\n  deepMerge,\n  deepMergeWithCombinedArrays,\n  deepMergeWithReactComponents,\n  deepMergeWithSourceArrays,\n} from './utilities/deepMerge.js'\nexport {\n  checkDependencies,\n  type CustomVersionParser,\n} from './utilities/dependencies/dependencyChecker.js'\nexport { getDependencies } from './utilities/dependencies/getDependencies.js'\nexport { dynamicImport } from './utilities/dynamicImport.js'\nexport {\n  findUp,\n  findUpSync,\n  pathExistsAndIsAccessible,\n  pathExistsAndIsAccessibleSync,\n} from './utilities/findUp.js'\nexport { flattenAllFields } from './utilities/flattenAllFields.js'\nexport { flattenTopLevelFields } from './utilities/flattenTopLevelFields.js'\nexport { formatErrors } from './utilities/formatErrors.js'\nexport { formatLabels, formatNames, toWords } from './utilities/formatLabels.js'\nexport { getBlockSelect } from './utilities/getBlockSelect.js'\nexport { getCollectionIDFieldTypes } from './utilities/getCollectionIDFieldTypes.js'\nexport { getFieldByPath } from './utilities/getFieldByPath.js'\nexport { getObjectDotNotation } from './utilities/getObjectDotNotation.js'\nexport { getRequestLanguage } from './utilities/getRequestLanguage.js'\nexport { handleEndpoints } from './utilities/handleEndpoints.js'\nexport { headersWithCors } from './utilities/headersWithCors.js'\nexport { initTransaction } from './utilities/initTransaction.js'\nexport { isEntityHidden } from './utilities/isEntityHidden.js'\nexport { isolateObjectProperty } from './utilities/isolateObjectProperty.js'\nexport { isPlainObject } from './utilities/isPlainObject.js'\nexport { isValidID } from './utilities/isValidID.js'\nexport { killTransaction } from './utilities/killTransaction.js'\nexport { logError } from './utilities/logError.js'\nexport { defaultLoggerOptions } from './utilities/logger.js'\nexport { mapAsync } from './utilities/mapAsync.js'\nexport { mergeHeaders } from './utilities/mergeHeaders.js'\nexport { parseDocumentID } from './utilities/parseDocumentID.js'\nexport { sanitizeFallbackLocale } from './utilities/sanitizeFallbackLocale.js'\nexport { sanitizeJoinParams } from './utilities/sanitizeJoinParams.js'\nexport { sanitizePopulateParam } from './utilities/sanitizePopulateParam.js'\nexport { sanitizeSelectParam } from './utilities/sanitizeSelectParam.js'\nexport { stripUnselectedFields } from './utilities/stripUnselectedFields.js'\nexport { traverseFields } from './utilities/traverseFields.js'\nexport type { TraverseFieldsCallback } from './utilities/traverseFields.js'\nexport { buildVersionCollectionFields } from './versions/buildCollectionFields.js'\nexport { buildVersionGlobalFields } from './versions/buildGlobalFields.js'\nexport { buildVersionCompoundIndexes } from './versions/buildVersionCompoundIndexes.js'\nexport { versionDefaults } from './versions/defaults.js'\nexport { deleteCollectionVersions } from './versions/deleteCollectionVersions.js'\n\nexport { appendVersionToQueryKey } from './versions/drafts/appendVersionToQueryKey.js'\nexport { getQueryDraftsSort } from './versions/drafts/getQueryDraftsSort.js'\nexport { enforceMaxVersions } from './versions/enforceMaxVersions.js'\nexport { getLatestCollectionVersion } from './versions/getLatestCollectionVersion.js'\nexport { getLatestGlobalVersion } from './versions/getLatestGlobalVersion.js'\nexport { localizeStatus } from './versions/migrations/localizeStatus/index.js'\nexport type {\n  MongoLocalizeStatusArgs,\n  SqlLocalizeStatusArgs,\n} from './versions/migrations/localizeStatus/index.js'\nexport { saveVersion } from './versions/saveVersion.js'\nexport type { SchedulePublishTaskInput } from './versions/schedule/types.js'\n\nexport type { SchedulePublish, TypeWithVersion } from './versions/types.js'\nexport { deepMergeSimple } from '@payloadcms/translations/utilities'\n"],"names":["spawn","crypto","fileURLToPath","path","WebSocket","forgotPasswordLocal","loginLocal","resetPasswordLocal","unlockLocal","verifyEmailLocal","countLocal","createLocal","deleteLocal","duplicateLocal","findLocal","findByIDLocal","findDistinct","findDistinctLocal","findVersionByIDLocal","findVersionsLocal","restoreVersionLocal","updateLocal","countGlobalVersionsLocal","findOneGlobalLocal","findGlobalVersionByIDLocal","findGlobalVersionsLocal","restoreGlobalVersionLocal","updateGlobalLocal","EntityType","Cron","decrypt","encrypt","authLocal","APIKeyAuthentication","JWTAuthentication","generateImportMap","checkPayloadDependencies","countVersionsLocal","consoleEmailAdapter","fieldAffectsData","getJobsLocalAPI","_internal_jobSystemGlobals","formatAdminURL","isNextBuild","getLogger","serverInit","serverInitTelemetry","traverseFields","accountLockFields","baseAccountLockFields","apiKeyFields","baseAPIKeyFields","baseAuthFields","emailFieldConfig","baseEmailField","sessionsFieldConfig","baseSessionsField","usernameFieldConfig","baseUsernameField","verificationFields","baseVerificationFields","executeAccess","executeAuthStrategies","extractAccessFromPermission","getAccessResults","getFieldsToSign","getLoginOptions","filename","url","dirname","checkedDependencies","BasePayload","auth","options","authStrategies","blocks","collections","config","count","countGlobalVersions","countVersions","create","crons","db","destroy","length","cronsToStop","splice","Promise","all","map","cron","stop","duplicate","email","extensions","find","findByID","findGlobal","findGlobalVersionByID","findGlobalVersions","findVersionByID","findVersions","forgotPassword","getAdminURL","adminRoute","routes","admin","serverURL","getAPIURL","apiRoute","api","globals","importMap","jobs","kv","logger","login","resetPassword","restoreGlobalVersion","restoreVersion","schema","secret","sendEmail","types","unlock","updateGlobal","validationRules","verifyEmail","versions","_initializeCrons","enabled","autoRun","DEFAULT_CRON","DEFAULT_LIMIT","cronJobs","cronConfig","jobAutorunCron","shouldAutoSchedule","disableScheduling","scheduling","handleSchedules","allQueues","queue","shouldAutoRun","run","limit","silent","protect","push","bin","args","cwd","log","resolve","reject","spawned","stdio","undefined","on","code","error","delete","init","process","env","NODE_ENV","PAYLOAD_DISABLE_DEPENDENCY_CHECKER","Error","createHash","update","digest","slice","collection","customIDType","findCustomID","field","includes","type","name","callback","fields","parentIsLocalized","slug","reduce","block","typescript","autoGenerate","payload","disableDBConnect","connect","awaitedAdapter","NEXT_PHASE","warn","sharp","some","c","upload","imageSizes","formatOptions","VERCEL","uploadCollWithoutAdapter","filter","adapter","slugs","join","jwtStrategyEnabled","strategies","useAPIKey","authenticate","disableLocalStrategy","disableOnInit","onInit","err","initialized","reload","skipImportMapGeneration","ignoreResolveError","hotReload","global","_payload_clientConfigs","_payload_schemaMap","_payload_clientSchemaMap","_payload_doNotCacheClientConfig","_payload_doNotCacheSchemaMap","_payload_doNotCacheClientSchemaMap","_cached","_payload","Map","getPayload","alreadyCachedSameConfig","cached","get","key","initializedCrons","Boolean","promise","ws","set","res","DISABLE_PAYLOAD_HMR","port","PORT","hasHTTPS","USE_HTTPS","argv","protocol","prefix","__NEXT_ASSET_PREFIX","PAYLOAD_HMR_URL_OVERRIDE","onmessage","event","data","JSON","parse","action","onerror","_","e","payloadInitError","jwtSign","accessOperation","forgotPasswordOperation","initOperation","checkLoginPermission","loginOperation","logoutOperation","meOperation","refreshOperation","registerFirstUserOperation","resetPasswordOperation","unlockOperation","verifyEmailOperation","incrementLoginAttempts","resetLoginAttempts","genImportMapIterateFields","migrate","migrateCLI","createClientCollectionConfig","createClientCollectionConfigs","createDataloaderCacheKey","getDataLoader","countOperation","createOperation","deleteOperation","deleteByIDOperation","docAccessOperation","duplicateOperation","findOperation","findByIDOperation","findVersionByIDOperation","findVersionsOperation","restoreVersionOperation","updateOperation","updateByIDOperation","buildConfig","createClientConfig","createUnauthenticatedClientConfig","serverOnlyAdminConfigProperties","serverOnlyConfigProperties","defaults","sanitizeConfig","combineQueries","createDatabaseAdapter","defaultBeginTransaction","flattenWhereToOperators","getLocalizedPaths","createMigration","findMigrationDir","getMigrations","getPredefinedMigration","migrateDown","migrateRefresh","migrateReset","migrateStatus","migrationsCollection","migrationTemplate","readMigrationFiles","writeMigrationIndex","validateQueryPaths","validateSearchParam","APIError","APIErrorName","AuthenticationError","DuplicateCollection","DuplicateFieldName","DuplicateGlobal","ErrorDeletingFile","FileRetrievalError","FileUploadError","Forbidden","InvalidConfiguration","InvalidFieldName","InvalidFieldRelationship","Locked","LockedAuth","MissingCollectionLabel","MissingEditorProp","MissingFieldInputOptions","MissingFieldType","MissingFile","NotFound","QueryError","UnauthorizedError","UnverifiedEmail","ValidationError","ValidationErrorName","baseBlockFields","baseIDField","slugField","createClientField","createClientFields","sanitizeFields","getDefaultValue","afterChangeTraverseFields","afterReadPromise","afterReadTraverseFields","beforeChangeTraverseFields","beforeValidateTraverseFields","sortableFieldTypes","validateBlocksFilterOptions","validations","getFolderData","createClientGlobalConfig","createClientGlobalConfigs","docAccessOperationGlobal","findOneOperation","findVersionByIDOperationGlobal","findVersionsOperationGlobal","restoreVersionOperationGlobal","updateOperationGlobal","jobAfterRead","JobCancelledError","countRunnableOrActiveJobsForQueue","importHandlerPath","_internal_resetJobSystemGlobals","getCurrentDate","getLocalI18n","getFileByPath","_internal_safeFetchGlobal","addDataAndFileToRequest","addLocalesToRequestFromData","sanitizeLocales","canAccessAdmin","commitTransaction","configToJSONSchema","entityToJSONSchema","fieldsToJSONSchema","withNullableJSONSchemaType","createArrayFromCommaDelineated","createLocalReq","createPayloadRequest","deepCopyObject","deepCopyObjectComplex","deepCopyObjectSimple","deepMerge","deepMergeWithCombinedArrays","deepMergeWithReactComponents","deepMergeWithSourceArrays","checkDependencies","getDependencies","dynamicImport","findUp","findUpSync","pathExistsAndIsAccessible","pathExistsAndIsAccessibleSync","flattenAllFields","flattenTopLevelFields","formatErrors","formatLabels","formatNames","toWords","getBlockSelect","getCollectionIDFieldTypes","getFieldByPath","getObjectDotNotation","getRequestLanguage","handleEndpoints","headersWithCors","initTransaction","isEntityHidden","isolateObjectProperty","isPlainObject","isValidID","killTransaction","logError","defaultLoggerOptions","mapAsync","mergeHeaders","parseDocumentID","sanitizeFallbackLocale","sanitizeJoinParams","sanitizePopulateParam","sanitizeSelectParam","stripUnselectedFields","buildVersionCollectionFields","buildVersionGlobalFields","buildVersionCompoundIndexes","versionDefaults","deleteCollectionVersions","appendVersionToQueryKey","getQueryDraftsSort","enforceMaxVersions","getLatestCollectionVersion","getLatestGlobalVersion","localizeStatus","saveVersion","deepMergeSimple"],"mappings":"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"}}]
}