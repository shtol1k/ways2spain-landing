{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/uploads/fetchAPI-multipart/isEligibleRequest.ts"],"sourcesContent":["// eslint-disable-next-line regexp/no-super-linear-backtracking, regexp/no-obscure-range\nconst ACCEPTABLE_CONTENT_TYPE = /multipart\\/['\"()+-_]+(?:; ?['\"()+-_]*)+$/i\nconst UNACCEPTABLE_METHODS = new Set(['CONNECT', 'DELETE', 'GET', 'HEAD', 'OPTIONS', 'TRACE'])\n\nconst hasBody = (req: Request): boolean => {\n  return Boolean(\n    req.headers.get('transfer-encoding') ||\n      (req.headers.get('content-length') && req.headers.get('content-length') !== '0'),\n  )\n}\n\nconst hasAcceptableMethod = (req: Request): boolean => !UNACCEPTABLE_METHODS.has(req.method)\n\nconst hasAcceptableContentType = (req: Request): boolean => {\n  const contType = req.headers.get('content-type')\n  return contType!.includes('boundary=') && ACCEPTABLE_CONTENT_TYPE.test(contType!)\n}\n\nexport const isEligibleRequest = (req: Request): boolean => {\n  try {\n    return hasBody(req) && hasAcceptableMethod(req) && hasAcceptableContentType(req)\n  } catch (ignore) {\n    return false\n  }\n}\n"],"names":["ACCEPTABLE_CONTENT_TYPE","UNACCEPTABLE_METHODS","Set","hasBody","req","Boolean","headers","get","hasAcceptableMethod","has","method","hasAcceptableContentType","contType","includes","test","isEligibleRequest","ignore"],"mappings":";;;;AAAA,wFAAwF;AACxF,MAAMA,0BAA0B;AAChC,MAAMC,uBAAuB,IAAIC,IAAI;IAAC;IAAW;IAAU;IAAO;IAAQ;IAAW;CAAQ;AAE7F,MAAMC,UAAU,CAACC;IACf,OAAOC,QACLD,IAAIE,OAAO,CAACC,GAAG,CAAC,wBACbH,IAAIE,OAAO,CAACC,GAAG,CAAC,qBAAqBH,IAAIE,OAAO,CAACC,GAAG,CAAC,sBAAsB;AAElF;AAEA,MAAMC,sBAAsB,CAACJ,MAA0B,CAACH,qBAAqBQ,GAAG,CAACL,IAAIM,MAAM;AAE3F,MAAMC,2BAA2B,CAACP;IAChC,MAAMQ,WAAWR,IAAIE,OAAO,CAACC,GAAG,CAAC;IACjC,OAAOK,SAAUC,QAAQ,CAAC,gBAAgBb,wBAAwBc,IAAI,CAACF;AACzE;AAEO,MAAMG,oBAAoB,CAACX;IAChC,IAAI;QACF,OAAOD,QAAQC,QAAQI,oBAAoBJ,QAAQO,yBAAyBP;IAC9E,EAAE,OAAOY,QAAQ;QACf,OAAO;IACT;AACF,EAAC"}},
    {"offset": {"line": 37, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/uploads/fetchAPI-multipart/utilities.ts"],"sourcesContent":["import fs from 'fs'\nimport path from 'path'\nimport { Readable } from 'stream'\n\nimport type { FetchAPIFileUploadOptions } from '../../config/types.js'\n\n// Parameters for safe file name parsing.\nconst SAFE_FILE_NAME_REGEX = /[^\\w-]/g\nconst MAX_EXTENSION_LENGTH = 3\n\n// Parameters to generate unique temporary file names:\nconst TEMP_COUNTER_MAX = 65536\nconst TEMP_PREFIX = 'tmp'\nlet tempCounter = 0\n\n/**\n * Logs message to console if options.debug option set to true.\n */\nexport const debugLog = (options: FetchAPIFileUploadOptions, msg: string) => {\n  const opts = options || {}\n  if (!opts.debug) {\n    return false\n  }\n  console.log(`Next-file-upload: ${msg}`) // eslint-disable-line\n  return true\n}\n\n/**\n * Generates unique temporary file name. e.g. tmp-5000-156788789789.\n */\nexport const getTempFilename = (prefix: string = TEMP_PREFIX) => {\n  tempCounter = tempCounter >= TEMP_COUNTER_MAX ? 1 : tempCounter + 1\n  return `${prefix}-${tempCounter}-${Date.now()}`\n}\n\ntype FuncType = (...args: any[]) => any\nexport const isFunc = (value: any): value is FuncType => {\n  return typeof value === 'function'\n}\n\n/**\n * Set errorFunc to the same value as successFunc for callback mode.\n */\ntype ErrorFunc = (resolve: () => void, reject: (err: Error) => void) => (err: Error) => void\nconst errorFunc: ErrorFunc = (resolve, reject) => (isFunc(reject) ? reject : resolve)\n\n/**\n * Return a callback function for promise resole/reject args.\n * Ensures that callback is called only once.\n */\ntype PromiseCallback = (resolve: () => void, reject: (err: Error) => void) => (err: Error) => void\nexport const promiseCallback: PromiseCallback = (resolve, reject) => {\n  let hasFired = false\n  return (err: Error) => {\n    if (hasFired) {\n      return\n    }\n\n    hasFired = true\n    return err ? errorFunc(resolve, reject)(err) : resolve()\n  }\n}\n\n// The default prototypes for both objects and arrays.\n// Used by isSafeFromPollution\nconst OBJECT_PROTOTYPE_KEYS = Object.getOwnPropertyNames(Object.prototype)\nconst ARRAY_PROTOTYPE_KEYS = Object.getOwnPropertyNames(Array.prototype)\n\n/**\n * Determines whether a key insertion into an object could result in a prototype pollution\n */\ntype IsSafeFromPollution = (base: any, key: string) => boolean\nexport const isSafeFromPollution: IsSafeFromPollution = (base, key) => {\n  // We perform an instanceof check instead of Array.isArray as the former is more\n  // permissive for cases in which the object as an Array prototype but was not constructed\n  // via an Array constructor or literal.\n  const TOUCHES_ARRAY_PROTOTYPE = base instanceof Array && ARRAY_PROTOTYPE_KEYS.includes(key)\n  const TOUCHES_OBJECT_PROTOTYPE = OBJECT_PROTOTYPE_KEYS.includes(key)\n\n  return !TOUCHES_ARRAY_PROTOTYPE && !TOUCHES_OBJECT_PROTOTYPE\n}\n\n/**\n * Build request field/file objects to return\n */\ntype BuildFields = (instance: any, field: string, value: any) => any\nexport const buildFields: BuildFields = (instance, field, value) => {\n  // Do nothing if value is not set.\n  if (value === null || value === undefined) {\n    return instance\n  }\n  instance = instance || Object.create(null)\n\n  if (!isSafeFromPollution(instance, field)) {\n    return instance\n  }\n  // Non-array fields\n  if (!instance[field]) {\n    instance[field] = value\n    return instance\n  }\n  // Array fields\n  if (instance[field] instanceof Array) {\n    instance[field].push(value)\n  } else {\n    instance[field] = [instance[field], value]\n  }\n  return instance\n}\n\n/**\n * Creates a folder if it does not exist\n * for file specified in the path variable\n */\ntype CheckAndMakeDir = (fileUploadOptions: FetchAPIFileUploadOptions, filePath: string) => boolean\nexport const checkAndMakeDir: CheckAndMakeDir = (fileUploadOptions, filePath) => {\n  if (!fileUploadOptions.createParentPath) {\n    return false\n  }\n  // Check whether folder for the file exists.\n  const parentPath = path.dirname(filePath)\n  // Create folder if it doesn't exist.\n  if (!fs.existsSync(parentPath)) {\n    fs.mkdirSync(parentPath, { recursive: true })\n  }\n  // Checks folder again and return a results.\n  return fs.existsSync(parentPath)\n}\n\n/**\n * Delete a file.\n */\ntype DeleteFile = (filePath: string, callback: (args: any) => void) => void\nexport const deleteFile: DeleteFile = (filePath, callback) => fs.unlink(filePath, callback)\n\n/**\n * Copy file via streams\n */\ntype CopyFile = (src: string, dst: string, callback: (err: Error) => void) => void\nconst copyFile: CopyFile = (src, dst, callback) => {\n  // cbCalled flag and runCb helps to run cb only once.\n  let cbCalled = false\n  const runCb = (err?: Error) => {\n    if (cbCalled) {\n      return\n    }\n    cbCalled = true\n    callback(err!)\n  }\n  // Create read stream\n  const readable = fs.createReadStream(src)\n  readable.on('error', runCb)\n  // Create write stream\n  const writable = fs.createWriteStream(dst)\n  writable.on('error', (err: Error) => {\n    readable.destroy()\n    runCb(err)\n  })\n  writable.on('close', () => runCb())\n  // Copy file via piping streams.\n  readable.pipe(writable)\n}\n\n/**\n * moveFile: moves the file from src to dst.\n * Firstly trying to rename the file if no luck copying it to dst and then deleting src.\n */\ntype MoveFile = (\n  src: string,\n  dst: string,\n  callback: (err: Error, renamed?: boolean) => void,\n) => void\nexport const moveFile: MoveFile = (src, dst, callback) =>\n  fs.rename(src, dst, (err) => {\n    if (err) {\n      // Try to copy file if rename didn't work.\n      copyFile(src, dst, (cpErr) => (cpErr ? callback(cpErr) : deleteFile(src, callback)))\n      return\n    }\n    // File was renamed successfully: Add true to the callback to indicate that.\n    callback(null!, true)\n  })\n\n/**\n * Save buffer data to a file.\n * @param {Buffer} buffer - buffer to save to a file.\n * @param {string} filePath - path to a file.\n */\nexport const saveBufferToFile = (\n  buffer: Buffer,\n  filePath: string,\n  callback: (err?: Error) => void,\n) => {\n  if (!Buffer.isBuffer(buffer)) {\n    return callback(new Error('buffer variable should be type of Buffer!'))\n  }\n  // Setup readable stream from buffer.\n  let streamData = buffer\n  const readStream = new Readable()\n  readStream._read = () => {\n    readStream.push(streamData)\n    streamData = null!\n  }\n  // Setup file system writable stream.\n  const fstream = fs.createWriteStream(filePath)\n  // console.log(\"Calling saveBuffer\");\n  fstream.on('error', (err) => {\n    // console.log(\"err cb\")\n    callback(err)\n  })\n  fstream.on('close', () => {\n    // console.log(\"close cb\");\n    callback()\n  })\n  // Copy file via piping streams.\n  readStream.pipe(fstream)\n}\n\n/**\n * Decodes uriEncoded file names.\n * @param {Object} opts - middleware options.\n * @param fileName {String} - file name to decode.\n * @returns {String}\n */\nconst uriDecodeFileName = (opts: FetchAPIFileUploadOptions, fileName: string) => {\n  if (!opts || !opts.uriDecodeFileNames) {\n    return fileName\n  }\n  // Decode file name from URI with checking URI malformed errors.\n  // See Issue https://github.com/richardgirges/express-fileupload/issues/342.\n  try {\n    return decodeURIComponent(fileName)\n  } catch (ignore) {\n    const matcher = /(%[a-f\\d]{2})/gi\n    return fileName\n      .split(matcher)\n      .map((str) => {\n        try {\n          return decodeURIComponent(str)\n        } catch (ignore) {\n          return ''\n        }\n      })\n      .join('')\n  }\n}\n\n/**\n * Parses filename and extension and returns object {name, extension}.\n */\ntype ParseFileNameExtension = (\n  preserveExtension: boolean | number,\n  fileName: string,\n) => {\n  extension: string\n  name: string\n}\nexport const parseFileNameExtension: ParseFileNameExtension = (preserveExtension, fileName) => {\n  const defaultResult = {\n    name: fileName,\n    extension: '',\n  }\n  if (!preserveExtension) {\n    return defaultResult\n  }\n\n  // Define maximum extension length\n  const maxExtLength =\n    typeof preserveExtension === 'boolean' ? MAX_EXTENSION_LENGTH : preserveExtension\n\n  const nameParts = fileName.split('.')\n  if (nameParts.length < 2) {\n    return defaultResult\n  }\n\n  let extension = nameParts.pop()\n  if (extension!.length > maxExtLength && maxExtLength > 0) {\n    nameParts[nameParts.length - 1] += '.' + extension!.substr(0, extension!.length - maxExtLength)\n    extension = extension!.substr(-maxExtLength)\n  }\n\n  return {\n    name: nameParts.join('.'),\n    extension: maxExtLength ? extension! : '',\n  }\n}\n\n/**\n * Parse file name and extension.\n */\ntype ParseFileName = (opts: FetchAPIFileUploadOptions, fileName: string) => string\nexport const parseFileName: ParseFileName = (opts, fileName) => {\n  // Check fileName argument\n  if (!fileName || typeof fileName !== 'string') {\n    return getTempFilename()\n  }\n  // Cut off file name if it's length more then 255.\n  let parsedName = fileName.length <= 255 ? fileName : fileName.substr(0, 255)\n  // Decode file name if uriDecodeFileNames option set true.\n  parsedName = uriDecodeFileName(opts, parsedName)\n  // Stop parsing file name if safeFileNames options hasn't been set.\n  if (!opts.safeFileNames) {\n    return parsedName\n  }\n  // Set regular expression for the file name.\n  const nameRegex =\n    typeof opts.safeFileNames === 'object' && opts.safeFileNames instanceof RegExp\n      ? opts.safeFileNames\n      : SAFE_FILE_NAME_REGEX\n  // Parse file name extension.\n  const parsedFileName = parseFileNameExtension(opts.preserveExtension!, parsedName)\n  if (parsedFileName.extension.length) {\n    parsedFileName.extension = '.' + parsedFileName.extension.replace(nameRegex, '')\n  }\n\n  return parsedFileName.name.replace(nameRegex, '').concat(parsedFileName.extension)\n}\n"],"names":["fs","path","Readable","SAFE_FILE_NAME_REGEX","MAX_EXTENSION_LENGTH","TEMP_COUNTER_MAX","TEMP_PREFIX","tempCounter","debugLog","options","msg","opts","debug","console","log","getTempFilename","prefix","Date","now","isFunc","value","errorFunc","resolve","reject","promiseCallback","hasFired","err","OBJECT_PROTOTYPE_KEYS","Object","getOwnPropertyNames","prototype","ARRAY_PROTOTYPE_KEYS","Array","isSafeFromPollution","base","key","TOUCHES_ARRAY_PROTOTYPE","includes","TOUCHES_OBJECT_PROTOTYPE","buildFields","instance","field","undefined","create","push","checkAndMakeDir","fileUploadOptions","filePath","createParentPath","parentPath","dirname","existsSync","mkdirSync","recursive","deleteFile","callback","unlink","copyFile","src","dst","cbCalled","runCb","readable","createReadStream","on","writable","createWriteStream","destroy","pipe","moveFile","rename","cpErr","saveBufferToFile","buffer","Buffer","isBuffer","Error","streamData","readStream","_read","fstream","uriDecodeFileName","fileName","uriDecodeFileNames","decodeURIComponent","ignore","matcher","split","map","str","join","parseFileNameExtension","preserveExtension","defaultResult","name","extension","maxExtLength","nameParts","length","pop","substr","parseFileName","parsedName","safeFileNames","nameRegex","RegExp","parsedFileName","replace","concat"],"mappings":"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"}},
    {"offset": {"line": 286, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/uploads/fetchAPI-multipart/fileFactory.ts"],"sourcesContent":["import type { FetchAPIFileUploadOptions } from '../../config/types.js'\nimport type { FileShape } from './index.js'\n\nimport {\n  checkAndMakeDir,\n  debugLog,\n  isFunc,\n  moveFile,\n  promiseCallback,\n  saveBufferToFile,\n} from './utilities.js'\n\ntype MoveFile = (\n  filePath: string,\n  options: FileFactoryOptions,\n  fileUploadOptions: FetchAPIFileUploadOptions,\n) => (resolve: () => void, reject: () => void) => void\n\n/**\n * Returns Local function that moves the file to a different location on the filesystem\n * which takes two function arguments to make it compatible w/ Promise or Callback APIs\n */\nconst moveFromTemp: MoveFile = (filePath, options, fileUploadOptions) => (resolve, reject) => {\n  debugLog(fileUploadOptions, `Moving temporary file ${options.tempFilePath} to ${filePath}`)\n  moveFile(options.tempFilePath, filePath, promiseCallback(resolve, reject))\n}\n\n/**\n * Returns Local function that moves the file from buffer to a different location on the filesystem\n * which takes two function arguments to make it compatible w/ Promise or Callback APIs\n */\nconst moveFromBuffer: MoveFile = (filePath, options, fileUploadOptions) => (resolve, reject) => {\n  debugLog(fileUploadOptions, `Moving uploaded buffer to ${filePath}`)\n  // @ts-expect-error - vestiges of when tsconfig was not strict. Feel free to improve\n  saveBufferToFile(options.buffer, filePath, promiseCallback(resolve, reject))\n}\n\ntype FileFactoryOptions = {\n  buffer: Buffer\n  encoding: string\n  hash: Buffer | string\n  mimetype: string\n  name: string\n  size: number\n  tempFilePath: string\n  truncated: boolean\n}\ntype FileFactory = (\n  options: FileFactoryOptions,\n  fileUploadOptions: FetchAPIFileUploadOptions,\n) => FileShape\nexport const fileFactory: FileFactory = (options, fileUploadOptions) => {\n  // see: https://github.com/richardgirges/express-fileupload/issues/14\n  // firefox uploads empty file in case of cache miss when f5ing page.\n  // resulting in unexpected behavior. if there is no file data, the file is invalid.\n  // if (!fileUploadOptions.useTempFiles && !options.buffer.length) return;\n\n  // Create and return file object.\n  return {\n    name: options.name,\n    data: options.buffer,\n    encoding: options.encoding,\n    md5: options.hash,\n    mimetype: options.mimetype,\n    mv: (filePath: string, callback) => {\n      // Define a proper move function.\n      const moveFunc = fileUploadOptions.useTempFiles\n        ? moveFromTemp(filePath, options, fileUploadOptions)\n        : moveFromBuffer(filePath, options, fileUploadOptions)\n      // Create a folder for a file.\n      checkAndMakeDir(fileUploadOptions, filePath)\n      // If callback is passed in, use the callback API, otherwise return a promise.\n      const defaultReject = () => undefined\n      return isFunc(callback) ? moveFunc(callback, defaultReject) : new Promise(moveFunc)\n    },\n    size: options.size,\n    tempFilePath: options.tempFilePath,\n    truncated: options.truncated,\n  }\n}\n"],"names":["checkAndMakeDir","debugLog","isFunc","moveFile","promiseCallback","saveBufferToFile","moveFromTemp","filePath","options","fileUploadOptions","resolve","reject","tempFilePath","moveFromBuffer","buffer","fileFactory","name","data","encoding","md5","hash","mimetype","mv","callback","moveFunc","useTempFiles","defaultReject","undefined","Promise","size","truncated"],"mappings":";;;;AAGA,SACEA,eAAe,EACfC,QAAQ,EACRC,MAAM,EACNC,QAAQ,EACRC,eAAe,EACfC,gBAAgB,QACX,iBAAgB;;AAQvB;;;CAGC,GACD,MAAMC,eAAyB,CAACC,UAAUC,SAASC,oBAAsB,CAACC,SAASC;YACjFV,8LAAAA,EAASQ,mBAAmB,CAAC,sBAAsB,EAAED,QAAQI,YAAY,CAAC,IAAI,EAAEL,UAAU;YAC1FJ,8LAAAA,EAASK,QAAQI,YAAY,EAAEL,cAAUH,qMAAAA,EAAgBM,SAASC;IACpE;AAEA;;;CAGC,GACD,MAAME,iBAA2B,CAACN,UAAUC,SAASC,oBAAsB,CAACC,SAASC;YACnFV,8LAAAA,EAASQ,mBAAmB,CAAC,0BAA0B,EAAEF,UAAU;QACnE,oFAAoF;YACpFF,sMAAAA,EAAiBG,QAAQM,MAAM,EAAEP,cAAUH,qMAAAA,EAAgBM,SAASC;IACtE;AAgBO,MAAMI,cAA2B,CAACP,SAASC;IAChD,qEAAqE;IACrE,oEAAoE;IACpE,mFAAmF;IACnF,yEAAyE;IAEzE,iCAAiC;IACjC,OAAO;QACLO,MAAMR,QAAQQ,IAAI;QAClBC,MAAMT,QAAQM,MAAM;QACpBI,UAAUV,QAAQU,QAAQ;QAC1BC,KAAKX,QAAQY,IAAI;QACjBC,UAAUb,QAAQa,QAAQ;QAC1BC,IAAI,CAACf,UAAkBgB;YACrB,iCAAiC;YACjC,MAAMC,WAAWf,kBAAkBgB,YAAY,GAC3CnB,aAAaC,UAAUC,SAASC,qBAChCI,eAAeN,UAAUC,SAASC;YACtC,8BAA8B;gBAC9BT,qMAAAA,EAAgBS,mBAAmBF;YACnC,8EAA8E;YAC9E,MAAMmB,gBAAgB,IAAMC;YAC5B,WAAOzB,4LAAAA,EAAOqB,YAAYC,SAASD,UAAUG,iBAAiB,IAAIE,QAAQJ;QAC5E;QACAK,MAAMrB,QAAQqB,IAAI;QAClBjB,cAAcJ,QAAQI,YAAY;QAClCkB,WAAWtB,QAAQsB,SAAS;IAC9B;AACF,EAAC"}},
    {"offset": {"line": 337, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/uploads/fetchAPI-multipart/handlers.ts"],"sourcesContent":["import crypto from 'crypto'\nimport fs, { WriteStream } from 'fs'\nimport path from 'path'\n\nimport type { FetchAPIFileUploadOptions } from '../../config/types.js'\n\nimport { checkAndMakeDir, debugLog, deleteFile, getTempFilename } from './utilities.js'\n\ntype Handler = (\n  options: FetchAPIFileUploadOptions,\n  fieldname: string,\n  filename: string,\n) => {\n  cleanup: () => void\n  complete: () => Buffer\n  dataHandler: (data: Buffer) => void\n  getFilePath: () => string\n  getFileSize: () => number\n  getHash: () => string\n  getWritePromise: () => Promise<boolean>\n}\n\nexport const tempFileHandler: Handler = (options, fieldname, filename) => {\n  const dir = path.normalize(options.tempFileDir!)\n  const tempFilePath = path.join(process.cwd(), dir, getTempFilename())\n  checkAndMakeDir({ createParentPath: true }, tempFilePath)\n\n  debugLog(options, `Temporary file path is ${tempFilePath}`)\n\n  const hash = crypto.createHash('md5')\n  let fileSize = 0\n  let completed = false\n\n  debugLog(options, `Opening write stream for ${fieldname}->${filename}...`)\n  const writeStream = fs.createWriteStream(tempFilePath)\n  const writePromise = new Promise<boolean>((resolve, reject) => {\n    writeStream.on('finish', () => resolve(true))\n    writeStream.on('error', (err) => {\n      debugLog(options, `Error write temp file: ${err}`)\n      reject(err)\n    })\n  })\n\n  return {\n    cleanup: () => {\n      completed = true\n      debugLog(options, `Cleaning up temporary file ${tempFilePath}...`)\n      writeStream.end()\n      deleteFile(tempFilePath, (err) =>\n        err\n          ? debugLog(options, `Cleaning up temporary file ${tempFilePath} failed: ${err}`)\n          : debugLog(options, `Cleaning up temporary file ${tempFilePath} done.`),\n      )\n    },\n    complete: () => {\n      completed = true\n      debugLog(options, `Upload ${fieldname}->${filename} completed, bytes:${fileSize}.`)\n      if (writeStream instanceof WriteStream) {\n        writeStream.end()\n      }\n      // Return empty buff since data was uploaded into a temp file.\n      return Buffer.concat([])\n    },\n    dataHandler: (data) => {\n      if (completed === true) {\n        debugLog(options, `Error: got ${fieldname}->${filename} data chunk for completed upload!`)\n        return\n      }\n      writeStream.write(data)\n      hash.update(data)\n      fileSize += data.length\n      debugLog(options, `Uploading ${fieldname}->${filename}, bytes:${fileSize}...`)\n    },\n    getFilePath: () => tempFilePath,\n    getFileSize: () => fileSize,\n    getHash: () => hash.digest('hex'),\n    getWritePromise: () => writePromise,\n  }\n}\n\nexport const memHandler: Handler = (options, fieldname, filename) => {\n  const buffers: Buffer[] = []\n  const hash = crypto.createHash('md5')\n  let fileSize = 0\n  let completed = false\n\n  const getBuffer = () => Buffer.concat(buffers, fileSize)\n\n  return {\n    cleanup: () => {\n      completed = true\n    },\n    complete: () => {\n      debugLog(options, `Upload ${fieldname}->${filename} completed, bytes:${fileSize}.`)\n      completed = true\n      return getBuffer()\n    },\n    dataHandler: (data) => {\n      if (completed === true) {\n        debugLog(options, `Error: got ${fieldname}->${filename} data chunk for completed upload!`)\n        return\n      }\n      buffers.push(data)\n      hash.update(data)\n      fileSize += data.length\n      debugLog(options, `Uploading ${fieldname}->${filename}, bytes:${fileSize}...`)\n    },\n    getFilePath: () => '',\n    getFileSize: () => fileSize,\n    getHash: () => hash.digest('hex'),\n    getWritePromise: () => Promise.resolve(true),\n  }\n}\n"],"names":["crypto","fs","WriteStream","path","checkAndMakeDir","debugLog","deleteFile","getTempFilename","tempFileHandler","options","fieldname","filename","dir","normalize","tempFileDir","tempFilePath","join","process","cwd","createParentPath","hash","createHash","fileSize","completed","writeStream","createWriteStream","writePromise","Promise","resolve","reject","on","err","cleanup","end","complete","Buffer","concat","dataHandler","data","write","update","length","getFilePath","getFileSize","getHash","digest","getWritePromise","memHandler","buffers","getBuffer","push"],"mappings":"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"}},
    {"offset": {"line": 437, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/uploads/fetchAPI-multipart/processNested.ts"],"sourcesContent":["import { isSafeFromPollution } from './utilities.js'\n\nexport const processNested = function (data: Record<string, any>) {\n  if (!data || data.length < 1) {\n    return Object.create(null)\n  }\n\n  const d = Object.create(null),\n    keys = Object.keys(data)\n\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i]!,\n      keyParts = key?.replace(new RegExp(/\\[/g), '.').replace(new RegExp(/\\]/g), '').split('.'),\n      value = data[key]\n    let current = d\n\n    for (let index = 0; index < keyParts.length; index++) {\n      const k = keyParts[index]!\n\n      // Ensure we don't allow prototype pollution\n      if (!isSafeFromPollution(current, k)) {\n        continue\n      }\n\n      if (index >= keyParts.length - 1) {\n        current[k] = value\n      } else {\n        if (!current[k]) {\n          current[k] = !keyParts[index + 1] ? [] : Object.create(null)\n        }\n        current = current[k]\n      }\n    }\n  }\n  return d\n}\n"],"names":["isSafeFromPollution","processNested","data","length","Object","create","d","keys","i","key","keyParts","replace","RegExp","split","value","current","index","k"],"mappings":";;;;AAAA,SAASA,mBAAmB,QAAQ,iBAAgB;;AAE7C,MAAMC,gBAAgB,SAAUC,IAAyB;IAC9D,IAAI,CAACA,QAAQA,KAAKC,MAAM,GAAG,GAAG;QAC5B,OAAOC,OAAOC,MAAM,CAAC;IACvB;IAEA,MAAMC,IAAIF,OAAOC,MAAM,CAAC,OACtBE,OAAOH,OAAOG,IAAI,CAACL;IAErB,IAAK,IAAIM,IAAI,GAAGA,IAAID,KAAKJ,MAAM,EAAEK,IAAK;QACpC,MAAMC,MAAMF,IAAI,CAACC,EAAE,EACjBE,WAAWD,KAAKE,QAAQ,IAAIC,OAAO,QAAQ,KAAKD,QAAQ,IAAIC,OAAO,QAAQ,IAAIC,MAAM,MACrFC,QAAQZ,IAAI,CAACO,IAAI;QACnB,IAAIM,UAAUT;QAEd,IAAK,IAAIU,QAAQ,GAAGA,QAAQN,SAASP,MAAM,EAAEa,QAAS;YACpD,MAAMC,IAAIP,QAAQ,CAACM,MAAM;YAEzB,4CAA4C;YAC5C,IAAI,KAAChB,yMAAAA,EAAoBe,SAASE,IAAI;gBACpC;YACF;YAEA,IAAID,SAASN,SAASP,MAAM,GAAG,GAAG;gBAChCY,OAAO,CAACE,EAAE,GAAGH;YACf,OAAO;gBACL,IAAI,CAACC,OAAO,CAACE,EAAE,EAAE;oBACfF,OAAO,CAACE,EAAE,GAAG,CAACP,QAAQ,CAACM,QAAQ,EAAE,GAAG,EAAE,GAAGZ,OAAOC,MAAM,CAAC;gBACzD;gBACAU,UAAUA,OAAO,CAACE,EAAE;YACtB;QACF;IACF;IACA,OAAOX;AACT,EAAC"}},
    {"offset": {"line": 473, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/uploads/fetchAPI-multipart/uploadTimer.ts"],"sourcesContent":["type CreateUploadTimer = (\n  timeout?: number,\n  callback?: () => void,\n) => {\n  clear: () => void\n  set: () => boolean\n}\n\nexport const createUploadTimer: CreateUploadTimer = (timeout = 0, callback = () => {}) => {\n  let timer: NodeJS.Timeout | null | number = null\n\n  const clear = () => {\n    clearTimeout(timer!)\n  }\n\n  const set = () => {\n    // Do not start a timer if zero timeout or it hasn't been set.\n    if (!timeout) {\n      return false\n    }\n    clear()\n    timer = setTimeout(callback, timeout)\n    return true\n  }\n\n  return { clear, set }\n}\n"],"names":["createUploadTimer","timeout","callback","timer","clear","clearTimeout","set","setTimeout"],"mappings":";;;;AAQO,MAAMA,oBAAuC,CAACC,UAAU,CAAC,EAAEC,WAAW,KAAO,CAAC;IACnF,IAAIC,QAAwC;IAE5C,MAAMC,QAAQ;QACZC,aAAaF;IACf;IAEA,MAAMG,MAAM;QACV,8DAA8D;QAC9D,IAAI,CAACL,SAAS;YACZ,OAAO;QACT;QACAG;QACAD,QAAQI,WAAWL,UAAUD;QAC7B,OAAO;IACT;IAEA,OAAO;QAAEG;QAAOE;IAAI;AACtB,EAAC"}},
    {"offset": {"line": 500, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/uploads/fetchAPI-multipart/processMultipart.ts"],"sourcesContent":["import type { Readable } from 'stream'\n\nimport Busboy from 'busboy'\nimport { status as httpStatus } from 'http-status'\n\nimport type { FetchAPIFileUploadOptions } from '../../config/types.js'\nimport type { FetchAPIFileUploadResponse } from './index.js'\n\nimport { APIError } from '../../errors/APIError.js'\nimport { fileFactory } from './fileFactory.js'\nimport { memHandler, tempFileHandler } from './handlers.js'\nimport { processNested } from './processNested.js'\nimport { createUploadTimer } from './uploadTimer.js'\nimport { buildFields, debugLog, isFunc, parseFileName } from './utilities.js'\n\nconst waitFlushProperty = Symbol('wait flush property symbol')\n\ndeclare global {\n  interface Request {\n    [waitFlushProperty]?: Promise<any>[]\n  }\n}\n\ntype ProcessMultipart = (args: {\n  options: FetchAPIFileUploadOptions\n  request: Request\n}) => Promise<FetchAPIFileUploadResponse>\nexport const processMultipart: ProcessMultipart = async ({ options, request }) => {\n  let parsingRequest = true\n\n  let shouldAbortProccessing = false\n  let fileCount = 0\n  let filesCompleted = 0\n  let allFilesHaveResolved: (value?: unknown) => void\n  let failedResolvingFiles: (err: Error) => void\n\n  const allFilesComplete = new Promise((res, rej) => {\n    allFilesHaveResolved = res\n    failedResolvingFiles = rej\n  })\n\n  const result: FetchAPIFileUploadResponse = {\n    fields: undefined!,\n    files: undefined!,\n  }\n\n  const headersObject: Record<string, string> = {}\n  request.headers.forEach((value, name) => {\n    headersObject[name] = value\n  })\n\n  const reader = request.body?.getReader()\n\n  const busboy = Busboy({ ...options, headers: headersObject })\n\n  function abortAndDestroyFile(file: Readable, err: APIError) {\n    file.destroy()\n    shouldAbortProccessing = true\n    failedResolvingFiles(err)\n  }\n\n  // Build multipart req.body fields\n  busboy.on('field', (field, val) => {\n    result.fields = buildFields(result.fields, field, val)\n  })\n\n  // Build req.files fields\n  busboy.on('file', (field, file, info) => {\n    fileCount += 1\n    // Parse file name(cutting huge names, decoding, etc..).\n    const { encoding, filename: name, mimeType: mime } = info\n    const filename = parseFileName(options, name)\n\n    const inferredMimeType =\n      (filename && filename.endsWith('.glb') && 'model/gltf-binary') ||\n      (filename && filename.endsWith('.gltf') && 'model/gltf+json') ||\n      mime\n\n    // Define methods and handlers for upload process.\n    const { cleanup, complete, dataHandler, getFilePath, getFileSize, getHash, getWritePromise } =\n      options.useTempFiles\n        ? tempFileHandler(options, field, filename) // Upload into temporary file.\n        : memHandler(options, field, filename) // Upload into RAM.\n\n    const writePromise = options.useTempFiles\n      ? getWritePromise().catch(() => {\n          busboy.end()\n          cleanup()\n        })\n      : getWritePromise()\n\n    const uploadTimer = createUploadTimer(options.uploadTimeout, () => {\n      return abortAndDestroyFile(\n        file,\n        new APIError(`Upload timeout for ${field}->${filename}, bytes:${getFileSize()}`),\n      )\n    })\n\n    file.on('limit', () => {\n      debugLog(options, `Size limit reached for ${field}->${filename}, bytes:${getFileSize()}`)\n      uploadTimer.clear()\n\n      if (isFunc(options.limitHandler)) {\n        options.limitHandler({ request, size: getFileSize() })\n      }\n\n      // Return error and cleanup files if abortOnLimit set.\n      if (options.abortOnLimit) {\n        debugLog(options, `Upload file size limit reached ${field}->${filename}.`)\n        cleanup()\n        abortAndDestroyFile(\n          file,\n          new APIError(options.responseOnLimit!, httpStatus.REQUEST_ENTITY_TOO_LARGE, {\n            size: getFileSize(),\n          }),\n        )\n      }\n    })\n\n    file.on('data', (data) => {\n      uploadTimer.set()\n      dataHandler(data)\n    })\n\n    file.on('end', () => {\n      const size = getFileSize()\n      debugLog(options, `Upload finished ${field}->${filename}, bytes:${size}`)\n      uploadTimer.clear()\n\n      if (!name && size === 0) {\n        fileCount -= 1\n        if (options.useTempFiles) {\n          cleanup()\n          debugLog(options, `Removing the empty file ${field}->${filename}`)\n        }\n        return debugLog(options, `Don't add file instance if original name and size are empty`)\n      }\n\n      filesCompleted += 1\n\n      result.files = buildFields(\n        result.files,\n        field,\n        fileFactory(\n          {\n            name: filename,\n            buffer: complete(),\n            encoding,\n            hash: getHash(),\n            mimetype: inferredMimeType,\n            size,\n            tempFilePath: getFilePath(),\n            truncated: Boolean('truncated' in file && file.truncated) || false,\n          },\n          options,\n        ),\n      )\n\n      if (!request[waitFlushProperty]) {\n        request[waitFlushProperty] = []\n      }\n      request[waitFlushProperty].push(writePromise)\n\n      if (filesCompleted === fileCount) {\n        allFilesHaveResolved()\n      }\n    })\n\n    file.on('error', (err) => {\n      uploadTimer.clear()\n      debugLog(options, `File Error: ${err.message}`)\n      cleanup()\n      failedResolvingFiles(err)\n    })\n\n    // Start upload process.\n    debugLog(options, `New upload started ${field}->${filename}, bytes:${getFileSize()}`)\n    uploadTimer.set()\n  })\n\n  busboy.on('finish', async () => {\n    debugLog(options, `Busboy finished parsing request.`)\n    if (options.parseNested) {\n      result.fields = processNested(result.fields)\n      result.files = processNested(result.files)\n    }\n\n    if (request[waitFlushProperty]) {\n      try {\n        await Promise.all(request[waitFlushProperty]).then(() => {\n          delete request[waitFlushProperty]\n        })\n      } catch (err) {\n        debugLog(options, `Error waiting for file write promises: ${err}`)\n      }\n    }\n\n    return result\n  })\n\n  busboy.on(\n    'error',\n    (err = new APIError('Busboy error parsing multipart request', httpStatus.BAD_REQUEST)) => {\n      debugLog(options, `Busboy error`)\n      throw err\n    },\n  )\n\n  while (parsingRequest) {\n    const { done, value } = await reader!.read()\n\n    if (done) {\n      parsingRequest = false\n    }\n\n    if (value && !shouldAbortProccessing) {\n      busboy.write(value)\n    }\n  }\n\n  if (fileCount !== 0) {\n    await allFilesComplete.catch((e) => {\n      throw e\n    })\n  }\n\n  return result\n}\n"],"names":["Busboy","status","httpStatus","APIError","fileFactory","memHandler","tempFileHandler","processNested","createUploadTimer","buildFields","debugLog","isFunc","parseFileName","waitFlushProperty","Symbol","processMultipart","options","request","parsingRequest","shouldAbortProccessing","fileCount","filesCompleted","allFilesHaveResolved","failedResolvingFiles","allFilesComplete","Promise","res","rej","result","fields","undefined","files","headersObject","headers","forEach","value","name","reader","body","getReader","busboy","abortAndDestroyFile","file","err","destroy","on","field","val","info","encoding","filename","mimeType","mime","inferredMimeType","endsWith","cleanup","complete","dataHandler","getFilePath","getFileSize","getHash","getWritePromise","useTempFiles","writePromise","catch","end","uploadTimer","uploadTimeout","clear","limitHandler","size","abortOnLimit","responseOnLimit","REQUEST_ENTITY_TOO_LARGE","data","set","buffer","hash","mimetype","tempFilePath","truncated","Boolean","push","message","parseNested","all","then","BAD_REQUEST","done","read","write","e"],"mappings":"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"}},
    {"offset": {"line": 677, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/uploads/fetchAPI-multipart/index.ts"],"sourcesContent":["import path from 'path'\n\nimport type { FetchAPIFileUploadOptions } from '../../config/types.js'\n\nimport { APIError } from '../../errors/APIError.js'\nimport { isEligibleRequest } from './isEligibleRequest.js'\nimport { processMultipart } from './processMultipart.js'\nimport { debugLog } from './utilities.js'\n\nconst DEFAULT_UPLOAD_OPTIONS: FetchAPIFileUploadOptions = {\n  abortOnLimit: false,\n  createParentPath: false,\n  debug: false,\n  defParamCharset: 'utf8',\n  limitHandler: false,\n  parseNested: false,\n  preserveExtension: false,\n  responseOnLimit: 'File size limit has been reached',\n  safeFileNames: false,\n  tempFileDir: path.join(process.cwd(), 'tmp'),\n  uploadTimeout: 60000,\n  uriDecodeFileNames: false,\n  useTempFiles: false,\n}\n\nexport type FileShape = {\n  data: Buffer\n  encoding: string\n  md5: Buffer | string\n  mimetype: string\n  mv: (filePath: string, callback: () => void) => Promise<void> | void\n  name: string\n  size: number\n  tempFilePath: string\n  truncated: boolean\n}\n\ntype FetchAPIFileUploadResponseFile = {\n  data: Buffer\n  mimetype: string\n  name: string\n  size: number\n  tempFilePath?: string\n}\n\nexport type FetchAPIFileUploadResponse = {\n  error?: APIError\n  fields: Record<string, string>\n  files: Record<string, FetchAPIFileUploadResponseFile>\n}\n\ntype FetchAPIFileUpload = (args: {\n  options?: FetchAPIFileUploadOptions\n  request: Request\n}) => Promise<FetchAPIFileUploadResponse>\n\nexport const processMultipartFormdata: FetchAPIFileUpload = async ({\n  options: incomingOptions,\n  request,\n}) => {\n  const options: FetchAPIFileUploadOptions = { ...DEFAULT_UPLOAD_OPTIONS, ...incomingOptions }\n\n  if (!isEligibleRequest(request)) {\n    debugLog(options, 'Request is not eligible for file upload!')\n\n    return {\n      error: new APIError('Request is not eligible for file upload', 500),\n      fields: undefined!,\n      files: undefined!,\n    }\n  } else {\n    return processMultipart({ options, request })\n  }\n}\n"],"names":["path","APIError","isEligibleRequest","processMultipart","debugLog","DEFAULT_UPLOAD_OPTIONS","abortOnLimit","createParentPath","debug","defParamCharset","limitHandler","parseNested","preserveExtension","responseOnLimit","safeFileNames","tempFileDir","join","process","cwd","uploadTimeout","uriDecodeFileNames","useTempFiles","processMultipartFormdata","options","incomingOptions","request","error","fields","undefined","files"],"mappings":";;;;AAAA,OAAOA,UAAU,OAAM;AAIvB,SAASC,QAAQ,QAAQ,2BAA0B;AACnD,SAASC,iBAAiB,QAAQ,yBAAwB;AAC1D,SAASC,gBAAgB,QAAQ,wBAAuB;AACxD,SAASC,QAAQ,QAAQ,iBAAgB;;;;;;AAEzC,MAAMC,yBAAoD;IACxDC,cAAc;IACdC,kBAAkB;IAClBC,OAAO;IACPC,iBAAiB;IACjBC,cAAc;IACdC,aAAa;IACbC,mBAAmB;IACnBC,iBAAiB;IACjBC,eAAe;IACfC,aAAaf,4GAAAA,CAAKgB,IAAI,CAACC,QAAQC,GAAG,IAAI;IACtCC,eAAe;IACfC,oBAAoB;IACpBC,cAAc;AAChB;AAiCO,MAAMC,2BAA+C,OAAO,EACjEC,SAASC,eAAe,EACxBC,OAAO,EACR;IACC,MAAMF,UAAqC;QAAE,GAAGlB,sBAAsB;QAAE,GAAGmB,eAAe;IAAC;IAE3F,IAAI,KAACtB,+MAAAA,EAAkBuB,UAAU;YAC/BrB,8LAAAA,EAASmB,SAAS;QAElB,OAAO;YACLG,OAAO,IAAIzB,mKAAAA,CAAS,2CAA2C;YAC/D0B,QAAQC;YACRC,OAAOD;QACT;IACF,OAAO;QACL,WAAOzB,6MAAAA,EAAiB;YAAEoB;YAASE;QAAQ;IAC7C;AACF,EAAC"}},
    {"offset": {"line": 729, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/uploads/checkFileAccess.ts"],"sourcesContent":["import type { Collection, TypeWithID } from '../collections/config/types.js'\nimport type { PayloadRequest, Where } from '../types/index.js'\n\nimport { executeAccess } from '../auth/executeAccess.js'\nimport { Forbidden } from '../errors/Forbidden.js'\n\nexport const checkFileAccess = async ({\n  collection,\n  filename,\n  req,\n}: {\n  collection: Collection\n  filename: string\n  req: PayloadRequest\n}): Promise<TypeWithID | undefined> => {\n  if (filename.includes('../') || filename.includes('..\\\\')) {\n    throw new Forbidden(req.t)\n  }\n  const { config } = collection\n\n  const accessResult = await executeAccess(\n    { data: { filename }, isReadingStaticFile: true, req },\n    config.access.read,\n  )\n\n  if (typeof accessResult === 'object') {\n    const queryToBuild: Where = {\n      and: [\n        {\n          or: [\n            {\n              filename: {\n                equals: filename,\n              },\n            },\n          ],\n        },\n        accessResult,\n      ],\n    }\n\n    if (config.upload.imageSizes) {\n      config.upload.imageSizes.forEach(({ name }) => {\n        queryToBuild.and?.[0]?.or?.push({\n          [`sizes.${name}.filename`]: {\n            equals: filename,\n          },\n        })\n      })\n    }\n\n    const doc = await req.payload.db.findOne({\n      collection: config.slug,\n      req,\n      where: queryToBuild,\n    })\n\n    if (!doc) {\n      throw new Forbidden(req.t)\n    }\n\n    return doc\n  }\n}\n"],"names":["executeAccess","Forbidden","checkFileAccess","collection","filename","req","includes","t","config","accessResult","data","isReadingStaticFile","access","read","queryToBuild","and","or","equals","upload","imageSizes","forEach","name","push","doc","payload","db","findOne","slug","where"],"mappings":";;;;AAGA,SAASA,aAAa,QAAQ,2BAA0B;AACxD,SAASC,SAAS,QAAQ,yBAAwB;;;AAE3C,MAAMC,kBAAkB,OAAO,EACpCC,UAAU,EACVC,QAAQ,EACRC,GAAG,EAKJ;IACC,IAAID,SAASE,QAAQ,CAAC,UAAUF,SAASE,QAAQ,CAAC,SAAS;QACzD,MAAM,IAAIL,qKAAAA,CAAUI,IAAIE,CAAC;IAC3B;IACA,MAAM,EAAEC,MAAM,EAAE,GAAGL;IAEnB,MAAMM,eAAe,UAAMT,2KAAAA,EACzB;QAAEU,MAAM;YAAEN;QAAS;QAAGO,qBAAqB;QAAMN;IAAI,GACrDG,OAAOI,MAAM,CAACC,IAAI;IAGpB,IAAI,OAAOJ,iBAAiB,UAAU;QACpC,MAAMK,eAAsB;YAC1BC,KAAK;gBACH;oBACEC,IAAI;wBACF;4BACEZ,UAAU;gCACRa,QAAQb;4BACV;wBACF;qBACD;gBACH;gBACAK;aACD;QACH;QAEA,IAAID,OAAOU,MAAM,CAACC,UAAU,EAAE;YAC5BX,OAAOU,MAAM,CAACC,UAAU,CAACC,OAAO,CAAC,CAAC,EAAEC,IAAI,EAAE;gBACxCP,aAAaC,GAAG,EAAE,CAAC,EAAE,EAAEC,IAAIM,KAAK;oBAC9B,CAAC,CAAC,MAAM,EAAED,KAAK,SAAS,CAAC,CAAC,EAAE;wBAC1BJ,QAAQb;oBACV;gBACF;YACF;QACF;QAEA,MAAMmB,MAAM,MAAMlB,IAAImB,OAAO,CAACC,EAAE,CAACC,OAAO,CAAC;YACvCvB,YAAYK,OAAOmB,IAAI;YACvBtB;YACAuB,OAAOd;QACT;QAEA,IAAI,CAACS,KAAK;YACR,MAAM,IAAItB,qKAAAA,CAAUI,IAAIE,CAAC;QAC3B;QAEA,OAAOgB;IACT;AACF,EAAC"}},
    {"offset": {"line": 788, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/uploads/fetchAPI-stream-file/index.ts"],"sourcesContent":["import fs from 'fs'\n\nexport function iteratorToStream(iterator: AsyncIterator<Uint8Array>) {\n  return new ReadableStream({\n    async pull(controller) {\n      const { done, value } = await iterator.next()\n      if (done) {\n        controller.close()\n      } else {\n        controller.enqueue(value)\n      }\n    },\n  })\n}\n\nexport async function* nodeStreamToIterator(stream: fs.ReadStream) {\n  for await (const chunk of stream) {\n    yield new Uint8Array(chunk)\n  }\n}\n\nexport function streamFile({\n  filePath,\n  options,\n}: {\n  filePath: string\n  options?: { end?: number; start?: number }\n}): ReadableStream {\n  const nodeStream = fs.createReadStream(filePath, options)\n  const data: ReadableStream = iteratorToStream(nodeStreamToIterator(nodeStream))\n  return data\n}\n"],"names":["fs","iteratorToStream","iterator","ReadableStream","pull","controller","done","value","next","close","enqueue","nodeStreamToIterator","stream","chunk","Uint8Array","streamFile","filePath","options","nodeStream","createReadStream","data"],"mappings":";;;;;;;;AAAA,OAAOA,QAAQ,KAAI;;AAEZ,SAASC,iBAAiBC,QAAmC;IAClE,OAAO,IAAIC,eAAe;QACxB,MAAMC,MAAKC,UAAU;YACnB,MAAM,EAAEC,IAAI,EAAEC,KAAK,EAAE,GAAG,MAAML,SAASM,IAAI;YAC3C,IAAIF,MAAM;gBACRD,WAAWI,KAAK;YAClB,OAAO;gBACLJ,WAAWK,OAAO,CAACH;YACrB;QACF;IACF;AACF;AAEO,gBAAgBI,qBAAqBC,MAAqB;IAC/D,WAAW,MAAMC,SAASD,OAAQ;QAChC,MAAM,IAAIE,WAAWD;IACvB;AACF;AAEO,SAASE,WAAW,EACzBC,QAAQ,EACRC,OAAO,EAIR;IACC,MAAMC,aAAalB,wGAAAA,CAAGmB,gBAAgB,CAACH,UAAUC;IACjD,MAAMG,OAAuBnB,iBAAiBU,qBAAqBO;IACnE,OAAOE;AACT"}},
    {"offset": {"line": 824, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/uploads/getFileTypeFallback.ts"],"sourcesContent":["type ReturnType = {\n  ext: string\n  mime: string\n}\n\nconst extensionMap: {\n  [ext: string]: string\n} = {\n  css: 'text/css',\n  csv: 'text/csv',\n  htm: 'text/html',\n  html: 'text/html',\n  js: 'application/javascript',\n  json: 'application/json',\n  md: 'text/markdown',\n  svg: 'image/svg+xml',\n  xml: 'application/xml',\n  yml: 'application/x-yaml',\n}\n\nexport const getFileTypeFallback = (path: string): ReturnType => {\n  const ext = path.split('.').pop() || 'txt'\n\n  return {\n    ext,\n    mime: extensionMap[ext] || 'text/plain',\n  }\n}\n"],"names":["extensionMap","css","csv","htm","html","js","json","md","svg","xml","yml","getFileTypeFallback","path","ext","split","pop","mime"],"mappings":";;;;AAKA,MAAMA,eAEF;IACFC,KAAK;IACLC,KAAK;IACLC,KAAK;IACLC,MAAM;IACNC,IAAI;IACJC,MAAM;IACNC,IAAI;IACJC,KAAK;IACLC,KAAK;IACLC,KAAK;AACP;AAEO,MAAMC,sBAAsB,CAACC;IAClC,MAAMC,MAAMD,KAAKE,KAAK,CAAC,KAAKC,GAAG,MAAM;IAErC,OAAO;QACLF;QACAG,MAAMhB,YAAY,CAACa,IAAI,IAAI;IAC7B;AACF,EAAC"}},
    {"offset": {"line": 851, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/uploads/parseRangeHeader.ts"],"sourcesContent":["import parseRange from 'range-parser'\n\nexport type ByteRange = {\n  end: number\n  start: number\n}\n\nexport type ParseRangeResult =\n  | { range: ByteRange; type: 'partial' }\n  | { range: null; type: 'full' }\n  | { range: null; type: 'invalid' }\n\n/**\n * Parses HTTP Range header according to RFC 7233\n *\n * @returns Result object indicating whether to serve full file, partial content, or invalid range\n */\nexport function parseRangeHeader({\n  fileSize,\n  rangeHeader,\n}: {\n  fileSize: number\n  rangeHeader: null | string\n}): ParseRangeResult {\n  // No Range header - serve full file\n  if (!rangeHeader) {\n    return { type: 'full', range: null }\n  }\n\n  const result = parseRange(fileSize, rangeHeader)\n\n  // Invalid range syntax or unsatisfiable range\n  if (result === -1 || result === -2) {\n    return { type: 'invalid', range: null }\n  }\n\n  // Must be bytes range type\n  if (result.type !== 'bytes' || result.length === 0) {\n    return { type: 'invalid', range: null }\n  }\n\n  // Multi-range requests: use first range only (standard simplification)\n  const range = result[0]\n\n  if (!range) {\n    return { type: 'invalid', range: null }\n  }\n\n  return {\n    type: 'partial',\n    range: {\n      end: range.end,\n      start: range.start,\n    },\n  }\n}\n"],"names":["parseRange","parseRangeHeader","fileSize","rangeHeader","type","range","result","length","end","start"],"mappings":";;;;AAAA,OAAOA,gBAAgB,eAAc;;AAiB9B,SAASC,iBAAiB,EAC/BC,QAAQ,EACRC,WAAW,EAIZ;IACC,oCAAoC;IACpC,IAAI,CAACA,aAAa;QAChB,OAAO;YAAEC,MAAM;YAAQC,OAAO;QAAK;IACrC;IAEA,MAAMC,aAASN,qJAAAA,EAAWE,UAAUC;IAEpC,8CAA8C;IAC9C,IAAIG,WAAW,CAAC,KAAKA,WAAW,CAAC,GAAG;QAClC,OAAO;YAAEF,MAAM;YAAWC,OAAO;QAAK;IACxC;IAEA,2BAA2B;IAC3B,IAAIC,OAAOF,IAAI,KAAK,WAAWE,OAAOC,MAAM,KAAK,GAAG;QAClD,OAAO;YAAEH,MAAM;YAAWC,OAAO;QAAK;IACxC;IAEA,uEAAuE;IACvE,MAAMA,QAAQC,MAAM,CAAC,EAAE;IAEvB,IAAI,CAACD,OAAO;QACV,OAAO;YAAED,MAAM;YAAWC,OAAO;QAAK;IACxC;IAEA,OAAO;QACLD,MAAM;QACNC,OAAO;YACLG,KAAKH,MAAMG,GAAG;YACdC,OAAOJ,MAAMI,KAAK;QACpB;IACF;AACF"}},
    {"offset": {"line": 900, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/uploads/endpoints/getFile.ts"],"sourcesContent":["import type { Stats } from 'fs'\n\nimport { fileTypeFromFile } from 'file-type'\nimport fsPromises from 'fs/promises'\nimport { status as httpStatus } from 'http-status'\nimport path from 'path'\n\nimport type { PayloadHandler } from '../../config/types.js'\n\nimport { APIError } from '../../errors/APIError.js'\nimport { checkFileAccess } from '../../uploads/checkFileAccess.js'\nimport { streamFile } from '../../uploads/fetchAPI-stream-file/index.js'\nimport { getFileTypeFallback } from '../../uploads/getFileTypeFallback.js'\nimport { parseRangeHeader } from '../../uploads/parseRangeHeader.js'\nimport { getRequestCollection } from '../../utilities/getRequestEntity.js'\nimport { headersWithCors } from '../../utilities/headersWithCors.js'\n\nexport const getFileHandler: PayloadHandler = async (req) => {\n  const collection = getRequestCollection(req)\n\n  const filename = req.routeParams?.filename as string\n\n  if (!collection.config.upload) {\n    throw new APIError(\n      `This collection is not an upload collection: ${collection.config.slug}`,\n      httpStatus.BAD_REQUEST,\n    )\n  }\n\n  const accessResult = (await checkFileAccess({\n    collection,\n    filename,\n    req,\n  }))!\n\n  if (accessResult instanceof Response) {\n    return accessResult\n  }\n\n  if (collection.config.upload.handlers?.length) {\n    let customResponse: null | Response | void = null\n    const headers = new Headers()\n\n    for (const handler of collection.config.upload.handlers) {\n      customResponse = await handler(req, {\n        doc: accessResult,\n        headers,\n        params: {\n          collection: collection.config.slug,\n          filename,\n        },\n      })\n      if (customResponse && customResponse instanceof Response) {\n        break\n      }\n    }\n\n    if (customResponse instanceof Response) {\n      return customResponse\n    }\n  }\n\n  const fileDir = collection.config.upload?.staticDir || collection.config.slug\n  const filePath = path.resolve(`${fileDir}/${filename}`)\n  let stats: Stats\n\n  try {\n    stats = await fsPromises.stat(filePath)\n  } catch (err) {\n    if ((err as { code?: string }).code === 'ENOENT') {\n      req.payload.logger.error(\n        `File ${filename} for collection ${collection.config.slug} is missing on the disk. Expected path: ${filePath}`,\n      )\n\n      // Omit going to the routeError handler by returning response instead of\n      // throwing an error to cut down log noise. The response still matches what you get with APIError to not leak details to the user.\n      return Response.json(\n        {\n          errors: [\n            {\n              message: 'Something went wrong.',\n            },\n          ],\n        },\n        {\n          headers: headersWithCors({\n            headers: new Headers(),\n            req,\n          }),\n          status: 500,\n        },\n      )\n    }\n\n    throw err\n  }\n\n  const fileTypeResult = (await fileTypeFromFile(filePath)) || getFileTypeFallback(filePath)\n  let mimeType = fileTypeResult.mime\n\n  if (filePath.endsWith('.svg') && fileTypeResult.mime === 'application/xml') {\n    mimeType = 'image/svg+xml'\n  }\n\n  // Parse Range header for byte range requests\n  const rangeHeader = req.headers.get('range')\n  const rangeResult = parseRangeHeader({\n    fileSize: stats.size,\n    rangeHeader,\n  })\n\n  if (rangeResult.type === 'invalid') {\n    let headers = new Headers()\n    headers.set('Content-Range', `bytes */${stats.size}`)\n    headers = collection.config.upload?.modifyResponseHeaders\n      ? collection.config.upload.modifyResponseHeaders({ headers }) || headers\n      : headers\n\n    return new Response(null, {\n      headers: headersWithCors({\n        headers,\n        req,\n      }),\n      status: httpStatus.REQUESTED_RANGE_NOT_SATISFIABLE,\n    })\n  }\n\n  let headers = new Headers()\n  headers.set('Content-Type', mimeType)\n  headers.set('Accept-Ranges', 'bytes')\n\n  let data: ReadableStream\n  let status: number\n  const isPartial = rangeResult.type === 'partial'\n  const range = rangeResult.range\n\n  if (isPartial && range) {\n    const contentLength = range.end - range.start + 1\n    headers.set('Content-Length', String(contentLength))\n    headers.set('Content-Range', `bytes ${range.start}-${range.end}/${stats.size}`)\n    data = streamFile({ filePath, options: { end: range.end, start: range.start } })\n    status = httpStatus.PARTIAL_CONTENT\n  } else {\n    headers.set('Content-Length', String(stats.size))\n    data = streamFile({ filePath })\n    status = httpStatus.OK\n  }\n\n  headers = collection.config.upload?.modifyResponseHeaders\n    ? collection.config.upload.modifyResponseHeaders({ headers }) || headers\n    : headers\n\n  return new Response(data, {\n    headers: headersWithCors({\n      headers,\n      req,\n    }),\n    status,\n  })\n}\n"],"names":["fileTypeFromFile","fsPromises","status","httpStatus","path","APIError","checkFileAccess","streamFile","getFileTypeFallback","parseRangeHeader","getRequestCollection","headersWithCors","getFileHandler","req","collection","filename","routeParams","config","upload","slug","BAD_REQUEST","accessResult","Response","handlers","length","customResponse","headers","Headers","handler","doc","params","fileDir","staticDir","filePath","resolve","stats","stat","err","code","payload","logger","error","json","errors","message","fileTypeResult","mimeType","mime","endsWith","rangeHeader","get","rangeResult","fileSize","size","type","set","modifyResponseHeaders","REQUESTED_RANGE_NOT_SATISFIABLE","data","isPartial","range","contentLength","end","start","String","options","PARTIAL_CONTENT","OK"],"mappings":"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"}},
    {"offset": {"line": 1053, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/uploads/endpoints/getFileFromURL.ts"],"sourcesContent":["import type { PayloadHandler } from '../../config/types.js'\n\nimport { executeAccess } from '../../auth/executeAccess.js'\nimport { APIError } from '../../errors/APIError.js'\nimport { Forbidden } from '../../errors/Forbidden.js'\nimport { getRequestCollectionWithID } from '../../utilities/getRequestEntity.js'\nimport { isURLAllowed } from '../../utilities/isURLAllowed.js'\n\n// If doc id is provided, it means we are updating the doc\n// /:collectionSlug/paste-url/:doc-id?src=:fileUrl\n\n// If doc id is not provided, it means we are creating a new doc\n// /:collectionSlug/paste-url?src=:fileUrl\n\nexport const getFileFromURLHandler: PayloadHandler = async (req) => {\n  const { id, collection } = getRequestCollectionWithID(req, { optionalID: true })\n\n  if (!req.user) {\n    throw new Forbidden(req.t)\n  }\n\n  const config = collection?.config\n\n  if (id) {\n    // updating doc\n    const accessResult = await executeAccess({ req }, config.access.update)\n    if (!accessResult) {\n      throw new Forbidden(req.t)\n    }\n  } else {\n    // creating doc\n    const accessResult = await executeAccess({ req }, config.access?.create)\n    if (!accessResult) {\n      throw new Forbidden(req.t)\n    }\n  }\n  try {\n    if (!req.url) {\n      throw new APIError('Request URL is missing.', 400)\n    }\n\n    const { searchParams } = new URL(req.url)\n    const src = searchParams.get('src')\n\n    if (!src || typeof src !== 'string') {\n      throw new APIError('A valid URL string is required.', 400)\n    }\n\n    const validatedUrl = new URL(src)\n\n    if (\n      typeof config.upload?.pasteURL === 'object' &&\n      !isURLAllowed(validatedUrl.href, config.upload.pasteURL.allowList)\n    ) {\n      throw new APIError(`The provided URL (${validatedUrl.href}) is not allowed.`, 400)\n    }\n\n    // Fetch the file with no compression\n    const response = await fetch(validatedUrl.href, {\n      headers: {\n        'Accept-Encoding': 'identity',\n      },\n    })\n\n    if (!response.ok) {\n      throw new APIError(`Failed to fetch file from ${validatedUrl.href}`, response.status)\n    }\n\n    const decodedFileName = decodeURIComponent(validatedUrl.pathname.split('/').pop() || '')\n\n    return new Response(response.body, {\n      headers: {\n        'Content-Disposition': `attachment; filename=\"${decodedFileName}\"`,\n        'Content-Length': response.headers.get('content-length') || '',\n        'Content-Type': response.headers.get('content-type') || 'application/octet-stream',\n      },\n    })\n  } catch (err) {\n    throw new APIError(\n      `Error fetching file: ${err instanceof Error ? err.message : 'Unknown error'}`,\n      500,\n    )\n  }\n}\n"],"names":["executeAccess","APIError","Forbidden","getRequestCollectionWithID","isURLAllowed","getFileFromURLHandler","req","id","collection","optionalID","user","t","config","accessResult","access","update","create","url","searchParams","URL","src","get","validatedUrl","upload","pasteURL","href","allowList","response","fetch","headers","ok","status","decodedFileName","decodeURIComponent","pathname","split","pop","Response","body","err","Error","message"],"mappings":";;;;AAEA,SAASA,aAAa,QAAQ,8BAA6B;AAC3D,SAASC,QAAQ,QAAQ,2BAA0B;AACnD,SAASC,SAAS,QAAQ,4BAA2B;AACrD,SAASC,0BAA0B,QAAQ,sCAAqC;AAChF,SAASC,YAAY,QAAQ,kCAAiC;;;;;;AAQvD,MAAMC,wBAAwC,OAAOC;IAC1D,MAAM,EAAEC,EAAE,EAAEC,UAAU,EAAE,OAAGL,gMAAAA,EAA2BG,KAAK;QAAEG,YAAY;IAAK;IAE9E,IAAI,CAACH,IAAII,IAAI,EAAE;QACb,MAAM,IAAIR,qKAAAA,CAAUI,IAAIK,CAAC;IAC3B;IAEA,MAAMC,SAASJ,YAAYI;IAE3B,IAAIL,IAAI;QACN,eAAe;QACf,MAAMM,eAAe,UAAMb,2KAAAA,EAAc;YAAEM;QAAI,GAAGM,OAAOE,MAAM,CAACC,MAAM;QACtE,IAAI,CAACF,cAAc;YACjB,MAAM,IAAIX,qKAAAA,CAAUI,IAAIK,CAAC;QAC3B;IACF,OAAO;QACL,eAAe;QACf,MAAME,eAAe,UAAMb,2KAAAA,EAAc;YAAEM;QAAI,GAAGM,OAAOE,MAAM,EAAEE;QACjE,IAAI,CAACH,cAAc;YACjB,MAAM,IAAIX,qKAAAA,CAAUI,IAAIK,CAAC;QAC3B;IACF;IACA,IAAI;QACF,IAAI,CAACL,IAAIW,GAAG,EAAE;YACZ,MAAM,IAAIhB,mKAAAA,CAAS,2BAA2B;QAChD;QAEA,MAAM,EAAEiB,YAAY,EAAE,GAAG,IAAIC,IAAIb,IAAIW,GAAG;QACxC,MAAMG,MAAMF,aAAaG,GAAG,CAAC;QAE7B,IAAI,CAACD,OAAO,OAAOA,QAAQ,UAAU;YACnC,MAAM,IAAInB,mKAAAA,CAAS,mCAAmC;QACxD;QAEA,MAAMqB,eAAe,IAAIH,IAAIC;QAE7B,IACE,OAAOR,OAAOW,MAAM,EAAEC,aAAa,YACnC,KAACpB,8KAAAA,EAAakB,aAAaG,IAAI,EAAEb,OAAOW,MAAM,CAACC,QAAQ,CAACE,SAAS,GACjE;YACA,MAAM,IAAIzB,mKAAAA,CAAS,CAAC,kBAAkB,EAAEqB,aAAaG,IAAI,CAAC,iBAAiB,CAAC,EAAE;QAChF;QAEA,qCAAqC;QACrC,MAAME,WAAW,MAAMC,MAAMN,aAAaG,IAAI,EAAE;YAC9CI,SAAS;gBACP,mBAAmB;YACrB;QACF;QAEA,IAAI,CAACF,SAASG,EAAE,EAAE;YAChB,MAAM,IAAI7B,mKAAAA,CAAS,CAAC,0BAA0B,EAAEqB,aAAaG,IAAI,EAAE,EAAEE,SAASI,MAAM;QACtF;QAEA,MAAMC,kBAAkBC,mBAAmBX,aAAaY,QAAQ,CAACC,KAAK,CAAC,KAAKC,GAAG,MAAM;QAErF,OAAO,IAAIC,SAASV,SAASW,IAAI,EAAE;YACjCT,SAAS;gBACP,uBAAuB,CAAC,sBAAsB,EAAEG,gBAAgB,CAAC,CAAC;gBAClE,kBAAkBL,SAASE,OAAO,CAACR,GAAG,CAAC,qBAAqB;gBAC5D,gBAAgBM,SAASE,OAAO,CAACR,GAAG,CAAC,mBAAmB;YAC1D;QACF;IACF,EAAE,OAAOkB,KAAK;QACZ,MAAM,IAAItC,mKAAAA,CACR,CAAC,qBAAqB,EAAEsC,eAAeC,QAAQD,IAAIE,OAAO,GAAG,iBAAiB,EAC9E;IAEJ;AACF,EAAC"}},
    {"offset": {"line": 1130, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/uploads/endpoints/index.ts"],"sourcesContent":["import type { Endpoint } from '../../config/types.js'\n\nimport { wrapInternalEndpoints } from '../../utilities/wrapInternalEndpoints.js'\nimport { getFileHandler } from './getFile.js'\nimport { getFileFromURLHandler } from './getFileFromURL.js'\n\nexport const uploadCollectionEndpoints: Endpoint[] = wrapInternalEndpoints([\n  {\n    handler: getFileFromURLHandler,\n    method: 'get',\n    path: '/paste-url/:id?',\n  },\n  {\n    handler: getFileHandler,\n    method: 'get',\n    path: '/file/:filename',\n  },\n])\n"],"names":["wrapInternalEndpoints","getFileHandler","getFileFromURLHandler","uploadCollectionEndpoints","handler","method","path"],"mappings":";;;;AAEA,SAASA,qBAAqB,QAAQ,2CAA0C;AAChF,SAASC,cAAc,QAAQ,eAAc;AAC7C,SAASC,qBAAqB,QAAQ,sBAAqB;;;;AAEpD,MAAMC,gCAAwCH,gMAAAA,EAAsB;IACzE;QACEI,SAASF,oMAAAA;QACTG,QAAQ;QACRC,MAAM;IACR;IACA;QACEF,SAASH,sLAAAA;QACTI,QAAQ;QACRC,MAAM;IACR;CACD,EAAC"}},
    {"offset": {"line": 1156, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/uploads/generateFilePathOrURL.ts"],"sourcesContent":["import type { Config } from '../config/types.js'\n\nimport { formatAdminURL } from '../utilities/formatAdminURL.js'\n\n/**\n * Generates a file path or URL based on the provided parameters.\n *\n * If urlOrPath is an external URL, it returns it as is.\n * If a filename is provided, it constructs a URL using the collection slug and API route.\n * If neither condition is met, it returns null.\n *\n * If you set relative to true, the returned URL will be relative to the serverURL (unless external).\n */\nexport function generateFilePathOrURL({\n  collectionSlug,\n  config,\n  filename,\n  relative,\n  serverURL,\n  urlOrPath,\n}: {\n  collectionSlug: string\n  config: Config\n  filename?: string\n  relative: boolean\n  serverURL?: string\n  urlOrPath: string | undefined\n}): null | string {\n  if (urlOrPath) {\n    if (!urlOrPath.startsWith('/') && !urlOrPath.startsWith(serverURL || '')) {\n      // external url\n      return urlOrPath\n    }\n  }\n\n  if (filename) {\n    // local file url\n    return formatAdminURL({\n      apiRoute: config.routes?.api || '',\n      path: `/${collectionSlug}/file/${encodeURIComponent(filename)}`,\n      relative,\n      serverURL: config.serverURL,\n    })\n  }\n\n  return null\n}\n"],"names":["formatAdminURL","generateFilePathOrURL","collectionSlug","config","filename","relative","serverURL","urlOrPath","startsWith","apiRoute","routes","api","path","encodeURIComponent"],"mappings":";;;;AAEA,SAASA,cAAc,QAAQ,iCAAgC;;AAWxD,SAASC,sBAAsB,EACpCC,cAAc,EACdC,MAAM,EACNC,QAAQ,EACRC,QAAQ,EACRC,SAAS,EACTC,SAAS,EAQV;IACC,IAAIA,WAAW;QACb,IAAI,CAACA,UAAUC,UAAU,CAAC,QAAQ,CAACD,UAAUC,UAAU,CAACF,aAAa,KAAK;YACxE,eAAe;YACf,OAAOC;QACT;IACF;IAEA,IAAIH,UAAU;QACZ,iBAAiB;QACjB,WAAOJ,kLAAAA,EAAe;YACpBS,UAAUN,OAAOO,MAAM,EAAEC,OAAO;YAChCC,MAAM,CAAC,CAAC,EAAEV,eAAe,MAAM,EAAEW,mBAAmBT,WAAW;YAC/DC;YACAC,WAAWH,OAAOG,SAAS;QAC7B;IACF;IAEA,OAAO;AACT"}},
    {"offset": {"line": 1184, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/uploads/mimeTypeValidator.ts"],"sourcesContent":["import type { Validate } from '../fields/config/types.js'\n\nimport { validateMimeType } from '../utilities/validateMimeType.js'\n\nexport const mimeTypeValidator =\n  (mimeTypes: string[]): Validate =>\n  (val: string, { siblingData }) => {\n    if (!siblingData.filename) {\n      return true\n    }\n\n    if (!val) {\n      return 'Invalid file type'\n    }\n\n    const isValidMimeType = validateMimeType(val, mimeTypes)\n    return isValidMimeType ? true : `Invalid file type: '${val}'`\n  }\n"],"names":["validateMimeType","mimeTypeValidator","mimeTypes","val","siblingData","filename","isValidMimeType"],"mappings":";;;;AAEA,SAASA,gBAAgB,QAAQ,mCAAkC;;AAE5D,MAAMC,oBACX,CAACC,YACD,CAACC,KAAa,EAAEC,WAAW,EAAE;QAC3B,IAAI,CAACA,YAAYC,QAAQ,EAAE;YACzB,OAAO;QACT;QAEA,IAAI,CAACF,KAAK;YACR,OAAO;QACT;QAEA,MAAMG,sBAAkBN,sLAAAA,EAAiBG,KAAKD;QAC9C,OAAOI,kBAAkB,OAAO,CAAC,oBAAoB,EAAEH,IAAI,CAAC,CAAC;IAC/D,EAAC"}},
    {"offset": {"line": 1204, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/uploads/getBaseFields.ts"],"sourcesContent":["import type { CollectionConfig } from '../collections/config/types.js'\nimport type { Config } from '../config/types.js'\nimport type { Field } from '../fields/config/types.js'\nimport type { UploadConfig } from './types.js'\n\nimport { generateFilePathOrURL } from './generateFilePathOrURL.js'\nimport { mimeTypeValidator } from './mimeTypeValidator.js'\n\ntype Options = {\n  collection: CollectionConfig\n  config: Config\n}\n\nexport const getBaseUploadFields = ({ collection, config }: Options): Field[] => {\n  const uploadOptions: UploadConfig = typeof collection.upload === 'object' ? collection.upload : {}\n\n  const mimeType: Field = {\n    name: 'mimeType',\n    type: 'text',\n    admin: {\n      hidden: true,\n      readOnly: true,\n    },\n    label: 'MIME Type',\n  }\n\n  const thumbnailURL: Field = {\n    name: 'thumbnailURL',\n    type: 'text',\n    admin: {\n      hidden: true,\n      readOnly: true,\n    },\n    hooks: {\n      afterRead: [\n        ({ originalDoc, req }) => {\n          const adminThumbnail =\n            typeof collection.upload !== 'boolean' ? collection.upload?.adminThumbnail : undefined\n\n          if (typeof adminThumbnail === 'function') {\n            return adminThumbnail({ doc: originalDoc })\n          }\n\n          return generateFilePathOrURL({\n            collectionSlug: collection.slug,\n            config,\n            filename:\n              typeof adminThumbnail === 'string'\n                ? (originalDoc.sizes?.[adminThumbnail].filename as string)\n                : undefined,\n            relative: false,\n            serverURL: req.payload.config.serverURL,\n            urlOrPath:\n              typeof adminThumbnail === 'string'\n                ? (originalDoc.sizes?.[adminThumbnail].url as string)\n                : undefined,\n          })\n        },\n      ],\n    },\n    label: 'Thumbnail URL',\n  }\n\n  const width: Field = {\n    name: 'width',\n    type: 'number',\n    admin: {\n      hidden: true,\n      readOnly: true,\n    },\n    label: ({ t }) => t('upload:width'),\n  }\n\n  const height: Field = {\n    name: 'height',\n    type: 'number',\n    admin: {\n      hidden: true,\n      readOnly: true,\n    },\n    label: ({ t }) => t('upload:height'),\n  }\n\n  const filesize: Field = {\n    name: 'filesize',\n    type: 'number',\n    admin: {\n      hidden: true,\n      readOnly: true,\n    },\n    label: ({ t }) => t('upload:fileSize'),\n  }\n\n  const filename: Field = {\n    name: 'filename',\n    type: 'text',\n    admin: {\n      disableBulkEdit: true,\n      hidden: true,\n      readOnly: true,\n    },\n    index: true,\n    label: ({ t }) => t('upload:fileName'),\n  }\n\n  // Only set unique: true if the collection does not have a compound index\n  if (\n    collection.upload === true ||\n    (typeof collection.upload === 'object' && !collection.upload.filenameCompoundIndex)\n  ) {\n    filename.unique = true\n  }\n\n  const url: Field = {\n    name: 'url',\n    type: 'text',\n    admin: {\n      hidden: true,\n      readOnly: true,\n    },\n    label: 'URL',\n  }\n\n  let uploadFields: Field[] = [\n    {\n      ...url,\n      hooks: {\n        afterRead: [\n          ({ data, originalDoc, req, value }) =>\n            generateFilePathOrURL({\n              collectionSlug: collection.slug,\n              config,\n              filename: data?.filename || originalDoc?.filename,\n              relative: false,\n              serverURL: req.payload.config.serverURL,\n              urlOrPath: value,\n            }),\n        ],\n        beforeChange: [\n          ({ collection, data, originalDoc, req, value }) =>\n            generateFilePathOrURL({\n              collectionSlug: collection?.slug as string,\n              config,\n              filename: data?.filename || originalDoc?.filename,\n              relative: true,\n              serverURL: req.payload.config.serverURL,\n              urlOrPath: value,\n            }),\n        ],\n      },\n    },\n    thumbnailURL,\n    filename,\n    mimeType,\n    filesize,\n    width,\n    height,\n  ]\n\n  // Add focal point fields if not disabled\n  if (\n    uploadOptions.focalPoint !== false ||\n    uploadOptions.imageSizes ||\n    uploadOptions.resizeOptions\n  ) {\n    uploadFields = uploadFields.concat(\n      ['focalX', 'focalY'].map((name) => {\n        return {\n          name,\n          type: 'number',\n          admin: {\n            disableGroupBy: true,\n            disableListColumn: true,\n            disableListFilter: true,\n            hidden: true,\n          },\n        }\n      }),\n    )\n  }\n\n  if (uploadOptions.mimeTypes) {\n    mimeType.validate = mimeTypeValidator(uploadOptions.mimeTypes)\n  }\n\n  // In Payload v4, image size subfields (`url`, `width`, `height`, etc.) should\n  // default to `disableGroupBy: true`, `disableListColumn: true` and `disableListFilter: true`\n  // to avoid cluttering the collection list view and filters by default.\n  if (uploadOptions.imageSizes) {\n    uploadFields = uploadFields.concat([\n      {\n        name: 'sizes',\n        type: 'group',\n        admin: {\n          hidden: true,\n        },\n        fields: uploadOptions.imageSizes.map((size) => ({\n          name: size.name,\n          type: 'group',\n          admin: {\n            hidden: true,\n            ...(size.admin?.disableGroupBy && { disableGroupBy: true }),\n            ...(size.admin?.disableListColumn && { disableListColumn: true }),\n            ...(size.admin?.disableListFilter && { disableListFilter: true }),\n          },\n          fields: [\n            {\n              ...url,\n              admin: {\n                ...url.admin,\n                ...(size.admin?.disableGroupBy && { disableGroupBy: true }),\n                ...(size.admin?.disableListColumn && { disableListColumn: true }),\n                ...(size.admin?.disableListFilter && { disableListFilter: true }),\n              },\n              hooks: {\n                afterRead: [\n                  ({ collection, data, originalDoc, req, value }) =>\n                    generateFilePathOrURL({\n                      collectionSlug: collection?.slug as string,\n                      config,\n                      filename:\n                        data?.sizes?.[size.name]?.filename ||\n                        originalDoc?.sizes?.[size.name]?.filename,\n                      relative: false,\n                      serverURL: req.payload.config.serverURL,\n                      urlOrPath: value,\n                    }),\n                ],\n                beforeChange: [\n                  ({ collection, data, originalDoc, req, value }) =>\n                    generateFilePathOrURL({\n                      collectionSlug: collection?.slug as string,\n                      config,\n                      filename:\n                        data?.sizes?.[size.name]?.filename ||\n                        originalDoc?.sizes?.[size.name]?.filename ||\n                        data?.filename ||\n                        originalDoc?.filename,\n                      relative: true,\n                      serverURL: req.payload.config.serverURL,\n                      urlOrPath: value,\n                    }),\n                ],\n              },\n            },\n            {\n              ...width,\n              admin: {\n                ...width.admin,\n                ...(size.admin?.disableGroupBy && { disableGroupBy: true }),\n                ...(size.admin?.disableListColumn && { disableListColumn: true }),\n                ...(size.admin?.disableListFilter && { disableListFilter: true }),\n              },\n            },\n            {\n              ...height,\n              admin: {\n                ...height.admin,\n                ...(size.admin?.disableGroupBy && { disableGroupBy: true }),\n                ...(size.admin?.disableListColumn && { disableListColumn: true }),\n                ...(size.admin?.disableListFilter && { disableListFilter: true }),\n              },\n            },\n            {\n              ...mimeType,\n              admin: {\n                ...mimeType.admin,\n                ...(size.admin?.disableGroupBy && { disableGroupBy: true }),\n                ...(size.admin?.disableListColumn && { disableListColumn: true }),\n                ...(size.admin?.disableListFilter && { disableListFilter: true }),\n              },\n            },\n            {\n              ...filesize,\n              admin: {\n                ...filesize.admin,\n                ...(size.admin?.disableGroupBy && { disableGroupBy: true }),\n                ...(size.admin?.disableListColumn && { disableListColumn: true }),\n                ...(size.admin?.disableListFilter && { disableListFilter: true }),\n              },\n            },\n            {\n              ...filename,\n              admin: {\n                ...filename.admin,\n                ...(size.admin?.disableGroupBy && { disableGroupBy: true }),\n                ...(size.admin?.disableListColumn && { disableListColumn: true }),\n                ...(size.admin?.disableListFilter && { disableListFilter: true }),\n              },\n              unique: false,\n            },\n          ],\n          label: size.name,\n        })),\n        label: ({ t }) => t('upload:sizes'),\n      },\n    ])\n  }\n  return uploadFields\n}\n"],"names":["generateFilePathOrURL","mimeTypeValidator","getBaseUploadFields","collection","config","uploadOptions","upload","mimeType","name","type","admin","hidden","readOnly","label","thumbnailURL","hooks","afterRead","originalDoc","req","adminThumbnail","undefined","doc","collectionSlug","slug","filename","sizes","relative","serverURL","payload","urlOrPath","url","width","t","height","filesize","disableBulkEdit","index","filenameCompoundIndex","unique","uploadFields","data","value","beforeChange","focalPoint","imageSizes","resizeOptions","concat","map","disableGroupBy","disableListColumn","disableListFilter","mimeTypes","validate","fields","size"],"mappings":"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"}},
    {"offset": {"line": 1510, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/uploads/canResizeImage.ts"],"sourcesContent":["export function canResizeImage(mimeType: string): boolean {\n  return (\n    ['image/jpeg', 'image/png', 'image/gif', 'image/webp', 'image/tiff', 'image/avif'].indexOf(\n      mimeType,\n    ) > -1\n  )\n}\n"],"names":["canResizeImage","mimeType","indexOf"],"mappings":";;;;AAAO,SAASA,eAAeC,QAAgB;IAC7C,OACE;QAAC;QAAc;QAAa;QAAa;QAAc;QAAc;KAAa,CAACC,OAAO,CACxFD,YACE,CAAC;AAET"}},
    {"offset": {"line": 1528, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/uploads/detectSvgFromXml.ts"],"sourcesContent":["/**\n * Securely detect if an XML buffer contains a valid SVG document\n */\nexport function detectSvgFromXml(buffer: Buffer): boolean {\n  try {\n    // Limit buffer size to prevent processing large malicious files\n    const maxSize = 2048\n    const content = buffer.toString('utf8', 0, Math.min(buffer.length, maxSize))\n\n    // Check for XML declaration and extract encoding if present\n    const xmlDeclMatch = content.match(/^<\\?xml[^>]*encoding=[\"']([^\"']+)[\"']/i)\n    const declaredEncoding = xmlDeclMatch?.[1]?.toLowerCase()\n\n    // Only support safe encodings\n    if (declaredEncoding && !['ascii', 'utf-8', 'utf8'].includes(declaredEncoding)) {\n      return false\n    }\n\n    // Remove XML declarations, comments, and processing instructions\n    const cleanContent = content\n      .replace(/<\\?xml[^>]*\\?>/gi, '')\n      .replace(/<!--[\\s\\S]*?-->/g, '')\n      .replace(/<\\?[^>]*\\?>/g, '')\n      .trim()\n\n    // Find the first actual element (root element)\n    const rootElementMatch = cleanContent.match(/^<(\\w+)(?:\\s|>)/)\n    if (!rootElementMatch || rootElementMatch[1] !== 'svg') {\n      return false\n    }\n\n    // Validate SVG namespace - must be present for valid SVG\n    const svgNamespaceRegex = /xmlns=[\"']http:\\/\\/www\\.w3\\.org\\/2000\\/svg[\"']/\n    if (!svgNamespaceRegex.test(content)) {\n      return false\n    }\n\n    // Additional validation: ensure it's not malformed\n    const svgOpenTag = content.match(/<svg[\\s>]/)\n    if (!svgOpenTag) {\n      return false\n    }\n\n    return true\n  } catch (_error) {\n    // If any error occurs during parsing, treat as not SVG\n    return false\n  }\n}\n"],"names":["detectSvgFromXml","buffer","maxSize","content","toString","Math","min","length","xmlDeclMatch","match","declaredEncoding","toLowerCase","includes","cleanContent","replace","trim","rootElementMatch","svgNamespaceRegex","test","svgOpenTag","_error"],"mappings":"AAAA;;CAEC,GACD;;;;AAAO,SAASA,iBAAiBC,MAAc;IAC7C,IAAI;QACF,gEAAgE;QAChE,MAAMC,UAAU;QAChB,MAAMC,UAAUF,OAAOG,QAAQ,CAAC,QAAQ,GAAGC,KAAKC,GAAG,CAACL,OAAOM,MAAM,EAAEL;QAEnE,4DAA4D;QAC5D,MAAMM,eAAeL,QAAQM,KAAK,CAAC;QACnC,MAAMC,mBAAmBF,cAAc,CAAC,EAAE,EAAEG;QAE5C,8BAA8B;QAC9B,IAAID,oBAAoB,CAAC;YAAC;YAAS;YAAS;SAAO,CAACE,QAAQ,CAACF,mBAAmB;YAC9E,OAAO;QACT;QAEA,iEAAiE;QACjE,MAAMG,eAAeV,QAClBW,OAAO,CAAC,oBAAoB,IAC5BA,OAAO,CAAC,oBAAoB,IAC5BA,OAAO,CAAC,gBAAgB,IACxBC,IAAI;QAEP,+CAA+C;QAC/C,MAAMC,mBAAmBH,aAAaJ,KAAK,CAAC;QAC5C,IAAI,CAACO,oBAAoBA,gBAAgB,CAAC,EAAE,KAAK,OAAO;YACtD,OAAO;QACT;QAEA,yDAAyD;QACzD,MAAMC,oBAAoB;QAC1B,IAAI,CAACA,kBAAkBC,IAAI,CAACf,UAAU;YACpC,OAAO;QACT;QAEA,mDAAmD;QACnD,MAAMgB,aAAahB,QAAQM,KAAK,CAAC;QACjC,IAAI,CAACU,YAAY;YACf,OAAO;QACT;QAEA,OAAO;IACT,EAAE,OAAOC,QAAQ;QACf,uDAAuD;QACvD,OAAO;IACT;AACF"}},
    {"offset": {"line": 1577, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/uploads/validateSvg.ts"],"sourcesContent":["/**\n * Validate SVG content for security vulnerabilities\n * Detects and blocks malicious patterns commonly used in SVG-based attacks\n */\nexport function validateSvg(buffer: Buffer): boolean {\n  try {\n    const content = buffer.toString('utf8')\n\n    const dangerousPatterns = [\n      // Script tags\n      /<script[\\s>]/i,\n      /<\\/script>/i,\n\n      // Event handlers (onclick, onload, onerror, etc.)\n      /\\son\\w+\\s*=/i,\n\n      // JavaScript URLs\n      /javascript:/i,\n      /data:text\\/html/i,\n\n      // Foreign objects (can embed HTML)\n      /<foreignObject[\\s>]/i,\n\n      // Embedded iframes\n      /<iframe[\\s>]/i,\n\n      // Embedded objects and embeds\n      /<object[\\s>]/i,\n      /<embed[\\s>]/i,\n\n      // Base64 encoded scripts (common obfuscation technique)\n      /data:image\\/svg\\+xml;base64,[\\w+/]*PHNjcmlwdA/i, // <script in base64\n\n      // XLink href with javascript (deprecated but still dangerous)\n      /xlink:href\\s*=\\s*[\"']javascript:/i,\n\n      // Import statements\n      /@import/i,\n\n      // External resource references that could be dangerous\n      /<!ENTITY/i,\n      /<!DOCTYPE[^>]*\\[/i, // DOCTYPE with internal subset\n\n      // Attempt to use CDATA to hide scripts\n      /<!\\[CDATA\\[[\\s\\S]*<script/i,\n    ]\n\n    for (const pattern of dangerousPatterns) {\n      if (pattern.test(content)) {\n        return false\n      }\n    }\n\n    return true\n  } catch (_error) {\n    return false\n  }\n}\n"],"names":["validateSvg","buffer","content","toString","dangerousPatterns","pattern","test","_error"],"mappings":"AAAA;;;CAGC,GACD;;;;AAAO,SAASA,YAAYC,MAAc;IACxC,IAAI;QACF,MAAMC,UAAUD,OAAOE,QAAQ,CAAC;QAEhC,MAAMC,oBAAoB;YACxB,cAAc;YACd;YACA;YAEA,kDAAkD;YAClD;YAEA,kBAAkB;YAClB;YACA;YAEA,mCAAmC;YACnC;YAEA,mBAAmB;YACnB;YAEA,8BAA8B;YAC9B;YACA;YAEA,wDAAwD;YACxD;YAEA,8DAA8D;YAC9D;YAEA,oBAAoB;YACpB;YAEA,uDAAuD;YACvD;YACA;YAEA,uCAAuC;YACvC;SACD;QAED,KAAK,MAAMC,WAAWD,kBAAmB;YACvC,IAAIC,QAAQC,IAAI,CAACJ,UAAU;gBACzB,OAAO;YACT;QACF;QAEA,OAAO;IACT,EAAE,OAAOK,QAAQ;QACf,OAAO;IACT;AACF"}},
    {"offset": {"line": 1629, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/uploads/checkFileRestrictions.ts"],"sourcesContent":["import { fileTypeFromBuffer } from 'file-type'\n\nimport type { checkFileRestrictionsParams, FileAllowList } from './types.js'\n\nimport { ValidationError } from '../errors/index.js'\nimport { validateMimeType } from '../utilities/validateMimeType.js'\nimport { validatePDF } from '../utilities/validatePDF.js'\nimport { detectSvgFromXml } from './detectSvgFromXml.js'\nimport { getFileTypeFallback } from './getFileTypeFallback.js'\nimport { validateSvg } from './validateSvg.js'\n\n/**\n * Restricted file types and their extensions.\n */\nexport const RESTRICTED_FILE_EXT_AND_TYPES: FileAllowList = [\n  { extensions: ['exe', 'dll'], mimeType: 'application/x-msdownload' },\n  { extensions: ['exe', 'com', 'app', 'action'], mimeType: 'application/x-executable' },\n  { extensions: ['bat', 'cmd'], mimeType: 'application/x-msdos-program' },\n  { extensions: ['exe', 'com'], mimeType: 'application/x-ms-dos-executable' },\n  { extensions: ['dmg'], mimeType: 'application/x-apple-diskimage' },\n  { extensions: ['deb'], mimeType: 'application/x-debian-package' },\n  { extensions: ['rpm'], mimeType: 'application/x-redhat-package-manager' },\n  { extensions: ['exe', 'dll'], mimeType: 'application/vnd.microsoft.portable-executable' },\n  { extensions: ['msi'], mimeType: 'application/x-msi' },\n  { extensions: ['jar', 'ear', 'war'], mimeType: 'application/java-archive' },\n  { extensions: ['desktop'], mimeType: 'application/x-desktop' },\n  { extensions: ['cpl'], mimeType: 'application/x-cpl' },\n  { extensions: ['lnk'], mimeType: 'application/x-ms-shortcut' },\n  { extensions: ['pkg'], mimeType: 'application/x-apple-installer' },\n  { extensions: ['htm', 'html', 'shtml', 'xhtml'], mimeType: 'text/html' },\n  { extensions: ['php', 'phtml'], mimeType: 'application/x-httpd-php' },\n  { extensions: ['js', 'jse'], mimeType: 'text/javascript' },\n  { extensions: ['jsp'], mimeType: 'application/x-jsp' },\n  { extensions: ['py'], mimeType: 'text/x-python' },\n  { extensions: ['rb'], mimeType: 'text/x-ruby' },\n  { extensions: ['pl'], mimeType: 'text/x-perl' },\n  { extensions: ['ps1', 'psc1', 'psd1', 'psh', 'psm1'], mimeType: 'application/x-powershell' },\n  { extensions: ['vbe', 'vbs'], mimeType: 'application/x-vbscript' },\n  { extensions: ['ws', 'wsc', 'wsf', 'wsh'], mimeType: 'application/x-ms-wsh' },\n  { extensions: ['scr'], mimeType: 'application/x-msdownload' },\n  { extensions: ['asp', 'aspx'], mimeType: 'application/x-asp' },\n  { extensions: ['hta'], mimeType: 'application/x-hta' },\n  { extensions: ['reg'], mimeType: 'application/x-registry' },\n  { extensions: ['url'], mimeType: 'application/x-url' },\n  { extensions: ['workflow'], mimeType: 'application/x-workflow' },\n  { extensions: ['command'], mimeType: 'application/x-command' },\n]\n\nexport const checkFileRestrictions = async ({\n  collection,\n  file,\n  req,\n}: checkFileRestrictionsParams): Promise<void> => {\n  const errors: string[] = []\n  const { upload: uploadConfig } = collection\n  const useTempFiles = req?.payload?.config?.upload?.useTempFiles ?? false\n  const configMimeTypes =\n    uploadConfig &&\n    typeof uploadConfig === 'object' &&\n    'mimeTypes' in uploadConfig &&\n    Array.isArray(uploadConfig.mimeTypes)\n      ? uploadConfig.mimeTypes\n      : []\n\n  const allowRestrictedFileTypes =\n    uploadConfig && typeof uploadConfig === 'object' && 'allowRestrictedFileTypes' in uploadConfig\n      ? (uploadConfig as { allowRestrictedFileTypes?: boolean }).allowRestrictedFileTypes\n      : false\n\n  const expectsDetectableType = (mimeType: string): boolean => {\n    const textBasedTypes = ['/svg', 'image/svg+xml', 'image/x-xbitmap', 'image/x-xpixmap']\n\n    if (textBasedTypes.includes(mimeType)) {\n      return false\n    }\n\n    return (\n      mimeType.startsWith('image/') ||\n      mimeType.startsWith('video/') ||\n      mimeType.startsWith('audio/') ||\n      mimeType === 'application/pdf'\n    )\n  }\n\n  // Skip validation if `allowRestrictedFileTypes` is true\n  if (allowRestrictedFileTypes) {\n    return\n  }\n\n  // Secondary mimetype check to assess file type from buffer\n  if (configMimeTypes.length > 0) {\n    let detected = await fileTypeFromBuffer(file.data)\n    const typeFromExtension = file.name.split('.').pop() || ''\n\n    // Handle SVG files that are detected as XML due to <?xml declarations\n    if (\n      detected?.mime === 'application/xml' &&\n      configMimeTypes.some(\n        (type) => type.includes('image/') && (type.includes('svg') || type === 'image/*'),\n      )\n    ) {\n      const isSvg = detectSvgFromXml(file.data)\n      if (isSvg) {\n        detected = { ext: 'svg' as any, mime: 'image/svg+xml' as any }\n      }\n    }\n\n    if (!detected && !useTempFiles) {\n      const mimeTypeFromExtension = getFileTypeFallback(file.name).mime\n      const extIsValid = validateMimeType(mimeTypeFromExtension, configMimeTypes)\n\n      if (!extIsValid) {\n        errors.push(\n          `File type ${mimeTypeFromExtension} (from extension ${typeFromExtension}) is not allowed.`,\n        )\n      } else {\n        // SVG security check (text-based files not detectable by buffer)\n        if (typeFromExtension.toLowerCase() === 'svg') {\n          const isSafeSvg = validateSvg(file.data)\n          if (!isSafeSvg) {\n            errors.push('SVG file contains potentially harmful content.')\n          }\n        }\n\n        // PDF validation\n        if (mimeTypeFromExtension === 'application/pdf') {\n          const isValidPDF = validatePDF(file.data)\n          if (!isValidPDF) {\n            errors.push('Invalid or corrupted PDF file.')\n          }\n        }\n      }\n\n      if (expectsDetectableType(mimeTypeFromExtension)) {\n        req.payload.logger.warn(\n          `File buffer returned no detectable MIME type for ${file.name}. Falling back to extension-based validation.`,\n        )\n      }\n    }\n\n    const passesMimeTypeCheck = detected?.mime && validateMimeType(detected.mime, configMimeTypes)\n\n    if (passesMimeTypeCheck && detected?.mime === 'application/pdf') {\n      const isValidPDF = validatePDF(file?.data)\n      if (!isValidPDF) {\n        errors.push('Invalid PDF file.')\n      }\n    }\n\n    if (detected && !passesMimeTypeCheck) {\n      errors.push(`Invalid MIME type: ${detected.mime}.`)\n    }\n  } else {\n    const isRestricted = RESTRICTED_FILE_EXT_AND_TYPES.some((type) => {\n      const hasRestrictedExt = type.extensions.some((ext) => file.name.toLowerCase().endsWith(ext))\n      const hasRestrictedMime = type.mimeType === file.mimetype\n      return hasRestrictedExt || hasRestrictedMime\n    })\n    if (isRestricted) {\n      errors.push(\n        `File type '${file.mimetype}' not allowed ${file.name}: Restricted file type detected -- set 'allowRestrictedFileTypes' to true to skip this check for this Collection.`,\n      )\n    }\n  }\n\n  if (errors.length > 0) {\n    req.payload.logger.error(errors.join(', '))\n    throw new ValidationError({\n      errors: [{ message: errors.join(', '), path: 'file' }],\n    })\n  }\n}\n"],"names":["fileTypeFromBuffer","ValidationError","validateMimeType","validatePDF","detectSvgFromXml","getFileTypeFallback","validateSvg","RESTRICTED_FILE_EXT_AND_TYPES","extensions","mimeType","checkFileRestrictions","collection","file","req","errors","upload","uploadConfig","useTempFiles","payload","config","configMimeTypes","Array","isArray","mimeTypes","allowRestrictedFileTypes","expectsDetectableType","textBasedTypes","includes","startsWith","length","detected","data","typeFromExtension","name","split","pop","mime","some","type","isSvg","ext","mimeTypeFromExtension","extIsValid","push","toLowerCase","isSafeSvg","isValidPDF","logger","warn","passesMimeTypeCheck","isRestricted","hasRestrictedExt","endsWith","hasRestrictedMime","mimetype","error","join","message","path"],"mappings":"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"}},
    {"offset": {"line": 1957, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/uploads/optionallyAppendMetadata.ts"],"sourcesContent":["import type { Sharp, Metadata as SharpMetadata } from 'sharp'\n\nimport type { PayloadRequest } from '../types/index.js'\n\nexport type WithMetadata =\n  | ((options: { metadata: SharpMetadata; req: PayloadRequest }) => Promise<boolean>)\n  | boolean\n\nexport async function optionallyAppendMetadata({\n  req,\n  sharpFile,\n  withMetadata,\n}: {\n  req: PayloadRequest\n  sharpFile: Sharp\n  withMetadata: WithMetadata\n}): Promise<Sharp> {\n  const metadata = await sharpFile.metadata()\n\n  if (withMetadata === true) {\n    return sharpFile.withMetadata()\n  } else if (typeof withMetadata === 'function') {\n    const useMetadata = await withMetadata({ metadata, req })\n\n    if (useMetadata) {\n      return sharpFile.withMetadata()\n    }\n  }\n\n  return sharpFile\n}\n"],"names":["optionallyAppendMetadata","req","sharpFile","withMetadata","metadata","useMetadata"],"mappings":";;;;AAQO,eAAeA,yBAAyB,EAC7CC,GAAG,EACHC,SAAS,EACTC,YAAY,EAKb;IACC,MAAMC,WAAW,MAAMF,UAAUE,QAAQ;IAEzC,IAAID,iBAAiB,MAAM;QACzB,OAAOD,UAAUC,YAAY;IAC/B,OAAO,IAAI,OAAOA,iBAAiB,YAAY;QAC7C,MAAME,cAAc,MAAMF,aAAa;YAAEC;YAAUH;QAAI;QAEvD,IAAII,aAAa;YACf,OAAOH,UAAUC,YAAY;QAC/B;IACF;IAEA,OAAOD;AACT"}},
    {"offset": {"line": 1980, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/uploads/cropImage.ts"],"sourcesContent":["import type { SharpOptions } from 'sharp'\n\nimport type { SanitizedConfig } from '../config/types.js'\nimport type { PayloadRequest } from '../types/index.js'\nimport type { WithMetadata } from './optionallyAppendMetadata.js'\nimport type { UploadEdits } from './types.js'\n\nimport { optionallyAppendMetadata } from './optionallyAppendMetadata.js'\n\nconst percentToPixel = (value: number, dimension: number) => {\n  return Math.floor((value / 100) * dimension)\n}\n\ntype CropImageArgs = {\n  cropData: UploadEdits['crop']\n  dimensions: { height: number; width: number }\n  file: PayloadRequest['file']\n  heightInPixels: number\n  req?: PayloadRequest\n  sharp: SanitizedConfig['sharp']\n  widthInPixels: number\n  withMetadata?: WithMetadata\n}\nexport async function cropImage({\n  cropData,\n  dimensions,\n  file: fileArg,\n  heightInPixels,\n  req,\n  sharp,\n  widthInPixels,\n  withMetadata,\n}: CropImageArgs) {\n  try {\n    const { x, y } = cropData!\n    const file = fileArg!\n\n    const fileIsAnimatedType = ['image/avif', 'image/gif', 'image/webp'].includes(file.mimetype)\n\n    const sharpOptions: SharpOptions = {}\n\n    if (fileIsAnimatedType) {\n      sharpOptions.animated = true\n    }\n\n    const { height: originalHeight, width: originalWidth } = dimensions\n    const newWidth = Number(widthInPixels)\n    const newHeight = Number(heightInPixels)\n\n    const dimensionsChanged = originalWidth !== newWidth || originalHeight !== newHeight\n\n    if (!dimensionsChanged) {\n      let adjustedHeight = originalHeight\n\n      if (fileIsAnimatedType) {\n        const animatedMetadata = await sharp(\n          file.tempFilePath || file.data,\n          sharpOptions,\n        ).metadata()\n        adjustedHeight = animatedMetadata.pages ? animatedMetadata.height! : originalHeight\n      }\n\n      return {\n        data: file.data,\n        info: {\n          height: adjustedHeight,\n          size: file.size,\n          width: originalWidth,\n        },\n      }\n    }\n\n    const formattedCropData = {\n      height: Number(heightInPixels),\n      left: percentToPixel(x, dimensions.width),\n      top: percentToPixel(y, dimensions.height),\n      width: Number(widthInPixels),\n    }\n\n    let cropped = sharp(file.tempFilePath || file.data, sharpOptions).extract(formattedCropData)\n\n    cropped = await optionallyAppendMetadata({\n      req: req!,\n      sharpFile: cropped,\n      withMetadata: withMetadata!,\n    })\n\n    return await cropped.toBuffer({\n      resolveWithObject: true,\n    })\n  } catch (error) {\n    console.error(`Error cropping image:`, error)\n    throw error\n  }\n}\n"],"names":["optionallyAppendMetadata","percentToPixel","value","dimension","Math","floor","cropImage","cropData","dimensions","file","fileArg","heightInPixels","req","sharp","widthInPixels","withMetadata","x","y","fileIsAnimatedType","includes","mimetype","sharpOptions","animated","height","originalHeight","width","originalWidth","newWidth","Number","newHeight","dimensionsChanged","adjustedHeight","animatedMetadata","tempFilePath","data","metadata","pages","info","size","formattedCropData","left","top","cropped","extract","sharpFile","toBuffer","resolveWithObject","error","console"],"mappings":";;;;AAOA,SAASA,wBAAwB,QAAQ,gCAA+B;;AAExE,MAAMC,iBAAiB,CAACC,OAAeC;IACrC,OAAOC,KAAKC,KAAK,CAAEH,QAAQ,MAAOC;AACpC;AAYO,eAAeG,UAAU,EAC9BC,QAAQ,EACRC,UAAU,EACVC,MAAMC,OAAO,EACbC,cAAc,EACdC,GAAG,EACHC,KAAK,EACLC,aAAa,EACbC,YAAY,EACE;IACd,IAAI;QACF,MAAM,EAAEC,CAAC,EAAEC,CAAC,EAAE,GAAGV;QACjB,MAAME,OAAOC;QAEb,MAAMQ,qBAAqB;YAAC;YAAc;YAAa;SAAa,CAACC,QAAQ,CAACV,KAAKW,QAAQ;QAE3F,MAAMC,eAA6B,CAAC;QAEpC,IAAIH,oBAAoB;YACtBG,aAAaC,QAAQ,GAAG;QAC1B;QAEA,MAAM,EAAEC,QAAQC,cAAc,EAAEC,OAAOC,aAAa,EAAE,GAAGlB;QACzD,MAAMmB,WAAWC,OAAOd;QACxB,MAAMe,YAAYD,OAAOjB;QAEzB,MAAMmB,oBAAoBJ,kBAAkBC,YAAYH,mBAAmBK;QAE3E,IAAI,CAACC,mBAAmB;YACtB,IAAIC,iBAAiBP;YAErB,IAAIN,oBAAoB;gBACtB,MAAMc,mBAAmB,MAAMnB,MAC7BJ,KAAKwB,YAAY,IAAIxB,KAAKyB,IAAI,EAC9Bb,cACAc,QAAQ;gBACVJ,iBAAiBC,iBAAiBI,KAAK,GAAGJ,iBAAiBT,MAAM,GAAIC;YACvE;YAEA,OAAO;gBACLU,MAAMzB,KAAKyB,IAAI;gBACfG,MAAM;oBACJd,QAAQQ;oBACRO,MAAM7B,KAAK6B,IAAI;oBACfb,OAAOC;gBACT;YACF;QACF;QAEA,MAAMa,oBAAoB;YACxBhB,QAAQK,OAAOjB;YACf6B,MAAMvC,eAAee,GAAGR,WAAWiB,KAAK;YACxCgB,KAAKxC,eAAegB,GAAGT,WAAWe,MAAM;YACxCE,OAAOG,OAAOd;QAChB;QAEA,IAAI4B,UAAU7B,MAAMJ,KAAKwB,YAAY,IAAIxB,KAAKyB,IAAI,EAAEb,cAAcsB,OAAO,CAACJ;QAE1EG,UAAU,UAAM1C,oMAAAA,EAAyB;YACvCY,KAAKA;YACLgC,WAAWF;YACX3B,cAAcA;QAChB;QAEA,OAAO,MAAM2B,QAAQG,QAAQ,CAAC;YAC5BC,mBAAmB;QACrB;IACF,EAAE,OAAOC,OAAO;QACdC,QAAQD,KAAK,CAAC,CAAC,qBAAqB,CAAC,EAAEA;QACvC,MAAMA;IACR;AACF"}},
    {"offset": {"line": 2045, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/uploads/safeFetch.ts"],"sourcesContent":["import type { LookupFunction } from 'net'\n\nimport { lookup } from 'dns'\nimport ipaddr from 'ipaddr.js'\nimport { Agent, fetch as undiciFetch } from 'undici'\n\n/**\n * @internal this is used to mock the IP `lookup` function in integration tests\n */\nexport const _internal_safeFetchGlobal = {\n  lookup,\n}\n\nconst isSafeIp = (ip: string) => {\n  try {\n    if (!ip) {\n      return false\n    }\n\n    if (!ipaddr.isValid(ip)) {\n      return false\n    }\n\n    const parsedIpAddress = ipaddr.parse(ip)\n    const range = parsedIpAddress.range()\n    if (range !== 'unicast') {\n      return false // Private IP Range\n    }\n  } catch (ignore) {\n    return false\n  }\n  return true\n}\n\nconst ssrfFilterInterceptor: LookupFunction = (hostname, options, callback) => {\n  _internal_safeFetchGlobal.lookup(hostname, options, (err, address, family) => {\n    if (err) {\n      callback(err, address, family)\n    } else {\n      let ips = [] as string[]\n      if (Array.isArray(address)) {\n        ips = address.map((a) => a.address)\n      } else {\n        ips = [address]\n      }\n\n      if (ips.some((ip) => !isSafeIp(ip))) {\n        callback(new Error(`Blocked unsafe attempt to ${hostname}`), address, family)\n        return\n      }\n\n      callback(null, address, family)\n    }\n  })\n}\n\nconst safeDispatcher = new Agent({\n  connect: { lookup: ssrfFilterInterceptor },\n})\n/**\n * A \"safe\" version of undici's fetch that prevents SSRF attacks.\n *\n * - Utilizes a custom dispatcher that filters out requests to unsafe IP addresses.\n * - Validates domain names by resolving them to IP addresses and checking if they're safe.\n * - Undici was used because it supported interceptors as well as \"credentials: include\". Native fetch\n */\nexport const safeFetch = async (...args: Parameters<typeof undiciFetch>) => {\n  const [unverifiedUrl, options] = args\n\n  try {\n    const url = new URL(unverifiedUrl)\n\n    let hostname = url.hostname\n\n    // Strip brackets from IPv6 addresses (e.g., \"[::1]\" => \"::1\")\n    if (hostname.startsWith('[') && hostname.endsWith(']')) {\n      hostname = hostname.slice(1, -1)\n    }\n\n    if (ipaddr.isValid(hostname)) {\n      if (!isSafeIp(hostname)) {\n        throw new Error(`Blocked unsafe attempt to ${hostname}`)\n      }\n    }\n    return await undiciFetch(url, {\n      ...options,\n      dispatcher: safeDispatcher,\n    })\n  } catch (error) {\n    if (error instanceof Error) {\n      if (error.cause instanceof Error && error.cause.message.includes('unsafe')) {\n        // Errors thrown from within interceptors always have 'fetch error' as the message\n        // The desired message we want to bubble up is in the cause\n        throw new Error(error.cause.message)\n      } else {\n        let stringifiedUrl: string | undefined = undefined\n        if (typeof unverifiedUrl === 'string') {\n          stringifiedUrl = unverifiedUrl\n        } else if (unverifiedUrl instanceof URL) {\n          stringifiedUrl = unverifiedUrl.toString()\n        } else if (unverifiedUrl instanceof Request) {\n          stringifiedUrl = unverifiedUrl.url\n        }\n\n        throw new Error(`Failed to fetch from ${stringifiedUrl}, ${error.message}`)\n      }\n    }\n    throw error\n  }\n}\n"],"names":["lookup","ipaddr","Agent","fetch","undiciFetch","_internal_safeFetchGlobal","isSafeIp","ip","isValid","parsedIpAddress","parse","range","ignore","ssrfFilterInterceptor","hostname","options","callback","err","address","family","ips","Array","isArray","map","a","some","Error","safeDispatcher","connect","safeFetch","args","unverifiedUrl","url","URL","startsWith","endsWith","slice","dispatcher","error","cause","message","includes","stringifiedUrl","undefined","toString","Request"],"mappings":";;;;;;AAEA,SAASA,MAAM,QAAQ,MAAK;AAC5B,OAAOC,YAAY,YAAW;AAC9B,SAASC,KAAK,EAAEC,SAASC,WAAW,QAAQ,SAAQ;;;;AAK7C,MAAMC,4BAA4B;YACvCL,yGAAAA;AACF,EAAC;AAED,MAAMM,WAAW,CAACC;IAChB,IAAI;QACF,IAAI,CAACA,IAAI;YACP,OAAO;QACT;QAEA,IAAI,CAACN,qLAAAA,CAAOO,OAAO,CAACD,KAAK;YACvB,OAAO;QACT;QAEA,MAAME,kBAAkBR,qLAAAA,CAAOS,KAAK,CAACH;QACrC,MAAMI,QAAQF,gBAAgBE,KAAK;QACnC,IAAIA,UAAU,WAAW;YACvB,OAAO,MAAM,mBAAmB;;QAClC;IACF,EAAE,OAAOC,QAAQ;QACf,OAAO;IACT;IACA,OAAO;AACT;AAEA,MAAMC,wBAAwC,CAACC,UAAUC,SAASC;IAChEX,0BAA0BL,MAAM,CAACc,UAAUC,SAAS,CAACE,KAAKC,SAASC;QACjE,IAAIF,KAAK;YACPD,SAASC,KAAKC,SAASC;QACzB,OAAO;YACL,IAAIC,MAAM,EAAE;YACZ,IAAIC,MAAMC,OAAO,CAACJ,UAAU;gBAC1BE,MAAMF,QAAQK,GAAG,CAAC,CAACC,IAAMA,EAAEN,OAAO;YACpC,OAAO;gBACLE,MAAM;oBAACF;iBAAQ;YACjB;YAEA,IAAIE,IAAIK,IAAI,CAAC,CAAClB,KAAO,CAACD,SAASC,MAAM;gBACnCS,SAAS,IAAIU,MAAM,CAAC,0BAA0B,EAAEZ,UAAU,GAAGI,SAASC;gBACtE;YACF;YAEAH,SAAS,MAAME,SAASC;QAC1B;IACF;AACF;AAEA,MAAMQ,iBAAiB,IAAIzB,0IAAAA,CAAM;IAC/B0B,SAAS;QAAE5B,QAAQa;IAAsB;AAC3C;AAQO,MAAMgB,YAAY,OAAO,GAAGC;IACjC,MAAM,CAACC,eAAehB,QAAQ,GAAGe;IAEjC,IAAI;QACF,MAAME,MAAM,IAAIC,IAAIF;QAEpB,IAAIjB,WAAWkB,IAAIlB,QAAQ;QAE3B,8DAA8D;QAC9D,IAAIA,SAASoB,UAAU,CAAC,QAAQpB,SAASqB,QAAQ,CAAC,MAAM;YACtDrB,WAAWA,SAASsB,KAAK,CAAC,GAAG,CAAC;QAChC;QAEA,IAAInC,qLAAAA,CAAOO,OAAO,CAACM,WAAW;YAC5B,IAAI,CAACR,SAASQ,WAAW;gBACvB,MAAM,IAAIY,MAAM,CAAC,0BAA0B,EAAEZ,UAAU;YACzD;QACF;QACA,OAAO,UAAMV,0IAAAA,EAAY4B,KAAK;YAC5B,GAAGjB,OAAO;YACVsB,YAAYV;QACd;IACF,EAAE,OAAOW,OAAO;QACd,IAAIA,iBAAiBZ,OAAO;YAC1B,IAAIY,MAAMC,KAAK,YAAYb,SAASY,MAAMC,KAAK,CAACC,OAAO,CAACC,QAAQ,CAAC,WAAW;gBAC1E,kFAAkF;gBAClF,2DAA2D;gBAC3D,MAAM,IAAIf,MAAMY,MAAMC,KAAK,CAACC,OAAO;YACrC,OAAO;gBACL,IAAIE,iBAAqCC;gBACzC,IAAI,OAAOZ,kBAAkB,UAAU;oBACrCW,iBAAiBX;gBACnB,OAAO,IAAIA,yBAAyBE,KAAK;oBACvCS,iBAAiBX,cAAca,QAAQ;gBACzC,OAAO,IAAIb,yBAAyBc,SAAS;oBAC3CH,iBAAiBX,cAAcC,GAAG;gBACpC;gBAEA,MAAM,IAAIN,MAAM,CAAC,qBAAqB,EAAEgB,eAAe,EAAE,EAAEJ,MAAME,OAAO,EAAE;YAC5E;QACF;QACA,MAAMF;IACR;AACF,EAAC"}},
    {"offset": {"line": 2148, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/uploads/getExternalFile.ts"],"sourcesContent":["import type { PayloadRequest } from '../types/index.js'\nimport type { File, FileData, UploadConfig } from './types.js'\n\nimport { APIError } from '../errors/index.js'\nimport { isURLAllowed } from '../utilities/isURLAllowed.js'\nimport { safeFetch } from './safeFetch.js'\n\ntype Args = {\n  data: FileData\n  req: PayloadRequest\n  uploadConfig: UploadConfig\n}\nexport const getExternalFile = async ({ data, req, uploadConfig }: Args): Promise<File> => {\n  const { filename, url } = data\n\n  let trimAuthCookies = true\n  if (typeof url === 'string') {\n    let fileURL = url\n    if (!url.startsWith('http')) {\n      // URL points to the same server - we can send any cookies safely to our server.\n      trimAuthCookies = false\n      const baseUrl = req.headers.get('origin') || `${req.protocol}://${req.headers.get('host')}`\n      fileURL = `${baseUrl}${url}`\n    }\n\n    let cookies = (req.headers.get('cookie') ?? '').split(';')\n\n    if (trimAuthCookies) {\n      cookies = cookies.filter(\n        (cookie) => !cookie.trim().startsWith(req.payload.config.cookiePrefix),\n      )\n    }\n\n    const headers = uploadConfig.externalFileHeaderFilter\n      ? uploadConfig.externalFileHeaderFilter(Object.fromEntries(new Headers(req.headers)))\n      : {\n          cookie: cookies.join(';'),\n        }\n\n    // Check if URL is allowed because of skipSafeFetch allowList\n    const skipSafeFetch: boolean =\n      uploadConfig.skipSafeFetch === true\n        ? uploadConfig.skipSafeFetch\n        : Array.isArray(uploadConfig.skipSafeFetch) &&\n          isURLAllowed(fileURL, uploadConfig.skipSafeFetch)\n\n    // Check if URL is allowed because of pasteURL allowList\n    const isAllowedPasteUrl: boolean | undefined =\n      uploadConfig.pasteURL &&\n      uploadConfig.pasteURL.allowList &&\n      isURLAllowed(fileURL, uploadConfig.pasteURL.allowList)\n\n    let res\n    if (skipSafeFetch || isAllowedPasteUrl) {\n      // Allowed\n      res = await fetch(fileURL, {\n        credentials: 'include',\n        headers,\n        method: 'GET',\n      })\n    } else {\n      // Default\n      res = await safeFetch(fileURL, {\n        credentials: 'include',\n        headers,\n        method: 'GET',\n      })\n    }\n\n    if (!res.ok) {\n      throw new APIError(`Failed to fetch file from ${fileURL}`, res.status)\n    }\n\n    const data = await res.arrayBuffer()\n\n    return {\n      name: filename,\n      data: Buffer.from(data),\n      mimetype: res.headers.get('content-type') || undefined!,\n      size: Number(res.headers.get('content-length')) || 0,\n    }\n  }\n\n  throw new APIError('Invalid file url', 400)\n}\n"],"names":["APIError","isURLAllowed","safeFetch","getExternalFile","data","req","uploadConfig","filename","url","trimAuthCookies","fileURL","startsWith","baseUrl","headers","get","protocol","cookies","split","filter","cookie","trim","payload","config","cookiePrefix","externalFileHeaderFilter","Object","fromEntries","Headers","join","skipSafeFetch","Array","isArray","isAllowedPasteUrl","pasteURL","allowList","res","fetch","credentials","method","ok","status","arrayBuffer","name","Buffer","from","mimetype","undefined","size","Number"],"mappings":";;;;AAGA,SAASA,QAAQ,QAAQ,qBAAoB;AAC7C,SAASC,YAAY,QAAQ,+BAA8B;AAC3D,SAASC,SAAS,QAAQ,iBAAgB;;;;AAOnC,MAAMC,kBAAkB,OAAO,EAAEC,IAAI,EAAEC,GAAG,EAAEC,YAAY,EAAQ;IACrE,MAAM,EAAEC,QAAQ,EAAEC,GAAG,EAAE,GAAGJ;IAE1B,IAAIK,kBAAkB;IACtB,IAAI,OAAOD,QAAQ,UAAU;QAC3B,IAAIE,UAAUF;QACd,IAAI,CAACA,IAAIG,UAAU,CAAC,SAAS;YAC3B,gFAAgF;YAChFF,kBAAkB;YAClB,MAAMG,UAAUP,IAAIQ,OAAO,CAACC,GAAG,CAAC,aAAa,GAAGT,IAAIU,QAAQ,CAAC,GAAG,EAAEV,IAAIQ,OAAO,CAACC,GAAG,CAAC,SAAS;YAC3FJ,UAAU,GAAGE,UAAUJ,KAAK;QAC9B;QAEA,IAAIQ,UAAWX,CAAAA,IAAIQ,OAAO,CAACC,GAAG,CAAC,aAAa,EAAC,EAAGG,KAAK,CAAC;QAEtD,IAAIR,iBAAiB;YACnBO,UAAUA,QAAQE,MAAM,CACtB,CAACC,SAAW,CAACA,OAAOC,IAAI,GAAGT,UAAU,CAACN,IAAIgB,OAAO,CAACC,MAAM,CAACC,YAAY;QAEzE;QAEA,MAAMV,UAAUP,aAAakB,wBAAwB,GACjDlB,aAAakB,wBAAwB,CAACC,OAAOC,WAAW,CAAC,IAAIC,QAAQtB,IAAIQ,OAAO,MAChF;YACEM,QAAQH,QAAQY,IAAI,CAAC;QACvB;QAEJ,6DAA6D;QAC7D,MAAMC,gBACJvB,aAAauB,aAAa,KAAK,OAC3BvB,aAAauB,aAAa,GAC1BC,MAAMC,OAAO,CAACzB,aAAauB,aAAa,SACxC5B,8KAAAA,EAAaS,SAASJ,aAAauB,aAAa;QAEtD,wDAAwD;QACxD,MAAMG,oBACJ1B,aAAa2B,QAAQ,IACrB3B,aAAa2B,QAAQ,CAACC,SAAS,QAC/BjC,8KAAAA,EAAaS,SAASJ,aAAa2B,QAAQ,CAACC,SAAS;QAEvD,IAAIC;QACJ,IAAIN,iBAAiBG,mBAAmB;YACtC,UAAU;YACVG,MAAM,MAAMC,MAAM1B,SAAS;gBACzB2B,aAAa;gBACbxB;gBACAyB,QAAQ;YACV;QACF,OAAO;YACL,UAAU;YACVH,MAAM,UAAMjC,sKAAAA,EAAUQ,SAAS;gBAC7B2B,aAAa;gBACbxB;gBACAyB,QAAQ;YACV;QACF;QAEA,IAAI,CAACH,IAAII,EAAE,EAAE;YACX,MAAM,IAAIvC,mKAAAA,CAAS,CAAC,0BAA0B,EAAEU,SAAS,EAAEyB,IAAIK,MAAM;QACvE;QAEA,MAAMpC,OAAO,MAAM+B,IAAIM,WAAW;QAElC,OAAO;YACLC,MAAMnC;YACNH,MAAMuC,OAAOC,IAAI,CAACxC;YAClByC,UAAUV,IAAItB,OAAO,CAACC,GAAG,CAAC,mBAAmBgC;YAC7CC,MAAMC,OAAOb,IAAItB,OAAO,CAACC,GAAG,CAAC,sBAAsB;QACrD;IACF;IAEA,MAAM,IAAId,mKAAAA,CAAS,oBAAoB;AACzC,EAAC"}},
    {"offset": {"line": 2213, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/uploads/getFileByPath.ts"],"sourcesContent":["import { fileTypeFromFile } from 'file-type'\nimport fs from 'fs/promises'\nimport path from 'path'\n\nimport type { PayloadRequest } from '../types/index.js'\n\nconst mimeTypeEstimate: Record<string, string> = {\n  svg: 'image/svg+xml',\n}\n\nexport const getFileByPath = async (filePath: string): Promise<PayloadRequest['file']> => {\n  if (typeof filePath !== 'string') {\n    return undefined\n  }\n\n  const name = path.basename(filePath)\n  const ext = path.extname(filePath).slice(1)\n\n  const [data, stat, type] = await Promise.all([\n    fs.readFile(filePath),\n    fs.stat(filePath),\n    fileTypeFromFile(filePath),\n  ])\n\n  return {\n    name,\n    data,\n    mimetype: type?.mime || mimeTypeEstimate[ext]!,\n    size: stat.size,\n  }\n}\n"],"names":["fileTypeFromFile","fs","path","mimeTypeEstimate","svg","getFileByPath","filePath","undefined","name","basename","ext","extname","slice","data","stat","type","Promise","all","readFile","mimetype","mime","size"],"mappings":";;;;AAAA,SAASA,gBAAgB,QAAQ,YAAW;AAC5C,OAAOC,QAAQ,cAAa;AAC5B,OAAOC,UAAU,OAAM;;;;AAIvB,MAAMC,mBAA2C;IAC/CC,KAAK;AACP;AAEO,MAAMC,gBAAgB,OAAOC;IAClC,IAAI,OAAOA,aAAa,UAAU;QAChC,OAAOC;IACT;IAEA,MAAMC,OAAON,4GAAAA,CAAKO,QAAQ,CAACH;IAC3B,MAAMI,MAAMR,4GAAAA,CAAKS,OAAO,CAACL,UAAUM,KAAK,CAAC;IAEzC,MAAM,CAACC,MAAMC,MAAMC,KAAK,GAAG,MAAMC,QAAQC,GAAG,CAAC;QAC3ChB,gIAAAA,CAAGiB,QAAQ,CAACZ;QACZL,gIAAAA,CAAGa,IAAI,CAACR;YACRN,2KAAAA,EAAiBM;KAClB;IAED,OAAO;QACLE;QACAK;QACAM,UAAUJ,MAAMK,QAAQjB,gBAAgB,CAACO,IAAI;QAC7CW,MAAMP,KAAKO,IAAI;IACjB;AACF,EAAC"}},
    {"offset": {"line": 2248, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/uploads/tempFile.ts"],"sourcesContent":["import fs from 'fs/promises'\nimport os from 'node:os'\nimport path from 'node:path'\nimport { v4 as uuid } from 'uuid'\n\nasync function runTask(temporaryPath: string, callback: (temporaryPath: string) => Promise<any>) {\n  try {\n    return await callback(temporaryPath)\n  } finally {\n    await fs.rm(temporaryPath, { force: true, maxRetries: 2, recursive: true })\n  }\n}\n\ntype Options = {\n  extension?: string\n  name?: string\n}\n\nexport const temporaryFileTask = async (\n  callback: (temporaryPath: string) => Promise<any>,\n  options: Options = {},\n) => {\n  const filePath = await temporaryFile(options)\n  return runTask(filePath, callback)\n}\n\nasync function temporaryFile(options: Options) {\n  if (options.name) {\n    if (options.extension !== undefined && options.extension !== null) {\n      throw new Error('The `name` and `extension` options are mutually exclusive')\n    }\n\n    return path.join(await temporaryDirectory(), options.name)\n  }\n\n  return (\n    (await getPath()) +\n    (options.extension === undefined || options.extension === null\n      ? ''\n      : '.' + options.extension.replace(/^\\./, ''))\n  )\n}\n\nasync function temporaryDirectory({ prefix = '' } = {}) {\n  const directory = await getPath(prefix)\n  await fs.mkdir(directory)\n  return directory\n}\n\nasync function getPath(prefix = ''): Promise<string> {\n  const temporaryDirectory = await fs.realpath(os.tmpdir())\n  return path.join(temporaryDirectory, prefix + uuid())\n}\n"],"names":["fs","os","path","v4","uuid","runTask","temporaryPath","callback","rm","force","maxRetries","recursive","temporaryFileTask","options","filePath","temporaryFile","name","extension","undefined","Error","join","temporaryDirectory","getPath","replace","prefix","directory","mkdir","realpath","tmpdir"],"mappings":";;;;AAAA,OAAOA,QAAQ,cAAa;AAC5B,OAAOC,QAAQ,UAAS;AACxB,OAAOC,UAAU,YAAW;AAC5B,SAASC,MAAMC,IAAI,QAAQ,OAAM;;;;;AAEjC,eAAeC,QAAQC,aAAqB,EAAEC,QAAiD;IAC7F,IAAI;QACF,OAAO,MAAMA,SAASD;IACxB,SAAU;QACR,MAAMN,gIAAAA,CAAGQ,EAAE,CAACF,eAAe;YAAEG,OAAO;YAAMC,YAAY;YAAGC,WAAW;QAAK;IAC3E;AACF;AAOO,MAAMC,oBAAoB,OAC/BL,UACAM,UAAmB,CAAC,CAAC;IAErB,MAAMC,WAAW,MAAMC,cAAcF;IACrC,OAAOR,QAAQS,UAAUP;AAC3B,EAAC;AAED,eAAeQ,cAAcF,OAAgB;IAC3C,IAAIA,QAAQG,IAAI,EAAE;QAChB,IAAIH,QAAQI,SAAS,KAAKC,aAAaL,QAAQI,SAAS,KAAK,MAAM;YACjE,MAAM,IAAIE,MAAM;QAClB;QAEA,OAAOjB,4HAAAA,CAAKkB,IAAI,CAAC,MAAMC,sBAAsBR,QAAQG,IAAI;IAC3D;IAEA,OACG,MAAMM,YACNT,CAAAA,QAAQI,SAAS,KAAKC,aAAaL,QAAQI,SAAS,KAAK,OACtD,KACA,MAAMJ,QAAQI,SAAS,CAACM,OAAO,CAAC,OAAO,GAAE;AAEjD;AAEA,eAAeF,mBAAmB,EAAEG,SAAS,EAAE,EAAE,GAAG,CAAC,CAAC;IACpD,MAAMC,YAAY,MAAMH,QAAQE;IAChC,MAAMxB,gIAAAA,CAAG0B,KAAK,CAACD;IACf,OAAOA;AACT;AAEA,eAAeH,QAAQE,SAAS,EAAE;IAChC,MAAMH,qBAAqB,MAAMrB,gIAAAA,CAAG2B,QAAQ,CAAC1B,wHAAAA,CAAG2B,MAAM;IACtD,OAAO1B,4HAAAA,CAAKkB,IAAI,CAACC,oBAAoBG,aAASpB,0LAAAA;AAChD"}},
    {"offset": {"line": 2297, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/uploads/getImageSize.ts"],"sourcesContent":["import fs from 'fs/promises'\nimport { imageSize } from 'image-size'\nimport { imageSizeFromFile } from 'image-size/fromFile'\n\nimport type { PayloadRequest } from '../types/index.js'\nimport type { ProbedImageSize } from './types.js'\n\nimport { temporaryFileTask } from './tempFile.js'\n\nexport async function getImageSize(file: PayloadRequest['file']): Promise<ProbedImageSize> {\n  if (file?.tempFilePath) {\n    return imageSizeFromFile(file.tempFilePath)\n  }\n\n  // Tiff file do not support buffers or streams, so we must write to file first\n  // then retrieve dimensions. https://github.com/image-size/image-size/issues/103\n  if (file?.mimetype === 'image/tiff') {\n    const dimensions = await temporaryFileTask(\n      async (filepath: string) => {\n        await fs.writeFile(filepath, file.data)\n        return imageSizeFromFile(filepath)\n      },\n      { extension: 'tiff' },\n    )\n    return dimensions\n  }\n\n  return imageSize(file!.data)\n}\n"],"names":["fs","imageSize","imageSizeFromFile","temporaryFileTask","getImageSize","file","tempFilePath","mimetype","dimensions","filepath","writeFile","data","extension"],"mappings":";;;;AAAA,OAAOA,QAAQ,cAAa;AAC5B,SAASC,SAAS,QAAQ,aAAY;AACtC,SAASC,iBAAiB,QAAQ,sBAAqB;AAKvD,SAASC,iBAAiB,QAAQ,gBAAe;;;;;AAE1C,eAAeC,aAAaC,IAA4B;IAC7D,IAAIA,MAAMC,cAAc;QACtB,WAAOJ,yKAAAA,EAAkBG,KAAKC,YAAY;IAC5C;IAEA,8EAA8E;IAC9E,gFAAgF;IAChF,IAAID,MAAME,aAAa,cAAc;QACnC,MAAMC,aAAa,UAAML,6KAAAA,EACvB,OAAOM;YACL,MAAMT,gIAAAA,CAAGU,SAAS,CAACD,UAAUJ,KAAKM,IAAI;YACtC,WAAOT,yKAAAA,EAAkBO;QAC3B,GACA;YAAEG,WAAW;QAAO;QAEtB,OAAOJ;IACT;IAEA,WAAOP,8JAAAA,EAAUI,KAAMM,IAAI;AAC7B"}},
    {"offset": {"line": 2330, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/uploads/docWithFilenameExists.ts"],"sourcesContent":["import type { PayloadRequest, Where } from '../types/index.js'\n\ntype Args = {\n  collectionSlug: string\n  filename: string\n  path: string\n  prefix?: string\n  req: PayloadRequest\n}\n\nexport const docWithFilenameExists = async ({\n  collectionSlug,\n  filename,\n  prefix,\n  req,\n}: Args): Promise<boolean> => {\n  const where: Where = {\n    filename: {\n      equals: filename,\n    },\n  }\n\n  if (prefix) {\n    where.prefix = { equals: prefix }\n  }\n\n  const doc = await req.payload.db.findOne({\n    collection: collectionSlug,\n    req,\n    where,\n  })\n\n  return !!doc\n}\n"],"names":["docWithFilenameExists","collectionSlug","filename","prefix","req","where","equals","doc","payload","db","findOne","collection"],"mappings":";;;;AAUO,MAAMA,wBAAwB,OAAO,EAC1CC,cAAc,EACdC,QAAQ,EACRC,MAAM,EACNC,GAAG,EACE;IACL,MAAMC,QAAe;QACnBH,UAAU;YACRI,QAAQJ;QACV;IACF;IAEA,IAAIC,QAAQ;QACVE,MAAMF,MAAM,GAAG;YAAEG,QAAQH;QAAO;IAClC;IAEA,MAAMI,MAAM,MAAMH,IAAII,OAAO,CAACC,EAAE,CAACC,OAAO,CAAC;QACvCC,YAAYV;QACZG;QACAC;IACF;IAEA,OAAO,CAAC,CAACE;AACX,EAAC"}},
    {"offset": {"line": 2356, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/uploads/fileExists.ts"],"sourcesContent":["import fs from 'fs/promises'\n\nexport const fileExists = async (filename: string): Promise<boolean> => {\n  try {\n    await fs.stat(filename)\n\n    return true\n  } catch (ignore) {\n    return false\n  }\n}\n"],"names":["fs","fileExists","filename","stat","ignore"],"mappings":";;;;AAAA,OAAOA,QAAQ,cAAa;;AAErB,MAAMC,aAAa,OAAOC;IAC/B,IAAI;QACF,MAAMF,gIAAAA,CAAGG,IAAI,CAACD;QAEd,OAAO;IACT,EAAE,OAAOE,QAAQ;QACf,OAAO;IACT;AACF,EAAC"}},
    {"offset": {"line": 2374, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/uploads/getSafeFilename.ts"],"sourcesContent":["import sanitize from 'sanitize-filename'\n\nimport type { PayloadRequest } from '../types/index.js'\n\nimport { docWithFilenameExists } from './docWithFilenameExists.js'\nimport { fileExists } from './fileExists.js'\n\n/**\n * Increments a filename by appending or incrementing a numeric suffix.\n * @example\n * incrementName('file.jpg') // 'file-1.jpg'\n * incrementName('file-1.jpg') // 'file-2.jpg'\n * incrementName('file-99.jpg') // 'file-100.jpg'\n */\nexport const incrementName = (name: string): string => {\n  const extension = name.split('.').pop()\n  const baseFilename = sanitize(name.substring(0, name.lastIndexOf('.')) || name)\n  let incrementedName = baseFilename\n  const regex = /(.*)-(\\d+)$/\n  const found = baseFilename.match(regex)\n  if (found === null) {\n    incrementedName += '-1'\n  } else {\n    const matchedName = found[1]\n    const matchedNumber = found[2]\n    const incremented = Number(matchedNumber) + 1\n    incrementedName = `${matchedName}-${incremented}`\n  }\n  return `${incrementedName}.${extension}`\n}\n\ntype Args = {\n  collectionSlug: string\n  desiredFilename: string\n  prefix?: string\n  req: PayloadRequest\n  staticPath: string\n}\n\n/**\n * Generates a safe, unique filename by checking for conflicts in both the database\n * and filesystem. If a conflict exists, it increments a numeric suffix until a\n * unique name is found.\n *\n * @param args.collectionSlug - The slug of the upload collection\n * @param args.desiredFilename - The original filename to make safe\n * @param args.prefix - Optional prefix path for cloud storage adapters\n * @param args.req - The Payload request object\n * @param args.staticPath - The filesystem path where uploads are stored\n * @returns A unique filename that doesn't conflict with existing files\n *\n * @example\n * // If 'photo.jpg' already exists, returns 'photo-1.jpg'\n * const safeName = await getSafeFileName({\n *   collectionSlug: 'media',\n *   desiredFilename: 'photo.jpg',\n *   req,\n *   staticPath: '/uploads/media',\n * })\n */\nexport async function getSafeFileName({\n  collectionSlug,\n  desiredFilename,\n  prefix,\n  req,\n  staticPath,\n}: Args): Promise<string> {\n  let modifiedFilename = desiredFilename\n\n  while (\n    (await docWithFilenameExists({\n      collectionSlug,\n      filename: modifiedFilename,\n      path: staticPath,\n      prefix,\n      req,\n    })) ||\n    (await fileExists(`${staticPath}/${modifiedFilename}`))\n  ) {\n    modifiedFilename = incrementName(modifiedFilename)\n  }\n  return modifiedFilename\n}\n"],"names":["sanitize","docWithFilenameExists","fileExists","incrementName","name","extension","split","pop","baseFilename","substring","lastIndexOf","incrementedName","regex","found","match","matchedName","matchedNumber","incremented","Number","getSafeFileName","collectionSlug","desiredFilename","prefix","req","staticPath","modifiedFilename","filename","path"],"mappings":";;;;;;AAAA,OAAOA,cAAc,oBAAmB;AAIxC,SAASC,qBAAqB,QAAQ,6BAA4B;AAClE,SAASC,UAAU,QAAQ,kBAAiB;;;;AASrC,MAAMC,gBAAgB,CAACC;IAC5B,MAAMC,YAAYD,KAAKE,KAAK,CAAC,KAAKC,GAAG;IACrC,MAAMC,mBAAeR,0JAAAA,EAASI,KAAKK,SAAS,CAAC,GAAGL,KAAKM,WAAW,CAAC,SAASN;IAC1E,IAAIO,kBAAkBH;IACtB,MAAMI,QAAQ;IACd,MAAMC,QAAQL,aAAaM,KAAK,CAACF;IACjC,IAAIC,UAAU,MAAM;QAClBF,mBAAmB;IACrB,OAAO;QACL,MAAMI,cAAcF,KAAK,CAAC,EAAE;QAC5B,MAAMG,gBAAgBH,KAAK,CAAC,EAAE;QAC9B,MAAMI,cAAcC,OAAOF,iBAAiB;QAC5CL,kBAAkB,GAAGI,YAAY,CAAC,EAAEE,aAAa;IACnD;IACA,OAAO,GAAGN,gBAAgB,CAAC,EAAEN,WAAW;AAC1C,EAAC;AA+BM,eAAec,gBAAgB,EACpCC,cAAc,EACdC,eAAe,EACfC,MAAM,EACNC,GAAG,EACHC,UAAU,EACL;IACL,IAAIC,mBAAmBJ;IAEvB,MACG,UAAMpB,8LAAAA,EAAsB;QAC3BmB;QACAM,UAAUD;QACVE,MAAMH;QACNF;QACAC;IACF,MACC,UAAMrB,wKAAAA,EAAW,GAAGsB,WAAW,CAAC,EAAEC,kBAAkB,EACrD;QACAA,mBAAmBtB,cAAcsB;IACnC;IACA,OAAOA;AACT"}},
    {"offset": {"line": 2419, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/uploads/image-resizing/createImageSize.ts"],"sourcesContent":["/**\n * Create the result object for the image resize operation based on the\n * provided parameters. If the name is not provided, an empty result object\n * is returned.\n *\n * @param filename - the filename of the image\n * @param width - the width of the image\n * @param height - the height of the image\n * @param filesize - the filesize of the image\n * @param mimeType - the mime type of the image\n * @returns a FileSize result object\n */\n\nimport type { FileSize } from '../types.js'\n\ntype CreateResultArgs = {\n  filename?: FileSize['filename']\n  filesize?: FileSize['filesize']\n  height?: FileSize['height']\n  mimeType?: FileSize['mimeType']\n  url?: FileSize['url']\n  width?: FileSize['width']\n}\nexport const createImageSize = ({\n  filename = null,\n  filesize = null,\n  height = null,\n  mimeType = null,\n  url = null,\n  width = null,\n}: CreateResultArgs): FileSize => {\n  return {\n    filename,\n    filesize,\n    height,\n    mimeType,\n    url,\n    width,\n  }\n}\n"],"names":["createImageSize","filename","filesize","height","mimeType","url","width"],"mappings":"AAAA;;;;;;;;;;;CAWC,GAYD;;;;AAAO,MAAMA,kBAAkB,CAAC,EAC9BC,WAAW,IAAI,EACfC,WAAW,IAAI,EACfC,SAAS,IAAI,EACbC,WAAW,IAAI,EACfC,MAAM,IAAI,EACVC,QAAQ,IAAI,EACK;IACjB,OAAO;QACLL;QACAC;QACAC;QACAC;QACAC;QACAC;IACF;AACF,EAAC"}},
    {"offset": {"line": 2448, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/uploads/image-resizing/extractHeightFromImage.ts"],"sourcesContent":["import type { Metadata as SharpMetadata } from 'sharp'\n\n/**\n * Used to extract height from images, animated or not.\n *\n * @param sharpMetadata - the sharp metadata\n * @returns the height of the image\n */\nexport function extractHeightFromImage(sharpMetadata: SharpMetadata): number {\n  if (sharpMetadata?.pages) {\n    return sharpMetadata.height! / sharpMetadata.pages\n  }\n  return sharpMetadata.height!\n}\n"],"names":["extractHeightFromImage","sharpMetadata","pages","height"],"mappings":"AAEA;;;;;CAKC,GACD;;;;AAAO,SAASA,uBAAuBC,aAA4B;IACjE,IAAIA,eAAeC,OAAO;QACxB,OAAOD,cAAcE,MAAM,GAAIF,cAAcC,KAAK;IACpD;IACA,OAAOD,cAAcE,MAAM;AAC7B"}},
    {"offset": {"line": 2467, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/uploads/image-resizing/generateImageSizeFilename.ts"],"sourcesContent":["/**\n * Create a new image name based on the output image name, the dimensions and\n * the extension.\n *\n * Ignore the fact that duplicate names could happen if the there is one\n * size with `width AND height` and one with only `height OR width`. Because\n * space is expensive, we will reuse the same image for both sizes.\n *\n * @param outputImageName - the sanitized image name\n * @param bufferInfo - the buffer info\n * @param extension - the extension to use\n * @returns the new image name that is not taken\n */\ntype CreateImageNameArgs = {\n  extension: string\n  height: number\n  outputImageName: string\n  width: number\n}\nexport const generateImageSizeFilename = ({\n  extension,\n  height,\n  outputImageName,\n  width,\n}: CreateImageNameArgs): string => {\n  return `${outputImageName}-${width}x${height}.${extension}`\n}\n"],"names":["generateImageSizeFilename","extension","height","outputImageName","width"],"mappings":"AAAA;;;;;;;;;;;;CAYC,GAOD;;;;AAAO,MAAMA,4BAA4B,CAAC,EACxCC,SAAS,EACTC,MAAM,EACNC,eAAe,EACfC,KAAK,EACe;IACpB,OAAO,GAAGD,gBAAgB,CAAC,EAAEC,MAAM,CAAC,EAAEF,OAAO,CAAC,EAAED,WAAW;AAC7D,EAAC"}},
    {"offset": {"line": 2490, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/uploads/image-resizing/getImageResizeAction.ts"],"sourcesContent":["import type { ImageSize, ProbedImageSize } from '../types.js'\n\nimport { isNumber } from '../../utilities/isNumber.js'\n\n/**\n * Determine whether or not to resize the image.\n * - resize using image config\n * - resize using image config with focal adjustments\n * - do not resize at all\n *\n * `imageResizeConfig.withoutEnlargement`:\n * - undefined [default]: uploading images with smaller width AND height than the image size will return null\n * - false: always enlarge images to the image size\n * - true: if the image is smaller than the image size, return the original image\n *\n * `imageResizeConfig.withoutReduction`:\n * - false [default]: always enlarge images to the image size\n * - true: if the image is smaller than the image size, return the original image\n *\n * @return 'omit' | 'resize' | 'resizeWithFocalPoint'\n */\nexport const getImageResizeAction = ({\n  dimensions: originalImage,\n  hasFocalPoint,\n  imageResizeConfig,\n}: {\n  dimensions: ProbedImageSize\n  hasFocalPoint?: boolean\n  imageResizeConfig: ImageSize\n}): 'omit' | 'resize' | 'resizeWithFocalPoint' => {\n  const { fit, withoutEnlargement, withoutReduction } = imageResizeConfig\n  const targetWidth = imageResizeConfig.width!\n  const targetHeight = imageResizeConfig.height!\n\n  // prevent upscaling by default when x and y are both smaller than target image size\n  if (targetHeight && targetWidth) {\n    const originalImageIsSmallerXAndY =\n      originalImage.width < targetWidth && originalImage.height < targetHeight\n    if (withoutEnlargement === undefined && originalImageIsSmallerXAndY) {\n      return 'omit' // prevent image size from being enlarged\n    }\n  }\n\n  if (withoutEnlargement === undefined && (!targetWidth || !targetHeight)) {\n    if (\n      (targetWidth && originalImage.width < targetWidth) ||\n      (targetHeight && originalImage.height < targetHeight)\n    ) {\n      return 'omit'\n    }\n  }\n\n  const originalImageIsSmallerXOrY =\n    originalImage.width < targetWidth || originalImage.height < targetHeight\n  if (fit === 'contain' || fit === 'inside') {\n    return 'resize'\n  }\n  if (!isNumber(targetHeight) && !isNumber(targetWidth)) {\n    return 'resize'\n  }\n\n  const targetAspectRatio = targetWidth / targetHeight\n  const originalAspectRatio = originalImage.width / originalImage.height\n  if (originalAspectRatio === targetAspectRatio) {\n    return 'resize'\n  }\n\n  if (withoutEnlargement && originalImageIsSmallerXOrY) {\n    return 'resize'\n  }\n  if (withoutReduction && !originalImageIsSmallerXOrY) {\n    return 'resize'\n  }\n\n  return hasFocalPoint ? 'resizeWithFocalPoint' : 'resize'\n}\n"],"names":["isNumber","getImageResizeAction","dimensions","originalImage","hasFocalPoint","imageResizeConfig","fit","withoutEnlargement","withoutReduction","targetWidth","width","targetHeight","height","originalImageIsSmallerXAndY","undefined","originalImageIsSmallerXOrY","targetAspectRatio","originalAspectRatio"],"mappings":";;;;AAEA,SAASA,QAAQ,QAAQ,8BAA6B;;AAmB/C,MAAMC,uBAAuB,CAAC,EACnCC,YAAYC,aAAa,EACzBC,aAAa,EACbC,iBAAiB,EAKlB;IACC,MAAM,EAAEC,GAAG,EAAEC,kBAAkB,EAAEC,gBAAgB,EAAE,GAAGH;IACtD,MAAMI,cAAcJ,kBAAkBK,KAAK;IAC3C,MAAMC,eAAeN,kBAAkBO,MAAM;IAE7C,oFAAoF;IACpF,IAAID,gBAAgBF,aAAa;QAC/B,MAAMI,8BACJV,cAAcO,KAAK,GAAGD,eAAeN,cAAcS,MAAM,GAAGD;QAC9D,IAAIJ,uBAAuBO,aAAaD,6BAA6B;YACnE,OAAO,OAAO,yCAAyC;;QACzD;IACF;IAEA,IAAIN,uBAAuBO,aAAc,CAAA,CAACL,eAAe,CAACE,YAAW,GAAI;QACvE,IACGF,eAAeN,cAAcO,KAAK,GAAGD,eACrCE,gBAAgBR,cAAcS,MAAM,GAAGD,cACxC;YACA,OAAO;QACT;IACF;IAEA,MAAMI,6BACJZ,cAAcO,KAAK,GAAGD,eAAeN,cAAcS,MAAM,GAAGD;IAC9D,IAAIL,QAAQ,aAAaA,QAAQ,UAAU;QACzC,OAAO;IACT;IACA,IAAI,KAACN,sKAAAA,EAASW,iBAAiB,KAACX,sKAAAA,EAASS,cAAc;QACrD,OAAO;IACT;IAEA,MAAMO,oBAAoBP,cAAcE;IACxC,MAAMM,sBAAsBd,cAAcO,KAAK,GAAGP,cAAcS,MAAM;IACtE,IAAIK,wBAAwBD,mBAAmB;QAC7C,OAAO;IACT;IAEA,IAAIT,sBAAsBQ,4BAA4B;QACpD,OAAO;IACT;IACA,IAAIP,oBAAoB,CAACO,4BAA4B;QACnD,OAAO;IACT;IAEA,OAAOX,gBAAgB,yBAAyB;AAClD,EAAC"}},
    {"offset": {"line": 2537, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/uploads/image-resizing/parseFilename.ts"],"sourcesContent":["import sanitize from 'sanitize-filename'\n\ntype SanitizedImageData = {\n  ext: string\n  name: string\n}\n\n/**\n * Sanitize the image name and extract the extension from the source image\n *\n * @param sourceImage - the source image\n * @returns the sanitized name and extension\n */\nexport const parseFilename = (sourceImage: string): SanitizedImageData => {\n  const extension = sourceImage.split('.').pop()\n  const name = sanitize(sourceImage.substring(0, sourceImage.lastIndexOf('.')) || sourceImage)\n  return { name, ext: extension! }\n}\n"],"names":["sanitize","parseFilename","sourceImage","extension","split","pop","name","substring","lastIndexOf","ext"],"mappings":";;;;AAAA,OAAOA,cAAc,oBAAmB;;AAajC,MAAMC,gBAAgB,CAACC;IAC5B,MAAMC,YAAYD,YAAYE,KAAK,CAAC,KAAKC,GAAG;IAC5C,MAAMC,WAAON,0JAAAA,EAASE,YAAYK,SAAS,CAAC,GAAGL,YAAYM,WAAW,CAAC,SAASN;IAChF,OAAO;QAAEI;QAAMG,KAAKN;IAAW;AACjC,EAAC"}},
    {"offset": {"line": 2555, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/uploads/image-resizing/sanitizeResizeConfig.ts"],"sourcesContent":["import type { ImageSize } from '../types.js'\n\n/**\n * Sanitize the resize config. If the resize config has the `withoutReduction`\n * property set to true, the `fit` and `position` properties will be set to `contain`\n * and `top left` respectively.\n *\n * @param resizeConfig - the resize config\n * @returns a sanitized resize config\n */\nexport const sanitizeResizeConfig = (resizeConfig: ImageSize): ImageSize => {\n  if (resizeConfig.withoutReduction) {\n    return {\n      ...resizeConfig,\n      // Why fit `contain` should also be set to https://github.com/lovell/sharp/issues/3595\n      fit: resizeConfig?.fit || 'contain',\n      position: resizeConfig?.position || 'left top',\n    }\n  }\n  return resizeConfig\n}\n"],"names":["sanitizeResizeConfig","resizeConfig","withoutReduction","fit","position"],"mappings":"AAEA;;;;;;;CAOC,GACD;;;;AAAO,MAAMA,uBAAuB,CAACC;IACnC,IAAIA,aAAaC,gBAAgB,EAAE;QACjC,OAAO;YACL,GAAGD,YAAY;YACf,sFAAsF;YACtFE,KAAKF,cAAcE,OAAO;YAC1BC,UAAUH,cAAcG,YAAY;QACtC;IACF;IACA,OAAOH;AACT,EAAC"}},
    {"offset": {"line": 2581, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/uploads/image-resizing/createImageSizes.ts"],"sourcesContent":["import type { Sharp, SharpOptions } from 'sharp'\n\nimport { fileTypeFromBuffer } from 'file-type'\nimport fs from 'fs/promises'\n\nimport type { SanitizedCollectionConfig } from '../../collections/config/types.js'\nimport type { SharpDependency } from '../../config/types.js'\nimport type { PayloadRequest } from '../../types/index.js'\nimport type { WithMetadata } from '../optionallyAppendMetadata.js'\nimport type { FileSize, FileSizes, FileToSave, FocalPoint, ProbedImageSize } from '../types.js'\n\nimport { fileExists } from '../fileExists.js'\nimport { optionallyAppendMetadata } from '../optionallyAppendMetadata.js'\nimport { createImageSize } from './createImageSize.js'\nimport { extractHeightFromImage } from './extractHeightFromImage.js'\nimport { generateImageSizeFilename } from './generateImageSizeFilename.js'\nimport { getImageResizeAction } from './getImageResizeAction.js'\nimport { parseFilename } from './parseFilename.js'\nimport { sanitizeResizeConfig } from './sanitizeResizeConfig.js'\n\n/**\n * For the provided image sizes, handle the resizing and the transforms\n * (format, trim, etc.) of each requested image size and return the result object.\n * This only handles the image sizes. The transforms of the original image\n * are handled in {@link ./generateFileData.ts}.\n *\n * The image will be resized according to the provided\n * resize config. If no image sizes are requested, the resolved data will be empty.\n * For every image that does not need to be resized, a result object with `null`\n * parameters will be returned.\n *\n * @param resizeConfig - the resize config\n * @returns the result of the resize operation(s)\n */\n\ntype ResizeArgs = {\n  config: SanitizedCollectionConfig\n  dimensions: ProbedImageSize\n  file: PayloadRequest['file']\n  focalPoint?: FocalPoint\n  mimeType: string\n  req: PayloadRequest\n  savedFilename: string\n  sharp?: SharpDependency\n  staticPath: string\n  withMetadata?: WithMetadata\n}\n\n/** Result from resizing and transforming the requested image sizes */\ntype ImageSizesResult = {\n  sizeData: FileSizes\n  sizesToSave: FileToSave[]\n}\n\nexport async function createImageSizes({\n  config,\n  dimensions,\n  file,\n  focalPoint,\n  mimeType,\n  req,\n  savedFilename,\n  sharp,\n  staticPath,\n  withMetadata,\n}: ResizeArgs): Promise<ImageSizesResult> {\n  const { imageSizes } = config.upload\n\n  if (!imageSizes || !sharp) {\n    return {\n      sizeData: {},\n      sizesToSave: [],\n    }\n  }\n\n  // Determine if the file is animated\n  const fileIsAnimatedType = ['image/avif', 'image/gif', 'image/webp'].includes(file!.mimetype)\n  const sharpOptions: SharpOptions = {}\n\n  if (fileIsAnimatedType) {\n    sharpOptions.animated = true\n  }\n\n  const sharpBase: Sharp | undefined = sharp(\n    file!.tempFilePath || file!.data,\n    sharpOptions,\n  ).rotate() // pass rotate() to auto-rotate based on EXIF data. https://github.com/payloadcms/payload/pull/3081\n  const originalImageMeta = await sharpBase.metadata()\n\n  let adjustedDimensions = { ...dimensions }\n\n  // Images with an exif orientation of 5, 6, 7, or 8 are auto-rotated by sharp\n  // Need to adjust the dimensions to match the original image\n  if ([5, 6, 7, 8].includes(originalImageMeta.orientation!)) {\n    adjustedDimensions = {\n      ...dimensions,\n      height: dimensions.width,\n      width: dimensions.height,\n    }\n  }\n\n  const resizeImageMeta = {\n    height: originalImageMeta.height,\n    width: originalImageMeta.width,\n  }\n\n  const sizes = {} as Record<string, FileSize>\n  const imageSizeFiles: FileToSave[] = []\n\n  await Promise.all(\n    imageSizes.map(async (imageResizeConfig): Promise<void> => {\n      imageResizeConfig = sanitizeResizeConfig(imageResizeConfig)\n\n      const resizeAction = getImageResizeAction({\n        dimensions,\n        hasFocalPoint: Boolean(focalPoint),\n        imageResizeConfig,\n      })\n\n      if (resizeAction === 'omit') {\n        sizes[imageResizeConfig.name] = createImageSize({})\n        return\n      }\n\n      const imageToResize = sharpBase.clone()\n      let resized = imageToResize\n\n      if (resizeAction === 'resizeWithFocalPoint') {\n        let { height: resizeHeight, width: resizeWidth } = imageResizeConfig\n\n        const originalAspectRatio = adjustedDimensions.width / adjustedDimensions.height\n\n        // Calculate resizeWidth based on original aspect ratio if it's undefined\n        if (resizeHeight && !resizeWidth) {\n          resizeWidth = Math.round(resizeHeight * originalAspectRatio)\n        }\n\n        // Calculate resizeHeight based on original aspect ratio if it's undefined\n        if (resizeWidth && !resizeHeight) {\n          resizeHeight = Math.round(resizeWidth / originalAspectRatio)\n        }\n\n        if (!resizeHeight) {\n          resizeHeight = resizeImageMeta.height\n        }\n        if (!resizeWidth) {\n          resizeWidth = resizeImageMeta.width\n        }\n\n        const resizeAspectRatio = resizeWidth! / resizeHeight!\n        const prioritizeHeight = resizeAspectRatio < originalAspectRatio\n        // Scales the image before extracting from it\n        resized = imageToResize.resize({\n          fastShrinkOnLoad: false,\n          height: prioritizeHeight ? resizeHeight : undefined,\n          width: prioritizeHeight ? undefined : resizeWidth,\n        })\n\n        const metadataAppendedFile = await optionallyAppendMetadata({\n          req,\n          sharpFile: resized,\n          withMetadata: withMetadata!,\n        })\n\n        // Must read from buffer, resized.metadata will return the original image metadata\n        const { info } = await metadataAppendedFile.toBuffer({ resolveWithObject: true })\n\n        resizeImageMeta.height = extractHeightFromImage({\n          ...originalImageMeta,\n          height: info.height,\n        })\n        resizeImageMeta.width = info.width\n\n        const halfResizeX = resizeWidth! / 2\n        const xFocalCenter = resizeImageMeta.width * (focalPoint!.x / 100)\n        const calculatedRightPixelBound = xFocalCenter + halfResizeX\n        let leftBound = xFocalCenter - halfResizeX\n\n        // if the right bound is greater than the image width, adjust the left bound\n        // keeping focus on the right\n        if (calculatedRightPixelBound > resizeImageMeta.width) {\n          leftBound = resizeImageMeta.width - resizeWidth!\n        }\n\n        // if the left bound is less than 0, adjust the left bound to 0\n        // keeping the focus on the left\n        if (leftBound < 0) {\n          leftBound = 0\n        }\n\n        const halfResizeY = resizeHeight! / 2\n        const yFocalCenter = resizeImageMeta.height * (focalPoint!.y / 100)\n        const calculatedBottomPixelBound = yFocalCenter + halfResizeY\n        let topBound = yFocalCenter - halfResizeY\n\n        // if the bottom bound is greater than the image height, adjust the top bound\n        // keeping the image as far right as possible\n        if (calculatedBottomPixelBound > resizeImageMeta.height) {\n          topBound = resizeImageMeta.height - resizeHeight!\n        }\n\n        // if the top bound is less than 0, adjust the top bound to 0\n        // keeping the image focus near the top\n        if (topBound < 0) {\n          topBound = 0\n        }\n\n        resized = resized.extract({\n          height: resizeHeight!,\n          left: Math.floor(leftBound),\n          top: Math.floor(topBound),\n          width: resizeWidth!,\n        })\n      } else {\n        resized = imageToResize.resize(imageResizeConfig)\n      }\n\n      if (imageResizeConfig.formatOptions) {\n        resized = resized.toFormat(\n          imageResizeConfig.formatOptions.format,\n          imageResizeConfig.formatOptions.options,\n        )\n      }\n\n      if (imageResizeConfig.trimOptions) {\n        resized = resized.trim(imageResizeConfig.trimOptions)\n      }\n\n      const metadataAppendedFile = await optionallyAppendMetadata({\n        req,\n        sharpFile: resized,\n        withMetadata: withMetadata!,\n      })\n\n      const { data: bufferData, info: bufferInfo } = await metadataAppendedFile.toBuffer({\n        resolveWithObject: true,\n      })\n\n      const { name, ext } = parseFilename(savedFilename)\n\n      if (req.payloadUploadSizes) {\n        req.payloadUploadSizes[imageResizeConfig.name] = bufferData\n      }\n\n      const mimeInfo = await fileTypeFromBuffer(bufferData)\n\n      const imageNameWithDimensions = imageResizeConfig.generateImageName\n        ? imageResizeConfig.generateImageName({\n            extension: mimeInfo?.ext || ext,\n            height: extractHeightFromImage({\n              ...originalImageMeta,\n              height: bufferInfo.height,\n            }),\n            originalName: name,\n            sizeName: imageResizeConfig.name,\n            width: bufferInfo.width,\n          })\n        : generateImageSizeFilename({\n            extension: mimeInfo?.ext || ext,\n            height: extractHeightFromImage({\n              ...originalImageMeta,\n              height: bufferInfo.height,\n            }),\n            outputImageName: name,\n            width: bufferInfo.width,\n          })\n\n      const imagePath = `${staticPath}/${imageNameWithDimensions}`\n\n      if (await fileExists(imagePath)) {\n        try {\n          await fs.unlink(imagePath)\n        } catch {\n          // Ignore unlink errors\n        }\n      }\n\n      const { height, size, width } = bufferInfo\n      sizes[imageResizeConfig.name] = createImageSize({\n        filename: imageNameWithDimensions,\n        filesize: size,\n        height:\n          fileIsAnimatedType && originalImageMeta.pages ? height / originalImageMeta.pages : height,\n        mimeType: mimeInfo?.mime || mimeType,\n        width,\n      })\n\n      imageSizeFiles.push({\n        buffer: bufferData,\n        path: imagePath,\n      })\n    }),\n  )\n\n  return {\n    sizeData: sizes,\n    sizesToSave: imageSizeFiles,\n  }\n}\n"],"names":["fileTypeFromBuffer","fs","fileExists","optionallyAppendMetadata","createImageSize","extractHeightFromImage","generateImageSizeFilename","getImageResizeAction","parseFilename","sanitizeResizeConfig","createImageSizes","config","dimensions","file","focalPoint","mimeType","req","savedFilename","sharp","staticPath","withMetadata","imageSizes","upload","sizeData","sizesToSave","fileIsAnimatedType","includes","mimetype","sharpOptions","animated","sharpBase","tempFilePath","data","rotate","originalImageMeta","metadata","adjustedDimensions","orientation","height","width","resizeImageMeta","sizes","imageSizeFiles","Promise","all","map","imageResizeConfig","resizeAction","hasFocalPoint","Boolean","name","imageToResize","clone","resized","resizeHeight","resizeWidth","originalAspectRatio","Math","round","resizeAspectRatio","prioritizeHeight","resize","fastShrinkOnLoad","undefined","metadataAppendedFile","sharpFile","info","toBuffer","resolveWithObject","halfResizeX","xFocalCenter","x","calculatedRightPixelBound","leftBound","halfResizeY","yFocalCenter","y","calculatedBottomPixelBound","topBound","extract","left","floor","top","formatOptions","toFormat","format","options","trimOptions","trim","bufferData","bufferInfo","ext","payloadUploadSizes","mimeInfo","imageNameWithDimensions","generateImageName","extension","originalName","sizeName","outputImageName","imagePath","unlink","size","filename","filesize","pages","mime","push","buffer","path"],"mappings":"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"}},
    {"offset": {"line": 2805, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/uploads/isImage.ts"],"sourcesContent":["export function isImage(mimeType: string): boolean {\n  return (\n    [\n      'image/jpeg',\n      'image/png',\n      'image/gif',\n      'image/svg+xml',\n      'image/webp',\n      'image/avif',\n      'image/jxl',\n    ].indexOf(mimeType) > -1\n  )\n}\n"],"names":["isImage","mimeType","indexOf"],"mappings":";;;;AAAO,SAASA,QAAQC,QAAgB;IACtC,OACE;QACE;QACA;QACA;QACA;QACA;QACA;QACA;KACD,CAACC,OAAO,CAACD,YAAY,CAAC;AAE3B"}},
    {"offset": {"line": 2824, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/uploads/generateFileData.ts"],"sourcesContent":["import type { OutputInfo, Sharp, SharpOptions } from 'sharp'\n\nimport { fileTypeFromBuffer } from 'file-type'\nimport fs from 'fs/promises'\nimport sanitize from 'sanitize-filename'\n\nimport type { Collection } from '../collections/config/types.js'\nimport type { SanitizedConfig } from '../config/types.js'\nimport type { Document, PayloadRequest } from '../types/index.js'\nimport type { FileData, FileToSave, ProbedImageSize, UploadEdits } from './types.js'\n\nimport { FileRetrievalError, FileUploadError, Forbidden, MissingFile } from '../errors/index.js'\nimport { isNumber } from '../utilities/isNumber.js'\nimport { canResizeImage } from './canResizeImage.js'\nimport { checkFileRestrictions } from './checkFileRestrictions.js'\nimport { cropImage } from './cropImage.js'\nimport { getExternalFile } from './getExternalFile.js'\nimport { getFileByPath } from './getFileByPath.js'\nimport { getImageSize } from './getImageSize.js'\nimport { getSafeFileName } from './getSafeFilename.js'\nimport { createImageSizes } from './image-resizing/createImageSizes.js'\nimport { isImage } from './isImage.js'\nimport { optionallyAppendMetadata } from './optionallyAppendMetadata.js'\ntype Args<T> = {\n  collection: Collection\n  config: SanitizedConfig\n  data: T\n  isDuplicating?: boolean\n  operation: 'create' | 'update'\n  originalDoc?: T\n  overwriteExistingFiles?: boolean\n  req: PayloadRequest\n  throwOnMissingFile?: boolean\n}\n\ntype Result<T> = Promise<{\n  data: T\n  files: FileToSave[]\n}>\n\nconst shouldReupload = (\n  uploadEdits: UploadEdits,\n  fileData: Record<string, unknown> | undefined,\n) => {\n  if (!fileData) {\n    return false\n  }\n\n  if (uploadEdits.crop || uploadEdits.heightInPixels || uploadEdits.widthInPixels) {\n    return true\n  }\n\n  // Since uploadEdits always has focalPoint, compare to the value in the data if it was changed\n  if (uploadEdits.focalPoint) {\n    const incomingFocalX = uploadEdits.focalPoint.x\n    const incomingFocalY = uploadEdits.focalPoint.y\n\n    const currentFocalX = 'focalX' in fileData && fileData.focalX\n    const currentFocalY = 'focalY' in fileData && fileData.focalY\n\n    const isEqual = incomingFocalX === currentFocalX && incomingFocalY === currentFocalY\n    return !isEqual\n  }\n\n  return false\n}\n\nexport const generateFileData = async <T>({\n  collection: { config: collectionConfig },\n  data,\n  isDuplicating,\n  operation,\n  originalDoc,\n  overwriteExistingFiles,\n  req,\n  throwOnMissingFile,\n}: Args<T>): Result<T> => {\n  if (!collectionConfig.upload) {\n    return {\n      data,\n      files: [],\n    }\n  }\n\n  const { serverURL, sharp } = req.payload.config\n\n  let file = req.file\n\n  const uploadEdits = parseUploadEditsFromReqOrIncomingData({\n    data,\n    isDuplicating,\n    operation,\n    originalDoc,\n    req,\n  })\n\n  const {\n    constructorOptions,\n    disableLocalStorage,\n    focalPoint: focalPointEnabled = true,\n    formatOptions,\n    imageSizes,\n    resizeOptions,\n    staticDir,\n    trimOptions,\n    withMetadata,\n  } = collectionConfig.upload\n\n  const staticPath = staticDir\n\n  const incomingFileData: Document = isDuplicating ? originalDoc : data\n  let isLocalFile = false\n\n  if (\n    !file &&\n    (isDuplicating || shouldReupload(uploadEdits, incomingFileData as Record<string, unknown>))\n  ) {\n    const { filename, url } = incomingFileData as unknown as FileData\n    if (filename && (filename.includes('../') || filename.includes('..\\\\'))) {\n      throw new Forbidden(req.t)\n    }\n\n    if ((serverURL && url?.startsWith(serverURL)) || url?.startsWith('/')) {\n      isLocalFile = true\n    }\n\n    try {\n      if (!disableLocalStorage && isLocalFile) {\n        // File is stored locally\n        const filePath = `${staticPath}/${filename}`\n        const response = await getFileByPath(filePath)\n        file = response\n        overwriteExistingFiles = true\n      } else if (filename && url) {\n        // File is remote\n        file = await getExternalFile({\n          data: incomingFileData as unknown as FileData,\n          req,\n          uploadConfig: collectionConfig.upload,\n        })\n        overwriteExistingFiles = true\n      }\n    } catch (err: unknown) {\n      throw new FileRetrievalError(req.t, err instanceof Error ? err.message : undefined)\n    }\n  }\n\n  if (isDuplicating) {\n    overwriteExistingFiles = false\n  }\n\n  if (!file) {\n    if (throwOnMissingFile) {\n      throw new MissingFile(req.t)\n    }\n\n    return {\n      data: incomingFileData!,\n      files: [],\n    }\n  }\n\n  await checkFileRestrictions({\n    collection: collectionConfig,\n    file,\n    req,\n  })\n\n  if (!disableLocalStorage) {\n    await fs.mkdir(staticPath!, { recursive: true })\n  }\n\n  let newData = incomingFileData as T\n  const filesToSave: FileToSave[] = []\n  const fileData: Partial<FileData> = {}\n  const fileIsAnimatedType = ['image/avif', 'image/gif', 'image/webp'].includes(file.mimetype)\n  const cropData =\n    typeof uploadEdits === 'object' && 'crop' in uploadEdits ? uploadEdits.crop : undefined\n\n  try {\n    const fileSupportsResize = canResizeImage(file.mimetype)\n    let fsSafeName: string\n    let sharpFile: Sharp | undefined\n    let dimensions: ProbedImageSize | undefined\n    let fileBuffer!: { data: Buffer; info: OutputInfo }\n    let ext\n    let mime: string\n    const fileHasAdjustments =\n      fileSupportsResize &&\n      Boolean(\n        resizeOptions || formatOptions || trimOptions || constructorOptions || file.tempFilePath,\n      )\n\n    const sharpOptions: SharpOptions = { ...constructorOptions }\n\n    if (fileIsAnimatedType) {\n      sharpOptions.animated = true\n    }\n\n    if (sharp && (fileIsAnimatedType || fileHasAdjustments)) {\n      if (file.tempFilePath) {\n        sharpFile = sharp(file.tempFilePath, sharpOptions).rotate() // pass rotate() to auto-rotate based on EXIF data. https://github.com/payloadcms/payload/pull/3081\n      } else {\n        sharpFile = sharp(file.data, sharpOptions).rotate() // pass rotate() to auto-rotate based on EXIF data. https://github.com/payloadcms/payload/pull/3081\n      }\n\n      if (fileHasAdjustments) {\n        if (resizeOptions) {\n          sharpFile = sharpFile.resize(resizeOptions)\n        }\n        if (formatOptions) {\n          sharpFile = sharpFile.toFormat(formatOptions.format, formatOptions.options)\n        }\n        if (trimOptions) {\n          sharpFile = sharpFile.trim(trimOptions)\n        }\n      }\n    }\n\n    if (fileSupportsResize || isImage(file.mimetype)) {\n      dimensions = await getImageSize(file)\n      fileData.width = dimensions.width\n      fileData.height = dimensions.height\n    }\n\n    if (sharpFile) {\n      const metadata = await sharpFile.metadata()\n      sharpFile = await optionallyAppendMetadata({\n        req,\n        sharpFile,\n        withMetadata: withMetadata!,\n      })\n      fileBuffer = await sharpFile.toBuffer({ resolveWithObject: true })\n      ;({ ext, mime } = (await fileTypeFromBuffer(fileBuffer.data))!) // This is getting an incorrect gif height back.\n      fileData.width = fileBuffer.info.width\n      fileData.height = fileBuffer.info.height\n      fileData.filesize = fileBuffer.info.size\n\n      // Animated GIFs + WebP aggregate the height from every frame, so we need to use divide by number of pages\n      if (metadata.pages) {\n        fileData.height = fileBuffer.info.height / metadata.pages\n        fileData.filesize = fileBuffer.data.length\n      }\n    } else {\n      mime = file.mimetype\n      fileData.filesize = file.size\n\n      if (file.name.includes('.')) {\n        ext = file.name.split('.').pop()?.split('?')[0]\n      } else {\n        ext = ''\n      }\n    }\n\n    // Adjust SVG mime type. fromBuffer modifies it.\n    if (mime === 'application/xml' && ext === 'svg') {\n      mime = 'image/svg+xml'\n    }\n    fileData.mimeType = mime\n\n    const baseFilename = sanitize(file.name.substring(0, file.name.lastIndexOf('.')) || file.name)\n    fsSafeName = `${baseFilename}${ext ? `.${ext}` : ''}`\n\n    if (!overwriteExistingFiles) {\n      // Extract prefix if present (added by plugin-cloud-storage)\n      const prefix = (data as Record<string, unknown>)?.prefix as string | undefined\n      fsSafeName = await getSafeFileName({\n        collectionSlug: collectionConfig.slug,\n        desiredFilename: fsSafeName,\n        prefix,\n        req,\n        staticPath: staticPath!,\n      })\n    }\n\n    fileData.filename = fsSafeName\n\n    let fileForResize = file\n\n    if (cropData && sharp) {\n      const { data: croppedImage, info } = await cropImage({\n        cropData,\n        dimensions: dimensions!,\n        file,\n        heightInPixels: uploadEdits.heightInPixels!,\n        req,\n        sharp,\n        widthInPixels: uploadEdits.widthInPixels!,\n        withMetadata,\n      })\n\n      // Apply resize after cropping to ensure it conforms to resizeOptions\n      if (resizeOptions && !resizeOptions.withoutEnlargement) {\n        const resizedAfterCrop = await sharp(croppedImage)\n          .resize({\n            fit: resizeOptions?.fit || 'cover',\n            height: resizeOptions?.height,\n            position: resizeOptions?.position || 'center',\n            width: resizeOptions?.width,\n          })\n          .toBuffer({ resolveWithObject: true })\n\n        filesToSave.push({\n          buffer: resizedAfterCrop.data,\n          path: `${staticPath}/${fsSafeName}`,\n        })\n\n        fileForResize = {\n          ...fileForResize,\n          data: resizedAfterCrop.data,\n          size: resizedAfterCrop.info.size,\n        }\n\n        fileData.width = resizedAfterCrop.info.width\n        fileData.height = resizedAfterCrop.info.height\n        if (fileIsAnimatedType) {\n          const metadata = await sharpFile!.metadata()\n          fileData.height = metadata.pages\n            ? resizedAfterCrop.info.height / metadata.pages\n            : resizedAfterCrop.info.height\n        }\n        fileData.filesize = resizedAfterCrop.info.size\n      } else {\n        // If resizeOptions is not present, just save the cropped image\n        filesToSave.push({\n          buffer: croppedImage,\n          path: `${staticPath}/${fsSafeName}`,\n        })\n\n        fileForResize = {\n          ...file,\n          data: croppedImage,\n          size: info.size,\n        }\n\n        fileData.width = info.width\n        fileData.height = info.height\n        if (fileIsAnimatedType) {\n          const metadata = await sharpFile!.metadata()\n          fileData.height = metadata.pages ? info.height / metadata.pages : info.height\n        }\n        fileData.filesize = info.size\n      }\n\n      if (file.tempFilePath) {\n        await fs.writeFile(file.tempFilePath, croppedImage) // write fileBuffer to the temp path\n      } else {\n        req.file = fileForResize\n      }\n    } else {\n      filesToSave.push({\n        buffer: fileBuffer?.data || file.data,\n        path: `${staticPath}/${fsSafeName}`,\n      })\n\n      // If using temp files and the image is being resized, write the file to the temp path\n      if (fileBuffer?.data || file.data.length > 0) {\n        if (file.tempFilePath) {\n          await fs.writeFile(file.tempFilePath, fileBuffer?.data || file.data) // write fileBuffer to the temp path\n        } else {\n          // Assign the _possibly modified_ file to the request object\n          req.file = {\n            ...file,\n            data: fileBuffer?.data || file.data,\n            size: fileBuffer?.info.size,\n          }\n        }\n      }\n    }\n\n    if (fileSupportsResize && (Array.isArray(imageSizes) || focalPointEnabled !== false)) {\n      req.payloadUploadSizes = {}\n      // Focal point adjustments\n      const focalPoint =\n        focalPointEnabled && uploadEdits?.focalPoint\n          ? {\n              x: isNumber(uploadEdits.focalPoint.x) ? Math.round(uploadEdits.focalPoint.x) : 50,\n              y: isNumber(uploadEdits.focalPoint.y) ? Math.round(uploadEdits.focalPoint.y) : 50,\n            }\n          : undefined\n\n      const { sizeData, sizesToSave } = await createImageSizes({\n        config: collectionConfig,\n        dimensions: !cropData\n          ? dimensions!\n          : {\n              ...dimensions,\n              height: fileData.height!,\n              width: fileData.width!,\n            },\n        file: fileForResize,\n        focalPoint,\n        mimeType: fileData.mimeType,\n        req,\n        savedFilename: fsSafeName || file.name,\n        sharp,\n        staticPath: staticPath!,\n        withMetadata,\n      })\n\n      fileData.sizes = sizeData\n      fileData.focalX = focalPoint?.x\n      fileData.focalY = focalPoint?.y\n      filesToSave.push(...sizesToSave)\n    }\n  } catch (err) {\n    req.payload.logger.error(err)\n    throw new FileUploadError(req.t)\n  }\n\n  newData = {\n    ...newData,\n    ...fileData,\n  }\n\n  return {\n    data: newData,\n    files: filesToSave,\n  }\n}\n\n/**\n * Parse upload edits from req or incoming data\n */\nfunction parseUploadEditsFromReqOrIncomingData(args: {\n  data: unknown\n  isDuplicating?: boolean\n  operation: 'create' | 'update'\n  originalDoc: unknown\n  req: PayloadRequest\n}): UploadEdits {\n  const { data, isDuplicating, operation, originalDoc, req } = args\n\n  // Get intended focal point change from query string or incoming data\n  const uploadEdits =\n    req.query?.uploadEdits && typeof req.query.uploadEdits === 'object'\n      ? (req.query.uploadEdits as UploadEdits)\n      : {}\n\n  if (uploadEdits.focalPoint) {\n    return uploadEdits\n  }\n\n  const incomingData = data as FileData\n  const origDoc = originalDoc as FileData\n\n  if (origDoc && 'focalX' in origDoc && 'focalY' in origDoc) {\n    // If no change in focal point, return undefined.\n    // This prevents a refocal operation triggered from admin, because it always sends the focal point.\n    if (incomingData.focalX === origDoc.focalX && incomingData.focalY === origDoc.focalY) {\n      return undefined!\n    }\n\n    if (isDuplicating) {\n      uploadEdits.focalPoint = {\n        x: incomingData?.focalX || origDoc.focalX!,\n        y: incomingData?.focalY || origDoc.focalY!,\n      }\n      return uploadEdits\n    }\n  }\n\n  if (incomingData?.focalX && incomingData?.focalY) {\n    uploadEdits.focalPoint = {\n      x: incomingData.focalX,\n      y: incomingData.focalY,\n    }\n    return uploadEdits\n  }\n\n  // If no focal point is set, default to center\n  if (operation === 'create') {\n    uploadEdits.focalPoint = {\n      x: 50,\n      y: 50,\n    }\n  }\n\n  return uploadEdits\n}\n"],"names":["fileTypeFromBuffer","fs","sanitize","FileRetrievalError","FileUploadError","Forbidden","MissingFile","isNumber","canResizeImage","checkFileRestrictions","cropImage","getExternalFile","getFileByPath","getImageSize","getSafeFileName","createImageSizes","isImage","optionallyAppendMetadata","shouldReupload","uploadEdits","fileData","crop","heightInPixels","widthInPixels","focalPoint","incomingFocalX","x","incomingFocalY","y","currentFocalX","focalX","currentFocalY","focalY","isEqual","generateFileData","collection","config","collectionConfig","data","isDuplicating","operation","originalDoc","overwriteExistingFiles","req","throwOnMissingFile","upload","files","serverURL","sharp","payload","file","parseUploadEditsFromReqOrIncomingData","constructorOptions","disableLocalStorage","focalPointEnabled","formatOptions","imageSizes","resizeOptions","staticDir","trimOptions","withMetadata","staticPath","incomingFileData","isLocalFile","filename","url","includes","t","startsWith","filePath","response","uploadConfig","err","Error","message","undefined","mkdir","recursive","newData","filesToSave","fileIsAnimatedType","mimetype","cropData","fileSupportsResize","fsSafeName","sharpFile","dimensions","fileBuffer","ext","mime","fileHasAdjustments","Boolean","tempFilePath","sharpOptions","animated","rotate","resize","toFormat","format","options","trim","width","height","metadata","toBuffer","resolveWithObject","info","filesize","size","pages","length","name","split","pop","mimeType","baseFilename","substring","lastIndexOf","prefix","collectionSlug","slug","desiredFilename","fileForResize","croppedImage","withoutEnlargement","resizedAfterCrop","fit","position","push","buffer","path","writeFile","Array","isArray","payloadUploadSizes","Math","round","sizeData","sizesToSave","savedFilename","sizes","logger","error","args","query","incomingData","origDoc"],"mappings":"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"}},
    {"offset": {"line": 3211, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/uploads/unlinkTempFiles.ts"],"sourcesContent":["import fs from 'fs/promises'\n\nimport type { SanitizedCollectionConfig } from '../collections/config/types.js'\nimport type { SanitizedConfig } from '../config/types.js'\nimport type { PayloadRequest } from '../types/index.js'\n\nimport { mapAsync } from '../utilities/mapAsync.js'\n\ntype Args = {\n  collectionConfig: SanitizedCollectionConfig\n  config: SanitizedConfig\n  req: PayloadRequest\n}\n/**\n * Cleanup temp files after operation lifecycle\n */\nexport const unlinkTempFiles: (args: Args) => Promise<void> = async ({\n  collectionConfig,\n  config,\n  req,\n}) => {\n  if (config.upload?.useTempFiles && collectionConfig.upload) {\n    const { file } = req\n    const fileArray = [{ file }]\n    await mapAsync(fileArray, async ({ file }) => {\n      // Still need this check because this will not be populated if using local API\n      if (file?.tempFilePath) {\n        await fs.unlink(file.tempFilePath)\n      }\n    })\n  }\n}\n"],"names":["fs","mapAsync","unlinkTempFiles","collectionConfig","config","req","upload","useTempFiles","file","fileArray","tempFilePath","unlink"],"mappings":";;;;AAAA,OAAOA,QAAQ,cAAa;AAM5B,SAASC,QAAQ,QAAQ,2BAA0B;;;AAU5C,MAAMC,kBAAiD,OAAO,EACnEC,gBAAgB,EAChBC,MAAM,EACNC,GAAG,EACJ;IACC,IAAID,OAAOE,MAAM,EAAEC,gBAAgBJ,iBAAiBG,MAAM,EAAE;QAC1D,MAAM,EAAEE,IAAI,EAAE,GAAGH;QACjB,MAAMI,YAAY;YAAC;gBAAED;YAAK;SAAE;QAC5B,UAAMP,sKAAAA,EAASQ,WAAW,OAAO,EAAED,IAAI,EAAE;YACvC,8EAA8E;YAC9E,IAAIA,MAAME,cAAc;gBACtB,MAAMV,gIAAAA,CAAGW,MAAM,CAACH,KAAKE,YAAY;YACnC;QACF;IACF;AACF,EAAC"}},
    {"offset": {"line": 3239, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/uploads/saveBufferToFile.ts"],"sourcesContent":["import fs from 'fs/promises'\nimport { Readable } from 'stream'\n\n/**\n * Save buffer data to a file.\n * @param {Buffer} buffer - buffer to save to a file.\n * @param {string} filePath - path to a file.\n */\nexport const saveBufferToFile = async (buffer: Buffer, filePath: string): Promise<void> => {\n  // Setup readable stream from buffer.\n  let streamData = buffer\n  const readStream = new Readable()\n  readStream._read = () => {\n    readStream.push(streamData)\n    streamData = null!\n  }\n  // Setup file system writable stream.\n  return await fs.writeFile(filePath, buffer)\n}\n"],"names":["fs","Readable","saveBufferToFile","buffer","filePath","streamData","readStream","_read","push","writeFile"],"mappings":";;;;AAAA,OAAOA,QAAQ,cAAa;AAC5B,SAASC,QAAQ,QAAQ,SAAQ;;;AAO1B,MAAMC,mBAAmB,OAAOC,QAAgBC;IACrD,qCAAqC;IACrC,IAAIC,aAAaF;IACjB,MAAMG,aAAa,IAAIL,iHAAAA;IACvBK,WAAWC,KAAK,GAAG;QACjBD,WAAWE,IAAI,CAACH;QAChBA,aAAa;IACf;IACA,qCAAqC;IACrC,OAAO,MAAML,gIAAAA,CAAGS,SAAS,CAACL,UAAUD;AACtC,EAAC"}},
    {"offset": {"line": 3262, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/uploads/uploadFiles.ts"],"sourcesContent":["import type { Payload } from '../index.js'\nimport type { PayloadRequest } from '../types/index.js'\nimport type { FileToSave } from './types.js'\n\nimport { FileUploadError } from '../errors/index.js'\nimport { saveBufferToFile } from './saveBufferToFile.js'\n\nexport const uploadFiles = async (\n  payload: Payload,\n  files: FileToSave[],\n  req: PayloadRequest,\n): Promise<void> => {\n  try {\n    await Promise.all(\n      files.map(async ({ buffer, path }) => {\n        await saveBufferToFile(buffer, path)\n      }),\n    )\n  } catch (err) {\n    payload.logger.error(err)\n    throw new FileUploadError(req.t)\n  }\n}\n"],"names":["FileUploadError","saveBufferToFile","uploadFiles","payload","files","req","Promise","all","map","buffer","path","err","logger","error","t"],"mappings":";;;;AAIA,SAASA,eAAe,QAAQ,qBAAoB;AACpD,SAASC,gBAAgB,QAAQ,wBAAuB;;;AAEjD,MAAMC,cAAc,OACzBC,SACAC,OACAC;IAEA,IAAI;QACF,MAAMC,QAAQC,GAAG,CACfH,MAAMI,GAAG,CAAC,OAAO,EAAEC,MAAM,EAAEC,IAAI,EAAE;YAC/B,UAAMT,oLAAAA,EAAiBQ,QAAQC;QACjC;IAEJ,EAAE,OAAOC,KAAK;QACZR,QAAQS,MAAM,CAACC,KAAK,CAACF;QACrB,MAAM,IAAIX,iLAAAA,CAAgBK,IAAIS,CAAC;IACjC;AACF,EAAC"}},
    {"offset": {"line": 3284, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/uploads/deleteAssociatedFiles.ts"],"sourcesContent":["import fs from 'fs/promises'\n\nimport type { SanitizedCollectionConfig } from '../collections/config/types.js'\nimport type { SanitizedConfig } from '../config/types.js'\nimport type { PayloadRequest } from '../types/index.js'\nimport type { FileData, FileToSave } from './types.js'\n\nimport { ErrorDeletingFile } from '../errors/index.js'\nimport { fileExists } from './fileExists.js'\n\ntype Args = {\n  collectionConfig: SanitizedCollectionConfig\n  config: SanitizedConfig\n  doc: Record<string, unknown>\n  files?: FileToSave[]\n  overrideDelete: boolean\n  req: PayloadRequest\n}\n\nexport const deleteAssociatedFiles: (args: Args) => Promise<void> = async ({\n  collectionConfig,\n  doc,\n  files = [],\n  overrideDelete,\n  req,\n}) => {\n  if (!collectionConfig.upload) {\n    return\n  }\n  if (overrideDelete || files.length > 0) {\n    const { staticDir: staticPath } = collectionConfig.upload\n\n    const fileToDelete = `${staticPath}/${doc.filename as string}`\n\n    try {\n      if (await fileExists(fileToDelete)) {\n        await fs.unlink(fileToDelete)\n      }\n    } catch (ignore) {\n      throw new ErrorDeletingFile(req.t)\n    }\n\n    if (doc.sizes) {\n      const sizes: FileData[] = Object.values(doc.sizes)\n      // Since forEach will not wait until unlink is finished it could\n      // happen that two operations will try to delete the same file.\n      // To avoid this it is recommended to use \"sync\" instead\n\n      for (const size of sizes) {\n        const sizeToDelete = `${staticPath}/${size.filename}`\n        try {\n          if (await fileExists(sizeToDelete)) {\n            await fs.unlink(sizeToDelete)\n          }\n        } catch (ignore) {\n          throw new ErrorDeletingFile(req.t)\n        }\n      }\n    }\n  }\n}\n"],"names":["fs","ErrorDeletingFile","fileExists","deleteAssociatedFiles","collectionConfig","doc","files","overrideDelete","req","upload","length","staticDir","staticPath","fileToDelete","filename","unlink","ignore","t","sizes","Object","values","size","sizeToDelete"],"mappings":";;;;AAAA,OAAOA,QAAQ,cAAa;AAO5B,SAASC,iBAAiB,QAAQ,qBAAoB;AACtD,SAASC,UAAU,QAAQ,kBAAiB;;;;AAWrC,MAAMC,wBAAuD,OAAO,EACzEC,gBAAgB,EAChBC,GAAG,EACHC,QAAQ,EAAE,EACVC,cAAc,EACdC,GAAG,EACJ;IACC,IAAI,CAACJ,iBAAiBK,MAAM,EAAE;QAC5B;IACF;IACA,IAAIF,kBAAkBD,MAAMI,MAAM,GAAG,GAAG;QACtC,MAAM,EAAEC,WAAWC,UAAU,EAAE,GAAGR,iBAAiBK,MAAM;QAEzD,MAAMI,eAAe,GAAGD,WAAW,CAAC,EAAEP,IAAIS,QAAQ,EAAY;QAE9D,IAAI;YACF,IAAI,UAAMZ,wKAAAA,EAAWW,eAAe;gBAClC,MAAMb,gIAAAA,CAAGe,MAAM,CAACF;YAClB;QACF,EAAE,OAAOG,QAAQ;YACf,MAAM,IAAIf,qLAAAA,CAAkBO,IAAIS,CAAC;QACnC;QAEA,IAAIZ,IAAIa,KAAK,EAAE;YACb,MAAMA,QAAoBC,OAAOC,MAAM,CAACf,IAAIa,KAAK;YACjD,gEAAgE;YAChE,+DAA+D;YAC/D,wDAAwD;YAExD,KAAK,MAAMG,QAAQH,MAAO;gBACxB,MAAMI,eAAe,GAAGV,WAAW,CAAC,EAAES,KAAKP,QAAQ,EAAE;gBACrD,IAAI;oBACF,IAAI,UAAMZ,wKAAAA,EAAWoB,eAAe;wBAClC,MAAMtB,gIAAAA,CAAGe,MAAM,CAACO;oBAClB;gBACF,EAAE,OAAON,QAAQ;oBACf,MAAM,IAAIf,qLAAAA,CAAkBO,IAAIS,CAAC;gBACnC;YACF;QACF;IACF;AACF,EAAC"}}]
}