{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/collections/dataloader.ts"],"sourcesContent":["import type { BatchLoadFn } from 'dataloader'\n\nimport DataLoader from 'dataloader'\n\nimport type { FindArgs } from '../database/types.js'\nimport type { Payload, TypedFallbackLocale } from '../index.js'\nimport type { PayloadRequest, PopulateType, SelectType } from '../types/index.js'\nimport type { TypeWithID } from './config/types.js'\nimport type { FindOptions } from './operations/local/find.js'\n\nimport { isValidID } from '../utilities/isValidID.js'\n\n// Payload uses `dataloader` to solve the classic GraphQL N+1 problem.\n\n// We keep a list of all documents requested to be populated for any given request\n// and then batch together documents within the same collection,\n// making only 1 find per each collection, rather than `findByID` per each requested doc.\n\n// This dramatically improves performance for REST and Local API `depth` populations,\n// and also ensures complex GraphQL queries perform lightning-fast.\n\nconst batchAndLoadDocs =\n  (req: PayloadRequest): BatchLoadFn<string, TypeWithID> =>\n  async (keys: readonly string[]): Promise<TypeWithID[]> => {\n    const { payload } = req\n\n    // Create docs array of same length as keys, using null as value\n    // We will replace nulls with injected docs as they are retrieved\n    const docs: (null | TypeWithID)[] = keys.map(() => null)\n\n    /**\n    * Batch IDs by their `find` args\n    * so we can make one find query per combination of collection, depth, locale, and fallbackLocale.\n    *\n    * Resulting shape will be as follows:\n      {\n        // key is stringified set of find args\n        '[null,\"pages\",2,0,\"es\",\"en\",false,false]': [\n          // value is array of IDs to find with these args\n          'q34tl23462346234524',\n          '435523540194324280',\n          '2346245j35l3j5234532li',\n        ],\n        // etc\n      };\n    *\n    **/\n\n    const batchByFindArgs: Record<string, string[]> = {}\n\n    for (const key of keys) {\n      const [\n        transactionID,\n        collection,\n        id,\n        depth,\n        currentDepth,\n        locale,\n        fallbackLocale,\n        overrideAccess,\n        showHiddenFields,\n        draft,\n        select,\n        populate,\n      ] = JSON.parse(key)\n\n      const batchKeyArray = [\n        transactionID,\n        collection,\n        depth,\n        currentDepth,\n        locale,\n        fallbackLocale,\n        overrideAccess,\n        showHiddenFields,\n        draft,\n        select,\n        populate,\n      ]\n\n      const batchKey = JSON.stringify(batchKeyArray)\n\n      const idType = payload.collections?.[collection]?.customIDType || payload.db.defaultIDType\n      const sanitizedID = idType === 'number' ? parseFloat(id) : id\n\n      if (isValidID(sanitizedID, idType)) {\n        batchByFindArgs[batchKey] = [...(batchByFindArgs[batchKey] || []), sanitizedID]\n      }\n    }\n\n    // Run find requests one after another, so as to not hang transactions\n\n    for (const [batchKey, ids] of Object.entries(batchByFindArgs)) {\n      const [\n        transactionID,\n        collection,\n        depth,\n        currentDepth,\n        locale,\n        fallbackLocale,\n        overrideAccess,\n        showHiddenFields,\n        draft,\n        select,\n        populate,\n      ] = JSON.parse(batchKey)\n\n      req.transactionID = transactionID\n\n      const result = await payload.find({\n        collection,\n        currentDepth,\n        depth,\n        disableErrors: true,\n        draft,\n        fallbackLocale,\n        locale,\n        overrideAccess: Boolean(overrideAccess),\n        pagination: false,\n        populate,\n        req,\n        select,\n        showHiddenFields: Boolean(showHiddenFields),\n        where: {\n          id: {\n            in: ids,\n          },\n        },\n      })\n\n      // For each returned doc, find index in original keys\n      // Inject doc within docs array if index exists\n      for (const doc of result.docs) {\n        const docKey = createDataloaderCacheKey({\n          collectionSlug: collection,\n          currentDepth,\n          depth,\n          docID: doc.id,\n          draft,\n          fallbackLocale,\n          locale,\n          overrideAccess,\n          populate,\n          select,\n          showHiddenFields,\n          transactionID: req.transactionID!,\n        })\n        const docsIndex = keys.findIndex((key) => key === docKey)\n\n        if (docsIndex > -1) {\n          docs[docsIndex] = doc\n        }\n      }\n    }\n\n    // Return docs array,\n    // which has now been injected with all fetched docs\n    // and should match the length of the incoming keys arg\n    return docs as TypeWithID[]\n  }\n\nexport const getDataLoader = (req: PayloadRequest) => {\n  const findQueries = new Map()\n  const dataLoader = new DataLoader(batchAndLoadDocs(req)) as PayloadRequest['payloadDataLoader']\n\n  dataLoader.find = ((args: FindArgs) => {\n    const key = createFindDataloaderCacheKey(args)\n    const cached = findQueries.get(key)\n    if (cached) {\n      return cached\n    }\n    const request = req.payload.find(args)\n    findQueries.set(key, request)\n    return request\n  }) as Payload['find']\n\n  return dataLoader\n}\n\nconst createFindDataloaderCacheKey = ({\n  collection,\n  currentDepth,\n  depth,\n  disableErrors,\n  draft,\n  includeLockStatus,\n  joins,\n  limit,\n  overrideAccess,\n  page,\n  pagination,\n  populate,\n  req,\n  select,\n  showHiddenFields,\n  sort,\n  where,\n}: FindOptions<string, SelectType>): string =>\n  JSON.stringify([\n    collection,\n    currentDepth,\n    depth,\n    disableErrors,\n    draft,\n    includeLockStatus,\n    joins,\n    limit,\n    overrideAccess,\n    page,\n    pagination,\n    populate,\n    req?.locale,\n    req?.fallbackLocale,\n    req?.user?.id,\n    req?.transactionID,\n    select,\n    showHiddenFields,\n    sort,\n    where,\n  ])\n\ntype CreateCacheKeyArgs = {\n  collectionSlug: string\n  currentDepth: number\n  depth: number\n  docID: number | string\n  draft: boolean\n  fallbackLocale: TypedFallbackLocale\n  locale: string | string[]\n  overrideAccess: boolean\n  populate?: PopulateType\n  select?: SelectType\n  showHiddenFields: boolean\n  transactionID: number | Promise<number | string> | string\n}\nexport const createDataloaderCacheKey = ({\n  collectionSlug,\n  currentDepth,\n  depth,\n  docID,\n  draft,\n  fallbackLocale,\n  locale,\n  overrideAccess,\n  populate,\n  select,\n  showHiddenFields,\n  transactionID,\n}: CreateCacheKeyArgs): string =>\n  JSON.stringify([\n    transactionID,\n    collectionSlug,\n    docID,\n    depth,\n    currentDepth,\n    locale,\n    fallbackLocale,\n    overrideAccess,\n    showHiddenFields,\n    draft,\n    select,\n    populate,\n  ])\n"],"names":["DataLoader","isValidID","batchAndLoadDocs","req","keys","payload","docs","map","batchByFindArgs","key","transactionID","collection","id","depth","currentDepth","locale","fallbackLocale","overrideAccess","showHiddenFields","draft","select","populate","JSON","parse","batchKeyArray","batchKey","stringify","idType","collections","customIDType","db","defaultIDType","sanitizedID","parseFloat","ids","Object","entries","result","find","disableErrors","Boolean","pagination","where","in","doc","docKey","createDataloaderCacheKey","collectionSlug","docID","docsIndex","findIndex","getDataLoader","findQueries","Map","dataLoader","args","createFindDataloaderCacheKey","cached","get","request","set","includeLockStatus","joins","limit","page","sort","user"],"mappings":"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"}},
    {"offset": {"line": 174, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/collections/operations/utilities/buildAfterOperation.ts"],"sourcesContent":["import type { CollectionSlug } from '../../../index.js'\nimport type { AfterOperationArg, OperationMap, OperationResult } from './types.js'\n\nexport const buildAfterOperation = async <\n  TOperationGeneric extends CollectionSlug,\n  O extends keyof OperationMap<TOperationGeneric> = keyof OperationMap<TOperationGeneric>,\n>(\n  operationArgs: { operation: O } & Omit<AfterOperationArg<TOperationGeneric>, 'req'>,\n): Promise<any | OperationResult<TOperationGeneric, O>> => {\n  const { args, collection, operation, overrideAccess, result } = operationArgs\n\n  let newResult = result as OperationResult<TOperationGeneric, O>\n\n  if (args.collection.config.hooks?.afterOperation?.length) {\n    for (const hook of args.collection.config.hooks.afterOperation) {\n      const hookResult = await hook({\n        args,\n        collection,\n        operation,\n        overrideAccess,\n        req: args.req,\n        result: newResult,\n      } as AfterOperationArg<TOperationGeneric>)\n\n      if (hookResult !== undefined) {\n        newResult = hookResult as OperationResult<TOperationGeneric, O>\n      }\n    }\n  }\n\n  return newResult\n}\n"],"names":["buildAfterOperation","operationArgs","args","collection","operation","overrideAccess","result","newResult","config","hooks","afterOperation","length","hook","hookResult","req","undefined"],"mappings":";;;;AAGO,MAAMA,sBAAsB,OAIjCC;IAEA,MAAM,EAAEC,IAAI,EAAEC,UAAU,EAAEC,SAAS,EAAEC,cAAc,EAAEC,MAAM,EAAE,GAAGL;IAEhE,IAAIM,YAAYD;IAEhB,IAAIJ,KAAKC,UAAU,CAACK,MAAM,CAACC,KAAK,EAAEC,gBAAgBC,QAAQ;QACxD,KAAK,MAAMC,QAAQV,KAAKC,UAAU,CAACK,MAAM,CAACC,KAAK,CAACC,cAAc,CAAE;YAC9D,MAAMG,aAAa,MAAMD,KAAK;gBAC5BV;gBACAC;gBACAC;gBACAC;gBACAS,KAAKZ,KAAKY,GAAG;gBACbR,QAAQC;YACV;YAEA,IAAIM,eAAeE,WAAW;gBAC5BR,YAAYM;YACd;QACF;IACF;IAEA,OAAON;AACT,EAAC"}},
    {"offset": {"line": 202, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/collections/operations/utilities/types.ts"],"sourcesContent":["import type { forgotPasswordOperation } from '../../../auth/operations/forgotPassword.js'\nimport type { loginOperation } from '../../../auth/operations/login.js'\nimport type { refreshOperation } from '../../../auth/operations/refresh.js'\nimport type { resetPasswordOperation } from '../../../auth/operations/resetPassword.js'\nimport type { unlockOperation } from '../../../auth/operations/unlock.js'\nimport type { CollectionSlug, RequestContext, restoreVersionOperation } from '../../../index.js'\nimport type { PayloadRequest } from '../../../types/index.js'\nimport type { SanitizedCollectionConfig, SelectFromCollectionSlug } from '../../config/types.js'\nimport type { countOperation } from '../count.js'\nimport type { countVersionsOperation } from '../countVersions.js'\nimport type { createOperation } from '../create.js'\nimport type { deleteOperation } from '../delete.js'\nimport type { deleteByIDOperation } from '../deleteByID.js'\nimport type { findOperation } from '../find.js'\nimport type { findByIDOperation } from '../findByID.js'\nimport type { findDistinctOperation } from '../findDistinct.js'\nimport type { findVersionByIDOperation } from '../findVersionByID.js'\nimport type { findVersionsOperation } from '../findVersions.js'\nimport type { updateOperation } from '../update.js'\nimport type { updateByIDOperation } from '../updateByID.js'\n\nexport type OperationMap<TOperationGeneric extends CollectionSlug> = {\n  count: typeof countOperation<TOperationGeneric>\n  countVersions: typeof countVersionsOperation<TOperationGeneric>\n  create: typeof createOperation<TOperationGeneric, SelectFromCollectionSlug<TOperationGeneric>>\n  delete: typeof deleteOperation<TOperationGeneric, SelectFromCollectionSlug<TOperationGeneric>>\n  deleteByID: typeof deleteByIDOperation<\n    TOperationGeneric,\n    SelectFromCollectionSlug<TOperationGeneric>\n  >\n  find: typeof findOperation<TOperationGeneric, SelectFromCollectionSlug<TOperationGeneric>>\n  findByID: typeof findByIDOperation<\n    TOperationGeneric,\n    boolean,\n    SelectFromCollectionSlug<TOperationGeneric>\n  >\n  findDistinct: typeof findDistinctOperation\n  findVersionByID: typeof findVersionByIDOperation\n  findVersions: typeof findVersionsOperation\n  forgotPassword: typeof forgotPasswordOperation\n  login: typeof loginOperation<TOperationGeneric>\n  refresh: typeof refreshOperation\n  resetPassword: typeof resetPasswordOperation<TOperationGeneric>\n  restoreVersion: typeof restoreVersionOperation\n  unlock: typeof unlockOperation<TOperationGeneric>\n  update: typeof updateOperation<TOperationGeneric, SelectFromCollectionSlug<TOperationGeneric>>\n  updateByID: typeof updateByIDOperation<\n    TOperationGeneric,\n    SelectFromCollectionSlug<TOperationGeneric>\n  >\n}\n\nexport type AfterOperationArg<TOperationGeneric extends CollectionSlug> = {\n  /** The collection which this hook is being run on */\n  collection: SanitizedCollectionConfig\n  /**\n   * Whether access control is being overridden for this operation\n   */\n  overrideAccess?: boolean\n  req: PayloadRequest\n} & (\n  | {\n      args: Parameters<OperationMap<TOperationGeneric>['count']>[0]\n      operation: 'count'\n      result: Awaited<ReturnType<OperationMap<TOperationGeneric>['count']>>\n    }\n  | {\n      args: Parameters<OperationMap<TOperationGeneric>['countVersions']>[0]\n      operation: 'countVersions'\n      result: Awaited<ReturnType<OperationMap<TOperationGeneric>['countVersions']>>\n    }\n  | {\n      args: Parameters<OperationMap<TOperationGeneric>['create']>[0]\n      operation: 'create'\n      result: Awaited<ReturnType<OperationMap<TOperationGeneric>['create']>>\n    }\n  | {\n      args: Parameters<OperationMap<TOperationGeneric>['delete']>[0]\n      operation: 'delete'\n      result: Awaited<ReturnType<OperationMap<TOperationGeneric>['delete']>>\n    }\n  | {\n      args: Parameters<OperationMap<TOperationGeneric>['deleteByID']>[0]\n      operation: 'deleteByID'\n      result: Awaited<ReturnType<OperationMap<TOperationGeneric>['deleteByID']>>\n    }\n  | {\n      args: Parameters<OperationMap<TOperationGeneric>['find']>[0]\n      /**\n       * @deprecated Use 'find' or 'findByID' operation instead\n       *\n       * TODO: v4 - remove this union option\n       */\n      operation: 'read'\n      result: Awaited<ReturnType<OperationMap<TOperationGeneric>['find']>>\n    }\n  | {\n      args: Parameters<OperationMap<TOperationGeneric>['find']>[0]\n      operation: 'find'\n      result: Awaited<ReturnType<OperationMap<TOperationGeneric>['find']>>\n    }\n  | {\n      args: Parameters<OperationMap<TOperationGeneric>['findByID']>[0]\n      operation: 'findByID'\n      result: Awaited<ReturnType<OperationMap<TOperationGeneric>['findByID']>>\n    }\n  | {\n      args: Parameters<OperationMap<TOperationGeneric>['findDistinct']>[0]\n      operation: 'findDistinct'\n      result: Awaited<ReturnType<OperationMap<TOperationGeneric>['findDistinct']>>\n    }\n  | {\n      args: Parameters<OperationMap<TOperationGeneric>['findVersionByID']>[0]\n      operation: 'findVersionByID'\n      result: Awaited<ReturnType<OperationMap<TOperationGeneric>['findVersionByID']>>\n    }\n  | {\n      args: Parameters<OperationMap<TOperationGeneric>['findVersions']>[0]\n      operation: 'findVersions'\n      result: Awaited<ReturnType<OperationMap<TOperationGeneric>['findVersions']>>\n    }\n  | {\n      args: Parameters<OperationMap<TOperationGeneric>['forgotPassword']>[0]\n      operation: 'forgotPassword'\n      result: Awaited<ReturnType<OperationMap<TOperationGeneric>['forgotPassword']>>\n    }\n  | {\n      args: Parameters<OperationMap<TOperationGeneric>['login']>[0]\n      operation: 'login'\n      result: Awaited<ReturnType<OperationMap<TOperationGeneric>['login']>>\n    }\n  | {\n      args: Parameters<OperationMap<TOperationGeneric>['refresh']>[0]\n      operation: 'refresh'\n      result: Awaited<ReturnType<OperationMap<TOperationGeneric>['refresh']>>\n    }\n  | {\n      args: Parameters<OperationMap<TOperationGeneric>['resetPassword']>[0]\n      operation: 'resetPassword'\n      result: Awaited<ReturnType<OperationMap<TOperationGeneric>['resetPassword']>>\n    }\n  | {\n      args: Parameters<OperationMap<TOperationGeneric>['restoreVersion']>[0]\n      operation: 'restoreVersion'\n      result: Awaited<ReturnType<OperationMap<TOperationGeneric>['restoreVersion']>>\n    }\n  | {\n      args: Parameters<OperationMap<TOperationGeneric>['unlock']>[0]\n      operation: 'unlock'\n      result: Awaited<ReturnType<OperationMap<TOperationGeneric>['unlock']>>\n    }\n  | {\n      args: Parameters<OperationMap<TOperationGeneric>['update']>[0]\n      operation: 'update'\n      result: Awaited<ReturnType<OperationMap<TOperationGeneric>['update']>>\n    }\n  | {\n      args: Parameters<OperationMap<TOperationGeneric>['updateByID']>[0]\n      operation: 'updateByID'\n      result: Awaited<ReturnType<OperationMap<TOperationGeneric>['updateByID']>>\n    }\n)\n\nexport type OperationResult<\n  TOperationGeneric extends CollectionSlug,\n  O extends keyof OperationMap<TOperationGeneric>,\n> = Awaited<ReturnType<OperationMap<TOperationGeneric>[O]>>\n\nexport type OperationArgs<\n  TOperationGeneric extends CollectionSlug,\n  O extends keyof OperationMap<TOperationGeneric>,\n> = Parameters<OperationMap<TOperationGeneric>[O]>[0]\n\n// Map internal operation names to HookOperationType\nexport const operationToHookOperation = {\n  count: 'count',\n  countVersions: 'countVersions',\n  create: 'create',\n  delete: 'delete',\n  deleteByID: 'delete',\n  find: 'read',\n  findByID: 'read',\n  findDistinct: 'readDistinct',\n  findVersionByID: 'read',\n  findVersions: 'read',\n  forgotPassword: 'forgotPassword',\n  login: 'login',\n  read: 'read',\n  readDistinct: 'readDistinct',\n  refresh: 'refresh',\n  resetPassword: 'resetPassword',\n  restoreVersion: 'restoreVersion',\n  unlock: 'unlock',\n  update: 'update',\n  updateByID: 'update',\n} as const\n\nexport type BeforeOperationArg<TOperationGeneric extends CollectionSlug> = {\n  /** The collection which this hook is being run on */\n  collection: SanitizedCollectionConfig\n  context: RequestContext\n  /**\n   * Whether access control is being overridden for this operation\n   */\n  overrideAccess?: boolean\n  req: PayloadRequest\n} & (\n  | {\n      args:\n        | Parameters<OperationMap<TOperationGeneric>['find']>[0]\n        | Parameters<OperationMap<TOperationGeneric>['findByID']>[0]\n      /**\n       * @deprecated Use 'find' or 'findByID' operation instead\n       *\n       * TODO: v4 - remove this union option\n       */\n      operation: 'read'\n    }\n  | {\n      args: Parameters<OperationMap<TOperationGeneric>['count']>[0]\n      operation: 'count'\n    }\n  | {\n      args: Parameters<OperationMap<TOperationGeneric>['countVersions']>[0]\n      operation: 'countVersions'\n    }\n  | {\n      args: Parameters<OperationMap<TOperationGeneric>['create']>[0]\n      operation: 'create'\n    }\n  | {\n      args: Parameters<OperationMap<TOperationGeneric>['delete']>[0]\n      operation: 'delete'\n    }\n  | {\n      args: Parameters<OperationMap<TOperationGeneric>['deleteByID']>[0]\n      operation: 'deleteByID'\n    }\n  | {\n      args: Parameters<OperationMap<TOperationGeneric>['find']>[0]\n      operation: 'find'\n    }\n  | {\n      args: Parameters<OperationMap<TOperationGeneric>['findByID']>[0]\n      operation: 'findByID'\n    }\n  | {\n      args: Parameters<OperationMap<TOperationGeneric>['findDistinct']>[0]\n      /**\n       * @deprecated Use 'findDistinct' operation instead\n       *\n       * TODO: v4 - remove this union option\n       */\n      operation: 'readDistinct'\n    }\n  | {\n      args: Parameters<OperationMap<TOperationGeneric>['findDistinct']>[0]\n      operation: 'findDistinct'\n    }\n  | {\n      args: Parameters<OperationMap<TOperationGeneric>['findVersionByID']>[0]\n      operation: 'findVersionByID'\n    }\n  | {\n      args: Parameters<OperationMap<TOperationGeneric>['findVersions']>[0]\n      operation: 'findVersions'\n    }\n  | {\n      args: Parameters<OperationMap<TOperationGeneric>['forgotPassword']>[0]\n      operation: 'forgotPassword'\n    }\n  | {\n      args: Parameters<OperationMap<TOperationGeneric>['login']>[0]\n      operation: 'login'\n    }\n  | {\n      args: Parameters<OperationMap<TOperationGeneric>['refresh']>[0]\n      operation: 'refresh'\n    }\n  | {\n      args: Parameters<OperationMap<TOperationGeneric>['resetPassword']>[0]\n      operation: 'resetPassword'\n    }\n  | {\n      args: Parameters<OperationMap<TOperationGeneric>['restoreVersion']>[0]\n      operation: 'restoreVersion'\n    }\n  | {\n      args: Parameters<OperationMap<TOperationGeneric>['unlock']>[0]\n      operation: 'unlock'\n    }\n  | {\n      args: Parameters<OperationMap<TOperationGeneric>['update']>[0]\n      operation: 'update'\n    }\n  | {\n      args: Parameters<OperationMap<TOperationGeneric>['updateByID']>[0]\n      operation: 'updateByID'\n    }\n)\n"],"names":["operationToHookOperation","count","countVersions","create","delete","deleteByID","find","findByID","findDistinct","findVersionByID","findVersions","forgotPassword","login","read","readDistinct","refresh","resetPassword","restoreVersion","unlock","update","updateByID"],"mappings":"AA6KA,oDAAoD;;;;;AAC7C,MAAMA,2BAA2B;IACtCC,OAAO;IACPC,eAAe;IACfC,QAAQ;IACRC,QAAQ;IACRC,YAAY;IACZC,MAAM;IACNC,UAAU;IACVC,cAAc;IACdC,iBAAiB;IACjBC,cAAc;IACdC,gBAAgB;IAChBC,OAAO;IACPC,MAAM;IACNC,cAAc;IACdC,SAAS;IACTC,eAAe;IACfC,gBAAgB;IAChBC,QAAQ;IACRC,QAAQ;IACRC,YAAY;AACd,EAAU"}},
    {"offset": {"line": 233, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/collections/operations/utilities/buildBeforeOperation.ts"],"sourcesContent":["import type { CollectionSlug } from '../../../index.js'\nimport type { BeforeOperationArg, OperationArgs, OperationMap } from './types.js'\n\nimport { operationToHookOperation } from './types.js'\n// Specific overloads with TArgs (these take priority over the general overload)\n// Overload for 'read' operation (deprecated, backward compatibility)\n\n/**\n * TODO V4: remove overloads and operations should be the literal operation that was called\n *\n * - `read`: replace with `find` and `findByID` in both operations\n * - `delete`: replace with `deleteByID` in deleteByID operation\n * - `update`: replace with `updateByID` in updateByID operation\n */\n\n/**\n * @deprecated\n *\n * Should use `find` or `findByID`\n */\nexport async function buildBeforeOperation<TOperationGeneric extends CollectionSlug, TArgs>(\n  operationArgs: {\n    args: TArgs\n    operation: 'read'\n  } & Omit<BeforeOperationArg<TOperationGeneric>, 'args' | 'context' | 'operation' | 'req'>,\n): Promise<TArgs>\n\n/**\n * Overload for 'readDistinct' operation\n *\n * @deprecated - use `findDistinct`\n */\nexport async function buildBeforeOperation<TOperationGeneric extends CollectionSlug, TArgs>(\n  operationArgs: {\n    args: TArgs\n    operation: 'readDistinct'\n  } & Omit<BeforeOperationArg<TOperationGeneric>, 'args' | 'context' | 'operation' | 'req'>,\n): Promise<TArgs>\n\n// Overload for 'update' operation (can be called by both update and updateByID)\nexport async function buildBeforeOperation<TOperationGeneric extends CollectionSlug, TArgs>(\n  operationArgs: {\n    args: TArgs\n    operation: 'update'\n  } & Omit<BeforeOperationArg<TOperationGeneric>, 'args' | 'context' | 'operation' | 'req'>,\n): Promise<TArgs>\n\n// Overload for 'updateByID' operation\nexport async function buildBeforeOperation<TOperationGeneric extends CollectionSlug, TArgs>(\n  operationArgs: {\n    args: TArgs\n    operation: 'updateByID'\n  } & Omit<BeforeOperationArg<TOperationGeneric>, 'args' | 'context' | 'operation' | 'req'>,\n): Promise<TArgs>\n\nexport async function buildBeforeOperation<TOperationGeneric extends CollectionSlug, TArgs>(\n  operationArgs: {\n    args: TArgs\n    operation: 'delete'\n  } & Omit<BeforeOperationArg<TOperationGeneric>, 'args' | 'context' | 'operation' | 'req'>,\n): Promise<TArgs>\n\n// Overload for 'deleteByID' operation\nexport async function buildBeforeOperation<TOperationGeneric extends CollectionSlug, TArgs>(\n  operationArgs: {\n    args: TArgs\n    operation: 'deleteByID'\n  } & Omit<BeforeOperationArg<TOperationGeneric>, 'args' | 'context' | 'operation' | 'req'>,\n): Promise<TArgs>\n\n// General overload for operations that exist in OperationMap (fallback)\nexport async function buildBeforeOperation<\n  TOperationGeneric extends CollectionSlug,\n  O extends keyof OperationMap<TOperationGeneric>,\n>(\n  operationArgs: { operation: O } & Omit<BeforeOperationArg<TOperationGeneric>, 'context' | 'req'>,\n): Promise<OperationArgs<TOperationGeneric, O>>\n\n// Implementation\nexport async function buildBeforeOperation<TOperationGeneric extends CollectionSlug>(\n  operationArgs: Omit<BeforeOperationArg<TOperationGeneric>, 'context' | 'req'>,\n): Promise<unknown> {\n  const { args, collection, operation, overrideAccess } = operationArgs\n\n  let newArgs = args\n\n  if (args.collection.config.hooks?.beforeOperation?.length) {\n    // TODO: v4 should not need this mapping\n    // Map the operation to the hook operation type for backward compatibility\n    const hookOperation = operationToHookOperation[operation]\n\n    for (const hook of args.collection.config.hooks.beforeOperation) {\n      const hookResult = await hook({\n        args: newArgs,\n        collection,\n        context: args.req!.context,\n        operation: hookOperation,\n        overrideAccess,\n        req: args.req!,\n      } as BeforeOperationArg<TOperationGeneric>)\n\n      if (hookResult !== undefined) {\n        newArgs = hookResult\n      }\n    }\n  }\n\n  return newArgs\n}\n"],"names":["operationToHookOperation","buildBeforeOperation","operationArgs","args","collection","operation","overrideAccess","newArgs","config","hooks","beforeOperation","length","hookOperation","hook","hookResult","context","req","undefined"],"mappings":";;;;AAGA,SAASA,wBAAwB,QAAQ,aAAY;;AA4E9C,eAAeC,qBACpBC,aAA6E;IAE7E,MAAM,EAAEC,IAAI,EAAEC,UAAU,EAAEC,SAAS,EAAEC,cAAc,EAAE,GAAGJ;IAExD,IAAIK,UAAUJ;IAEd,IAAIA,KAAKC,UAAU,CAACI,MAAM,CAACC,KAAK,EAAEC,iBAAiBC,QAAQ;QACzD,wCAAwC;QACxC,0EAA0E;QAC1E,MAAMC,gBAAgBZ,gNAAwB,CAACK,UAAU;QAEzD,KAAK,MAAMQ,QAAQV,KAAKC,UAAU,CAACI,MAAM,CAACC,KAAK,CAACC,eAAe,CAAE;YAC/D,MAAMI,aAAa,MAAMD,KAAK;gBAC5BV,MAAMI;gBACNH;gBACAW,SAASZ,KAAKa,GAAG,CAAED,OAAO;gBAC1BV,WAAWO;gBACXN;gBACAU,KAAKb,KAAKa,GAAG;YACf;YAEA,IAAIF,eAAeG,WAAW;gBAC5BV,UAAUO;YACZ;QACF;IACF;IAEA,OAAOP;AACT"}},
    {"offset": {"line": 266, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/collections/operations/count.ts"],"sourcesContent":["import type { AccessResult } from '../../config/types.js'\nimport type { CollectionSlug } from '../../index.js'\nimport type { PayloadRequest, Where } from '../../types/index.js'\nimport type { Collection } from '../config/types.js'\n\nimport { executeAccess } from '../../auth/executeAccess.js'\nimport { combineQueries } from '../../database/combineQueries.js'\nimport { validateQueryPaths } from '../../database/queryValidation/validateQueryPaths.js'\nimport { sanitizeWhereQuery } from '../../database/sanitizeWhereQuery.js'\nimport { appendNonTrashedFilter } from '../../utilities/appendNonTrashedFilter.js'\nimport { killTransaction } from '../../utilities/killTransaction.js'\nimport { buildAfterOperation } from './utilities/buildAfterOperation.js'\nimport { buildBeforeOperation } from './utilities/buildBeforeOperation.js'\n\nexport type Arguments = {\n  collection: Collection\n  disableErrors?: boolean\n  overrideAccess?: boolean\n  req?: PayloadRequest\n  trash?: boolean\n  where?: Where\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport const countOperation = async <TSlug extends CollectionSlug>(\n  incomingArgs: Arguments,\n): Promise<{ totalDocs: number }> => {\n  let args = incomingArgs\n\n  try {\n    // /////////////////////////////////////\n    // beforeOperation - Collection\n    // /////////////////////////////////////\n\n    args = await buildBeforeOperation({\n      args,\n      collection: args.collection.config,\n      operation: 'count',\n      overrideAccess: args.overrideAccess!,\n    })\n\n    const {\n      collection: { config: collectionConfig },\n      disableErrors,\n      overrideAccess,\n      req,\n      trash = false,\n      where,\n    } = args\n\n    const { payload } = req!\n\n    // /////////////////////////////////////\n    // Access\n    // /////////////////////////////////////\n\n    let accessResult: AccessResult\n\n    if (!overrideAccess) {\n      accessResult = await executeAccess({ disableErrors, req: req! }, collectionConfig.access.read)\n\n      // If errors are disabled, and access returns false, return empty results\n      if (accessResult === false) {\n        return {\n          totalDocs: 0,\n        }\n      }\n    }\n\n    let result: { totalDocs: number }\n\n    let fullWhere = combineQueries(where!, accessResult!)\n    sanitizeWhereQuery({ fields: collectionConfig.flattenedFields, payload, where: fullWhere })\n\n    // Exclude trashed documents when trash: false\n    fullWhere = appendNonTrashedFilter({\n      enableTrash: collectionConfig.trash,\n      trash,\n      where: fullWhere,\n    })\n\n    await validateQueryPaths({\n      collectionConfig,\n      overrideAccess: overrideAccess!,\n      req: req!,\n      where: where!,\n    })\n\n    result = await payload.db.count({\n      collection: collectionConfig.slug,\n      req,\n      where: fullWhere,\n    })\n\n    // /////////////////////////////////////\n    // afterOperation - Collection\n    // /////////////////////////////////////\n\n    result = await buildAfterOperation({\n      args,\n      collection: collectionConfig,\n      operation: 'count',\n      overrideAccess,\n      result,\n    })\n\n    // /////////////////////////////////////\n    // Return results\n    // /////////////////////////////////////\n\n    return result\n  } catch (error: unknown) {\n    await killTransaction(args.req!)\n    throw error\n  }\n}\n"],"names":["executeAccess","combineQueries","validateQueryPaths","sanitizeWhereQuery","appendNonTrashedFilter","killTransaction","buildAfterOperation","buildBeforeOperation","countOperation","incomingArgs","args","collection","config","operation","overrideAccess","collectionConfig","disableErrors","req","trash","where","payload","accessResult","access","read","totalDocs","result","fullWhere","fields","flattenedFields","enableTrash","db","count","slug","error"],"mappings":";;;;AAKA,SAASA,aAAa,QAAQ,8BAA6B;AAC3D,SAASC,cAAc,QAAQ,mCAAkC;AACjE,SAASC,kBAAkB,QAAQ,uDAAsD;AACzF,SAASC,kBAAkB,QAAQ,uCAAsC;AACzE,SAASC,sBAAsB,QAAQ,4CAA2C;AAClF,SAASC,eAAe,QAAQ,qCAAoC;AACpE,SAASC,mBAAmB,QAAQ,qCAAoC;AACxE,SAASC,oBAAoB,QAAQ,sCAAqC;;;;;;;;;AAYnE,MAAMC,iBAAiB,OAC5BC;IAEA,IAAIC,OAAOD;IAEX,IAAI;QACF,wCAAwC;QACxC,+BAA+B;QAC/B,wCAAwC;QAExCC,OAAO,UAAMH,2NAAAA,EAAqB;YAChCG;YACAC,YAAYD,KAAKC,UAAU,CAACC,MAAM;YAClCC,WAAW;YACXC,gBAAgBJ,KAAKI,cAAc;QACrC;QAEA,MAAM,EACJH,YAAY,EAAEC,QAAQG,gBAAgB,EAAE,EACxCC,aAAa,EACbF,cAAc,EACdG,GAAG,EACHC,QAAQ,KAAK,EACbC,KAAK,EACN,GAAGT;QAEJ,MAAM,EAAEU,OAAO,EAAE,GAAGH;QAEpB,wCAAwC;QACxC,SAAS;QACT,wCAAwC;QAExC,IAAII;QAEJ,IAAI,CAACP,gBAAgB;YACnBO,eAAe,UAAMrB,2KAAAA,EAAc;gBAAEgB;gBAAeC,KAAKA;YAAK,GAAGF,iBAAiBO,MAAM,CAACC,IAAI;YAE7F,yEAAyE;YACzE,IAAIF,iBAAiB,OAAO;gBAC1B,OAAO;oBACLG,WAAW;gBACb;YACF;QACF;QAEA,IAAIC;QAEJ,IAAIC,gBAAYzB,iLAAAA,EAAekB,OAAQE;YACvClB,yLAAAA,EAAmB;YAAEwB,QAAQZ,iBAAiBa,eAAe;YAAER;YAASD,OAAOO;QAAU;QAEzF,8CAA8C;QAC9CA,gBAAYtB,kMAAAA,EAAuB;YACjCyB,aAAad,iBAAiBG,KAAK;YACnCA;YACAC,OAAOO;QACT;QAEA,UAAMxB,4MAAAA,EAAmB;YACvBa;YACAD,gBAAgBA;YAChBG,KAAKA;YACLE,OAAOA;QACT;QAEAM,SAAS,MAAML,QAAQU,EAAE,CAACC,KAAK,CAAC;YAC9BpB,YAAYI,iBAAiBiB,IAAI;YACjCf;YACAE,OAAOO;QACT;QAEA,wCAAwC;QACxC,8BAA8B;QAC9B,wCAAwC;QAExCD,SAAS,UAAMnB,yNAAAA,EAAoB;YACjCI;YACAC,YAAYI;YACZF,WAAW;YACXC;YACAW;QACF;QAEA,wCAAwC;QACxC,iBAAiB;QACjB,wCAAwC;QAExC,OAAOA;IACT,EAAE,OAAOQ,OAAgB;QACvB,UAAM5B,oLAAAA,EAAgBK,KAAKO,GAAG;QAC9B,MAAMgB;IACR;AACF,EAAC"}},
    {"offset": {"line": 363, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/collections/operations/local/count.ts"],"sourcesContent":["import type { CollectionSlug, Payload, RequestContext, TypedLocale } from '../../../index.js'\nimport type { Document, PayloadRequest, Where } from '../../../types/index.js'\nimport type { CreateLocalReqOptions } from '../../../utilities/createLocalReq.js'\n\nimport { APIError } from '../../../errors/index.js'\nimport { createLocalReq } from '../../../utilities/createLocalReq.js'\nimport { countOperation } from '../count.js'\n\nexport type CountOptions<TSlug extends CollectionSlug> = {\n  /**\n   * the Collection slug to operate against.\n   */\n  collection: TSlug\n  /**\n   * [Context](https://payloadcms.com/docs/hooks/context), which will then be passed to `context` and `req.context`,\n   * which can be read by hooks. Useful if you want to pass additional information to the hooks which\n   * shouldn't be necessarily part of the document, for example a `triggerBeforeChange` option which can be read by the BeforeChange hook\n   * to determine if it should run or not.\n   */\n  context?: RequestContext\n  /**\n   * When set to `true`, errors will not be thrown.\n   */\n  disableErrors?: boolean\n  /**\n   *  Specify [locale](https://payloadcms.com/docs/configuration/localization) for any returned documents.\n   */\n  locale?: TypedLocale\n  /**\n   * Skip access control.\n   * Set to `false` if you want to respect Access Control for the operation, for example when fetching data for the front-end.\n   * @default true\n   */\n  overrideAccess?: boolean\n  /**\n   * The `PayloadRequest` object. You can pass it to thread the current [transaction](https://payloadcms.com/docs/database/transactions), user and locale to the operation.\n   * Recommended to pass when using the Local API from hooks, as usually you want to execute the operation within the current transaction.\n   */\n  req?: Partial<PayloadRequest>\n  /**\n   * When set to `true`, the query will include both normal and trashed documents.\n   * To query only trashed documents, pass `trash: true` and combine with a `where` clause filtering by `deletedAt`.\n   * By default (`false`), the query will only include normal documents and exclude those with a `deletedAt` field.\n   *\n   * This argument has no effect unless `trash` is enabled on the collection.\n   * @default false\n   */\n  trash?: boolean\n  /**\n   * If you set `overrideAccess` to `false`, you can pass a user to use against the access control checks.\n   */\n  user?: Document\n  /**\n   * A filter [query](https://payloadcms.com/docs/queries/overview)\n   */\n  where?: Where\n}\n\nexport async function countLocal<TSlug extends CollectionSlug>(\n  payload: Payload,\n  options: CountOptions<TSlug>,\n): Promise<{ totalDocs: number }> {\n  const {\n    collection: collectionSlug,\n    disableErrors,\n    overrideAccess = true,\n    trash = false,\n    where,\n  } = options\n\n  const collection = payload.collections[collectionSlug]\n\n  if (!collection) {\n    throw new APIError(\n      `The collection with slug ${String(collectionSlug)} can't be found. Count Operation.`,\n    )\n  }\n\n  return countOperation<TSlug>({\n    collection,\n    disableErrors,\n    overrideAccess,\n    req: await createLocalReq(options as CreateLocalReqOptions, payload),\n    trash,\n    where,\n  })\n}\n"],"names":["APIError","createLocalReq","countOperation","countLocal","payload","options","collection","collectionSlug","disableErrors","overrideAccess","trash","where","collections","String","req"],"mappings":";;;;AAIA,SAASA,QAAQ,QAAQ,2BAA0B;AACnD,SAASC,cAAc,QAAQ,uCAAsC;AACrE,SAASC,cAAc,QAAQ,cAAa;;;;AAoDrC,eAAeC,WACpBC,OAAgB,EAChBC,OAA4B;IAE5B,MAAM,EACJC,YAAYC,cAAc,EAC1BC,aAAa,EACbC,iBAAiB,IAAI,EACrBC,QAAQ,KAAK,EACbC,KAAK,EACN,GAAGN;IAEJ,MAAMC,aAAaF,QAAQQ,WAAW,CAACL,eAAe;IAEtD,IAAI,CAACD,YAAY;QACf,MAAM,IAAIN,mKAAAA,CACR,CAAC,yBAAyB,EAAEa,OAAON,gBAAgB,iCAAiC,CAAC;IAEzF;IAEA,WAAOL,yLAAAA,EAAsB;QAC3BI;QACAE;QACAC;QACAK,KAAK,UAAMb,kLAAAA,EAAeI,SAAkCD;QAC5DM;QACAC;IACF;AACF"}},
    {"offset": {"line": 392, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/collections/operations/create.ts"],"sourcesContent":["import crypto from 'crypto'\n\nimport type { CollectionSlug, FindOptions, JsonObject } from '../../index.js'\nimport type {\n  Document,\n  PayloadRequest,\n  PopulateType,\n  SelectType,\n  TransformCollectionWithSelect,\n} from '../../types/index.js'\nimport type {\n  Collection,\n  DataFromCollectionSlug,\n  RequiredDataFromCollectionSlug,\n  SelectFromCollectionSlug,\n} from '../config/types.js'\n\nimport { ensureUsernameOrEmail } from '../../auth/ensureUsernameOrEmail.js'\nimport { executeAccess } from '../../auth/executeAccess.js'\nimport { sendVerificationEmail } from '../../auth/sendVerificationEmail.js'\nimport { registerLocalStrategy } from '../../auth/strategies/local/register.js'\nimport { getDuplicateDocumentData } from '../../duplicateDocument/index.js'\nimport { afterChange } from '../../fields/hooks/afterChange/index.js'\nimport { afterRead } from '../../fields/hooks/afterRead/index.js'\nimport { beforeChange } from '../../fields/hooks/beforeChange/index.js'\nimport { beforeValidate } from '../../fields/hooks/beforeValidate/index.js'\nimport { saveVersion } from '../../index.js'\nimport { generateFileData } from '../../uploads/generateFileData.js'\nimport { unlinkTempFiles } from '../../uploads/unlinkTempFiles.js'\nimport { uploadFiles } from '../../uploads/uploadFiles.js'\nimport { commitTransaction } from '../../utilities/commitTransaction.js'\nimport {\n  hasDraftsEnabled,\n  hasDraftValidationEnabled,\n  hasLocalizeStatusEnabled,\n} from '../../utilities/getVersionsConfig.js'\nimport { initTransaction } from '../../utilities/initTransaction.js'\nimport { killTransaction } from '../../utilities/killTransaction.js'\nimport { sanitizeInternalFields } from '../../utilities/sanitizeInternalFields.js'\nimport { sanitizeSelect } from '../../utilities/sanitizeSelect.js'\nimport { buildAfterOperation } from './utilities/buildAfterOperation.js'\nimport { buildBeforeOperation } from './utilities/buildBeforeOperation.js'\n\nexport type Arguments<TSlug extends CollectionSlug> = {\n  autosave?: boolean\n  collection: Collection\n  data: RequiredDataFromCollectionSlug<TSlug>\n  depth?: number\n  disableTransaction?: boolean\n  disableVerificationEmail?: boolean\n  draft?: boolean\n  duplicateFromID?: DataFromCollectionSlug<TSlug>['id']\n  overrideAccess?: boolean\n  overwriteExistingFiles?: boolean\n  populate?: PopulateType\n  publishAllLocales?: boolean\n  publishSpecificLocale?: string\n  req: PayloadRequest\n  selectedLocales?: string[]\n  showHiddenFields?: boolean\n} & Pick<FindOptions<TSlug, SelectType>, 'select'>\n\nexport const createOperation = async <\n  TSlug extends CollectionSlug,\n  TSelect extends SelectFromCollectionSlug<TSlug>,\n>(\n  incomingArgs: Arguments<TSlug>,\n): Promise<TransformCollectionWithSelect<TSlug, TSelect>> => {\n  let args = incomingArgs\n\n  try {\n    const shouldCommit = !args.disableTransaction && (await initTransaction(args.req))\n\n    ensureUsernameOrEmail<TSlug>({\n      authOptions: args.collection.config.auth,\n      collectionSlug: args.collection.config.slug,\n      data: args.data,\n      operation: 'create',\n      req: args.req,\n    })\n\n    // /////////////////////////////////////\n    // beforeOperation - Collection\n    // /////////////////////////////////////\n\n    args = await buildBeforeOperation({\n      args,\n      collection: args.collection.config,\n      operation: 'create',\n      overrideAccess: args.overrideAccess!,\n    })\n\n    if (args.publishSpecificLocale) {\n      args.req.locale = args.publishSpecificLocale\n    }\n\n    const {\n      autosave = false,\n      collection: { config: collectionConfig },\n      collection,\n      depth,\n      disableVerificationEmail,\n      draft = false,\n      duplicateFromID,\n      overrideAccess,\n      overwriteExistingFiles = false,\n      populate,\n      publishAllLocales: publishAllLocalesArg,\n      publishSpecificLocale,\n      req: {\n        fallbackLocale,\n        locale,\n        payload,\n        payload: { config },\n      },\n      req,\n      select: incomingSelect,\n      selectedLocales,\n      showHiddenFields,\n    } = args\n\n    let { data } = args\n\n    const publishAllLocales =\n      !draft &&\n      (publishAllLocalesArg ?? (hasLocalizeStatusEnabled(collectionConfig) ? false : true))\n    const isSavingDraft = Boolean(draft && hasDraftsEnabled(collectionConfig) && !publishAllLocales)\n\n    if (isSavingDraft) {\n      data._status = 'draft'\n    }\n\n    let duplicatedFromDocWithLocales: JsonObject = {}\n    let duplicatedFromDoc: JsonObject = {}\n\n    if (duplicateFromID) {\n      const duplicateResult = await getDuplicateDocumentData({\n        id: duplicateFromID,\n        collectionConfig,\n        draftArg: isSavingDraft,\n        overrideAccess,\n        req,\n        selectedLocales,\n      })\n\n      duplicatedFromDoc = duplicateResult.duplicatedFromDoc\n      duplicatedFromDocWithLocales = duplicateResult.duplicatedFromDocWithLocales\n    }\n\n    // /////////////////////////////////////\n    // Access\n    // /////////////////////////////////////\n\n    if (!overrideAccess) {\n      await executeAccess({ data, req }, collectionConfig.access.create)\n    }\n\n    // /////////////////////////////////////\n    // Generate data for all files and sizes\n    // /////////////////////////////////////\n\n    const { data: newFileData, files: filesToUpload } = await generateFileData({\n      collection,\n      config,\n      data,\n      isDuplicating: Boolean(duplicateFromID),\n      operation: 'create',\n      originalDoc: duplicatedFromDoc,\n      overwriteExistingFiles,\n      req,\n      throwOnMissingFile:\n        !isSavingDraft && collection.config.upload.filesRequiredOnCreate !== false,\n    })\n\n    data = newFileData\n\n    // /////////////////////////////////////\n    // beforeValidate - Fields\n    // /////////////////////////////////////\n\n    data = await beforeValidate({\n      collection: collectionConfig,\n      context: req.context,\n      data,\n      doc: duplicatedFromDoc,\n      global: null,\n      operation: 'create',\n      overrideAccess: overrideAccess!,\n      req,\n    })\n\n    // /////////////////////////////////////\n    // beforeValidate - Collections\n    // /////////////////////////////////////\n\n    if (collectionConfig.hooks.beforeValidate?.length) {\n      for (const hook of collectionConfig.hooks.beforeValidate) {\n        data =\n          (await hook({\n            collection: collectionConfig,\n            context: req.context,\n            data,\n            operation: 'create',\n            originalDoc: duplicatedFromDoc,\n            req,\n          })) || data\n      }\n    }\n\n    // /////////////////////////////////////\n    // beforeChange - Collection\n    // /////////////////////////////////////\n\n    if (collectionConfig.hooks?.beforeChange?.length) {\n      for (const hook of collectionConfig.hooks.beforeChange) {\n        data =\n          (await hook({\n            collection: collectionConfig,\n            context: req.context,\n            data,\n            operation: 'create',\n            originalDoc: duplicatedFromDoc,\n            req,\n          })) || data\n      }\n    }\n\n    // /////////////////////////////////////\n    // beforeChange - Fields\n    // /////////////////////////////////////\n\n    const resultWithLocales = await beforeChange<JsonObject>({\n      collection: collectionConfig,\n      context: req.context,\n      data,\n      doc: duplicatedFromDoc,\n      docWithLocales: duplicatedFromDocWithLocales,\n      global: null,\n      operation: 'create',\n      overrideAccess,\n      req,\n      skipValidation: isSavingDraft && !hasDraftValidationEnabled(collectionConfig),\n    })\n\n    if (\n      config.localization &&\n      collectionConfig.versions &&\n      collectionConfig.versions.drafts &&\n      collectionConfig.versions.drafts.localizeStatus &&\n      publishAllLocales\n    ) {\n      let accessibleLocaleCodes = config.localization.localeCodes\n\n      if (config.localization.filterAvailableLocales) {\n        const filteredLocales = await config.localization.filterAvailableLocales({\n          locales: config.localization.locales,\n          req,\n        })\n        accessibleLocaleCodes = filteredLocales.map((locale) =>\n          typeof locale === 'string' ? locale : locale.code,\n        )\n      }\n\n      if (typeof resultWithLocales._status !== 'object' || resultWithLocales._status === null) {\n        resultWithLocales._status = {}\n      }\n\n      for (const localeCode of accessibleLocaleCodes) {\n        resultWithLocales._status[localeCode] = 'published'\n      }\n    }\n\n    // /////////////////////////////////////\n    // Write files to local storage\n    // /////////////////////////////////////\n\n    if (!collectionConfig.upload.disableLocalStorage) {\n      await uploadFiles(payload, filesToUpload, req)\n    }\n\n    // /////////////////////////////////////\n    // Create\n    // /////////////////////////////////////\n\n    let doc\n\n    const select = sanitizeSelect({\n      fields: collectionConfig.flattenedFields,\n      forceSelect: collectionConfig.forceSelect,\n      select: incomingSelect,\n    })\n\n    if (collectionConfig.auth && !collectionConfig.auth.disableLocalStrategy) {\n      if (collectionConfig.auth.verify) {\n        resultWithLocales._verified = Boolean(resultWithLocales._verified) || false\n        resultWithLocales._verificationToken = crypto.randomBytes(20).toString('hex')\n      }\n\n      doc = await registerLocalStrategy({\n        collection: collectionConfig,\n        doc: resultWithLocales,\n        password: data.password as string,\n        payload: req.payload,\n        req,\n      })\n    } else {\n      doc = await payload.db.create({\n        collection: collectionConfig.slug,\n        data: resultWithLocales,\n        req,\n      })\n    }\n\n    const verificationToken = doc._verificationToken\n    let result: Document = sanitizeInternalFields(doc)\n\n    // /////////////////////////////////////\n    // Create version\n    // /////////////////////////////////////\n\n    if (collectionConfig.versions) {\n      await saveVersion({\n        id: result.id,\n        autosave,\n        collection: collectionConfig,\n        docWithLocales: result,\n        operation: 'create',\n        payload,\n        publishSpecificLocale,\n        req,\n        returning: false,\n      })\n    }\n\n    // /////////////////////////////////////\n    // Send verification email if applicable\n    // /////////////////////////////////////\n\n    if (collectionConfig.auth && collectionConfig.auth.verify && result.email) {\n      await sendVerificationEmail({\n        collection: { config: collectionConfig },\n        config: payload.config,\n        disableEmail: disableVerificationEmail!,\n        email: payload.email,\n        req,\n        token: verificationToken,\n        user: result,\n      })\n    }\n\n    // /////////////////////////////////////\n    // afterRead - Fields\n    // /////////////////////////////////////\n\n    result = await afterRead({\n      collection: collectionConfig,\n      context: req.context,\n      depth: depth!,\n      doc: result,\n      draft,\n      fallbackLocale: fallbackLocale!,\n      global: null,\n      locale: locale!,\n      overrideAccess: overrideAccess!,\n      populate,\n      req,\n      select,\n      showHiddenFields: showHiddenFields!,\n    })\n\n    // /////////////////////////////////////\n    // afterRead - Collection\n    // /////////////////////////////////////\n\n    if (collectionConfig.hooks?.afterRead?.length) {\n      for (const hook of collectionConfig.hooks.afterRead) {\n        result =\n          (await hook({\n            collection: collectionConfig,\n            context: req.context,\n            doc: result,\n            overrideAccess,\n            req,\n          })) || result\n      }\n    }\n\n    // /////////////////////////////////////\n    // afterChange - Fields\n    // /////////////////////////////////////\n\n    result = await afterChange({\n      collection: collectionConfig,\n      context: req.context,\n      data,\n      doc: result,\n      global: null,\n      operation: 'create',\n      previousDoc: {},\n      req,\n    })\n\n    // /////////////////////////////////////\n    // afterChange - Collection\n    // /////////////////////////////////////\n\n    if (collectionConfig.hooks?.afterChange?.length) {\n      for (const hook of collectionConfig.hooks.afterChange) {\n        result =\n          (await hook({\n            collection: collectionConfig,\n            context: req.context,\n            data,\n            doc: result,\n            operation: 'create',\n            overrideAccess,\n            previousDoc: {},\n            req: args.req,\n          })) || result\n      }\n    }\n\n    // /////////////////////////////////////\n    // afterOperation - Collection\n    // /////////////////////////////////////\n\n    result = await buildAfterOperation<TSlug>({\n      args,\n      collection: collectionConfig,\n      operation: 'create',\n      overrideAccess: args.overrideAccess!,\n      result,\n    })\n\n    await unlinkTempFiles({ collectionConfig, config, req })\n\n    // /////////////////////////////////////\n    // Return results\n    // /////////////////////////////////////\n\n    if (shouldCommit) {\n      await commitTransaction(req)\n    }\n\n    return result\n  } catch (error: unknown) {\n    await killTransaction(args.req)\n    throw error\n  }\n}\n"],"names":["crypto","ensureUsernameOrEmail","executeAccess","sendVerificationEmail","registerLocalStrategy","getDuplicateDocumentData","afterChange","afterRead","beforeChange","beforeValidate","saveVersion","generateFileData","unlinkTempFiles","uploadFiles","commitTransaction","hasDraftsEnabled","hasDraftValidationEnabled","hasLocalizeStatusEnabled","initTransaction","killTransaction","sanitizeInternalFields","sanitizeSelect","buildAfterOperation","buildBeforeOperation","createOperation","incomingArgs","args","shouldCommit","disableTransaction","req","authOptions","collection","config","auth","collectionSlug","slug","data","operation","overrideAccess","publishSpecificLocale","locale","autosave","collectionConfig","depth","disableVerificationEmail","draft","duplicateFromID","overwriteExistingFiles","populate","publishAllLocales","publishAllLocalesArg","fallbackLocale","payload","select","incomingSelect","selectedLocales","showHiddenFields","isSavingDraft","Boolean","_status","duplicatedFromDocWithLocales","duplicatedFromDoc","duplicateResult","id","draftArg","access","create","newFileData","files","filesToUpload","isDuplicating","originalDoc","throwOnMissingFile","upload","filesRequiredOnCreate","context","doc","global","hooks","length","hook","resultWithLocales","docWithLocales","skipValidation","localization","versions","drafts","localizeStatus","accessibleLocaleCodes","localeCodes","filterAvailableLocales","filteredLocales","locales","map","code","localeCode","disableLocalStorage","fields","flattenedFields","forceSelect","disableLocalStrategy","verify","_verified","_verificationToken","randomBytes","toString","password","db","verificationToken","result","returning","email","disableEmail","token","user","previousDoc","error"],"mappings":"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"}},
    {"offset": {"line": 743, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/collections/operations/local/create.ts"],"sourcesContent":["import type {\n  Document,\n  PayloadRequest,\n  PopulateType,\n  SelectType,\n  TransformCollectionWithSelect,\n} from '../../../types/index.js'\nimport type { File } from '../../../uploads/types.js'\nimport type { CreateLocalReqOptions } from '../../../utilities/createLocalReq.js'\nimport type {\n  CollectionsWithoutDrafts,\n  DataFromCollectionSlug,\n  DraftDataFromCollectionSlug,\n  RequiredDataFromCollectionSlug,\n  SelectFromCollectionSlug,\n} from '../../config/types.js'\n\nimport { APIError } from '../../../errors/index.js'\nimport {\n  type CollectionSlug,\n  deepCopyObjectSimple,\n  type FindOptions,\n  type GeneratedTypes,\n  type Payload,\n  type RequestContext,\n  type TypedLocale,\n} from '../../../index.js'\nimport { getFileByPath } from '../../../uploads/getFileByPath.js'\nimport { createLocalReq } from '../../../utilities/createLocalReq.js'\nimport { createOperation } from '../create.js'\n\ntype BaseOptions<TSlug extends CollectionSlug, TSelect extends SelectType> = {\n  /**\n   * the Collection slug to operate against.\n   */\n  collection: TSlug\n  /**\n   * [Context](https://payloadcms.com/docs/hooks/context), which will then be passed to `context` and `req.context`,\n   * which can be read by hooks. Useful if you want to pass additional information to the hooks which\n   * shouldn't be necessarily part of the document, for example a `triggerBeforeChange` option which can be read by the BeforeChange hook\n   * to determine if it should run or not.\n   */\n  context?: RequestContext\n  /**\n   * [Control auto-population](https://payloadcms.com/docs/queries/depth) of nested relationship and upload fields.\n   */\n  depth?: number\n  /**\n   * When set to `true`, a [database transactions](https://payloadcms.com/docs/database/transactions) will not be initialized.\n   * @default false\n   */\n  disableTransaction?: boolean\n  /**\n   * If creating verification-enabled auth doc,\n   * you can disable the email that is auto-sent\n   */\n  disableVerificationEmail?: boolean\n  /**\n   * If you want to create a document that is a duplicate of another document\n   */\n  duplicateFromID?: DataFromCollectionSlug<TSlug>['id']\n  /**\n   * Specify a [fallback locale](https://payloadcms.com/docs/configuration/localization) to use for any returned documents.\n   */\n  fallbackLocale?: false | TypedLocale\n  /**\n   * A `File` object when creating a collection with `upload: true`.\n   */\n  file?: File\n  /**\n   * A file path when creating a collection with `upload: true`.\n   */\n  filePath?: string\n  /**\n   * Specify [locale](https://payloadcms.com/docs/configuration/localization) for any returned documents.\n   */\n  locale?: TypedLocale\n  /**\n   * Skip access control.\n   * Set to `false` if you want to respect Access Control for the operation, for example when fetching data for the front-end.\n   * @default true\n   */\n  overrideAccess?: boolean\n  /**\n   * If you are uploading a file and would like to replace\n   * the existing file instead of generating a new filename,\n   * you can set the following property to `true`\n   */\n  overwriteExistingFiles?: boolean\n  /**\n   * Specify [populate](https://payloadcms.com/docs/queries/select#populate) to control which fields to include to the result from populated documents.\n   */\n  populate?: PopulateType\n  /**\n   * Publish to all locales\n   */\n  publishAllLocales?: boolean\n  /**\n   * The `PayloadRequest` object. You can pass it to thread the current [transaction](https://payloadcms.com/docs/database/transactions), user and locale to the operation.\n   * Recommended to pass when using the Local API from hooks, as usually you want to execute the operation within the current transaction.\n   */\n  req?: Partial<PayloadRequest>\n  /**\n   * Opt-in to receiving hidden fields. By default, they are hidden from returned documents in accordance to your config.\n   * @default false\n   */\n  showHiddenFields?: boolean\n  /**\n   * If you set `overrideAccess` to `false`, you can pass a user to use against the access control checks.\n   */\n  user?: Document\n} & Pick<FindOptions<TSlug, TSelect>, 'select'>\n\nexport type Options<\n  TSlug extends CollectionSlug,\n  TSelect extends SelectType,\n> = GeneratedTypes extends { strictDraftTypes: true }\n  ? CollectionsWithoutDrafts extends TSlug\n    ? {\n        /**\n         * The data for the document to create.\n         */\n        data: DataFromCollectionSlug<TSlug>\n        /**\n         * Create a **draft** document. [More](https://payloadcms.com/docs/versions/drafts#draft-api)\n         */\n        draft?: boolean\n      } & BaseOptions<TSlug, TSelect>\n    : TSlug extends CollectionsWithoutDrafts\n      ? {\n          data: RequiredDataFromCollectionSlug<TSlug>\n          /**\n           * The `draft` property is not allowed because this collection does not have `versions.drafts` enabled.\n           */\n          draft?: never\n        } & BaseOptions<TSlug, TSelect>\n      : (\n          | {\n              /**\n               * The data for the document to create.\n               */\n              data: RequiredDataFromCollectionSlug<TSlug>\n              /**\n               * Create a **draft** document. [More](https://payloadcms.com/docs/versions/drafts#draft-api)\n               * Omit this property or set to `false` to create a published document.\n               */\n              draft?: false\n            }\n          | {\n              /**\n               * The data for the document to create.\n               * When creating a draft, required fields are optional as validation is skipped by default.\n               */\n              data: DraftDataFromCollectionSlug<TSlug>\n              /**\n               * Create a **draft** document. [More](https://payloadcms.com/docs/versions/drafts#draft-api)\n               */\n              draft: true\n            }\n        ) &\n          BaseOptions<TSlug, TSelect>\n  :\n      | ({\n          /**\n           * The data for the document to create.\n           */\n          data: RequiredDataFromCollectionSlug<TSlug>\n          /**\n           * Create a **draft** document. [More](https://payloadcms.com/docs/versions/drafts#draft-api)\n           */\n          draft?: false\n        } & BaseOptions<TSlug, TSelect>)\n      | ({\n          /**\n           * The data for the document to create.\n           * When creating a draft, required fields are optional as validation is skipped by default.\n           */\n          data: DraftDataFromCollectionSlug<TSlug>\n          /**\n           * Create a **draft** document. [More](https://payloadcms.com/docs/versions/drafts#draft-api)\n           */\n          draft: true\n        } & BaseOptions<TSlug, TSelect>)\n\nexport async function createLocal<\n  TSlug extends CollectionSlug,\n  TSelect extends SelectFromCollectionSlug<TSlug>,\n>(\n  payload: Payload,\n  options: Options<TSlug, TSelect>,\n): Promise<TransformCollectionWithSelect<TSlug, TSelect>> {\n  const {\n    collection: collectionSlug,\n    data,\n    depth,\n    disableTransaction,\n    disableVerificationEmail,\n    draft,\n    duplicateFromID,\n    file,\n    filePath,\n    overrideAccess = true,\n    overwriteExistingFiles = false,\n    populate,\n    publishAllLocales,\n    select,\n    showHiddenFields,\n  } = options\n\n  const collection = payload.collections[collectionSlug]\n\n  if (!collection) {\n    throw new APIError(\n      `The collection with slug ${String(collectionSlug)} can't be found. Create Operation.`,\n    )\n  }\n\n  const req = await createLocalReq(options as CreateLocalReqOptions, payload)\n\n  req.file = file ?? (await getFileByPath(filePath!))\n\n  return createOperation<TSlug, TSelect>({\n    collection,\n    data: deepCopyObjectSimple(data), // Ensure mutation of data in create operation hooks doesn't affect the original data\n    depth,\n    disableTransaction,\n    disableVerificationEmail,\n    draft,\n    duplicateFromID,\n    overrideAccess,\n    overwriteExistingFiles,\n    populate,\n    publishAllLocales,\n    req,\n    select,\n    showHiddenFields,\n  })\n}\n"],"names":["APIError","deepCopyObjectSimple","getFileByPath","createLocalReq","createOperation","createLocal","payload","options","collection","collectionSlug","data","depth","disableTransaction","disableVerificationEmail","draft","duplicateFromID","file","filePath","overrideAccess","overwriteExistingFiles","populate","publishAllLocales","select","showHiddenFields","collections","String","req"],"mappings":";;;;AAiBA,SAASA,QAAQ,QAAQ,2BAA0B;AACnD,SAEEC,oBAAoB,QAMf,oBAAmB;AAC1B,SAASC,aAAa,QAAQ,oCAAmC;AACjE,SAASC,cAAc,QAAQ,uCAAsC;AACrE,SAASC,eAAe,QAAQ,eAAc;;;;;;AA2JvC,eAAeC,YAIpBC,OAAgB,EAChBC,OAAgC;IAEhC,MAAM,EACJC,YAAYC,cAAc,EAC1BC,IAAI,EACJC,KAAK,EACLC,kBAAkB,EAClBC,wBAAwB,EACxBC,KAAK,EACLC,eAAe,EACfC,IAAI,EACJC,QAAQ,EACRC,iBAAiB,IAAI,EACrBC,yBAAyB,KAAK,EAC9BC,QAAQ,EACRC,iBAAiB,EACjBC,MAAM,EACNC,gBAAgB,EACjB,GAAGhB;IAEJ,MAAMC,aAAaF,QAAQkB,WAAW,CAACf,eAAe;IAEtD,IAAI,CAACD,YAAY;QACf,MAAM,IAAIR,mKAAAA,CACR,CAAC,yBAAyB,EAAEyB,OAAOhB,gBAAgB,kCAAkC,CAAC;IAE1F;IAEA,MAAMiB,MAAM,UAAMvB,kLAAAA,EAAeI,SAAkCD;IAEnEoB,IAAIV,IAAI,GAAGA,QAAS,UAAMd,8KAAAA,EAAce;IAExC,WAAOb,2LAAAA,EAAgC;QACrCI;QACAE,UAAMT,wLAAAA,EAAqBS;QAC3BC;QACAC;QACAC;QACAC;QACAC;QACAG;QACAC;QACAC;QACAC;QACAK;QACAJ;QACAC;IACF;AACF"}},
    {"offset": {"line": 786, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/collections/operations/delete.ts"],"sourcesContent":["import { status as httpStatus } from 'http-status'\n\nimport type { AccessResult } from '../../config/types.js'\nimport type { CollectionSlug, FindOptions } from '../../index.js'\nimport type { PayloadRequest, PopulateType, SelectType, Where } from '../../types/index.js'\nimport type {\n  BulkOperationResult,\n  Collection,\n  DataFromCollectionSlug,\n  SelectFromCollectionSlug,\n} from '../config/types.js'\n\nimport { executeAccess } from '../../auth/executeAccess.js'\nimport { combineQueries } from '../../database/combineQueries.js'\nimport { validateQueryPaths } from '../../database/queryValidation/validateQueryPaths.js'\nimport { sanitizeWhereQuery } from '../../database/sanitizeWhereQuery.js'\nimport { APIError } from '../../errors/index.js'\nimport { afterRead } from '../../fields/hooks/afterRead/index.js'\nimport { deleteUserPreferences } from '../../preferences/deleteUserPreferences.js'\nimport { deleteAssociatedFiles } from '../../uploads/deleteAssociatedFiles.js'\nimport { appendNonTrashedFilter } from '../../utilities/appendNonTrashedFilter.js'\nimport { checkDocumentLockStatus } from '../../utilities/checkDocumentLockStatus.js'\nimport { commitTransaction } from '../../utilities/commitTransaction.js'\nimport { hasScheduledPublishEnabled } from '../../utilities/getVersionsConfig.js'\nimport { initTransaction } from '../../utilities/initTransaction.js'\nimport { isErrorPublic } from '../../utilities/isErrorPublic.js'\nimport { killTransaction } from '../../utilities/killTransaction.js'\nimport { sanitizeSelect } from '../../utilities/sanitizeSelect.js'\nimport { deleteCollectionVersions } from '../../versions/deleteCollectionVersions.js'\nimport { deleteScheduledPublishJobs } from '../../versions/deleteScheduledPublishJobs.js'\nimport { buildAfterOperation } from './utilities/buildAfterOperation.js'\nimport { buildBeforeOperation } from './utilities/buildBeforeOperation.js'\n\nexport type Arguments = {\n  collection: Collection\n  depth?: number\n  disableTransaction?: boolean\n  overrideAccess?: boolean\n  overrideLock?: boolean\n  populate?: PopulateType\n  req: PayloadRequest\n  showHiddenFields?: boolean\n  trash?: boolean\n  where: Where\n} & Pick<FindOptions<string, SelectType>, 'select'>\n\nexport const deleteOperation = async <\n  TSlug extends CollectionSlug,\n  TSelect extends SelectFromCollectionSlug<TSlug>,\n>(\n  incomingArgs: Arguments,\n): Promise<BulkOperationResult<TSlug, TSelect>> => {\n  let args = incomingArgs\n\n  try {\n    const shouldCommit = !args.disableTransaction && (await initTransaction(args.req))\n    // /////////////////////////////////////\n    // beforeOperation - Collection\n    // /////////////////////////////////////\n\n    args = await buildBeforeOperation({\n      args,\n      collection: args.collection.config,\n      operation: 'delete',\n      overrideAccess: args.overrideAccess!,\n    })\n\n    const {\n      collection: { config: collectionConfig },\n      depth,\n      overrideAccess,\n      overrideLock,\n      populate,\n      req: {\n        fallbackLocale,\n        locale,\n        payload: { config },\n        payload,\n      },\n      req,\n      select: incomingSelect,\n      showHiddenFields,\n      trash = false,\n      where,\n    } = args\n\n    if (!where) {\n      throw new APIError(\"Missing 'where' query of documents to delete.\", httpStatus.BAD_REQUEST)\n    }\n\n    // /////////////////////////////////////\n    // Access\n    // /////////////////////////////////////\n\n    let accessResult: AccessResult\n\n    if (!overrideAccess) {\n      accessResult = await executeAccess({ req }, collectionConfig.access.delete)\n    }\n\n    await validateQueryPaths({\n      collectionConfig,\n      overrideAccess: overrideAccess!,\n      req,\n      where,\n    })\n\n    let fullWhere = combineQueries(where, accessResult!)\n\n    // Exclude trashed documents when trash: false\n    fullWhere = appendNonTrashedFilter({\n      enableTrash: collectionConfig.trash,\n      trash,\n      where: fullWhere,\n    })\n\n    sanitizeWhereQuery({ fields: collectionConfig.flattenedFields, payload, where: fullWhere })\n\n    const select = sanitizeSelect({\n      fields: collectionConfig.flattenedFields,\n      forceSelect: collectionConfig.forceSelect,\n      select: incomingSelect,\n    })\n\n    // /////////////////////////////////////\n    // Retrieve documents\n    // /////////////////////////////////////\n\n    const { docs } = await payload.db.find<DataFromCollectionSlug<TSlug>>({\n      collection: collectionConfig.slug,\n      locale: locale!,\n      req,\n      select,\n      where: fullWhere,\n    })\n\n    const errors: BulkOperationResult<TSlug, TSelect>['errors'] = []\n\n    const promises = docs.map(async (doc) => {\n      let result\n\n      const { id } = doc\n\n      try {\n        // Each document gets its own transaction when singleTransaction is enabled\n        let docShouldCommit = false\n        if (req.payload.db.bulkOperationsSingleTransaction) {\n          docShouldCommit = await initTransaction(req)\n        }\n\n        // /////////////////////////////////////\n        // Handle potentially locked documents\n        // /////////////////////////////////////\n\n        await checkDocumentLockStatus({\n          id,\n          collectionSlug: collectionConfig.slug,\n          lockErrorMessage: `Document with ID ${id} is currently locked and cannot be deleted.`,\n          overrideLock,\n          req,\n        })\n\n        // /////////////////////////////////////\n        // beforeDelete - Collection\n        // /////////////////////////////////////\n\n        if (collectionConfig.hooks?.beforeDelete?.length) {\n          for (const hook of collectionConfig.hooks.beforeDelete) {\n            await hook({\n              id,\n              collection: collectionConfig,\n              context: req.context,\n              req,\n            })\n          }\n        }\n\n        await deleteAssociatedFiles({\n          collectionConfig,\n          config,\n          doc,\n          overrideDelete: true,\n          req,\n        })\n\n        // /////////////////////////////////////\n        // Delete versions\n        // /////////////////////////////////////\n\n        if (collectionConfig.versions) {\n          await deleteCollectionVersions({\n            id,\n            slug: collectionConfig.slug,\n            payload,\n            req,\n          })\n        }\n\n        // /////////////////////////////////////\n        // Delete scheduled posts\n        // /////////////////////////////////////\n        if (hasScheduledPublishEnabled(collectionConfig)) {\n          await deleteScheduledPublishJobs({\n            id,\n            slug: collectionConfig.slug,\n            payload,\n            req,\n          })\n        }\n\n        // /////////////////////////////////////\n        // Delete document\n        // /////////////////////////////////////\n\n        await payload.db.deleteOne({\n          collection: collectionConfig.slug,\n          req,\n          returning: false,\n          where: {\n            id: {\n              equals: id,\n            },\n          },\n        })\n\n        // /////////////////////////////////////\n        // afterRead - Fields\n        // /////////////////////////////////////\n\n        result = await afterRead({\n          collection: collectionConfig,\n          context: req.context,\n          depth: depth!,\n          doc: result || doc,\n          // @ts-expect-error - vestiges of when tsconfig was not strict. Feel free to improve\n          draft: undefined,\n          fallbackLocale: fallbackLocale!,\n          global: null,\n          locale: locale!,\n          overrideAccess: overrideAccess!,\n          populate,\n          req,\n          select,\n          showHiddenFields: showHiddenFields!,\n        })\n\n        // /////////////////////////////////////\n        // afterRead - Collection\n        // /////////////////////////////////////\n\n        if (collectionConfig.hooks?.afterRead?.length) {\n          for (const hook of collectionConfig.hooks.afterRead) {\n            result =\n              (await hook({\n                collection: collectionConfig,\n                context: req.context,\n                doc: result || doc,\n                overrideAccess,\n                req,\n              })) || result\n          }\n        }\n\n        // /////////////////////////////////////\n        // afterDelete - Collection\n        // /////////////////////////////////////\n\n        if (collectionConfig.hooks?.afterDelete?.length) {\n          for (const hook of collectionConfig.hooks.afterDelete) {\n            result =\n              (await hook({\n                id,\n                collection: collectionConfig,\n                context: req.context,\n                doc: result,\n                req,\n              })) || result\n          }\n        }\n\n        // /////////////////////////////////////\n        // 8. Return results\n        // /////////////////////////////////////\n        if (docShouldCommit) {\n          await commitTransaction(req)\n        }\n\n        return result\n      } catch (error) {\n        const isPublic = error instanceof Error ? isErrorPublic(error, config) : false\n\n        if (req.payload.db.bulkOperationsSingleTransaction) {\n          await killTransaction(req)\n        }\n        errors.push({\n          id: doc.id,\n          isPublic,\n          message: error instanceof Error ? error.message : 'Unknown error',\n        })\n      }\n      return null\n    })\n\n    // Process sequentially when using single transaction mode to avoid shared state issues\n    // Process in parallel when using one transaction for better performance\n    let awaitedDocs\n    if (req.payload.db.bulkOperationsSingleTransaction) {\n      awaitedDocs = []\n      for (const promise of promises) {\n        awaitedDocs.push(await promise)\n      }\n    } else {\n      awaitedDocs = await Promise.all(promises)\n    }\n\n    // /////////////////////////////////////\n    // Delete Preferences\n    // /////////////////////////////////////\n\n    await deleteUserPreferences({\n      collectionConfig,\n      ids: docs.map(({ id }) => id),\n      payload,\n      req,\n    })\n\n    let result = {\n      docs: awaitedDocs.filter(Boolean),\n      errors,\n    }\n\n    // /////////////////////////////////////\n    // afterOperation - Collection\n    // /////////////////////////////////////\n\n    result = await buildAfterOperation({\n      args,\n      collection: collectionConfig,\n      operation: 'delete',\n      overrideAccess,\n      result,\n    })\n\n    if (shouldCommit) {\n      await commitTransaction(req)\n    }\n\n    return result\n  } catch (error: unknown) {\n    await killTransaction(args.req)\n    throw error\n  }\n}\n"],"names":["status","httpStatus","executeAccess","combineQueries","validateQueryPaths","sanitizeWhereQuery","APIError","afterRead","deleteUserPreferences","deleteAssociatedFiles","appendNonTrashedFilter","checkDocumentLockStatus","commitTransaction","hasScheduledPublishEnabled","initTransaction","isErrorPublic","killTransaction","sanitizeSelect","deleteCollectionVersions","deleteScheduledPublishJobs","buildAfterOperation","buildBeforeOperation","deleteOperation","incomingArgs","args","shouldCommit","disableTransaction","req","collection","config","operation","overrideAccess","collectionConfig","depth","overrideLock","populate","fallbackLocale","locale","payload","select","incomingSelect","showHiddenFields","trash","where","BAD_REQUEST","accessResult","access","delete","fullWhere","enableTrash","fields","flattenedFields","forceSelect","docs","db","find","slug","errors","promises","map","doc","result","id","docShouldCommit","bulkOperationsSingleTransaction","collectionSlug","lockErrorMessage","hooks","beforeDelete","length","hook","context","overrideDelete","versions","deleteOne","returning","equals","draft","undefined","global","afterDelete","error","isPublic","Error","push","message","awaitedDocs","promise","Promise","all","ids","filter","Boolean"],"mappings":";;;;;AAAA,SAASA,UAAUC,UAAU,QAAQ,cAAa;AAYlD,SAASC,aAAa,QAAQ,8BAA6B;AAC3D,SAASC,cAAc,QAAQ,mCAAkC;AACjE,SAASC,kBAAkB,QAAQ,uDAAsD;AACzF,SAASC,kBAAkB,QAAQ,uCAAsC;AACzE,SAASC,QAAQ,QAAQ,wBAAuB;AAChD,SAASC,SAAS,QAAQ,wCAAuC;AACjE,SAASC,qBAAqB,QAAQ,6CAA4C;AAClF,SAASC,qBAAqB,QAAQ,yCAAwC;AAC9E,SAASC,sBAAsB,QAAQ,4CAA2C;AAClF,SAASC,uBAAuB,QAAQ,6CAA4C;AACpF,SAASC,iBAAiB,QAAQ,uCAAsC;AACxE,SAASC,0BAA0B,QAAQ,uCAAsC;AACjF,SAASC,eAAe,QAAQ,qCAAoC;AACpE,SAASC,aAAa,QAAQ,mCAAkC;AAChE,SAASC,eAAe,QAAQ,qCAAoC;AACpE,SAASC,cAAc,QAAQ,oCAAmC;AAClE,SAASC,wBAAwB,QAAQ,6CAA4C;AACrF,SAASC,0BAA0B,QAAQ,+CAA8C;AACzF,SAASC,mBAAmB,QAAQ,qCAAoC;AACxE,SAASC,oBAAoB,QAAQ,sCAAqC;;;;;;;;;;;;;;;;;;;;;;AAenE,MAAMC,kBAAkB,OAI7BC;IAEA,IAAIC,OAAOD;IAEX,IAAI;QACF,MAAME,eAAe,CAACD,KAAKE,kBAAkB,IAAK,UAAMZ,oLAAAA,EAAgBU,KAAKG,GAAG;QAChF,wCAAwC;QACxC,+BAA+B;QAC/B,wCAAwC;QAExCH,OAAO,UAAMH,2NAAAA,EAAqB;YAChCG;YACAI,YAAYJ,KAAKI,UAAU,CAACC,MAAM;YAClCC,WAAW;YACXC,gBAAgBP,KAAKO,cAAc;QACrC;QAEA,MAAM,EACJH,YAAY,EAAEC,QAAQG,gBAAgB,EAAE,EACxCC,KAAK,EACLF,cAAc,EACdG,YAAY,EACZC,QAAQ,EACRR,KAAK,EACHS,cAAc,EACdC,MAAM,EACNC,SAAS,EAAET,MAAM,EAAE,EACnBS,OAAO,EACR,EACDX,GAAG,EACHY,QAAQC,cAAc,EACtBC,gBAAgB,EAChBC,QAAQ,KAAK,EACbC,KAAK,EACN,GAAGnB;QAEJ,IAAI,CAACmB,OAAO;YACV,MAAM,IAAIrC,mKAAAA,CAAS,iDAAiDL,sMAAAA,CAAW2C,WAAW;QAC5F;QAEA,wCAAwC;QACxC,SAAS;QACT,wCAAwC;QAExC,IAAIC;QAEJ,IAAI,CAACd,gBAAgB;YACnBc,eAAe,UAAM3C,2KAAAA,EAAc;gBAAEyB;YAAI,GAAGK,iBAAiBc,MAAM,CAACC,MAAM;QAC5E;QAEA,UAAM3C,4MAAAA,EAAmB;YACvB4B;YACAD,gBAAgBA;YAChBJ;YACAgB;QACF;QAEA,IAAIK,gBAAY7C,iLAAAA,EAAewC,OAAOE;QAEtC,8CAA8C;QAC9CG,gBAAYtC,kMAAAA,EAAuB;YACjCuC,aAAajB,iBAAiBU,KAAK;YACnCA;YACAC,OAAOK;QACT;YAEA3C,yLAAAA,EAAmB;YAAE6C,QAAQlB,iBAAiBmB,eAAe;YAAEb;YAASK,OAAOK;QAAU;QAEzF,MAAMT,aAAStB,kLAAAA,EAAe;YAC5BiC,QAAQlB,iBAAiBmB,eAAe;YACxCC,aAAapB,iBAAiBoB,WAAW;YACzCb,QAAQC;QACV;QAEA,wCAAwC;QACxC,qBAAqB;QACrB,wCAAwC;QAExC,MAAM,EAAEa,IAAI,EAAE,GAAG,MAAMf,QAAQgB,EAAE,CAACC,IAAI,CAAgC;YACpE3B,YAAYI,iBAAiBwB,IAAI;YACjCnB,QAAQA;YACRV;YACAY;YACAI,OAAOK;QACT;QAEA,MAAMS,SAAwD,EAAE;QAEhE,MAAMC,WAAWL,KAAKM,GAAG,CAAC,OAAOC;YAC/B,IAAIC;YAEJ,MAAM,EAAEC,EAAE,EAAE,GAAGF;YAEf,IAAI;gBACF,2EAA2E;gBAC3E,IAAIG,kBAAkB;gBACtB,IAAIpC,IAAIW,OAAO,CAACgB,EAAE,CAACU,+BAA+B,EAAE;oBAClDD,kBAAkB,UAAMjD,oLAAAA,EAAgBa;gBAC1C;gBAEA,wCAAwC;gBACxC,sCAAsC;gBACtC,wCAAwC;gBAExC,UAAMhB,oMAAAA,EAAwB;oBAC5BmD;oBACAG,gBAAgBjC,iBAAiBwB,IAAI;oBACrCU,kBAAkB,CAAC,iBAAiB,EAAEJ,GAAG,2CAA2C,CAAC;oBACrF5B;oBACAP;gBACF;gBAEA,wCAAwC;gBACxC,4BAA4B;gBAC5B,wCAAwC;gBAExC,IAAIK,iBAAiBmC,KAAK,EAAEC,cAAcC,QAAQ;oBAChD,KAAK,MAAMC,QAAQtC,iBAAiBmC,KAAK,CAACC,YAAY,CAAE;wBACtD,MAAME,KAAK;4BACTR;4BACAlC,YAAYI;4BACZuC,SAAS5C,IAAI4C,OAAO;4BACpB5C;wBACF;oBACF;gBACF;gBAEA,UAAMlB,8LAAAA,EAAsB;oBAC1BuB;oBACAH;oBACA+B;oBACAY,gBAAgB;oBAChB7C;gBACF;gBAEA,wCAAwC;gBACxC,kBAAkB;gBAClB,wCAAwC;gBAExC,IAAIK,iBAAiByC,QAAQ,EAAE;oBAC7B,UAAMvD,qMAAAA,EAAyB;wBAC7B4C;wBACAN,MAAMxB,iBAAiBwB,IAAI;wBAC3BlB;wBACAX;oBACF;gBACF;gBAEA,wCAAwC;gBACxC,yBAAyB;gBACzB,wCAAwC;gBACxC,QAAId,iMAAAA,EAA2BmB,mBAAmB;oBAChD,UAAMb,yMAAAA,EAA2B;wBAC/B2C;wBACAN,MAAMxB,iBAAiBwB,IAAI;wBAC3BlB;wBACAX;oBACF;gBACF;gBAEA,wCAAwC;gBACxC,kBAAkB;gBAClB,wCAAwC;gBAExC,MAAMW,QAAQgB,EAAE,CAACoB,SAAS,CAAC;oBACzB9C,YAAYI,iBAAiBwB,IAAI;oBACjC7B;oBACAgD,WAAW;oBACXhC,OAAO;wBACLmB,IAAI;4BACFc,QAAQd;wBACV;oBACF;gBACF;gBAEA,wCAAwC;gBACxC,qBAAqB;gBACrB,wCAAwC;gBAExCD,SAAS,UAAMtD,uLAAAA,EAAU;oBACvBqB,YAAYI;oBACZuC,SAAS5C,IAAI4C,OAAO;oBACpBtC,OAAOA;oBACP2B,KAAKC,UAAUD;oBACf,oFAAoF;oBACpFiB,OAAOC;oBACP1C,gBAAgBA;oBAChB2C,QAAQ;oBACR1C,QAAQA;oBACRN,gBAAgBA;oBAChBI;oBACAR;oBACAY;oBACAE,kBAAkBA;gBACpB;gBAEA,wCAAwC;gBACxC,yBAAyB;gBACzB,wCAAwC;gBAExC,IAAIT,iBAAiBmC,KAAK,EAAE5D,WAAW8D,QAAQ;oBAC7C,KAAK,MAAMC,QAAQtC,iBAAiBmC,KAAK,CAAC5D,SAAS,CAAE;wBACnDsD,SACG,MAAMS,KAAK;4BACV1C,YAAYI;4BACZuC,SAAS5C,IAAI4C,OAAO;4BACpBX,KAAKC,UAAUD;4BACf7B;4BACAJ;wBACF,MAAOkC;oBACX;gBACF;gBAEA,wCAAwC;gBACxC,2BAA2B;gBAC3B,wCAAwC;gBAExC,IAAI7B,iBAAiBmC,KAAK,EAAEa,aAAaX,QAAQ;oBAC/C,KAAK,MAAMC,QAAQtC,iBAAiBmC,KAAK,CAACa,WAAW,CAAE;wBACrDnB,SACG,MAAMS,KAAK;4BACVR;4BACAlC,YAAYI;4BACZuC,SAAS5C,IAAI4C,OAAO;4BACpBX,KAAKC;4BACLlC;wBACF,MAAOkC;oBACX;gBACF;gBAEA,wCAAwC;gBACxC,oBAAoB;gBACpB,wCAAwC;gBACxC,IAAIE,iBAAiB;oBACnB,UAAMnD,wLAAAA,EAAkBe;gBAC1B;gBAEA,OAAOkC;YACT,EAAE,OAAOoB,OAAO;gBACd,MAAMC,WAAWD,iBAAiBE,YAAQpE,gLAAAA,EAAckE,OAAOpD,UAAU;gBAEzE,IAAIF,IAAIW,OAAO,CAACgB,EAAE,CAACU,+BAA+B,EAAE;oBAClD,UAAMhD,oLAAAA,EAAgBW;gBACxB;gBACA8B,OAAO2B,IAAI,CAAC;oBACVtB,IAAIF,IAAIE,EAAE;oBACVoB;oBACAG,SAASJ,iBAAiBE,QAAQF,MAAMI,OAAO,GAAG;gBACpD;YACF;YACA,OAAO;QACT;QAEA,uFAAuF;QACvF,wEAAwE;QACxE,IAAIC;QACJ,IAAI3D,IAAIW,OAAO,CAACgB,EAAE,CAACU,+BAA+B,EAAE;YAClDsB,cAAc,EAAE;YAChB,KAAK,MAAMC,WAAW7B,SAAU;gBAC9B4B,YAAYF,IAAI,CAAC,MAAMG;YACzB;QACF,OAAO;YACLD,cAAc,MAAME,QAAQC,GAAG,CAAC/B;QAClC;QAEA,wCAAwC;QACxC,qBAAqB;QACrB,wCAAwC;QAExC,UAAMlD,kMAAAA,EAAsB;YAC1BwB;YACA0D,KAAKrC,KAAKM,GAAG,CAAC,CAAC,EAAEG,EAAE,EAAE,GAAKA;YAC1BxB;YACAX;QACF;QAEA,IAAIkC,SAAS;YACXR,MAAMiC,YAAYK,MAAM,CAACC;YACzBnC;QACF;QAEA,wCAAwC;QACxC,8BAA8B;QAC9B,wCAAwC;QAExCI,SAAS,UAAMzC,yNAAAA,EAAoB;YACjCI;YACAI,YAAYI;YACZF,WAAW;YACXC;YACA8B;QACF;QAEA,IAAIpC,cAAc;YAChB,UAAMb,wLAAAA,EAAkBe;QAC1B;QAEA,OAAOkC;IACT,EAAE,OAAOoB,OAAgB;QACvB,UAAMjE,oLAAAA,EAAgBQ,KAAKG,GAAG;QAC9B,MAAMsD;IACR;AACF,EAAC"}},
    {"offset": {"line": 1081, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/collections/operations/deleteByID.ts"],"sourcesContent":["import type { CollectionSlug, FindOptions } from '../../index.js'\nimport type {\n  PayloadRequest,\n  PopulateType,\n  SelectType,\n  TransformCollectionWithSelect,\n} from '../../types/index.js'\nimport type { Collection, DataFromCollectionSlug } from '../config/types.js'\n\nimport { executeAccess } from '../../auth/executeAccess.js'\nimport { hasWhereAccessResult } from '../../auth/types.js'\nimport { combineQueries } from '../../database/combineQueries.js'\nimport { Forbidden, NotFound } from '../../errors/index.js'\nimport { afterRead } from '../../fields/hooks/afterRead/index.js'\nimport { deleteUserPreferences } from '../../preferences/deleteUserPreferences.js'\nimport { deleteAssociatedFiles } from '../../uploads/deleteAssociatedFiles.js'\nimport { appendNonTrashedFilter } from '../../utilities/appendNonTrashedFilter.js'\nimport { checkDocumentLockStatus } from '../../utilities/checkDocumentLockStatus.js'\nimport { commitTransaction } from '../../utilities/commitTransaction.js'\nimport { hasScheduledPublishEnabled } from '../../utilities/getVersionsConfig.js'\nimport { initTransaction } from '../../utilities/initTransaction.js'\nimport { killTransaction } from '../../utilities/killTransaction.js'\nimport { sanitizeSelect } from '../../utilities/sanitizeSelect.js'\nimport { deleteCollectionVersions } from '../../versions/deleteCollectionVersions.js'\nimport { deleteScheduledPublishJobs } from '../../versions/deleteScheduledPublishJobs.js'\nimport { buildAfterOperation } from './utilities/buildAfterOperation.js'\nimport { buildBeforeOperation } from './utilities/buildBeforeOperation.js'\n\nexport type Arguments<TSlug extends CollectionSlug, TSelect extends SelectType> = {\n  collection: Collection\n  depth?: number\n  disableTransaction?: boolean\n  id: number | string\n  overrideAccess?: boolean\n  overrideLock?: boolean\n  populate?: PopulateType\n  req: PayloadRequest\n  showHiddenFields?: boolean\n  trash?: boolean\n} & Pick<FindOptions<TSlug, TSelect>, 'select'>\n\nexport const deleteByIDOperation = async <TSlug extends CollectionSlug, TSelect extends SelectType>(\n  incomingArgs: Arguments<TSlug, TSelect>,\n): Promise<TransformCollectionWithSelect<TSlug, TSelect>> => {\n  let args = incomingArgs\n\n  try {\n    const shouldCommit = !args.disableTransaction && (await initTransaction(args.req))\n\n    // /////////////////////////////////////\n    // beforeOperation - Collection\n    // /////////////////////////////////////\n\n    args = await buildBeforeOperation({\n      args,\n      collection: args.collection.config,\n      operation: 'delete',\n      overrideAccess: args.overrideAccess!,\n    })\n\n    const {\n      id,\n      collection: { config: collectionConfig },\n      depth,\n      overrideAccess,\n      overrideLock,\n      populate,\n      req: {\n        fallbackLocale,\n        locale,\n        payload: { config },\n        payload,\n      },\n      req,\n      select: incomingSelect,\n      showHiddenFields,\n      trash = false,\n    } = args\n\n    // /////////////////////////////////////\n    // Access\n    // /////////////////////////////////////\n\n    const accessResults = !overrideAccess\n      ? await executeAccess({ id, req }, collectionConfig.access.delete)\n      : true\n    const hasWhereAccess = hasWhereAccessResult(accessResults)\n\n    // /////////////////////////////////////\n    // beforeDelete - Collection\n    // /////////////////////////////////////\n\n    if (collectionConfig.hooks?.beforeDelete?.length) {\n      for (const hook of collectionConfig.hooks.beforeDelete) {\n        await hook({\n          id,\n          collection: collectionConfig,\n          context: req.context,\n          req,\n        })\n      }\n    }\n\n    // /////////////////////////////////////\n    // Retrieve document\n    // /////////////////////////////////////\n\n    let where = combineQueries({ id: { equals: id } }, accessResults)\n\n    // Exclude trashed documents when trash: false\n    where = appendNonTrashedFilter({\n      enableTrash: collectionConfig.trash,\n      trash,\n      where,\n    })\n\n    const docToDelete = await req.payload.db.findOne({\n      collection: collectionConfig.slug,\n      locale: req.locale!,\n      req,\n      where,\n    })\n\n    if (!docToDelete && !hasWhereAccess) {\n      throw new NotFound(req.t)\n    }\n    if (!docToDelete && hasWhereAccess) {\n      throw new Forbidden(req.t)\n    }\n\n    // /////////////////////////////////////\n    // Handle potentially locked documents\n    // /////////////////////////////////////\n\n    await checkDocumentLockStatus({\n      id,\n      collectionSlug: collectionConfig.slug,\n      lockErrorMessage: `Document with ID ${id} is currently locked and cannot be deleted.`,\n      overrideLock,\n      req,\n    })\n\n    await deleteAssociatedFiles({\n      collectionConfig,\n      config,\n      doc: docToDelete!,\n      overrideDelete: true,\n      req,\n    })\n\n    // /////////////////////////////////////\n    // Delete versions\n    // /////////////////////////////////////\n\n    if (collectionConfig.versions) {\n      await deleteCollectionVersions({\n        id,\n        slug: collectionConfig.slug,\n        payload,\n        req,\n      })\n    }\n\n    // /////////////////////////////////////\n    // Delete scheduled posts\n    // /////////////////////////////////////\n    if (hasScheduledPublishEnabled(collectionConfig)) {\n      await deleteScheduledPublishJobs({\n        id,\n        slug: collectionConfig.slug,\n        payload,\n        req,\n      })\n    }\n\n    const select = sanitizeSelect({\n      fields: collectionConfig.flattenedFields,\n      forceSelect: collectionConfig.forceSelect,\n      select: incomingSelect,\n    })\n\n    // /////////////////////////////////////\n    // Delete document\n    // /////////////////////////////////////\n\n    let result: DataFromCollectionSlug<TSlug> = await req.payload.db.deleteOne({\n      collection: collectionConfig.slug,\n      req,\n      select,\n      where: { id: { equals: id } },\n    })\n\n    // /////////////////////////////////////\n    // Delete Preferences\n    // /////////////////////////////////////\n\n    await deleteUserPreferences({\n      collectionConfig,\n      ids: [id],\n      payload,\n      req,\n    })\n\n    // /////////////////////////////////////\n    // afterRead - Fields\n    // /////////////////////////////////////\n\n    result = await afterRead({\n      collection: collectionConfig,\n      context: req.context,\n      depth: depth!,\n      doc: result,\n      draft: undefined!,\n      fallbackLocale: fallbackLocale!,\n      global: null,\n      locale: locale!,\n      overrideAccess: overrideAccess!,\n      populate,\n      req,\n      select,\n      showHiddenFields: showHiddenFields!,\n    })\n\n    // /////////////////////////////////////\n    // afterRead - Collection\n    // /////////////////////////////////////\n\n    if (collectionConfig.hooks?.afterRead?.length) {\n      for (const hook of collectionConfig.hooks.afterRead) {\n        result =\n          (await hook({\n            collection: collectionConfig,\n            context: req.context,\n            doc: result,\n            overrideAccess,\n            req,\n          })) || result\n      }\n    }\n\n    // /////////////////////////////////////\n    // afterDelete - Collection\n    // /////////////////////////////////////\n\n    if (collectionConfig.hooks?.afterDelete?.length) {\n      for (const hook of collectionConfig.hooks.afterDelete) {\n        result =\n          (await hook({\n            id,\n            collection: collectionConfig,\n            context: req.context,\n            doc: result,\n            req,\n          })) || result\n      }\n    }\n\n    // /////////////////////////////////////\n    // afterOperation - Collection\n    // /////////////////////////////////////\n\n    result = await buildAfterOperation({\n      args,\n      collection: collectionConfig,\n      operation: 'deleteByID',\n      overrideAccess,\n      result,\n    })\n\n    // /////////////////////////////////////\n    // 8. Return results\n    // /////////////////////////////////////\n\n    if (shouldCommit) {\n      await commitTransaction(req)\n    }\n\n    return result as TransformCollectionWithSelect<TSlug, TSelect>\n  } catch (error: unknown) {\n    await killTransaction(args.req)\n    throw error\n  }\n}\n"],"names":["executeAccess","hasWhereAccessResult","combineQueries","Forbidden","NotFound","afterRead","deleteUserPreferences","deleteAssociatedFiles","appendNonTrashedFilter","checkDocumentLockStatus","commitTransaction","hasScheduledPublishEnabled","initTransaction","killTransaction","sanitizeSelect","deleteCollectionVersions","deleteScheduledPublishJobs","buildAfterOperation","buildBeforeOperation","deleteByIDOperation","incomingArgs","args","shouldCommit","disableTransaction","req","collection","config","operation","overrideAccess","id","collectionConfig","depth","overrideLock","populate","fallbackLocale","locale","payload","select","incomingSelect","showHiddenFields","trash","accessResults","access","delete","hasWhereAccess","hooks","beforeDelete","length","hook","context","where","equals","enableTrash","docToDelete","db","findOne","slug","t","collectionSlug","lockErrorMessage","doc","overrideDelete","versions","fields","flattenedFields","forceSelect","result","deleteOne","ids","draft","undefined","global","afterDelete","error"],"mappings":"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"}},
    {"offset": {"line": 1323, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/collections/operations/local/delete.ts"],"sourcesContent":["import type {\n  CollectionSlug,\n  FindOptions,\n  Payload,\n  RequestContext,\n  TypedLocale,\n} from '../../../index.js'\nimport type {\n  Document,\n  PayloadRequest,\n  PopulateType,\n  SelectType,\n  TransformCollectionWithSelect,\n  Where,\n} from '../../../types/index.js'\nimport type { CreateLocalReqOptions } from '../../../utilities/createLocalReq.js'\nimport type { BulkOperationResult, SelectFromCollectionSlug } from '../../config/types.js'\n\nimport { APIError } from '../../../errors/index.js'\nimport { createLocalReq } from '../../../utilities/createLocalReq.js'\nimport { deleteOperation } from '../delete.js'\nimport { deleteByIDOperation } from '../deleteByID.js'\n\nexport type BaseOptions<TSlug extends CollectionSlug, TSelect extends SelectType> = {\n  /**\n   * the Collection slug to operate against.\n   */\n  collection: TSlug\n  /**\n   * [Context](https://payloadcms.com/docs/hooks/context), which will then be passed to `context` and `req.context`,\n   * which can be read by hooks. Useful if you want to pass additional information to the hooks which\n   * shouldn't be necessarily part of the document, for example a `triggerBeforeChange` option which can be read by the BeforeChange hook\n   * to determine if it should run or not.\n   */\n  context?: RequestContext\n  /**\n   * [Control auto-population](https://payloadcms.com/docs/queries/depth) of nested relationship and upload fields.\n   */\n  depth?: number\n  /**\n   * When set to `true`, a [database transactions](https://payloadcms.com/docs/database/transactions) will not be initialized.\n   * @default false\n   */\n  disableTransaction?: boolean\n  /**\n   * Specify a [fallback locale](https://payloadcms.com/docs/configuration/localization) to use for any returned documents.\n   */\n  fallbackLocale?: false | TypedLocale\n  /**\n   * Specify [locale](https://payloadcms.com/docs/configuration/localization) for any returned documents.\n   */\n  locale?: TypedLocale\n  /**\n   * Skip access control.\n   * Set to `false` if you want to respect Access Control for the operation, for example when fetching data for the front-end.\n   * @default true\n   */\n  overrideAccess?: boolean\n  /**\n   * By default, document locks are ignored (`true`). Set to `false` to enforce locks and prevent operations when a document is locked by another user. [More details](https://payloadcms.com/docs/admin/locked-documents).\n   * @default true\n   */\n  overrideLock?: boolean\n  /**\n   * Specify [populate](https://payloadcms.com/docs/queries/select#populate) to control which fields to include to the result from populated documents.\n   */\n  populate?: PopulateType\n  /**\n   * The `PayloadRequest` object. You can pass it to thread the current [transaction](https://payloadcms.com/docs/database/transactions), user and locale to the operation.\n   * Recommended to pass when using the Local API from hooks, as usually you want to execute the operation within the current transaction.\n   */\n  req?: Partial<PayloadRequest>\n  /**\n   * Opt-in to receiving hidden fields. By default, they are hidden from returned documents in accordance to your config.\n   * @default false\n   */\n  showHiddenFields?: boolean\n  /**\n   * When set to `true`, the operation will permanently delete both normal and trashed documents.\n   * By default (`false`), only normal (non-trashed) documents will be permanently deleted.\n   *\n   * This argument has no effect unless `trash` is enabled on the collection.\n   * @default false\n   */\n  trash?: boolean\n  /**\n   * If you set `overrideAccess` to `false`, you can pass a user to use against the access control checks.\n   */\n  user?: Document\n} & Pick<FindOptions<TSlug, TSelect>, 'select'>\n\nexport type ByIDOptions<\n  TSlug extends CollectionSlug,\n  TSelect extends SelectFromCollectionSlug<TSlug>,\n> = {\n  /**\n   * The ID of the document to delete.\n   */\n  id: number | string\n  /**\n   * A filter [query](https://payloadcms.com/docs/queries/overview)\n   */\n  where?: never\n} & BaseOptions<TSlug, TSelect>\n\nexport type ManyOptions<\n  TSlug extends CollectionSlug,\n  TSelect extends SelectFromCollectionSlug<TSlug>,\n> = {\n  /**\n   * The ID of the document to delete.\n   */\n  id?: never\n  /**\n   * A filter [query](https://payloadcms.com/docs/queries/overview)\n   */\n  where: Where\n} & BaseOptions<TSlug, TSelect>\n\nexport type Options<\n  TSlug extends CollectionSlug,\n  TSelect extends SelectFromCollectionSlug<TSlug>,\n> = ByIDOptions<TSlug, TSelect> | ManyOptions<TSlug, TSelect>\n\nasync function deleteLocal<\n  TSlug extends CollectionSlug,\n  TSelect extends SelectFromCollectionSlug<TSlug>,\n>(\n  payload: Payload,\n  options: ByIDOptions<TSlug, TSelect>,\n): Promise<TransformCollectionWithSelect<TSlug, TSelect>>\nasync function deleteLocal<\n  TSlug extends CollectionSlug,\n  TSelect extends SelectFromCollectionSlug<TSlug>,\n>(\n  payload: Payload,\n  options: ManyOptions<TSlug, TSelect>,\n): Promise<BulkOperationResult<TSlug, TSelect>>\nasync function deleteLocal<\n  TSlug extends CollectionSlug,\n  TSelect extends SelectFromCollectionSlug<TSlug>,\n>(\n  payload: Payload,\n  options: Options<TSlug, TSelect>,\n): Promise<BulkOperationResult<TSlug, TSelect> | TransformCollectionWithSelect<TSlug, TSelect>>\nasync function deleteLocal<\n  TSlug extends CollectionSlug,\n  TSelect extends SelectFromCollectionSlug<TSlug>,\n>(\n  payload: Payload,\n  options: Options<TSlug, TSelect>,\n): Promise<BulkOperationResult<TSlug, TSelect> | TransformCollectionWithSelect<TSlug, TSelect>> {\n  const {\n    id,\n    collection: collectionSlug,\n    depth,\n    disableTransaction,\n    overrideAccess = true,\n    overrideLock,\n    populate,\n    select,\n    showHiddenFields,\n    trash = false,\n    where,\n  } = options\n\n  const collection = payload.collections[collectionSlug]\n\n  if (!collection) {\n    throw new APIError(\n      `The collection with slug ${String(collectionSlug)} can't be found. Delete Operation.`,\n    )\n  }\n\n  const args = {\n    id,\n    collection,\n    depth,\n    disableTransaction,\n    overrideAccess,\n    overrideLock,\n    populate,\n    req: await createLocalReq(options as CreateLocalReqOptions, payload),\n    select,\n    showHiddenFields,\n    trash,\n    where,\n  }\n\n  if (options.id) {\n    // @ts-expect-error - vestiges of when tsconfig was not strict. Feel free to improve\n    return deleteByIDOperation<TSlug, TSelect>(args)\n  }\n  // @ts-expect-error - vestiges of when tsconfig was not strict. Feel free to improve\n  return deleteOperation<TSlug, TSelect>(args)\n}\n\nexport { deleteLocal }\n"],"names":["APIError","createLocalReq","deleteOperation","deleteByIDOperation","deleteLocal","payload","options","id","collection","collectionSlug","depth","disableTransaction","overrideAccess","overrideLock","populate","select","showHiddenFields","trash","where","collections","String","args","req"],"mappings":";;;;AAkBA,SAASA,QAAQ,QAAQ,2BAA0B;AACnD,SAASC,cAAc,QAAQ,uCAAsC;AACrE,SAASC,eAAe,QAAQ,eAAc;AAC9C,SAASC,mBAAmB,QAAQ,mBAAkB;;;;;AA4HtD,eAAeC,YAIbC,OAAgB,EAChBC,OAAgC;IAEhC,MAAM,EACJC,EAAE,EACFC,YAAYC,cAAc,EAC1BC,KAAK,EACLC,kBAAkB,EAClBC,iBAAiB,IAAI,EACrBC,YAAY,EACZC,QAAQ,EACRC,MAAM,EACNC,gBAAgB,EAChBC,QAAQ,KAAK,EACbC,KAAK,EACN,GAAGZ;IAEJ,MAAME,aAAaH,QAAQc,WAAW,CAACV,eAAe;IAEtD,IAAI,CAACD,YAAY;QACf,MAAM,IAAIR,mKAAAA,CACR,CAAC,yBAAyB,EAAEoB,OAAOX,gBAAgB,kCAAkC,CAAC;IAE1F;IAEA,MAAMY,OAAO;QACXd;QACAC;QACAE;QACAC;QACAC;QACAC;QACAC;QACAQ,KAAK,UAAMrB,kLAAAA,EAAeK,SAAkCD;QAC5DU;QACAC;QACAC;QACAC;IACF;IAEA,IAAIZ,QAAQC,EAAE,EAAE;QACd,oFAAoF;QACpF,WAAOJ,mMAAAA,EAAoCkB;IAC7C;IACA,oFAAoF;IACpF,WAAOnB,2LAAAA,EAAgCmB;AACzC"}},
    {"offset": {"line": 1368, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/collections/operations/duplicate.ts"],"sourcesContent":["import type { DeepPartial } from 'ts-essentials'\n\nimport type { CollectionSlug } from '../../index.js'\nimport type { TransformCollectionWithSelect } from '../../types/index.js'\nimport type { RequiredDataFromCollectionSlug, SelectFromCollectionSlug } from '../config/types.js'\n\nimport { type Arguments as CreateArguments, createOperation } from './create.js'\n\nexport type Arguments<TSlug extends CollectionSlug> = {\n  data?: DeepPartial<RequiredDataFromCollectionSlug<TSlug>>\n  id: number | string\n} & Omit<CreateArguments<TSlug>, 'data' | 'duplicateFromID'>\n\nexport const duplicateOperation = async <\n  TSlug extends CollectionSlug,\n  TSelect extends SelectFromCollectionSlug<TSlug>,\n>(\n  incomingArgs: Arguments<TSlug>,\n): Promise<TransformCollectionWithSelect<TSlug, TSelect>> => {\n  const { id, ...args } = incomingArgs\n  return createOperation({\n    ...args,\n    data: incomingArgs?.data || {},\n    duplicateFromID: id,\n  })\n}\n"],"names":["createOperation","duplicateOperation","incomingArgs","id","args","data","duplicateFromID"],"mappings":";;;;AAMA,SAA4CA,eAAe,QAAQ,cAAa;;AAOzE,MAAMC,qBAAqB,OAIhCC;IAEA,MAAM,EAAEC,EAAE,EAAE,GAAGC,MAAM,GAAGF;IACxB,WAAOF,2LAAAA,EAAgB;QACrB,GAAGI,IAAI;QACPC,MAAMH,cAAcG,QAAQ,CAAC;QAC7BC,iBAAiBH;IACnB;AACF,EAAC"}},
    {"offset": {"line": 1386, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/collections/operations/local/duplicate.ts"],"sourcesContent":["import type { DeepPartial } from 'ts-essentials'\n\nimport type { CollectionSlug, TypedLocale } from '../../..//index.js'\nimport type { FindOptions, Payload, RequestContext } from '../../../index.js'\nimport type {\n  Document,\n  PayloadRequest,\n  PopulateType,\n  SelectType,\n  TransformCollectionWithSelect,\n} from '../../../types/index.js'\nimport type { CreateLocalReqOptions } from '../../../utilities/createLocalReq.js'\nimport type {\n  DraftFlagFromCollectionSlug,\n  RequiredDataFromCollectionSlug,\n  SelectFromCollectionSlug,\n} from '../../config/types.js'\n\nimport { APIError } from '../../../errors/index.js'\nimport { createLocalReq } from '../../../utilities/createLocalReq.js'\nimport { duplicateOperation } from '../duplicate.js'\n\ntype BaseOptions<TSlug extends CollectionSlug, TSelect extends SelectType> = {\n  /**\n   * the Collection slug to operate against.\n   */\n  collection: TSlug\n  /**\n   * [Context](https://payloadcms.com/docs/hooks/context), which will then be passed to `context` and `req.context`,\n   * which can be read by hooks. Useful if you want to pass additional information to the hooks which\n   * shouldn't be necessarily part of the document, for example a `triggerBeforeChange` option which can be read by the BeforeChange hook\n   * to determine if it should run or not.\n   */\n  context?: RequestContext\n  /**\n   * Override the data for the document to duplicate.\n   */\n  data?: DeepPartial<RequiredDataFromCollectionSlug<TSlug>>\n  /**\n   * [Control auto-population](https://payloadcms.com/docs/queries/depth) of nested relationship and upload fields.\n   */\n  depth?: number\n  /**\n   * When set to `true`, a [database transactions](https://payloadcms.com/docs/database/transactions) will not be initialized.\n   * @default false\n   */\n  disableTransaction?: boolean\n  /**\n   * Specify a [fallback locale](https://payloadcms.com/docs/configuration/localization) to use for any returned documents.\n   */\n  fallbackLocale?: false | TypedLocale\n  /**\n   * The ID of the document to duplicate from.\n   */\n  id: number | string\n  /**\n   * Specify [locale](https://payloadcms.com/docs/configuration/localization) for any returned documents.\n   */\n  locale?: TypedLocale\n  /**\n   * Skip access control.\n   * Set to `false` if you want to respect Access Control for the operation, for example when fetching data for the front-end.\n   * @default true\n   */\n  overrideAccess?: boolean\n  /**\n   * Specify [populate](https://payloadcms.com/docs/queries/select#populate) to control which fields to include to the result from populated documents.\n   */\n  populate?: PopulateType\n  /**\n   * The `PayloadRequest` object. You can pass it to thread the current [transaction](https://payloadcms.com/docs/database/transactions), user and locale to the operation.\n   * Recommended to pass when using the Local API from hooks, as usually you want to execute the operation within the current transaction.\n   */\n  req?: Partial<PayloadRequest>\n  /**\n   * Specifies which locales to include when duplicating localized fields. Non-localized data is always duplicated.\n   * By default, all locales are duplicated.\n   */\n  selectedLocales?: string[]\n  /**\n   * Opt-in to receiving hidden fields. By default, they are hidden from returned documents in accordance to your config.\n   * @default false\n   */\n  showHiddenFields?: boolean\n  /**\n   * If you set `overrideAccess` to `false`, you can pass a user to use against the access control checks.\n   */\n  user?: Document\n} & Pick<FindOptions<TSlug, TSelect>, 'select'>\n\nexport type Options<TSlug extends CollectionSlug, TSelect extends SelectType> =\n  BaseOptions<TSlug, TSelect> & DraftFlagFromCollectionSlug<TSlug>\n\nexport async function duplicateLocal<\n  TSlug extends CollectionSlug,\n  TSelect extends SelectFromCollectionSlug<TSlug>,\n>(\n  payload: Payload,\n  options: Options<TSlug, TSelect>,\n): Promise<TransformCollectionWithSelect<TSlug, TSelect>> {\n  const {\n    id,\n    collection: collectionSlug,\n    data,\n    depth,\n    disableTransaction,\n    draft,\n    overrideAccess = true,\n    populate,\n    select,\n    selectedLocales,\n    showHiddenFields,\n  } = options\n\n  const collection = payload.collections[collectionSlug]\n\n  if (!collection) {\n    throw new APIError(\n      `The collection with slug ${String(collectionSlug)} can't be found. Duplicate Operation.`,\n    )\n  }\n\n  if (collection.config.disableDuplicate === true) {\n    throw new APIError(\n      `The collection with slug ${String(collectionSlug)} cannot be duplicated.`,\n      400,\n    )\n  }\n\n  const req = await createLocalReq(options as CreateLocalReqOptions, payload)\n\n  return duplicateOperation<TSlug, TSelect>({\n    id,\n    collection,\n    data,\n    depth,\n    disableTransaction,\n    draft,\n    overrideAccess,\n    populate,\n    req,\n    select,\n    selectedLocales,\n    showHiddenFields,\n  })\n}\n"],"names":["APIError","createLocalReq","duplicateOperation","duplicateLocal","payload","options","id","collection","collectionSlug","data","depth","disableTransaction","draft","overrideAccess","populate","select","selectedLocales","showHiddenFields","collections","String","config","disableDuplicate","req"],"mappings":";;;;AAkBA,SAASA,QAAQ,QAAQ,2BAA0B;AACnD,SAASC,cAAc,QAAQ,uCAAsC;AACrE,SAASC,kBAAkB,QAAQ,kBAAiB;;;;AAyE7C,eAAeC,eAIpBC,OAAgB,EAChBC,OAAgC;IAEhC,MAAM,EACJC,EAAE,EACFC,YAAYC,cAAc,EAC1BC,IAAI,EACJC,KAAK,EACLC,kBAAkB,EAClBC,KAAK,EACLC,iBAAiB,IAAI,EACrBC,QAAQ,EACRC,MAAM,EACNC,eAAe,EACfC,gBAAgB,EACjB,GAAGZ;IAEJ,MAAME,aAAaH,QAAQc,WAAW,CAACV,eAAe;IAEtD,IAAI,CAACD,YAAY;QACf,MAAM,IAAIP,mKAAAA,CACR,CAAC,yBAAyB,EAAEmB,OAAOX,gBAAgB,qCAAqC,CAAC;IAE7F;IAEA,IAAID,WAAWa,MAAM,CAACC,gBAAgB,KAAK,MAAM;QAC/C,MAAM,IAAIrB,mKAAAA,CACR,CAAC,yBAAyB,EAAEmB,OAAOX,gBAAgB,sBAAsB,CAAC,EAC1E;IAEJ;IAEA,MAAMc,MAAM,UAAMrB,kLAAAA,EAAeI,SAAkCD;IAEnE,WAAOF,iMAAAA,EAAmC;QACxCI;QACAC;QACAE;QACAC;QACAC;QACAC;QACAC;QACAC;QACAQ;QACAP;QACAC;QACAC;IACF;AACF"}},
    {"offset": {"line": 1425, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/collections/operations/utilities/sanitizeSortQuery.ts"],"sourcesContent":["import type { FlattenedField } from '../../../fields/config/types.js'\n\nconst sanitizeSort = ({ fields, sort }: { fields: FlattenedField[]; sort: string }): string => {\n  let sortProperty = sort\n  let desc = false\n  if (sort.indexOf('-') === 0) {\n    desc = true\n    sortProperty = sortProperty.substring(1)\n  }\n\n  const segments = sortProperty.split('.')\n\n  for (const segment of segments) {\n    const field = fields.find((each) => each.name === segment)\n    if (!field) {\n      return sort\n    }\n\n    if ('fields' in field) {\n      fields = field.flattenedFields\n      continue\n    }\n\n    if ('virtual' in field && typeof field.virtual === 'string') {\n      return `${desc ? '-' : ''}${field.virtual}`\n    }\n  }\n\n  return sort\n}\n\n/**\n * Sanitizes the sort parameter, for example virtual fields linked to relationships are replaced with the full path.\n */\nexport const sanitizeSortQuery = ({\n  fields,\n  sort,\n}: {\n  fields: FlattenedField[]\n  sort?: string | string[]\n}): string | string[] | undefined => {\n  if (!sort) {\n    return undefined\n  }\n\n  if (Array.isArray(sort)) {\n    return sort.map((sort) => sanitizeSort({ fields, sort }))\n  }\n\n  return sanitizeSort({ fields, sort })\n}\n"],"names":["sanitizeSort","fields","sort","sortProperty","desc","indexOf","substring","segments","split","segment","field","find","each","name","flattenedFields","virtual","sanitizeSortQuery","undefined","Array","isArray","map"],"mappings":";;;;AAEA,MAAMA,eAAe,CAAC,EAAEC,MAAM,EAAEC,IAAI,EAA8C;IAChF,IAAIC,eAAeD;IACnB,IAAIE,OAAO;IACX,IAAIF,KAAKG,OAAO,CAAC,SAAS,GAAG;QAC3BD,OAAO;QACPD,eAAeA,aAAaG,SAAS,CAAC;IACxC;IAEA,MAAMC,WAAWJ,aAAaK,KAAK,CAAC;IAEpC,KAAK,MAAMC,WAAWF,SAAU;QAC9B,MAAMG,QAAQT,OAAOU,IAAI,CAAC,CAACC,OAASA,KAAKC,IAAI,KAAKJ;QAClD,IAAI,CAACC,OAAO;YACV,OAAOR;QACT;QAEA,IAAI,YAAYQ,OAAO;YACrBT,SAASS,MAAMI,eAAe;YAC9B;QACF;QAEA,IAAI,aAAaJ,SAAS,OAAOA,MAAMK,OAAO,KAAK,UAAU;YAC3D,OAAO,GAAGX,OAAO,MAAM,KAAKM,MAAMK,OAAO,EAAE;QAC7C;IACF;IAEA,OAAOb;AACT;AAKO,MAAMc,oBAAoB,CAAC,EAChCf,MAAM,EACNC,IAAI,EAIL;IACC,IAAI,CAACA,MAAM;QACT,OAAOe;IACT;IAEA,IAAIC,MAAMC,OAAO,CAACjB,OAAO;QACvB,OAAOA,KAAKkB,GAAG,CAAC,CAAClB,OAASF,aAAa;gBAAEC;gBAAQC;YAAK;IACxD;IAEA,OAAOF,aAAa;QAAEC;QAAQC;IAAK;AACrC,EAAC"}},
    {"offset": {"line": 1471, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/collections/operations/find.ts"],"sourcesContent":["import type { AccessResult } from '../../config/types.js'\nimport type { PaginatedDocs } from '../../database/types.js'\nimport type { CollectionSlug, FindOptions, JoinQuery } from '../../index.js'\nimport type {\n  PayloadRequest,\n  PopulateType,\n  SelectType,\n  Sort,\n  TransformCollectionWithSelect,\n  Where,\n} from '../../types/index.js'\nimport type {\n  Collection,\n  DataFromCollectionSlug,\n  SelectFromCollectionSlug,\n} from '../config/types.js'\n\nimport { executeAccess } from '../../auth/executeAccess.js'\nimport { combineQueries } from '../../database/combineQueries.js'\nimport { validateQueryPaths } from '../../database/queryValidation/validateQueryPaths.js'\nimport { sanitizeJoinQuery } from '../../database/sanitizeJoinQuery.js'\nimport { sanitizeWhereQuery } from '../../database/sanitizeWhereQuery.js'\nimport { afterRead } from '../../fields/hooks/afterRead/index.js'\nimport { lockedDocumentsCollectionSlug } from '../../locked-documents/config.js'\nimport { appendNonTrashedFilter } from '../../utilities/appendNonTrashedFilter.js'\nimport { hasDraftsEnabled } from '../../utilities/getVersionsConfig.js'\nimport { killTransaction } from '../../utilities/killTransaction.js'\nimport { sanitizeSelect } from '../../utilities/sanitizeSelect.js'\nimport { buildVersionCollectionFields } from '../../versions/buildCollectionFields.js'\nimport { appendVersionToQueryKey } from '../../versions/drafts/appendVersionToQueryKey.js'\nimport { getQueryDraftsSelect } from '../../versions/drafts/getQueryDraftsSelect.js'\nimport { getQueryDraftsSort } from '../../versions/drafts/getQueryDraftsSort.js'\nimport { buildAfterOperation } from './utilities/buildAfterOperation.js'\nimport { buildBeforeOperation } from './utilities/buildBeforeOperation.js'\nimport { sanitizeSortQuery } from './utilities/sanitizeSortQuery.js'\n\nexport type Arguments = {\n  collection: Collection\n  currentDepth?: number\n  depth?: number\n  disableErrors?: boolean\n  draft?: boolean\n  includeLockStatus?: boolean\n  joins?: JoinQuery\n  limit?: number\n  overrideAccess?: boolean\n  page?: number\n  pagination?: boolean\n  populate?: PopulateType\n  req?: PayloadRequest\n  showHiddenFields?: boolean\n  sort?: Sort\n  trash?: boolean\n  where?: Where\n} & Pick<FindOptions<string, SelectType>, 'select'>\n\nconst lockDurationDefault = 300 // Default 5 minutes in seconds\n\nexport const findOperation = async <\n  TSlug extends CollectionSlug,\n  TSelect extends SelectFromCollectionSlug<TSlug>,\n>(\n  incomingArgs: Arguments,\n): Promise<PaginatedDocs<TransformCollectionWithSelect<TSlug, TSelect>>> => {\n  let args = incomingArgs\n\n  try {\n    // /////////////////////////////////////\n    // beforeOperation - Collection\n    // /////////////////////////////////////\n\n    args = await buildBeforeOperation({\n      args,\n      collection: args.collection.config,\n      operation: 'read',\n      overrideAccess: args.overrideAccess!,\n    })\n\n    const {\n      collection: { config: collectionConfig },\n      collection,\n      currentDepth,\n      depth,\n      disableErrors,\n      draft: draftsEnabled,\n      includeLockStatus: includeLockStatusFromArgs,\n      joins,\n      limit,\n      overrideAccess,\n      page,\n      pagination = true,\n      populate,\n      select: incomingSelect,\n      showHiddenFields,\n      sort: incomingSort,\n      trash = false,\n      where,\n    } = args\n\n    const req = args.req!\n\n    const includeLockStatus =\n      includeLockStatusFromArgs && req.payload.collections?.[lockedDocumentsCollectionSlug]\n\n    const { fallbackLocale, locale, payload } = req\n\n    const select = sanitizeSelect({\n      fields: collectionConfig.flattenedFields,\n      forceSelect: collectionConfig.forceSelect,\n      select: incomingSelect,\n    })\n\n    // /////////////////////////////////////\n    // Access\n    // /////////////////////////////////////\n\n    let accessResult: AccessResult\n\n    if (!overrideAccess) {\n      accessResult = await executeAccess({ disableErrors, req }, collectionConfig.access.read)\n\n      // If errors are disabled, and access returns false, return empty results\n      if (accessResult === false) {\n        return {\n          docs: [],\n          hasNextPage: false,\n          hasPrevPage: false,\n          limit: limit!,\n          nextPage: null,\n          page: 1,\n          pagingCounter: 1,\n          prevPage: null,\n          totalDocs: 0,\n          totalPages: 1,\n        }\n      }\n    }\n\n    // /////////////////////////////////////\n    // Find\n    // /////////////////////////////////////\n\n    const usePagination = pagination && limit !== 0\n    const sanitizedLimit = limit ?? (usePagination ? 10 : 0)\n    const sanitizedPage = page || 1\n\n    let result: PaginatedDocs<DataFromCollectionSlug<TSlug>>\n\n    let fullWhere = combineQueries(where!, accessResult!)\n    sanitizeWhereQuery({ fields: collectionConfig.flattenedFields, payload, where: fullWhere })\n\n    // Exclude trashed documents when trash: false\n    fullWhere = appendNonTrashedFilter({\n      enableTrash: collectionConfig.trash,\n      trash,\n      where: fullWhere,\n    })\n\n    const sort = sanitizeSortQuery({\n      fields: collection.config.flattenedFields,\n      sort: incomingSort,\n    })\n\n    const sanitizedJoins = await sanitizeJoinQuery({\n      collectionConfig,\n      joins,\n      overrideAccess: overrideAccess!,\n      req,\n    })\n\n    if (hasDraftsEnabled(collectionConfig) && draftsEnabled) {\n      fullWhere = appendVersionToQueryKey(fullWhere)\n\n      await validateQueryPaths({\n        collectionConfig: collection.config,\n        overrideAccess: overrideAccess!,\n        req,\n        versionFields: buildVersionCollectionFields(payload.config, collection.config, true),\n        where: appendVersionToQueryKey(where),\n      })\n\n      result = await payload.db.queryDrafts<DataFromCollectionSlug<TSlug>>({\n        collection: collectionConfig.slug,\n        joins: req.payloadAPI === 'GraphQL' ? false : sanitizedJoins,\n        limit: sanitizedLimit,\n        locale: locale!,\n        page: sanitizedPage,\n        pagination: usePagination,\n        req,\n        select: getQueryDraftsSelect({ select }),\n        sort: getQueryDraftsSort({\n          collectionConfig,\n          sort,\n        }),\n        where: fullWhere,\n      })\n    } else {\n      await validateQueryPaths({\n        collectionConfig,\n        overrideAccess: overrideAccess!,\n        req,\n        where: where!,\n      })\n\n      result = await payload.db.find<DataFromCollectionSlug<TSlug>>({\n        collection: collectionConfig.slug,\n        draftsEnabled,\n        joins: req.payloadAPI === 'GraphQL' ? false : sanitizedJoins,\n        limit: sanitizedLimit,\n        locale: locale!,\n        page: sanitizedPage,\n        pagination,\n        req,\n        select,\n        sort,\n        where: fullWhere,\n      })\n    }\n\n    if (includeLockStatus) {\n      try {\n        const lockDocumentsProp = collectionConfig?.lockDocuments\n\n        const lockDuration =\n          typeof lockDocumentsProp === 'object' ? lockDocumentsProp.duration : lockDurationDefault\n        const lockDurationInMilliseconds = lockDuration * 1000\n\n        const now = new Date().getTime()\n\n        const lockedDocuments = await payload.find({\n          collection: lockedDocumentsCollectionSlug,\n          depth: 1,\n          limit: sanitizedLimit,\n          overrideAccess: false,\n          pagination: false,\n          req,\n          where: {\n            and: [\n              {\n                'document.relationTo': {\n                  equals: collectionConfig.slug,\n                },\n              },\n              {\n                'document.value': {\n                  in: result.docs.map((doc) => doc.id),\n                },\n              },\n              // Query where the lock is newer than the current time minus lock time\n              {\n                updatedAt: {\n                  greater_than: new Date(now - lockDurationInMilliseconds),\n                },\n              },\n            ],\n          },\n        })\n\n        const lockedDocs = Array.isArray(lockedDocuments?.docs) ? lockedDocuments.docs : []\n\n        // Filter out stale locks\n        const validLockedDocs = lockedDocs.filter((lock) => {\n          const lastEditedAt = new Date(lock?.updatedAt).getTime()\n          return lastEditedAt + lockDurationInMilliseconds > now\n        })\n\n        for (const doc of result.docs) {\n          const lockedDoc = validLockedDocs.find((lock) => lock?.document?.value === doc.id)\n          doc._isLocked = !!lockedDoc\n          doc._userEditing = lockedDoc ? lockedDoc?.user?.value : null\n        }\n      } catch (_err) {\n        for (const doc of result.docs) {\n          doc._isLocked = false\n          doc._userEditing = null\n        }\n      }\n    }\n\n    // /////////////////////////////////////\n    // beforeRead - Collection\n    // /////////////////////////////////////\n\n    if (collectionConfig?.hooks?.beforeRead?.length) {\n      result.docs = await Promise.all(\n        result.docs.map(async (doc) => {\n          let docRef = doc\n\n          for (const hook of collectionConfig.hooks.beforeRead) {\n            docRef =\n              (await hook({\n                collection: collectionConfig,\n                context: req.context,\n                doc: docRef,\n                overrideAccess: overrideAccess!,\n                query: fullWhere,\n                req,\n              })) || docRef\n          }\n\n          return docRef\n        }),\n      )\n    }\n\n    // /////////////////////////////////////\n    // afterRead - Fields\n    // /////////////////////////////////////\n\n    result.docs = await Promise.all(\n      result.docs.map(async (doc) =>\n        afterRead<DataFromCollectionSlug<TSlug>>({\n          collection: collectionConfig,\n          context: req.context,\n          currentDepth,\n          depth: depth!,\n          doc,\n          draft: draftsEnabled!,\n          fallbackLocale: fallbackLocale!,\n          findMany: true,\n          global: null,\n          locale: locale!,\n          overrideAccess: overrideAccess!,\n          populate,\n          req,\n          select,\n          showHiddenFields: showHiddenFields!,\n        }),\n      ),\n    )\n\n    // /////////////////////////////////////\n    // afterRead - Collection\n    // /////////////////////////////////////\n\n    if (collectionConfig?.hooks?.afterRead?.length) {\n      result.docs = await Promise.all(\n        result.docs.map(async (doc) => {\n          let docRef = doc\n\n          for (const hook of collectionConfig.hooks.afterRead) {\n            docRef =\n              (await hook({\n                collection: collectionConfig,\n                context: req.context,\n                doc: docRef,\n                findMany: true,\n                overrideAccess: overrideAccess!,\n                query: fullWhere,\n                req,\n              })) || docRef\n          }\n\n          return docRef\n        }),\n      )\n    }\n\n    // /////////////////////////////////////\n    // afterOperation - Collection\n    // /////////////////////////////////////\n\n    result = await buildAfterOperation({\n      args,\n      collection: collectionConfig,\n      operation: 'find',\n      overrideAccess: overrideAccess!,\n      result,\n    })\n\n    // /////////////////////////////////////\n    // Return results\n    // /////////////////////////////////////\n\n    return result as PaginatedDocs<TransformCollectionWithSelect<TSlug, TSelect>>\n  } catch (error: unknown) {\n    await killTransaction(args.req!)\n    throw error\n  }\n}\n"],"names":["executeAccess","combineQueries","validateQueryPaths","sanitizeJoinQuery","sanitizeWhereQuery","afterRead","lockedDocumentsCollectionSlug","appendNonTrashedFilter","hasDraftsEnabled","killTransaction","sanitizeSelect","buildVersionCollectionFields","appendVersionToQueryKey","getQueryDraftsSelect","getQueryDraftsSort","buildAfterOperation","buildBeforeOperation","sanitizeSortQuery","lockDurationDefault","findOperation","incomingArgs","args","collection","config","operation","overrideAccess","collectionConfig","currentDepth","depth","disableErrors","draft","draftsEnabled","includeLockStatus","includeLockStatusFromArgs","joins","limit","page","pagination","populate","select","incomingSelect","showHiddenFields","sort","incomingSort","trash","where","req","payload","collections","fallbackLocale","locale","fields","flattenedFields","forceSelect","accessResult","access","read","docs","hasNextPage","hasPrevPage","nextPage","pagingCounter","prevPage","totalDocs","totalPages","usePagination","sanitizedLimit","sanitizedPage","result","fullWhere","enableTrash","sanitizedJoins","versionFields","db","queryDrafts","slug","payloadAPI","find","lockDocumentsProp","lockDocuments","lockDuration","duration","lockDurationInMilliseconds","now","Date","getTime","lockedDocuments","and","equals","in","map","doc","id","updatedAt","greater_than","lockedDocs","Array","isArray","validLockedDocs","filter","lock","lastEditedAt","lockedDoc","document","value","_isLocked","_userEditing","user","_err","hooks","beforeRead","length","Promise","all","docRef","hook","context","query","findMany","global","error"],"mappings":";;;;AAiBA,SAASA,aAAa,QAAQ,8BAA6B;AAC3D,SAASC,cAAc,QAAQ,mCAAkC;AACjE,SAASC,kBAAkB,QAAQ,uDAAsD;AACzF,SAASC,iBAAiB,QAAQ,sCAAqC;AACvE,SAASC,kBAAkB,QAAQ,uCAAsC;AACzE,SAASC,SAAS,QAAQ,wCAAuC;AACjE,SAASC,6BAA6B,QAAQ,mCAAkC;AAChF,SAASC,sBAAsB,QAAQ,4CAA2C;AAClF,SAASC,gBAAgB,QAAQ,uCAAsC;AACvE,SAASC,eAAe,QAAQ,qCAAoC;AACpE,SAASC,cAAc,QAAQ,oCAAmC;AAClE,SAASC,4BAA4B,QAAQ,0CAAyC;AACtF,SAASC,uBAAuB,QAAQ,mDAAkD;AAC1F,SAASC,oBAAoB,QAAQ,gDAA+C;AACpF,SAASC,kBAAkB,QAAQ,8CAA6C;AAChF,SAASC,mBAAmB,QAAQ,qCAAoC;AACxE,SAASC,oBAAoB,QAAQ,sCAAqC;AAC1E,SAASC,iBAAiB,QAAQ,mCAAkC;;;;;;;;;;;;;;;;;;;AAsBpE,MAAMC,sBAAsB,IAAI,+BAA+B;;AAExD,MAAMC,gBAAgB,OAI3BC;IAEA,IAAIC,OAAOD;IAEX,IAAI;QACF,wCAAwC;QACxC,+BAA+B;QAC/B,wCAAwC;QAExCC,OAAO,UAAML,2NAAAA,EAAqB;YAChCK;YACAC,YAAYD,KAAKC,UAAU,CAACC,MAAM;YAClCC,WAAW;YACXC,gBAAgBJ,KAAKI,cAAc;QACrC;QAEA,MAAM,EACJH,YAAY,EAAEC,QAAQG,gBAAgB,EAAE,EACxCJ,UAAU,EACVK,YAAY,EACZC,KAAK,EACLC,aAAa,EACbC,OAAOC,aAAa,EACpBC,mBAAmBC,yBAAyB,EAC5CC,KAAK,EACLC,KAAK,EACLV,cAAc,EACdW,IAAI,EACJC,aAAa,IAAI,EACjBC,QAAQ,EACRC,QAAQC,cAAc,EACtBC,gBAAgB,EAChBC,MAAMC,YAAY,EAClBC,QAAQ,KAAK,EACbC,KAAK,EACN,GAAGxB;QAEJ,MAAMyB,MAAMzB,KAAKyB,GAAG;QAEpB,MAAMd,oBACJC,6BAA6Ba,IAAIC,OAAO,CAACC,WAAW,EAAE,CAAC1C,mMAAAA,CAA8B;QAEvF,MAAM,EAAE2C,cAAc,EAAEC,MAAM,EAAEH,OAAO,EAAE,GAAGD;QAE5C,MAAMP,aAAS7B,kLAAAA,EAAe;YAC5ByC,QAAQzB,iBAAiB0B,eAAe;YACxCC,aAAa3B,iBAAiB2B,WAAW;YACzCd,QAAQC;QACV;QAEA,wCAAwC;QACxC,SAAS;QACT,wCAAwC;QAExC,IAAIc;QAEJ,IAAI,CAAC7B,gBAAgB;YACnB6B,eAAe,UAAMtD,2KAAAA,EAAc;gBAAE6B;gBAAeiB;YAAI,GAAGpB,iBAAiB6B,MAAM,CAACC,IAAI;YAEvF,yEAAyE;YACzE,IAAIF,iBAAiB,OAAO;gBAC1B,OAAO;oBACLG,MAAM,EAAE;oBACRC,aAAa;oBACbC,aAAa;oBACbxB,OAAOA;oBACPyB,UAAU;oBACVxB,MAAM;oBACNyB,eAAe;oBACfC,UAAU;oBACVC,WAAW;oBACXC,YAAY;gBACd;YACF;QACF;QAEA,wCAAwC;QACxC,OAAO;QACP,wCAAwC;QAExC,MAAMC,gBAAgB5B,cAAcF,UAAU;QAC9C,MAAM+B,iBAAiB/B,SAAU8B,CAAAA,gBAAgB,KAAK,CAAA;QACtD,MAAME,gBAAgB/B,QAAQ;QAE9B,IAAIgC;QAEJ,IAAIC,gBAAYpE,iLAAAA,EAAe4C,OAAQS;YACvClD,yLAAAA,EAAmB;YAAE+C,QAAQzB,iBAAiB0B,eAAe;YAAEL;YAASF,OAAOwB;QAAU;QAEzF,8CAA8C;QAC9CA,gBAAY9D,kMAAAA,EAAuB;YACjC+D,aAAa5C,iBAAiBkB,KAAK;YACnCA;YACAC,OAAOwB;QACT;QAEA,MAAM3B,WAAOzB,qNAAAA,EAAkB;YAC7BkC,QAAQ7B,WAAWC,MAAM,CAAC6B,eAAe;YACzCV,MAAMC;QACR;QAEA,MAAM4B,iBAAiB,UAAMpE,uLAAAA,EAAkB;YAC7CuB;YACAQ;YACAT,gBAAgBA;YAChBqB;QACF;QAEA,QAAItC,uLAAAA,EAAiBkB,qBAAqBK,eAAe;YACvDsC,gBAAYzD,6MAAAA,EAAwByD;YAEpC,UAAMnE,4MAAAA,EAAmB;gBACvBwB,kBAAkBJ,WAAWC,MAAM;gBACnCE,gBAAgBA;gBAChBqB;gBACA0B,mBAAe7D,sMAAAA,EAA6BoC,QAAQxB,MAAM,EAAED,WAAWC,MAAM,EAAE;gBAC/EsB,WAAOjC,6MAAAA,EAAwBiC;YACjC;YAEAuB,SAAS,MAAMrB,QAAQ0B,EAAE,CAACC,WAAW,CAAgC;gBACnEpD,YAAYI,iBAAiBiD,IAAI;gBACjCzC,OAAOY,IAAI8B,UAAU,KAAK,YAAY,QAAQL;gBAC9CpC,OAAO+B;gBACPhB,QAAQA;gBACRd,MAAM+B;gBACN9B,YAAY4B;gBACZnB;gBACAP,YAAQ1B,uMAAAA,EAAqB;oBAAE0B;gBAAO;gBACtCG,UAAM5B,mMAAAA,EAAmB;oBACvBY;oBACAgB;gBACF;gBACAG,OAAOwB;YACT;QACF,OAAO;YACL,UAAMnE,4MAAAA,EAAmB;gBACvBwB;gBACAD,gBAAgBA;gBAChBqB;gBACAD,OAAOA;YACT;YAEAuB,SAAS,MAAMrB,QAAQ0B,EAAE,CAACI,IAAI,CAAgC;gBAC5DvD,YAAYI,iBAAiBiD,IAAI;gBACjC5C;gBACAG,OAAOY,IAAI8B,UAAU,KAAK,YAAY,QAAQL;gBAC9CpC,OAAO+B;gBACPhB,QAAQA;gBACRd,MAAM+B;gBACN9B;gBACAS;gBACAP;gBACAG;gBACAG,OAAOwB;YACT;QACF;QAEA,IAAIrC,mBAAmB;YACrB,IAAI;gBACF,MAAM8C,oBAAoBpD,kBAAkBqD;gBAE5C,MAAMC,eACJ,OAAOF,sBAAsB,WAAWA,kBAAkBG,QAAQ,GAAG/D;gBACvE,MAAMgE,6BAA6BF,eAAe;gBAElD,MAAMG,MAAM,IAAIC,OAAOC,OAAO;gBAE9B,MAAMC,kBAAkB,MAAMvC,QAAQ8B,IAAI,CAAC;oBACzCvD,YAAYhB,mMAAAA;oBACZsB,OAAO;oBACPO,OAAO+B;oBACPzC,gBAAgB;oBAChBY,YAAY;oBACZS;oBACAD,OAAO;wBACL0C,KAAK;4BACH;gCACE,uBAAuB;oCACrBC,QAAQ9D,iBAAiBiD,IAAI;gCAC/B;4BACF;4BACA;gCACE,kBAAkB;oCAChBc,IAAIrB,OAAOX,IAAI,CAACiC,GAAG,CAAC,CAACC,MAAQA,IAAIC,EAAE;gCACrC;4BACF;4BACA,sEAAsE;4BACtE;gCACEC,WAAW;oCACTC,cAAc,IAAIV,KAAKD,MAAMD;gCAC/B;4BACF;yBACD;oBACH;gBACF;gBAEA,MAAMa,aAAaC,MAAMC,OAAO,CAACX,iBAAiB7B,QAAQ6B,gBAAgB7B,IAAI,GAAG,EAAE;gBAEnF,yBAAyB;gBACzB,MAAMyC,kBAAkBH,WAAWI,MAAM,CAAC,CAACC;oBACzC,MAAMC,eAAe,IAAIjB,KAAKgB,MAAMP,WAAWR,OAAO;oBACtD,OAAOgB,eAAenB,6BAA6BC;gBACrD;gBAEA,KAAK,MAAMQ,OAAOvB,OAAOX,IAAI,CAAE;oBAC7B,MAAM6C,YAAYJ,gBAAgBrB,IAAI,CAAC,CAACuB,OAASA,MAAMG,UAAUC,UAAUb,IAAIC,EAAE;oBACjFD,IAAIc,SAAS,GAAG,CAAC,CAACH;oBAClBX,IAAIe,YAAY,GAAGJ,YAAYA,WAAWK,MAAMH,QAAQ;gBAC1D;YACF,EAAE,OAAOI,MAAM;gBACb,KAAK,MAAMjB,OAAOvB,OAAOX,IAAI,CAAE;oBAC7BkC,IAAIc,SAAS,GAAG;oBAChBd,IAAIe,YAAY,GAAG;gBACrB;YACF;QACF;QAEA,wCAAwC;QACxC,0BAA0B;QAC1B,wCAAwC;QAExC,IAAIhF,kBAAkBmF,OAAOC,YAAYC,QAAQ;YAC/C3C,OAAOX,IAAI,GAAG,MAAMuD,QAAQC,GAAG,CAC7B7C,OAAOX,IAAI,CAACiC,GAAG,CAAC,OAAOC;gBACrB,IAAIuB,SAASvB;gBAEb,KAAK,MAAMwB,QAAQzF,iBAAiBmF,KAAK,CAACC,UAAU,CAAE;oBACpDI,SACG,MAAMC,KAAK;wBACV7F,YAAYI;wBACZ0F,SAAStE,IAAIsE,OAAO;wBACpBzB,KAAKuB;wBACLzF,gBAAgBA;wBAChB4F,OAAOhD;wBACPvB;oBACF,MAAOoE;gBACX;gBAEA,OAAOA;YACT;QAEJ;QAEA,wCAAwC;QACxC,qBAAqB;QACrB,wCAAwC;QAExC9C,OAAOX,IAAI,GAAG,MAAMuD,QAAQC,GAAG,CAC7B7C,OAAOX,IAAI,CAACiC,GAAG,CAAC,OAAOC,UACrBtF,uLAAAA,EAAyC;gBACvCiB,YAAYI;gBACZ0F,SAAStE,IAAIsE,OAAO;gBACpBzF;gBACAC,OAAOA;gBACP+D;gBACA7D,OAAOC;gBACPkB,gBAAgBA;gBAChBqE,UAAU;gBACVC,QAAQ;gBACRrE,QAAQA;gBACRzB,gBAAgBA;gBAChBa;gBACAQ;gBACAP;gBACAE,kBAAkBA;YACpB;QAIJ,wCAAwC;QACxC,yBAAyB;QACzB,wCAAwC;QAExC,IAAIf,kBAAkBmF,OAAOxG,WAAW0G,QAAQ;YAC9C3C,OAAOX,IAAI,GAAG,MAAMuD,QAAQC,GAAG,CAC7B7C,OAAOX,IAAI,CAACiC,GAAG,CAAC,OAAOC;gBACrB,IAAIuB,SAASvB;gBAEb,KAAK,MAAMwB,QAAQzF,iBAAiBmF,KAAK,CAACxG,SAAS,CAAE;oBACnD6G,SACG,MAAMC,KAAK;wBACV7F,YAAYI;wBACZ0F,SAAStE,IAAIsE,OAAO;wBACpBzB,KAAKuB;wBACLI,UAAU;wBACV7F,gBAAgBA;wBAChB4F,OAAOhD;wBACPvB;oBACF,MAAOoE;gBACX;gBAEA,OAAOA;YACT;QAEJ;QAEA,wCAAwC;QACxC,8BAA8B;QAC9B,wCAAwC;QAExC9C,SAAS,UAAMrD,yNAAAA,EAAoB;YACjCM;YACAC,YAAYI;YACZF,WAAW;YACXC,gBAAgBA;YAChB2C;QACF;QAEA,wCAAwC;QACxC,iBAAiB;QACjB,wCAAwC;QAExC,OAAOA;IACT,EAAE,OAAOoD,OAAgB;QACvB,UAAM/G,oLAAAA,EAAgBY,KAAKyB,GAAG;QAC9B,MAAM0E;IACR;AACF,EAAC"}},
    {"offset": {"line": 1769, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/collections/operations/local/find.ts"],"sourcesContent":["import type { PaginatedDocs } from '../../../database/types.js'\nimport type {\n  CollectionSlug,\n  GeneratedTypes,\n  JoinQuery,\n  Payload,\n  PayloadTypes,\n  RequestContext,\n  TypedFallbackLocale,\n  TypedLocale,\n} from '../../../index.js'\nimport type {\n  Document,\n  DraftTransformCollectionWithSelect,\n  PayloadRequest,\n  PopulateType,\n  SelectType,\n  Sort,\n  TransformCollectionWithSelect,\n  Where,\n} from '../../../types/index.js'\nimport type { CreateLocalReqOptions } from '../../../utilities/createLocalReq.js'\nimport type {\n  DraftFlagFromCollectionSlug,\n  SelectFromCollectionSlug,\n} from '../../config/types.js'\n\nimport { APIError } from '../../../errors/index.js'\nimport { createLocalReq } from '../../../utilities/createLocalReq.js'\nimport { findOperation } from '../find.js'\n\ntype BaseFindOptions<TSlug extends CollectionSlug, TSelect extends SelectType> = {\n  /**\n   * the Collection slug to operate against.\n   */\n  collection: TSlug\n  /**\n   * [Context](https://payloadcms.com/docs/hooks/context), which will then be passed to `context` and `req.context`,\n   * which can be read by hooks. Useful if you want to pass additional information to the hooks which\n   * shouldn't be necessarily part of the document, for example a `triggerBeforeChange` option which can be read by the BeforeChange hook\n   * to determine if it should run or not.\n   */\n  context?: RequestContext\n  /**\n   * The current population depth, used internally for relationships population.\n   * @internal\n   */\n  currentDepth?: number\n  /**\n   * [Control auto-population](https://payloadcms.com/docs/queries/depth) of nested relationship and upload fields.\n   */\n  depth?: number\n  /**\n   * When set to `true`, errors will not be thrown.\n   */\n  disableErrors?: boolean\n  /**\n   * Specify a [fallback locale](https://payloadcms.com/docs/configuration/localization) to use for any returned documents.\n   */\n  fallbackLocale?: TypedFallbackLocale\n  /**\n   * Include info about the lock status to the result into all documents with fields: `_isLocked` and `_userEditing`\n   */\n  includeLockStatus?: boolean\n  /**\n   * The [Join Field Query](https://payloadcms.com/docs/fields/join#query-options).\n   * Pass `false` to disable all join fields from the result.\n   */\n  joins?: JoinQuery<TSlug>\n  /**\n   * The maximum related documents to be returned.\n   * Defaults unless `defaultLimit` is specified for the collection config\n   * @default 10\n   */\n  limit?: number\n  /**\n   * Specify [locale](https://payloadcms.com/docs/configuration/localization) for any returned documents.\n   */\n  locale?: 'all' | TypedLocale\n  /**\n   * Skip access control.\n   * Set to `false` if you want to respect Access Control for the operation, for example when fetching data for the front-end.\n   * @default true\n   */\n  overrideAccess?: boolean\n  /**\n   * Get a specific page number\n   * @default 1\n   */\n  page?: number\n  /**\n   * Set to `false` to return all documents and avoid querying for document counts which introduces some overhead.\n   * You can also combine that property with a specified `limit` to limit documents but avoid the count query.\n   */\n  pagination?: boolean\n  /**\n   * Specify [populate](https://payloadcms.com/docs/queries/select#populate) to control which fields to include to the result from populated documents.\n   */\n  populate?: PopulateType\n  /**\n   * The `PayloadRequest` object. You can pass it to thread the current [transaction](https://payloadcms.com/docs/database/transactions), user and locale to the operation.\n   * Recommended to pass when using the Local API from hooks, as usually you want to execute the operation within the current transaction.\n   */\n  req?: Partial<PayloadRequest>\n  /**\n   * By default, Payload's APIs will return all fields for a given collection or global.\n   * But you may not need all of that data for all of your queries.\n   * Sometimes, you might want just a few fields from the response.\n   *\n   * With the Select API, you can define exactly which fields you'd like to retrieve.\n   * This can impact performance by reducing database load and response size.\n   *\n   *\n   * **Example: Select specific fields**\n   * ```ts\n   * const post = await payload.findByID({\n   *   collection: 'posts',\n   *   id: '1',\n   *   select: { title: true, content: true },\n   * })\n   *\n   * console.log(post) // { id: '1', title: 'My Post', content: 'This is my post' }\n   * ```\n   *\n   * **Example: Select all fields except `content`**\n   *\n   * ```ts\n   * const post = await payload.findByID({\n   *   collection: 'posts',\n   *   id: '1',\n   *   select: { content: false },\n   * })\n   *\n   * console.log(post) // { id: '1', title: 'My Post', number: 3 }\n   * ```\n   *\n   * **Example: Empty select returns only `id`**\n   *\n   * ```ts\n   * const post = await payload.findByID({\n   *   collection: 'posts',\n   *   id: '1',\n   *   select: {},\n   * })\n   *\n   * console.log(post) // { id: '1' }\n   * ```\n   *\n   * @see https://payloadcms.com/docs/queries/select\n   */\n  select?: TSelect\n  /**\n   * Opt-in to receiving hidden fields. By default, they are hidden from returned documents in accordance to your config.\n   * @default false\n   */\n  showHiddenFields?: boolean\n  /**\n   * Sort the documents, can be a string or an array of strings\n   * @example '-createdAt' // Sort DESC by createdAt\n   * @example ['group', '-createdAt'] // sort by 2 fields, ASC group and DESC createdAt\n   */\n  sort?: Sort\n  /**\n   * When set to `true`, the query will include both normal and trashed documents.\n   * To query only trashed documents, pass `trash: true` and combine with a `where` clause filtering by `deletedAt`.\n   * By default (`false`), the query will only include normal documents and exclude those with a `deletedAt` field.\n   *\n   * This argument has no effect unless `trash` is enabled on the collection.\n   * @default false\n   */\n  trash?: boolean\n  /**\n   * If you set `overrideAccess` to `false`, you can pass a user to use against the access control checks.\n   */\n  user?: Document\n  /**\n   * A filter [query](https://payloadcms.com/docs/queries/overview)\n   */\n  where?: Where\n}\n\nexport type Options<TSlug extends CollectionSlug, TSelect extends SelectType> =\n  BaseFindOptions<TSlug, TSelect> & DraftFlagFromCollectionSlug<TSlug>\n\n// Backward compatibility export\nexport type FindOptions<TSlug extends CollectionSlug, TSelect extends SelectType> =\n  Options<TSlug, TSelect>\n\nexport async function findLocal<\n  TSlug extends CollectionSlug,\n  TSelect extends SelectFromCollectionSlug<TSlug>,\n  TDraft extends boolean = false,\n>(\n  payload: Payload,\n  options: { draft?: TDraft } & FindOptions<TSlug, TSelect>,\n): Promise<\n  PaginatedDocs<\n    TDraft extends true\n      ? PayloadTypes extends { strictDraftTypes: true }\n        ? DraftTransformCollectionWithSelect<TSlug, TSelect>\n        : TransformCollectionWithSelect<TSlug, TSelect>\n      : TransformCollectionWithSelect<TSlug, TSelect>\n  >\n> {\n  const {\n    collection: collectionSlug,\n    currentDepth,\n    depth,\n    disableErrors,\n    draft = false,\n    includeLockStatus,\n    joins,\n    limit,\n    overrideAccess = true,\n    page,\n    pagination = true,\n    populate,\n    select,\n    showHiddenFields,\n    sort,\n    trash = false,\n    where,\n  } = options\n\n  const collection = payload.collections[collectionSlug]\n\n  if (!collection) {\n    throw new APIError(\n      `The collection with slug ${String(collectionSlug)} can't be found. Find Operation.`,\n    )\n  }\n\n  return findOperation<TSlug, TSelect>({\n    collection,\n    currentDepth,\n    depth,\n    disableErrors,\n    draft,\n    includeLockStatus,\n    joins,\n    limit,\n    overrideAccess,\n    page,\n    pagination,\n    populate,\n    req: await createLocalReq(options as CreateLocalReqOptions, payload),\n    select,\n    showHiddenFields,\n    sort,\n    trash,\n    where,\n  })\n}\n"],"names":["APIError","createLocalReq","findOperation","findLocal","payload","options","collection","collectionSlug","currentDepth","depth","disableErrors","draft","includeLockStatus","joins","limit","overrideAccess","page","pagination","populate","select","showHiddenFields","sort","trash","where","collections","String","req"],"mappings":";;;;AA2BA,SAASA,QAAQ,QAAQ,2BAA0B;AACnD,SAASC,cAAc,QAAQ,uCAAsC;AACrE,SAASC,aAAa,QAAQ,aAAY;;;;AA+JnC,eAAeC,UAKpBC,OAAgB,EAChBC,OAAyD;IAUzD,MAAM,EACJC,YAAYC,cAAc,EAC1BC,YAAY,EACZC,KAAK,EACLC,aAAa,EACbC,QAAQ,KAAK,EACbC,iBAAiB,EACjBC,KAAK,EACLC,KAAK,EACLC,iBAAiB,IAAI,EACrBC,IAAI,EACJC,aAAa,IAAI,EACjBC,QAAQ,EACRC,MAAM,EACNC,gBAAgB,EAChBC,IAAI,EACJC,QAAQ,KAAK,EACbC,KAAK,EACN,GAAGlB;IAEJ,MAAMC,aAAaF,QAAQoB,WAAW,CAACjB,eAAe;IAEtD,IAAI,CAACD,YAAY;QACf,MAAM,IAAIN,mKAAAA,CACR,CAAC,yBAAyB,EAAEyB,OAAOlB,gBAAgB,gCAAgC,CAAC;IAExF;IAEA,WAAOL,uLAAAA,EAA8B;QACnCI;QACAE;QACAC;QACAC;QACAC;QACAC;QACAC;QACAC;QACAC;QACAC;QACAC;QACAC;QACAQ,KAAK,UAAMzB,kLAAAA,EAAeI,SAAkCD;QAC5De;QACAC;QACAC;QACAC;QACAC;IACF;AACF"}},
    {"offset": {"line": 1810, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/collections/operations/findByID.ts"],"sourcesContent":["import type { FindOneArgs } from '../../database/types.js'\nimport type { CollectionSlug, FindOptions, JoinQuery } from '../../index.js'\nimport type {\n  ApplyDisableErrors,\n  JsonObject,\n  PayloadRequest,\n  PopulateType,\n  SelectType,\n  TransformCollectionWithSelect,\n} from '../../types/index.js'\nimport type {\n  Collection,\n  DataFromCollectionSlug,\n  SelectFromCollectionSlug,\n  TypeWithID,\n} from '../config/types.js'\n\nimport { executeAccess } from '../../auth/executeAccess.js'\nimport { combineQueries } from '../../database/combineQueries.js'\nimport { sanitizeJoinQuery } from '../../database/sanitizeJoinQuery.js'\nimport { sanitizeWhereQuery } from '../../database/sanitizeWhereQuery.js'\nimport { NotFound } from '../../errors/index.js'\nimport { afterRead, type AfterReadArgs } from '../../fields/hooks/afterRead/index.js'\nimport { validateQueryPaths } from '../../index.js'\nimport { lockedDocumentsCollectionSlug } from '../../locked-documents/config.js'\nimport { appendNonTrashedFilter } from '../../utilities/appendNonTrashedFilter.js'\nimport { getSelectMode } from '../../utilities/getSelectMode.js'\nimport { hasDraftsEnabled } from '../../utilities/getVersionsConfig.js'\nimport { killTransaction } from '../../utilities/killTransaction.js'\nimport { sanitizeSelect } from '../../utilities/sanitizeSelect.js'\nimport { replaceWithDraftIfAvailable } from '../../versions/drafts/replaceWithDraftIfAvailable.js'\nimport { buildAfterOperation } from './utilities/buildAfterOperation.js'\nimport { buildBeforeOperation } from './utilities/buildBeforeOperation.js'\n\nexport type FindByIDArgs = {\n  collection: Collection\n  currentDepth?: number\n  /**\n   * You may pass the document data directly which will skip the `db.findOne` database query.\n   * This is useful if you want to use this endpoint solely for running hooks and populating data.\n   */\n  data?: Record<string, unknown>\n  depth?: number\n  disableErrors?: boolean\n  draft?: boolean\n  id: number | string\n  includeLockStatus?: boolean\n  joins?: JoinQuery\n  overrideAccess?: boolean\n  populate?: PopulateType\n  req: PayloadRequest\n  showHiddenFields?: boolean\n  trash?: boolean\n} & Pick<AfterReadArgs<JsonObject>, 'flattenLocales'> &\n  Pick<FindOptions<string, SelectType>, 'select'>\n\nexport const findByIDOperation = async <\n  TSlug extends CollectionSlug,\n  TDisableErrors extends boolean,\n  TSelect extends SelectFromCollectionSlug<TSlug>,\n>(\n  incomingArgs: FindByIDArgs,\n): Promise<ApplyDisableErrors<TransformCollectionWithSelect<TSlug, TSelect>, TDisableErrors>> => {\n  let args = incomingArgs\n\n  try {\n    // /////////////////////////////////////\n    // beforeOperation - Collection\n    // /////////////////////////////////////\n\n    args = await buildBeforeOperation({\n      args,\n      collection: args.collection.config,\n      operation: 'read',\n      overrideAccess: args.overrideAccess!,\n    })\n\n    const {\n      id,\n      collection: { config: collectionConfig },\n      currentDepth,\n      depth,\n      disableErrors,\n      draft: replaceWithVersion = false,\n      flattenLocales,\n      includeLockStatus: includeLockStatusFromArgs,\n      joins,\n      overrideAccess = false,\n      populate,\n      req: { fallbackLocale, locale, t },\n      req,\n      select: incomingSelect,\n      showHiddenFields,\n      trash = false,\n    } = args\n\n    const includeLockStatus =\n      includeLockStatusFromArgs && req.payload.collections?.[lockedDocumentsCollectionSlug]\n\n    const select = sanitizeSelect({\n      fields: collectionConfig.flattenedFields,\n      forceSelect: collectionConfig.forceSelect,\n      select: incomingSelect,\n    })\n\n    // /////////////////////////////////////\n    // Access\n    // /////////////////////////////////////\n\n    const accessResult = !overrideAccess\n      ? await executeAccess({ id, disableErrors, req }, collectionConfig.access.read)\n      : true\n\n    // If errors are disabled, and access returns false, return null\n    if (accessResult === false) {\n      return null!\n    }\n\n    const where = { id: { equals: id } }\n\n    let fullWhere = combineQueries(where, accessResult)\n\n    // Exclude trashed documents when trash: false\n    fullWhere = appendNonTrashedFilter({\n      enableTrash: collectionConfig.trash,\n      trash,\n      where: fullWhere,\n    })\n\n    sanitizeWhereQuery({\n      fields: collectionConfig.flattenedFields,\n      payload: args.req.payload,\n      where: fullWhere,\n    })\n\n    const sanitizedJoins = await sanitizeJoinQuery({\n      collectionConfig,\n      joins,\n      overrideAccess,\n      req,\n    })\n\n    // execute only if there's a custom ID and potentially overwriten access on id\n    if (req.payload.collections[collectionConfig.slug]!.customIDType) {\n      await validateQueryPaths({\n        collectionConfig,\n        overrideAccess,\n        req,\n        where,\n      })\n    }\n\n    // /////////////////////////////////////\n    // Find by ID\n    // /////////////////////////////////////\n\n    let dbSelect = select\n\n    if (\n      collectionConfig.versions?.drafts &&\n      replaceWithVersion &&\n      select &&\n      getSelectMode(select) === 'include'\n    ) {\n      dbSelect = { ...select, createdAt: true, updatedAt: true }\n    }\n\n    const findOneArgs: FindOneArgs = {\n      collection: collectionConfig.slug,\n      draftsEnabled: replaceWithVersion,\n      joins: req.payloadAPI === 'GraphQL' ? false : sanitizedJoins,\n      locale: locale!,\n      req: {\n        transactionID: req.transactionID,\n      } as PayloadRequest,\n      select: dbSelect,\n      where: fullWhere,\n    }\n\n    if (!findOneArgs.where?.and?.[0]?.id) {\n      throw new NotFound(t)\n    }\n\n    const docFromDB = await req.payload.db.findOne(findOneArgs)\n\n    if (!docFromDB && !args.data) {\n      if (!disableErrors) {\n        throw new NotFound(req.t)\n      }\n      return null!\n    }\n\n    let result: DataFromCollectionSlug<TSlug> =\n      (args.data as DataFromCollectionSlug<TSlug>) ?? docFromDB!\n\n    // /////////////////////////////////////\n    // Include Lock Status if required\n    // /////////////////////////////////////\n\n    if (includeLockStatus && id) {\n      let lockStatus: (JsonObject & TypeWithID) | null = null\n\n      try {\n        const lockDocumentsProp = collectionConfig?.lockDocuments\n\n        const lockDurationDefault = 300 // Default 5 minutes in seconds\n        const lockDuration =\n          typeof lockDocumentsProp === 'object' ? lockDocumentsProp.duration : lockDurationDefault\n        const lockDurationInMilliseconds = lockDuration * 1000\n\n        const lockedDocument = await req.payload.find({\n          collection: lockedDocumentsCollectionSlug,\n          depth: 1,\n          limit: 1,\n          overrideAccess: false,\n          pagination: false,\n          req,\n          where: {\n            and: [\n              {\n                'document.relationTo': {\n                  equals: collectionConfig.slug,\n                },\n              },\n              {\n                'document.value': {\n                  equals: id,\n                },\n              },\n              // Query where the lock is newer than the current time minus lock time\n              {\n                updatedAt: {\n                  greater_than: new Date(new Date().getTime() - lockDurationInMilliseconds),\n                },\n              },\n            ],\n          },\n        })\n\n        if (lockedDocument && lockedDocument.docs.length > 0) {\n          lockStatus = lockedDocument.docs[0]!\n        }\n      } catch {\n        // swallow error\n      }\n\n      result._isLocked = !!lockStatus\n      result._userEditing = lockStatus?.user?.value ?? null\n    }\n\n    // /////////////////////////////////////\n    // Replace document with draft if available\n    // /////////////////////////////////////\n\n    if (replaceWithVersion && hasDraftsEnabled(collectionConfig)) {\n      result = await replaceWithDraftIfAvailable({\n        accessResult,\n        doc: result,\n        entity: collectionConfig,\n        entityType: 'collection',\n        overrideAccess,\n        req,\n        select,\n      })\n    }\n\n    // /////////////////////////////////////\n    // beforeRead - Collection\n    // /////////////////////////////////////\n\n    if (collectionConfig.hooks?.beforeRead?.length) {\n      for (const hook of collectionConfig.hooks.beforeRead) {\n        result =\n          (await hook({\n            collection: collectionConfig,\n            context: req.context,\n            doc: result,\n            overrideAccess,\n            query: findOneArgs.where,\n            req,\n          })) || result\n      }\n    }\n\n    // /////////////////////////////////////\n    // afterRead - Fields\n    // /////////////////////////////////////\n\n    result = await afterRead({\n      collection: collectionConfig,\n      context: req.context,\n      currentDepth,\n      depth: depth!,\n      doc: result,\n      draft: replaceWithVersion,\n      fallbackLocale: fallbackLocale!,\n      flattenLocales,\n      global: null,\n      locale: locale!,\n      overrideAccess,\n      populate,\n      req,\n      select,\n      showHiddenFields: showHiddenFields!,\n    })\n\n    // /////////////////////////////////////\n    // afterRead - Collection\n    // /////////////////////////////////////\n\n    if (collectionConfig.hooks?.afterRead?.length) {\n      for (const hook of collectionConfig.hooks.afterRead) {\n        result =\n          (await hook({\n            collection: collectionConfig,\n            context: req.context,\n            doc: result,\n            overrideAccess,\n            query: findOneArgs.where,\n            req,\n          })) || result\n      }\n    }\n\n    // /////////////////////////////////////\n    // afterOperation - Collection\n    // /////////////////////////////////////\n\n    result = await buildAfterOperation({\n      args,\n      collection: collectionConfig,\n      operation: 'findByID',\n      overrideAccess,\n      result,\n    })\n\n    // /////////////////////////////////////\n    // Return results\n    // /////////////////////////////////////\n\n    return result as ApplyDisableErrors<\n      TransformCollectionWithSelect<TSlug, TSelect>,\n      TDisableErrors\n    >\n  } catch (error: unknown) {\n    await killTransaction(args.req)\n    throw error\n  }\n}\n"],"names":["executeAccess","combineQueries","sanitizeJoinQuery","sanitizeWhereQuery","NotFound","afterRead","validateQueryPaths","lockedDocumentsCollectionSlug","appendNonTrashedFilter","getSelectMode","hasDraftsEnabled","killTransaction","sanitizeSelect","replaceWithDraftIfAvailable","buildAfterOperation","buildBeforeOperation","findByIDOperation","incomingArgs","args","collection","config","operation","overrideAccess","id","collectionConfig","currentDepth","depth","disableErrors","draft","replaceWithVersion","flattenLocales","includeLockStatus","includeLockStatusFromArgs","joins","populate","req","fallbackLocale","locale","t","select","incomingSelect","showHiddenFields","trash","payload","collections","fields","flattenedFields","forceSelect","accessResult","access","read","where","equals","fullWhere","enableTrash","sanitizedJoins","slug","customIDType","dbSelect","versions","drafts","createdAt","updatedAt","findOneArgs","draftsEnabled","payloadAPI","transactionID","and","docFromDB","db","findOne","data","result","lockStatus","lockDocumentsProp","lockDocuments","lockDurationDefault","lockDuration","duration","lockDurationInMilliseconds","lockedDocument","find","limit","pagination","greater_than","Date","getTime","docs","length","_isLocked","_userEditing","user","value","doc","entity","entityType","hooks","beforeRead","hook","context","query","global","error"],"mappings":"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"}},
    {"offset": {"line": 2077, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/collections/operations/local/findByID.ts"],"sourcesContent":["import type {\n  CollectionSlug,\n  FindOptions,\n  JoinQuery,\n  Payload,\n  RequestContext,\n  SelectType,\n  TypedFallbackLocale,\n  TypedLocale,\n} from '../../../index.js'\nimport type {\n  ApplyDisableErrors,\n  Document,\n  PayloadRequest,\n  PopulateType,\n  TransformCollectionWithSelect,\n} from '../../../types/index.js'\nimport type { CreateLocalReqOptions } from '../../../utilities/createLocalReq.js'\nimport type {\n  DraftFlagFromCollectionSlug,\n  SelectFromCollectionSlug,\n} from '../../config/types.js'\n\nimport { APIError } from '../../../errors/index.js'\nimport { createLocalReq } from '../../../utilities/createLocalReq.js'\nimport { type FindByIDArgs, findByIDOperation } from '../findByID.js'\n\ntype BaseFindByIDOptions<\n  TSlug extends CollectionSlug,\n  TDisableErrors extends boolean,\n  TSelect extends SelectType,\n> = {\n  /**\n   * the Collection slug to operate against.\n   */\n  collection: TSlug\n  /**\n   * [Context](https://payloadcms.com/docs/hooks/context), which will then be passed to `context` and `req.context`,\n   * which can be read by hooks. Useful if you want to pass additional information to the hooks which\n   * shouldn't be necessarily part of the document, for example a `triggerBeforeChange` option which can be read by the BeforeChange hook\n   * to determine if it should run or not.\n   */\n  context?: RequestContext\n  /**\n   * The current population depth, used internally for relationships population.\n   * @internal\n   */\n  currentDepth?: number\n  /**\n   * You may pass the document data directly which will skip the `db.findOne` database query.\n   * This is useful if you want to use this endpoint solely for running hooks and populating data.\n   */\n  data?: Record<string, unknown>\n  /**\n   * [Control auto-population](https://payloadcms.com/docs/queries/depth) of nested relationship and upload fields.\n   */\n  depth?: number\n  /**\n   * When set to `true`, errors will not be thrown.\n   * `null` will be returned instead, if the document on this ID was not found.\n   */\n  disableErrors?: TDisableErrors\n  /**\n   * Specify a [fallback locale](https://payloadcms.com/docs/configuration/localization) to use for any returned documents.\n   */\n  fallbackLocale?: TypedFallbackLocale\n  /**\n   * The ID of the document to find.\n   */\n  id: number | string\n  /**\n   * Include info about the lock status to the result with fields: `_isLocked` and `_userEditing`\n   */\n  includeLockStatus?: boolean\n  /**\n   * The [Join Field Query](https://payloadcms.com/docs/fields/join#query-options).\n   * Pass `false` to disable all join fields from the result.\n   */\n  joins?: JoinQuery<TSlug>\n  /**\n   * Specify [locale](https://payloadcms.com/docs/configuration/localization) for any returned documents.\n   */\n  locale?: 'all' | TypedLocale\n  /**\n   * Skip access control.\n   * Set to `false` if you want to respect Access Control for the operation, for example when fetching data for the front-end.\n   * @default true\n   */\n  overrideAccess?: boolean\n  /**\n   * Specify [populate](https://payloadcms.com/docs/queries/select#populate) to control which fields to include to the result from populated documents.\n   */\n  populate?: PopulateType\n  /**\n   * The `PayloadRequest` object. You can pass it to thread the current [transaction](https://payloadcms.com/docs/database/transactions), user and locale to the operation.\n   * Recommended to pass when using the Local API from hooks, as usually you want to execute the operation within the current transaction.\n   */\n  req?: Partial<PayloadRequest>\n  /**\n   * Opt-in to receiving hidden fields. By default, they are hidden from returned documents in accordance to your config.\n   * @default false\n   */\n  showHiddenFields?: boolean\n  /**\n   * When set to `true`, the operation will return a document by ID, even if it is trashed (soft-deleted).\n   * By default (`false`), the operation will exclude trashed documents.\n   * To fetch a trashed document, set `trash: true`.\n   *\n   * This argument has no effect unless `trash` is enabled on the collection.\n   * @default false\n   */\n  trash?: boolean\n  /**\n   * If you set `overrideAccess` to `false`, you can pass a user to use against the access control checks.\n   */\n  user?: Document\n} & Pick<FindByIDArgs, 'flattenLocales'> &\n  Pick<FindOptions<TSlug, TSelect>, 'select'>\n\nexport type Options<\n  TSlug extends CollectionSlug,\n  TDisableErrors extends boolean,\n  TSelect extends SelectType,\n> = BaseFindByIDOptions<TSlug, TDisableErrors, TSelect> & DraftFlagFromCollectionSlug<TSlug>\n\nexport async function findByIDLocal<\n  TSlug extends CollectionSlug,\n  TDisableErrors extends boolean,\n  TSelect extends SelectFromCollectionSlug<TSlug>,\n>(\n  payload: Payload,\n  options: Options<TSlug, TDisableErrors, TSelect>,\n): Promise<ApplyDisableErrors<TransformCollectionWithSelect<TSlug, TSelect>, TDisableErrors>> {\n  const {\n    id,\n    collection: collectionSlug,\n    currentDepth,\n    data,\n    depth,\n    disableErrors = false,\n    draft = false,\n    flattenLocales,\n    includeLockStatus,\n    joins,\n    overrideAccess = true,\n    populate,\n    select,\n    showHiddenFields,\n    trash = false,\n  } = options\n\n  const collection = payload.collections[collectionSlug]\n\n  if (!collection) {\n    throw new APIError(\n      `The collection with slug ${String(collectionSlug)} can't be found. Find By ID Operation.`,\n    )\n  }\n\n  return findByIDOperation<TSlug, TDisableErrors, TSelect>({\n    id,\n    collection,\n    currentDepth,\n    data,\n    depth,\n    disableErrors,\n    draft,\n    flattenLocales,\n    includeLockStatus,\n    joins,\n    overrideAccess,\n    populate,\n    req: await createLocalReq(options as CreateLocalReqOptions, payload),\n    select,\n    showHiddenFields,\n    trash,\n  })\n}\n"],"names":["APIError","createLocalReq","findByIDOperation","findByIDLocal","payload","options","id","collection","collectionSlug","currentDepth","data","depth","disableErrors","draft","flattenLocales","includeLockStatus","joins","overrideAccess","populate","select","showHiddenFields","trash","collections","String","req"],"mappings":";;;;AAuBA,SAASA,QAAQ,QAAQ,2BAA0B;AACnD,SAASC,cAAc,QAAQ,uCAAsC;AACrE,SAA4BC,iBAAiB,QAAQ,iBAAgB;;;;AAoG9D,eAAeC,cAKpBC,OAAgB,EAChBC,OAAgD;IAEhD,MAAM,EACJC,EAAE,EACFC,YAAYC,cAAc,EAC1BC,YAAY,EACZC,IAAI,EACJC,KAAK,EACLC,gBAAgB,KAAK,EACrBC,QAAQ,KAAK,EACbC,cAAc,EACdC,iBAAiB,EACjBC,KAAK,EACLC,iBAAiB,IAAI,EACrBC,QAAQ,EACRC,MAAM,EACNC,gBAAgB,EAChBC,QAAQ,KAAK,EACd,GAAGhB;IAEJ,MAAME,aAAaH,QAAQkB,WAAW,CAACd,eAAe;IAEtD,IAAI,CAACD,YAAY;QACf,MAAM,IAAIP,mKAAAA,CACR,CAAC,yBAAyB,EAAEuB,OAAOf,gBAAgB,sCAAsC,CAAC;IAE9F;IAEA,WAAON,+LAAAA,EAAkD;QACvDI;QACAC;QACAE;QACAC;QACAC;QACAC;QACAC;QACAC;QACAC;QACAC;QACAC;QACAC;QACAM,KAAK,UAAMvB,kLAAAA,EAAeI,SAAkCD;QAC5De;QACAC;QACAC;IACF;AACF"}},
    {"offset": {"line": 2116, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/collections/operations/findDistinct.ts"],"sourcesContent":["import httpStatus from 'http-status'\n\nimport type { AccessResult } from '../../config/types.js'\nimport type { PaginatedDistinctDocs } from '../../database/types.js'\nimport type { FlattenedField } from '../../fields/config/types.js'\nimport type { PayloadRequest, PopulateType, Sort, Where } from '../../types/index.js'\nimport type { Collection } from '../config/types.js'\n\nimport { executeAccess } from '../../auth/executeAccess.js'\nimport { combineQueries } from '../../database/combineQueries.js'\nimport { validateQueryPaths } from '../../database/queryValidation/validateQueryPaths.js'\nimport { sanitizeWhereQuery } from '../../database/sanitizeWhereQuery.js'\nimport { APIError } from '../../errors/APIError.js'\nimport { Forbidden } from '../../errors/Forbidden.js'\nimport { relationshipPopulationPromise } from '../../fields/hooks/afterRead/relationshipPopulationPromise.js'\nimport { appendNonTrashedFilter } from '../../utilities/appendNonTrashedFilter.js'\nimport { getFieldByPath } from '../../utilities/getFieldByPath.js'\nimport { killTransaction } from '../../utilities/killTransaction.js'\nimport { buildAfterOperation } from './utilities/buildAfterOperation.js'\nimport { buildBeforeOperation } from './utilities/buildBeforeOperation.js'\n\nexport type Arguments = {\n  collection: Collection\n  depth?: number\n  disableErrors?: boolean\n  field: string\n  limit?: number\n  locale?: string\n  overrideAccess?: boolean\n  page?: number\n  populate?: PopulateType\n  req?: PayloadRequest\n  showHiddenFields?: boolean\n  sort?: Sort\n  trash?: boolean\n  where?: Where\n}\nexport const findDistinctOperation = async (\n  incomingArgs: Arguments,\n): Promise<PaginatedDistinctDocs<Record<string, unknown>>> => {\n  let args = incomingArgs\n\n  try {\n    // /////////////////////////////////////\n    // beforeOperation - Collection\n    // /////////////////////////////////////\n\n    args = await buildBeforeOperation({\n      args,\n      collection: args.collection.config,\n      operation: 'readDistinct',\n      overrideAccess: args.overrideAccess!,\n    })\n\n    const {\n      collection: { config: collectionConfig },\n      disableErrors,\n      overrideAccess,\n      populate,\n      showHiddenFields = false,\n      trash = false,\n      where,\n    } = args\n\n    const req = args.req!\n    const { locale, payload } = req\n\n    // /////////////////////////////////////\n    // Access\n    // /////////////////////////////////////\n\n    let accessResult: AccessResult\n\n    if (!overrideAccess) {\n      accessResult = await executeAccess({ disableErrors, req }, collectionConfig.access.read)\n\n      // If errors are disabled, and access returns false, return empty results\n      if (accessResult === false) {\n        return {\n          hasNextPage: false,\n          hasPrevPage: false,\n          limit: args.limit || 0,\n          nextPage: null,\n          page: 1,\n          pagingCounter: 1,\n          prevPage: null,\n          totalDocs: 0,\n          totalPages: 0,\n          values: [],\n        }\n      }\n    }\n\n    // /////////////////////////////////////\n    // Find Distinct\n    // /////////////////////////////////////\n\n    let fullWhere = combineQueries(where!, accessResult!)\n    sanitizeWhereQuery({ fields: collectionConfig.flattenedFields, payload, where: fullWhere })\n\n    // Exclude trashed documents when trash: false\n    fullWhere = appendNonTrashedFilter({\n      enableTrash: collectionConfig.trash,\n      trash,\n      where: fullWhere,\n    })\n\n    await validateQueryPaths({\n      collectionConfig,\n      overrideAccess: overrideAccess!,\n      req,\n      where: where ?? {},\n    })\n\n    const fieldResult = getFieldByPath({\n      config: payload.config,\n      fields: collectionConfig.flattenedFields,\n      includeRelationships: true,\n      path: args.field,\n    })\n\n    if (!fieldResult) {\n      throw new APIError(\n        `Field ${args.field} was not found in the collection ${collectionConfig.slug}`,\n        httpStatus.BAD_REQUEST,\n      )\n    }\n\n    if (fieldResult.field.hidden && !showHiddenFields) {\n      throw new Forbidden(req.t)\n    }\n\n    if (fieldResult.field.access?.read) {\n      const hasAccess = await fieldResult.field.access.read({ req })\n      if (!hasAccess) {\n        throw new Forbidden(req.t)\n      }\n    }\n\n    if ('virtual' in fieldResult.field && fieldResult.field.virtual) {\n      if (typeof fieldResult.field.virtual !== 'string') {\n        throw new APIError(\n          `Cannot findDistinct by a virtual field that isn't linked to a relationship field.`,\n        )\n      }\n\n      let relationPath: string = ''\n      let currentFields: FlattenedField[] = collectionConfig.flattenedFields\n      const fieldPathSegments = fieldResult.field.virtual.split('.')\n      for (const segment of fieldResult.field.virtual.split('.')) {\n        relationPath = `${relationPath}${segment}`\n        fieldPathSegments.shift()\n        const field = currentFields.find((e) => e.name === segment)!\n        if (\n          (field.type === 'relationship' || field.type === 'upload') &&\n          typeof field.relationTo === 'string'\n        ) {\n          break\n        }\n        if ('flattenedFields' in field) {\n          currentFields = field.flattenedFields\n        }\n      }\n\n      const path = `${relationPath}.${fieldPathSegments.join('.')}`\n\n      const result = await payload.findDistinct({\n        collection: collectionConfig.slug,\n        depth: args.depth,\n        disableErrors,\n        field: path,\n        limit: args.limit,\n        locale,\n        overrideAccess,\n        page: args.page,\n        populate,\n        req,\n        showHiddenFields,\n        sort: args.sort,\n        trash,\n        where,\n      })\n\n      for (const val of result.values) {\n        val[args.field] = val[path]\n        delete val[path]\n      }\n\n      return result\n    }\n\n    let result = await payload.db.findDistinct({\n      collection: collectionConfig.slug,\n      field: args.field,\n      limit: args.limit,\n      locale: locale!,\n      page: args.page,\n      req,\n      sort: args.sort,\n      where: fullWhere,\n    })\n\n    if (\n      (fieldResult.field.type === 'relationship' || fieldResult.field.type === 'upload') &&\n      args.depth\n    ) {\n      const populationPromises: Promise<void>[] = []\n      const sanitizedField = { ...fieldResult.field }\n      if (fieldResult.field.hasMany) {\n        sanitizedField.hasMany = false\n      }\n      for (const doc of result.values) {\n        populationPromises.push(\n          relationshipPopulationPromise({\n            currentDepth: 0,\n            depth: args.depth,\n            draft: false,\n            fallbackLocale: req.fallbackLocale || null,\n            field: sanitizedField,\n            locale: req.locale || null,\n            overrideAccess: args.overrideAccess ?? true,\n            parentIsLocalized: false,\n            populate,\n            req,\n            showHiddenFields: false,\n            siblingDoc: doc,\n          }),\n        )\n      }\n      await Promise.all(populationPromises)\n    }\n\n    // /////////////////////////////////////\n    // afterOperation - Collection\n    // /////////////////////////////////////\n\n    result = await buildAfterOperation({\n      args,\n      collection: collectionConfig,\n      operation: 'findDistinct',\n      overrideAccess,\n      result,\n    })\n\n    // /////////////////////////////////////\n    // Return results\n    // /////////////////////////////////////\n\n    return result\n  } catch (error: unknown) {\n    await killTransaction(args.req!)\n    throw error\n  }\n}\n"],"names":["httpStatus","executeAccess","combineQueries","validateQueryPaths","sanitizeWhereQuery","APIError","Forbidden","relationshipPopulationPromise","appendNonTrashedFilter","getFieldByPath","killTransaction","buildAfterOperation","buildBeforeOperation","findDistinctOperation","incomingArgs","args","collection","config","operation","overrideAccess","collectionConfig","disableErrors","populate","showHiddenFields","trash","where","req","locale","payload","accessResult","access","read","hasNextPage","hasPrevPage","limit","nextPage","page","pagingCounter","prevPage","totalDocs","totalPages","values","fullWhere","fields","flattenedFields","enableTrash","fieldResult","includeRelationships","path","field","slug","BAD_REQUEST","hidden","t","hasAccess","virtual","relationPath","currentFields","fieldPathSegments","split","segment","shift","find","e","name","type","relationTo","join","result","findDistinct","depth","sort","val","db","populationPromises","sanitizedField","hasMany","doc","push","currentDepth","draft","fallbackLocale","parentIsLocalized","siblingDoc","Promise","all","error"],"mappings":"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"}},
    {"offset": {"line": 2328, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/collections/operations/local/findDistinct.ts"],"sourcesContent":["import type {\n  CollectionSlug,\n  DataFromCollectionSlug,\n  Document,\n  PaginatedDistinctDocs,\n  Payload,\n  PayloadRequest,\n  PopulateType,\n  RequestContext,\n  Sort,\n  TypedLocale,\n  Where,\n} from '../../../index.js'\nimport type { CreateLocalReqOptions } from '../../../utilities/createLocalReq.js'\n\nimport { APIError, createLocalReq } from '../../../index.js'\nimport { findDistinctOperation } from '../findDistinct.js'\n\nexport type Options<\n  TSlug extends CollectionSlug,\n  TField extends keyof DataFromCollectionSlug<TSlug>,\n> = {\n  /**\n   * the Collection slug to operate against.\n   */\n  collection: TSlug\n  /**\n   * [Context](https://payloadcms.com/docs/hooks/context), which will then be passed to `context` and `req.context`,\n   * which can be read by hooks. Useful if you want to pass additional information to the hooks which\n   * shouldn't be necessarily part of the document, for example a `triggerBeforeChange` option which can be read by the BeforeChange hook\n   * to determine if it should run or not.\n   */\n  context?: RequestContext\n  /**\n   * [Control auto-population](https://payloadcms.com/docs/queries/depth) of nested relationship and upload fields.\n   */\n  depth?: number\n  /**\n   * When set to `true`, errors will not be thrown.\n   */\n  disableErrors?: boolean\n  /**\n   * The field to get distinct values for\n   */\n  field: ({} & string) | TField\n  /**\n   * The maximum distinct field values to be returned.\n   * By default the operation returns all the values.\n   */\n  limit?: number\n  /**\n   * Specify [locale](https://payloadcms.com/docs/configuration/localization) for any returned documents.\n   */\n  locale?: 'all' | TypedLocale\n  /**\n   * Skip access control.\n   * Set to `false` if you want to respect Access Control for the operation, for example when fetching data for the front-end.\n   * @default true\n   */\n  overrideAccess?: boolean\n  /**\n   * Get a specific page number (if limit is specified)\n   * @default 1\n   */\n  page?: number\n  /**\n   * Specify [populate](https://payloadcms.com/docs/queries/select#populate) to control which fields to include to the result from populated documents.\n   */\n  populate?: PopulateType\n  /**\n   * The `PayloadRequest` object. You can pass it to thread the current [transaction](https://payloadcms.com/docs/database/transactions), user and locale to the operation.\n   * Recommended to pass when using the Local API from hooks, as usually you want to execute the operation within the current transaction.\n   */\n  req?: Partial<PayloadRequest>\n  /**\n   * Opt-in to receiving hidden fields. By default, they are hidden from returned documents in accordance to your config.\n   * @default false\n   */\n  showHiddenFields?: boolean\n  /**\n   * Sort the documents, can be a string or an array of strings\n   * @example '-createdAt' // Sort DESC by createdAt\n   * @example ['group', '-createdAt'] // sort by 2 fields, ASC group and DESC createdAt\n   */\n  sort?: Sort\n  /**\n   * When set to `true`, the query will include both normal and trashed documents.\n   * To query only trashed documents, pass `trash: true` and combine with a `where` clause filtering by `deletedAt`.\n   * By default (`false`), the query will only include normal documents and exclude those with a `deletedAt` field.\n   *\n   * This argument has no effect unless `trash` is enabled on the collection.\n   * @default false\n   */\n  trash?: boolean\n  /**\n   * If you set `overrideAccess` to `false`, you can pass a user to use against the access control checks.\n   */\n  user?: Document\n  /**\n   * A filter [query](https://payloadcms.com/docs/queries/overview)\n   */\n  where?: Where\n}\n\nexport async function findDistinct<\n  TSlug extends CollectionSlug,\n  TField extends keyof DataFromCollectionSlug<TSlug> & string,\n>(\n  payload: Payload,\n  options: Options<TSlug, TField>,\n): Promise<PaginatedDistinctDocs<Record<TField, DataFromCollectionSlug<TSlug>[TField]>>> {\n  const {\n    collection: collectionSlug,\n    depth = 0,\n    disableErrors,\n    field,\n    limit,\n    overrideAccess = true,\n    page,\n    populate,\n    showHiddenFields,\n    sort,\n    trash = false,\n    where,\n  } = options\n  const collection = payload.collections[collectionSlug]\n\n  if (!collection) {\n    throw new APIError(\n      `The collection with slug ${String(collectionSlug)} can't be found. Find Operation.`,\n    )\n  }\n\n  return findDistinctOperation({\n    collection,\n    depth,\n    disableErrors,\n    field,\n    limit,\n    overrideAccess,\n    page,\n    populate,\n    req: await createLocalReq(options as CreateLocalReqOptions, payload),\n    showHiddenFields,\n    sort,\n    trash,\n    where,\n  }) as Promise<PaginatedDistinctDocs<Record<TField, DataFromCollectionSlug<TSlug>[TField]>>>\n}\n"],"names":["APIError","createLocalReq","findDistinctOperation","findDistinct","payload","options","collection","collectionSlug","depth","disableErrors","field","limit","overrideAccess","page","populate","showHiddenFields","sort","trash","where","collections","String","req"],"mappings":";;;;;AAeA,SAASA,QAAQ,EAAEC,cAAc,QAAQ,oBAAmB;AAC5D,SAASC,qBAAqB,QAAQ,qBAAoB;;;AAwFnD,eAAeC,aAIpBC,OAAgB,EAChBC,OAA+B;IAE/B,MAAM,EACJC,YAAYC,cAAc,EAC1BC,QAAQ,CAAC,EACTC,aAAa,EACbC,KAAK,EACLC,KAAK,EACLC,iBAAiB,IAAI,EACrBC,IAAI,EACJC,QAAQ,EACRC,gBAAgB,EAChBC,IAAI,EACJC,QAAQ,KAAK,EACbC,KAAK,EACN,GAAGb;IACJ,MAAMC,aAAaF,QAAQe,WAAW,CAACZ,eAAe;IAEtD,IAAI,CAACD,YAAY;QACf,MAAM,IAAIN,mKAAAA,CACR,CAAC,yBAAyB,EAAEoB,OAAOb,gBAAgB,gCAAgC,CAAC;IAExF;IAEA,WAAOL,uMAAAA,EAAsB;QAC3BI;QACAE;QACAC;QACAC;QACAC;QACAC;QACAC;QACAC;QACAO,KAAK,UAAMpB,kLAAAA,EAAeI,SAAkCD;QAC5DW;QACAC;QACAC;QACAC;IACF;AACF"}},
    {"offset": {"line": 2363, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/collections/operations/findVersionByID.ts"],"sourcesContent":["import { status as httpStatus } from 'http-status'\n\nimport type { FindOptions } from '../../index.js'\nimport type { PayloadRequest, PopulateType, SelectType } from '../../types/index.js'\nimport type { TypeWithVersion } from '../../versions/types.js'\nimport type { Collection, TypeWithID } from '../config/types.js'\n\nimport { executeAccess } from '../../auth/executeAccess.js'\nimport { combineQueries } from '../../database/combineQueries.js'\nimport { APIError, Forbidden, NotFound } from '../../errors/index.js'\nimport { afterRead } from '../../fields/hooks/afterRead/index.js'\nimport { appendNonTrashedFilter } from '../../utilities/appendNonTrashedFilter.js'\nimport { killTransaction } from '../../utilities/killTransaction.js'\nimport { sanitizeSelect } from '../../utilities/sanitizeSelect.js'\nimport { buildVersionCollectionFields } from '../../versions/buildCollectionFields.js'\nimport { getQueryDraftsSelect } from '../../versions/drafts/getQueryDraftsSelect.js'\nimport { buildAfterOperation } from './utilities/buildAfterOperation.js'\nimport { buildBeforeOperation } from './utilities/buildBeforeOperation.js'\n\nexport type Arguments = {\n  collection: Collection\n  currentDepth?: number\n  depth?: number\n  disableErrors?: boolean\n  id: number | string\n  overrideAccess?: boolean\n  populate?: PopulateType\n  req: PayloadRequest\n  showHiddenFields?: boolean\n  trash?: boolean\n} & Pick<FindOptions<string, SelectType>, 'select'>\n\nexport const findVersionByIDOperation = async <TData extends TypeWithID = any>(\n  args: Arguments,\n): Promise<TypeWithVersion<TData>> => {\n  const {\n    id,\n    collection: { config: collectionConfig },\n    currentDepth,\n    depth,\n    disableErrors,\n    overrideAccess,\n    populate,\n    req: { fallbackLocale, locale, payload },\n    req,\n    select: incomingSelect,\n    showHiddenFields,\n    trash = false,\n  } = args\n\n  if (!id) {\n    throw new APIError('Missing ID of version.', httpStatus.BAD_REQUEST)\n  }\n\n  try {\n    // /////////////////////////////////////\n    // beforeOperation - Collection\n    // /////////////////////////////////////\n\n    args = await buildBeforeOperation({\n      args,\n      collection: collectionConfig,\n      operation: 'findVersionByID',\n      overrideAccess,\n    })\n\n    // /////////////////////////////////////\n    // Access\n    // /////////////////////////////////////\n\n    const accessResults = !overrideAccess\n      ? await executeAccess({ id, disableErrors, req }, collectionConfig.access.readVersions)\n      : true\n\n    // If errors are disabled, and access returns false, return null\n    if (accessResults === false) {\n      return null!\n    }\n\n    const hasWhereAccess = typeof accessResults === 'object'\n\n    const where = { id: { equals: id } }\n\n    let fullWhere = combineQueries(where, accessResults)\n\n    fullWhere = appendNonTrashedFilter({\n      deletedAtPath: 'version.deletedAt',\n      enableTrash: collectionConfig.trash,\n      trash,\n      where: fullWhere,\n    })\n\n    // /////////////////////////////////////\n    // Find by ID\n    // /////////////////////////////////////\n\n    const select = sanitizeSelect({\n      fields: buildVersionCollectionFields(payload.config, collectionConfig, true),\n      forceSelect: getQueryDraftsSelect({ select: collectionConfig.forceSelect }),\n      select: incomingSelect,\n      versions: true,\n    })\n\n    const versionsQuery = await payload.db.findVersions<TData>({\n      collection: collectionConfig.slug,\n      limit: 1,\n      locale: locale!,\n      pagination: false,\n      req,\n      select,\n      where: fullWhere,\n    })\n\n    let result = versionsQuery.docs[0]!\n\n    if (!result) {\n      if (!disableErrors) {\n        if (!hasWhereAccess) {\n          throw new NotFound(req.t)\n        }\n        if (hasWhereAccess) {\n          throw new Forbidden(req.t)\n        }\n      }\n\n      return null!\n    }\n\n    if (!result.version) {\n      // Fallback if not selected\n      ;(result as any).version = {}\n    }\n\n    // /////////////////////////////////////\n    // beforeRead - Collection\n    // /////////////////////////////////////\n\n    if (collectionConfig.hooks?.beforeRead?.length) {\n      for (const hook of collectionConfig.hooks.beforeRead) {\n        result.version =\n          (await hook({\n            collection: collectionConfig,\n            context: req.context,\n            doc: result.version,\n            overrideAccess,\n            query: fullWhere,\n            req,\n          })) || result.version\n      }\n    }\n\n    // /////////////////////////////////////\n    // afterRead - Fields\n    // /////////////////////////////////////\n\n    result.version = await afterRead({\n      collection: collectionConfig,\n      context: req.context,\n      currentDepth,\n      depth: depth!,\n      doc: result.version,\n      // @ts-expect-error - vestiges of when tsconfig was not strict. Feel free to improve\n      draft: undefined,\n      fallbackLocale: fallbackLocale!,\n      global: null,\n      locale: locale!,\n      overrideAccess: overrideAccess!,\n      populate,\n      req,\n      select: typeof select?.version === 'object' ? select.version : undefined,\n      showHiddenFields: showHiddenFields!,\n    })\n\n    // /////////////////////////////////////\n    // afterRead - Collection\n    // /////////////////////////////////////\n\n    if (collectionConfig.hooks?.afterRead?.length) {\n      for (const hook of collectionConfig.hooks.afterRead) {\n        result.version =\n          (await hook({\n            collection: collectionConfig,\n            context: req.context,\n            doc: result.version,\n            overrideAccess,\n            query: fullWhere,\n            req,\n          })) || result.version\n      }\n    }\n\n    // /////////////////////////////////////\n    // afterOperation - Collection\n    // /////////////////////////////////////\n\n    result = await buildAfterOperation({\n      args,\n      collection: collectionConfig,\n      operation: 'findVersionByID',\n      overrideAccess,\n      result,\n    })\n\n    // /////////////////////////////////////\n    // Return results\n    // /////////////////////////////////////\n\n    return result\n  } catch (error: unknown) {\n    await killTransaction(req)\n    throw error\n  }\n}\n"],"names":["status","httpStatus","executeAccess","combineQueries","APIError","Forbidden","NotFound","afterRead","appendNonTrashedFilter","killTransaction","sanitizeSelect","buildVersionCollectionFields","getQueryDraftsSelect","buildAfterOperation","buildBeforeOperation","findVersionByIDOperation","args","id","collection","config","collectionConfig","currentDepth","depth","disableErrors","overrideAccess","populate","req","fallbackLocale","locale","payload","select","incomingSelect","showHiddenFields","trash","BAD_REQUEST","operation","accessResults","access","readVersions","hasWhereAccess","where","equals","fullWhere","deletedAtPath","enableTrash","fields","forceSelect","versions","versionsQuery","db","findVersions","slug","limit","pagination","result","docs","t","version","hooks","beforeRead","length","hook","context","doc","query","draft","undefined","global","error"],"mappings":"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"}},
    {"offset": {"line": 2544, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/collections/operations/local/findVersionByID.ts"],"sourcesContent":["import type {\n  CollectionSlug,\n  FindOptions,\n  Payload,\n  RequestContext,\n  TypedLocale,\n} from '../../../index.js'\nimport type { Document, PayloadRequest, PopulateType, SelectType } from '../../../types/index.js'\nimport type { CreateLocalReqOptions } from '../../../utilities/createLocalReq.js'\nimport type { TypeWithVersion } from '../../../versions/types.js'\nimport type {\n  DataFromCollectionSlug,\n  DraftFlagFromCollectionSlug,\n} from '../../config/types.js'\n\nimport { APIError } from '../../../errors/index.js'\nimport { createLocalReq } from '../../../utilities/createLocalReq.js'\nimport { findVersionByIDOperation } from '../findVersionByID.js'\n\ntype BaseOptions<TSlug extends CollectionSlug> = {\n  /**\n   * the Collection slug to operate against.\n   */\n  collection: TSlug\n  /**\n   * [Context](https://payloadcms.com/docs/hooks/context), which will then be passed to `context` and `req.context`,\n   * which can be read by hooks. Useful if you want to pass additional information to the hooks which\n   * shouldn't be necessarily part of the document, for example a `triggerBeforeChange` option which can be read by the BeforeChange hook\n   * to determine if it should run or not.\n   */\n  context?: RequestContext\n  /**\n   * [Control auto-population](https://payloadcms.com/docs/queries/depth) of nested relationship and upload fields.\n   */\n  depth?: number\n  /**\n   * When set to `true`, errors will not be thrown.\n   * `null` will be returned instead, if the document on this ID was not found.\n   */\n  disableErrors?: boolean\n  /**\n   * Specify a [fallback locale](https://payloadcms.com/docs/configuration/localization) to use for any returned documents.\n   */\n  fallbackLocale?: false | TypedLocale\n  /**\n   * The ID of the version to find.\n   */\n  id: string\n  /**\n   * Specify [locale](https://payloadcms.com/docs/configuration/localization) for any returned documents.\n   */\n  locale?: 'all' | TypedLocale\n  /**\n   * Skip access control.\n   * Set to `false` if you want to respect Access Control for the operation, for example when fetching data for the front-end.\n   * @default true\n   */\n  overrideAccess?: boolean\n  /**\n   * Specify [populate](https://payloadcms.com/docs/queries/select#populate) to control which fields to include to the result from populated documents.\n   */\n  populate?: PopulateType\n  /**\n   * The `PayloadRequest` object. You can pass it to thread the current [transaction](https://payloadcms.com/docs/database/transactions), user and locale to the operation.\n   * Recommended to pass when using the Local API from hooks, as usually you want to execute the operation within the current transaction.\n   */\n  req?: Partial<PayloadRequest>\n  /**\n   * Opt-in to receiving hidden fields. By default, they are hidden from returned documents in accordance to your config.\n   * @default false\n   */\n  showHiddenFields?: boolean\n  /**\n   * When set to `true`, the operation will return a document by ID, even if it is trashed (soft-deleted).\n   * By default (`false`), the operation will exclude trashed documents.\n   * To fetch a trashed document, set `trash: true`.\n   *\n   * This argument has no effect unless `trash` is enabled on the collection.\n   * @default false\n   */\n  trash?: boolean\n  /**\n   * If you set `overrideAccess` to `false`, you can pass a user to use against the access control checks.\n   */\n  user?: Document\n} & Pick<FindOptions<TSlug, SelectType>, 'select'>\n\nexport type Options<TSlug extends CollectionSlug> =\n  BaseOptions<TSlug> & DraftFlagFromCollectionSlug<TSlug>\n\nexport async function findVersionByIDLocal<TSlug extends CollectionSlug>(\n  payload: Payload,\n  options: Options<TSlug>,\n): Promise<TypeWithVersion<DataFromCollectionSlug<TSlug>>> {\n  const {\n    id,\n    collection: collectionSlug,\n    depth,\n    disableErrors = false,\n    overrideAccess = true,\n    populate,\n    select,\n    showHiddenFields,\n    trash = false,\n  } = options\n\n  const collection = payload.collections[collectionSlug]\n\n  if (!collection) {\n    throw new APIError(\n      `The collection with slug ${String(\n        collectionSlug,\n      )} can't be found. Find Version By ID Operation.`,\n    )\n  }\n\n  return findVersionByIDOperation({\n    id,\n    collection,\n    depth,\n    disableErrors,\n    overrideAccess,\n    populate,\n    req: await createLocalReq(options as CreateLocalReqOptions, payload),\n    select,\n    showHiddenFields,\n    trash,\n  })\n}\n"],"names":["APIError","createLocalReq","findVersionByIDOperation","findVersionByIDLocal","payload","options","id","collection","collectionSlug","depth","disableErrors","overrideAccess","populate","select","showHiddenFields","trash","collections","String","req"],"mappings":";;;;AAeA,SAASA,QAAQ,QAAQ,2BAA0B;AACnD,SAASC,cAAc,QAAQ,uCAAsC;AACrE,SAASC,wBAAwB,QAAQ,wBAAuB;;;;AAyEzD,eAAeC,qBACpBC,OAAgB,EAChBC,OAAuB;IAEvB,MAAM,EACJC,EAAE,EACFC,YAAYC,cAAc,EAC1BC,KAAK,EACLC,gBAAgB,KAAK,EACrBC,iBAAiB,IAAI,EACrBC,QAAQ,EACRC,MAAM,EACNC,gBAAgB,EAChBC,QAAQ,KAAK,EACd,GAAGV;IAEJ,MAAME,aAAaH,QAAQY,WAAW,CAACR,eAAe;IAEtD,IAAI,CAACD,YAAY;QACf,MAAM,IAAIP,mKAAAA,CACR,CAAC,yBAAyB,EAAEiB,OAC1BT,gBACA,8CAA8C,CAAC;IAErD;IAEA,WAAON,6MAAAA,EAAyB;QAC9BI;QACAC;QACAE;QACAC;QACAC;QACAC;QACAM,KAAK,UAAMjB,kLAAAA,EAAeI,SAAkCD;QAC5DS;QACAC;QACAC;IACF;AACF"}},
    {"offset": {"line": 2577, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/collections/operations/findVersions.ts"],"sourcesContent":["import type { AccessResult } from '../../config/types.js'\nimport type { PaginatedDocs } from '../../database/types.js'\nimport type { PayloadRequest, PopulateType, SelectType, Sort, Where } from '../../types/index.js'\nimport type { TypeWithVersion } from '../../versions/types.js'\nimport type { Collection } from '../config/types.js'\nimport type { FindOptions } from './local/find.js'\n\nimport { executeAccess } from '../../auth/executeAccess.js'\nimport { combineQueries } from '../../database/combineQueries.js'\nimport { validateQueryPaths } from '../../database/queryValidation/validateQueryPaths.js'\nimport { sanitizeWhereQuery } from '../../database/sanitizeWhereQuery.js'\nimport { afterRead } from '../../fields/hooks/afterRead/index.js'\nimport { appendNonTrashedFilter } from '../../utilities/appendNonTrashedFilter.js'\nimport { killTransaction } from '../../utilities/killTransaction.js'\nimport { sanitizeInternalFields } from '../../utilities/sanitizeInternalFields.js'\nimport { sanitizeSelect } from '../../utilities/sanitizeSelect.js'\nimport { buildVersionCollectionFields } from '../../versions/buildCollectionFields.js'\nimport { getQueryDraftsSelect } from '../../versions/drafts/getQueryDraftsSelect.js'\nimport { buildAfterOperation } from './utilities/buildAfterOperation.js'\nimport { buildBeforeOperation } from './utilities/buildBeforeOperation.js'\n\nexport type Arguments = {\n  collection: Collection\n  depth?: number\n  limit?: number\n  overrideAccess?: boolean\n  page?: number\n  pagination?: boolean\n  populate?: PopulateType\n  req?: PayloadRequest\n  showHiddenFields?: boolean\n  sort?: Sort\n  trash?: boolean\n  where?: Where\n} & Pick<FindOptions<string, SelectType>, 'select'>\n\nexport const findVersionsOperation = async <TData extends TypeWithVersion<TData>>(\n  args: Arguments,\n): Promise<PaginatedDocs<TData>> => {\n  try {\n    // /////////////////////////////////////\n    // beforeOperation - Collection\n    // /////////////////////////////////////\n\n    args = await buildBeforeOperation({\n      args,\n      collection: args.collection.config,\n      operation: 'findVersions',\n      overrideAccess: args.overrideAccess!,\n    })\n\n    const {\n      collection: { config: collectionConfig },\n      depth,\n      limit,\n      overrideAccess,\n      page,\n      pagination = true,\n      populate,\n      select: incomingSelect,\n      showHiddenFields,\n      sort,\n      trash = false,\n      where,\n    } = args\n\n    const req = args.req!\n    const { fallbackLocale, locale, payload } = req\n\n    // /////////////////////////////////////\n    // Access\n    // /////////////////////////////////////\n\n    let accessResults!: AccessResult\n\n    if (!overrideAccess) {\n      accessResults = await executeAccess({ req }, collectionConfig.access.readVersions)\n    }\n\n    const versionFields = buildVersionCollectionFields(payload.config, collectionConfig, true)\n\n    await validateQueryPaths({\n      collectionConfig,\n      overrideAccess: overrideAccess!,\n      req,\n      versionFields,\n      where: where!,\n    })\n\n    let fullWhere = combineQueries(where!, accessResults)\n\n    // Exclude trashed documents when trash: false\n    fullWhere = appendNonTrashedFilter({\n      deletedAtPath: 'version.deletedAt',\n      enableTrash: collectionConfig.trash,\n      trash,\n      where: fullWhere,\n    })\n\n    sanitizeWhereQuery({ fields: versionFields, payload, where: fullWhere })\n\n    const select = sanitizeSelect({\n      fields: versionFields,\n      forceSelect: getQueryDraftsSelect({ select: collectionConfig.forceSelect }),\n      select: incomingSelect,\n      versions: true,\n    })\n\n    // /////////////////////////////////////\n    // Find\n    // /////////////////////////////////////\n\n    const usePagination = pagination && limit !== 0\n    const sanitizedLimit = limit ?? (usePagination ? 10 : 0)\n    const sanitizedPage = page || 1\n\n    const paginatedDocs = await payload.db.findVersions<TData>({\n      collection: collectionConfig.slug,\n      limit: sanitizedLimit,\n      locale: locale!,\n      page: sanitizedPage,\n      pagination,\n      req,\n      select,\n      sort,\n      where: fullWhere,\n    })\n\n    // /////////////////////////////////////\n    // beforeRead - Collection\n    // /////////////////////////////////////\n    let result: PaginatedDocs<TData> = paginatedDocs as unknown as PaginatedDocs<TData>\n    result.docs = (await Promise.all(\n      paginatedDocs.docs.map(async (doc) => {\n        const docRef = doc\n        // Fallback if not selected\n        if (!docRef.version) {\n          ;(docRef as any).version = {}\n        }\n\n        if (collectionConfig.hooks?.beforeRead?.length) {\n          for (const hook of collectionConfig.hooks.beforeRead) {\n            docRef.version =\n              (await hook({\n                collection: collectionConfig,\n                context: req.context,\n                doc: docRef.version,\n                overrideAccess,\n                query: fullWhere,\n                req,\n              })) || docRef.version\n          }\n        }\n\n        return docRef\n      }),\n    )) as TData[]\n    // /////////////////////////////////////\n    // afterRead - Fields\n    // /////////////////////////////////////\n\n    result.docs = await Promise.all(\n      result.docs.map(async (data) => {\n        data.version = await afterRead({\n          collection: collectionConfig,\n          context: req.context,\n          depth: depth!,\n          doc: data.version,\n          // @ts-expect-error - vestiges of when tsconfig was not strict. Feel free to improve\n          draft: undefined,\n          fallbackLocale: fallbackLocale!,\n          findMany: true,\n          global: null,\n          locale: locale!,\n          overrideAccess: overrideAccess!,\n          populate,\n          req,\n          select: typeof select?.version === 'object' ? select.version : undefined,\n          showHiddenFields: showHiddenFields!,\n        })\n        return data\n      }),\n    )\n\n    // /////////////////////////////////////\n    // afterRead - Collection\n    // /////////////////////////////////////\n\n    if (collectionConfig.hooks.afterRead?.length) {\n      result.docs = await Promise.all(\n        result.docs.map(async (doc) => {\n          const docRef = doc\n\n          for (const hook of collectionConfig.hooks.afterRead) {\n            docRef.version =\n              (await hook({\n                collection: collectionConfig,\n                context: req.context,\n                doc: doc.version,\n                findMany: true,\n                overrideAccess,\n                query: fullWhere,\n                req,\n              })) || doc.version\n          }\n\n          return docRef\n        }),\n      )\n    }\n\n    // /////////////////////////////////////\n    // Return results\n    // /////////////////////////////////////\n    result.docs = result.docs.map((doc) => sanitizeInternalFields<TData>(doc))\n\n    // /////////////////////////////////////\n    // afterOperation - Collection\n    // /////////////////////////////////////\n\n    result = await buildAfterOperation({\n      args,\n      collection: collectionConfig,\n      operation: 'findVersions',\n      overrideAccess,\n      result,\n    })\n\n    return result\n  } catch (error: unknown) {\n    await killTransaction(args.req!)\n    throw error\n  }\n}\n"],"names":["executeAccess","combineQueries","validateQueryPaths","sanitizeWhereQuery","afterRead","appendNonTrashedFilter","killTransaction","sanitizeInternalFields","sanitizeSelect","buildVersionCollectionFields","getQueryDraftsSelect","buildAfterOperation","buildBeforeOperation","findVersionsOperation","args","collection","config","operation","overrideAccess","collectionConfig","depth","limit","page","pagination","populate","select","incomingSelect","showHiddenFields","sort","trash","where","req","fallbackLocale","locale","payload","accessResults","access","readVersions","versionFields","fullWhere","deletedAtPath","enableTrash","fields","forceSelect","versions","usePagination","sanitizedLimit","sanitizedPage","paginatedDocs","db","findVersions","slug","result","docs","Promise","all","map","doc","docRef","version","hooks","beforeRead","length","hook","context","query","data","draft","undefined","findMany","global","error"],"mappings":"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"}},
    {"offset": {"line": 2768, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/collections/operations/local/findVersions.ts"],"sourcesContent":["import type { PaginatedDocs } from '../../../database/types.js'\nimport type {\n  CollectionSlug,\n  FindOptions,\n  Payload,\n  RequestContext,\n  TypedLocale,\n} from '../../../index.js'\nimport type {\n  Document,\n  PayloadRequest,\n  PopulateType,\n  SelectType,\n  Sort,\n  Where,\n} from '../../../types/index.js'\nimport type { CreateLocalReqOptions } from '../../../utilities/createLocalReq.js'\nimport type { TypeWithVersion } from '../../../versions/types.js'\nimport type {\n  DataFromCollectionSlug,\n  DraftFlagFromCollectionSlug,\n} from '../../config/types.js'\n\nimport { APIError } from '../../../errors/index.js'\nimport { createLocalReq } from '../../../utilities/createLocalReq.js'\nimport { findVersionsOperation } from '../findVersions.js'\n\ntype BaseOptions<TSlug extends CollectionSlug> = {\n  /**\n   * the Collection slug to operate against.\n   */\n  collection: TSlug\n  /**\n   * [Context](https://payloadcms.com/docs/hooks/context), which will then be passed to `context` and `req.context`,\n   * which can be read by hooks. Useful if you want to pass additional information to the hooks which\n   * shouldn't be necessarily part of the document, for example a `triggerBeforeChange` option which can be read by the BeforeChange hook\n   * to determine if it should run or not.\n   */\n  context?: RequestContext\n  /**\n   * [Control auto-population](https://payloadcms.com/docs/queries/depth) of nested relationship and upload fields.\n   */\n  depth?: number\n  /**\n   * Specify a [fallback locale](https://payloadcms.com/docs/configuration/localization) to use for any returned documents.\n   */\n  fallbackLocale?: false | TypedLocale\n  /**\n   * The maximum related documents to be returned.\n   * Defaults unless `defaultLimit` is specified for the collection config\n   * @default 10\n   */\n  limit?: number\n  /**\n   * Specify [locale](https://payloadcms.com/docs/configuration/localization) for any returned documents.\n   */\n  locale?: 'all' | TypedLocale\n  /**\n   * Skip access control.\n   * Set to `false` if you want to respect Access Control for the operation, for example when fetching data for the front-end.\n   * @default true\n   */\n  overrideAccess?: boolean\n  /**\n   * Get a specific page number\n   * @default 1\n   */\n  page?: number\n  /**\n   * Set to `false` to return all documents and avoid querying for document counts which introduces some overhead.\n   * You can also combine that property with a specified `limit` to limit documents but avoid the count query.\n   */\n  pagination?: boolean\n  /**\n   * Specify [populate](https://payloadcms.com/docs/queries/select#populate) to control which fields to include to the result from populated documents.\n   */\n  populate?: PopulateType\n  /**\n   * The `PayloadRequest` object. You can pass it to thread the current [transaction](https://payloadcms.com/docs/database/transactions), user and locale to the operation.\n   * Recommended to pass when using the Local API from hooks, as usually you want to execute the operation within the current transaction.\n   */\n  req?: Partial<PayloadRequest>\n  /**\n   * Opt-in to receiving hidden fields. By default, they are hidden from returned documents in accordance to your config.\n   * @default false\n   */\n  showHiddenFields?: boolean\n  /**\n   * Sort the documents, can be a string or an array of strings\n   * @example '-version.createdAt' // Sort DESC by createdAt\n   * @example ['version.group', '-version.createdAt'] // sort by 2 fields, ASC group and DESC createdAt\n   */\n  sort?: Sort\n  /**\n   * When set to `true`, the query will include both normal and trashed (soft-deleted) documents.\n   * To query only trashed documents, pass `trash: true` and combine with a `where` clause filtering by `deletedAt`.\n   * By default (`false`), the query will only include normal documents and exclude those with a `deletedAt` field.\n   *\n   * This argument has no effect unless `trash` is enabled on the collection.\n   * @default false\n   */\n  trash?: boolean\n  /**\n   * If you set `overrideAccess` to `false`, you can pass a user to use against the access control checks.\n   */\n  user?: Document\n  /**\n   * A filter [query](https://payloadcms.com/docs/queries/overview)\n   */\n  where?: Where\n} & Pick<FindOptions<TSlug, SelectType>, 'select'>\n\nexport type Options<TSlug extends CollectionSlug> =\n  BaseOptions<TSlug> & DraftFlagFromCollectionSlug<TSlug>\n\nexport async function findVersionsLocal<TSlug extends CollectionSlug>(\n  payload: Payload,\n  options: Options<TSlug>,\n): Promise<PaginatedDocs<TypeWithVersion<DataFromCollectionSlug<TSlug>>>> {\n  const {\n    collection: collectionSlug,\n    depth,\n    limit,\n    overrideAccess = true,\n    page,\n    pagination = true,\n    populate,\n    select,\n    showHiddenFields,\n    sort,\n    trash = false,\n    where,\n  } = options\n\n  const collection = payload.collections[collectionSlug]\n\n  if (!collection) {\n    throw new APIError(\n      `The collection with slug ${String(collectionSlug)} can't be found. Find Versions Operation.`,\n    )\n  }\n\n  return findVersionsOperation({\n    collection,\n    depth,\n    limit,\n    overrideAccess,\n    page,\n    pagination,\n    populate,\n    req: await createLocalReq(options as CreateLocalReqOptions, payload),\n    select,\n    showHiddenFields,\n    sort,\n    trash,\n    where,\n  })\n}\n"],"names":["APIError","createLocalReq","findVersionsOperation","findVersionsLocal","payload","options","collection","collectionSlug","depth","limit","overrideAccess","page","pagination","populate","select","showHiddenFields","sort","trash","where","collections","String","req"],"mappings":";;;;AAuBA,SAASA,QAAQ,QAAQ,2BAA0B;AACnD,SAASC,cAAc,QAAQ,uCAAsC;AACrE,SAASC,qBAAqB,QAAQ,qBAAoB;;;;AA0FnD,eAAeC,kBACpBC,OAAgB,EAChBC,OAAuB;IAEvB,MAAM,EACJC,YAAYC,cAAc,EAC1BC,KAAK,EACLC,KAAK,EACLC,iBAAiB,IAAI,EACrBC,IAAI,EACJC,aAAa,IAAI,EACjBC,QAAQ,EACRC,MAAM,EACNC,gBAAgB,EAChBC,IAAI,EACJC,QAAQ,KAAK,EACbC,KAAK,EACN,GAAGb;IAEJ,MAAMC,aAAaF,QAAQe,WAAW,CAACZ,eAAe;IAEtD,IAAI,CAACD,YAAY;QACf,MAAM,IAAIN,mKAAAA,CACR,CAAC,yBAAyB,EAAEoB,OAAOb,gBAAgB,yCAAyC,CAAC;IAEjG;IAEA,WAAOL,uMAAAA,EAAsB;QAC3BI;QACAE;QACAC;QACAC;QACAC;QACAC;QACAC;QACAQ,KAAK,UAAMpB,kLAAAA,EAAeI,SAAkCD;QAC5DU;QACAC;QACAC;QACAC;QACAC;IACF;AACF"}},
    {"offset": {"line": 2804, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/collections/operations/restoreVersion.ts"],"sourcesContent":["import { status as httpStatus } from 'http-status'\n\nimport type { FindOneArgs } from '../../database/types.js'\nimport type { JsonObject, PayloadRequest, PopulateType, SelectType } from '../../types/index.js'\nimport type { Collection, TypeWithID } from '../config/types.js'\nimport type { FindOptions } from './local/find.js'\n\nimport { executeAccess } from '../../auth/executeAccess.js'\nimport { hasWhereAccessResult } from '../../auth/types.js'\nimport { combineQueries } from '../../database/combineQueries.js'\nimport { APIError, Forbidden, NotFound } from '../../errors/index.js'\nimport { afterChange } from '../../fields/hooks/afterChange/index.js'\nimport { afterRead } from '../../fields/hooks/afterRead/index.js'\nimport { beforeChange } from '../../fields/hooks/beforeChange/index.js'\nimport { beforeValidate } from '../../fields/hooks/beforeValidate/index.js'\nimport { commitTransaction } from '../../utilities/commitTransaction.js'\nimport { deepCopyObjectSimple } from '../../utilities/deepCopyObject.js'\nimport { hasDraftValidationEnabled } from '../../utilities/getVersionsConfig.js'\nimport { initTransaction } from '../../utilities/initTransaction.js'\nimport { killTransaction } from '../../utilities/killTransaction.js'\nimport { sanitizeSelect } from '../../utilities/sanitizeSelect.js'\nimport { getLatestCollectionVersion } from '../../versions/getLatestCollectionVersion.js'\nimport { saveVersion } from '../../versions/saveVersion.js'\nimport { buildAfterOperation } from './utilities/buildAfterOperation.js'\nimport { buildBeforeOperation } from './utilities/buildBeforeOperation.js'\nexport type Arguments = {\n  collection: Collection\n  currentDepth?: number\n  depth?: number\n  disableErrors?: boolean\n  disableTransaction?: boolean\n  draft?: boolean\n  id: number | string\n  overrideAccess?: boolean\n  populate?: PopulateType\n  req: PayloadRequest\n  showHiddenFields?: boolean\n} & Pick<FindOptions<string, SelectType>, 'select'>\n\nexport const restoreVersionOperation = async <\n  TData extends JsonObject & TypeWithID = JsonObject & TypeWithID,\n>(\n  args: Arguments,\n): Promise<TData> => {\n  const {\n    id,\n    collection: { config: collectionConfig },\n    depth,\n    draft: draftArg = false,\n    overrideAccess = false,\n    populate,\n    req,\n    req: { fallbackLocale, locale, payload },\n    select: incomingSelect,\n    showHiddenFields,\n  } = args\n\n  try {\n    const shouldCommit = !args.disableTransaction && (await initTransaction(args.req))\n\n    // /////////////////////////////////////\n    // beforeOperation - Collection\n    // /////////////////////////////////////\n\n    args = await buildBeforeOperation({\n      args,\n      collection: args.collection.config,\n      operation: 'restoreVersion',\n      overrideAccess,\n    })\n\n    if (!id) {\n      throw new APIError('Missing ID of version to restore.', httpStatus.BAD_REQUEST)\n    }\n\n    // /////////////////////////////////////\n    // Retrieve original raw version\n    // /////////////////////////////////////\n\n    const { docs: versionDocs } = await req.payload.db.findVersions({\n      collection: collectionConfig.slug,\n      limit: 1,\n      locale: locale!,\n      pagination: false,\n      req,\n      where: { id: { equals: id } },\n    })\n\n    const [rawVersionToRestore] = versionDocs\n\n    if (!rawVersionToRestore) {\n      throw new NotFound(req.t)\n    }\n\n    const { parent: parentDocID, version: versionToRestoreWithLocales } = rawVersionToRestore\n\n    // /////////////////////////////////////\n    // Access\n    // /////////////////////////////////////\n\n    const accessResults = !overrideAccess\n      ? await executeAccess({ id: parentDocID, req }, collectionConfig.access.update)\n      : true\n    const hasWherePolicy = hasWhereAccessResult(accessResults)\n\n    // /////////////////////////////////////\n    // Retrieve document\n    // /////////////////////////////////////\n\n    const findOneArgs: FindOneArgs = {\n      collection: collectionConfig.slug,\n      locale: locale!,\n      req,\n      where: combineQueries({ id: { equals: parentDocID } }, accessResults),\n    }\n\n    // Get the document from the non versioned collection\n    const doc = await req.payload.db.findOne<TData>(findOneArgs)\n\n    if (!doc && !hasWherePolicy) {\n      throw new NotFound(req.t)\n    }\n    if (!doc && hasWherePolicy) {\n      throw new Forbidden(req.t)\n    }\n\n    if (collectionConfig.trash && doc?.deletedAt) {\n      throw new APIError(\n        `Cannot restore a version of a trashed document (ID: ${parentDocID}). Restore the document first.`,\n        httpStatus.FORBIDDEN,\n      )\n    }\n\n    // /////////////////////////////////////\n    // fetch previousDoc\n    // /////////////////////////////////////\n    const prevDocWithLocales = await getLatestCollectionVersion({\n      id: parentDocID,\n      config: collectionConfig,\n      payload,\n      query: findOneArgs,\n      req,\n    })\n\n    // originalDoc with hoisted localized data\n    const originalDoc = await afterRead({\n      collection: collectionConfig,\n      context: req.context,\n      depth: 0,\n      doc: deepCopyObjectSimple(prevDocWithLocales),\n      draft: draftArg,\n      fallbackLocale: null,\n      global: null,\n      locale: locale!,\n      overrideAccess: true,\n      req,\n      showHiddenFields: true,\n    })\n\n    // version data with hoisted localized data\n    const prevVersionDoc = await afterRead({\n      collection: collectionConfig,\n      context: req.context,\n      depth: 0,\n      doc: deepCopyObjectSimple(rawVersionToRestore.version),\n      draft: draftArg,\n      fallbackLocale: null,\n      global: null,\n      locale: locale!,\n      overrideAccess: true,\n      req,\n      showHiddenFields: true,\n    })\n\n    // /////////////////////////////////////\n    // beforeValidate - Fields\n    // /////////////////////////////////////\n\n    let data = await beforeValidate({\n      id: parentDocID,\n      collection: collectionConfig,\n      context: req.context,\n      data: deepCopyObjectSimple(prevVersionDoc),\n      doc: originalDoc,\n      global: null,\n      operation: 'update',\n      overrideAccess,\n      req,\n    })\n\n    // /////////////////////////////////////\n    // beforeValidate - Collection\n    // /////////////////////////////////////\n\n    if (collectionConfig.hooks?.beforeValidate?.length) {\n      for (const hook of collectionConfig.hooks.beforeValidate) {\n        data =\n          (await hook({\n            collection: collectionConfig,\n            context: req.context,\n            data,\n            operation: 'update',\n            originalDoc,\n            req,\n          })) || data\n      }\n    }\n\n    // /////////////////////////////////////\n    // beforeChange - Collection\n    // /////////////////////////////////////\n\n    if (collectionConfig.hooks?.beforeChange?.length) {\n      for (const hook of collectionConfig.hooks.beforeChange) {\n        data =\n          (await hook({\n            collection: collectionConfig,\n            context: req.context,\n            data,\n            operation: 'update',\n            originalDoc,\n            req,\n          })) || data\n      }\n    }\n\n    // /////////////////////////////////////\n    // beforeChange - Fields\n    // /////////////////////////////////////\n\n    let result = await beforeChange({\n      id: parentDocID,\n      collection: collectionConfig,\n      context: req.context,\n      data: { ...data, id: parentDocID },\n      doc: originalDoc,\n      docWithLocales: versionToRestoreWithLocales,\n      global: null,\n      operation: 'update',\n      overrideAccess,\n      req,\n      skipValidation: draftArg && !hasDraftValidationEnabled(collectionConfig),\n    })\n\n    // /////////////////////////////////////\n    // Update\n    // /////////////////////////////////////\n\n    const select = sanitizeSelect({\n      fields: collectionConfig.flattenedFields,\n      forceSelect: collectionConfig.forceSelect,\n      select: incomingSelect,\n    })\n\n    // Ensure updatedAt date is always updated\n    result.updatedAt = new Date().toISOString()\n    // Ensure status respects restoreAsDraft arg\n    result._status = draftArg ? 'draft' : result._status\n    if (!draftArg) {\n      result = await req.payload.db.updateOne({\n        id: parentDocID,\n        collection: collectionConfig.slug,\n        data: result,\n        req,\n        select,\n      })\n    }\n\n    // /////////////////////////////////////\n    // Save restored doc as a new version\n    // /////////////////////////////////////\n\n    result = await saveVersion({\n      id: parentDocID,\n      autosave: false,\n      collection: collectionConfig,\n      docWithLocales: result,\n      draft: draftArg,\n      operation: 'restoreVersion',\n      payload,\n      req,\n      select,\n    })\n\n    // /////////////////////////////////////\n    // afterRead - Fields\n    // /////////////////////////////////////\n\n    result = await afterRead({\n      collection: collectionConfig,\n      context: req.context,\n      depth: depth!,\n      doc: result,\n      // @ts-expect-error - vestiges of when tsconfig was not strict. Feel free to improve\n      draft: undefined,\n      fallbackLocale: fallbackLocale!,\n      global: null,\n      locale: locale!,\n      overrideAccess,\n      populate,\n      req,\n      select,\n      showHiddenFields: showHiddenFields!,\n    })\n\n    // /////////////////////////////////////\n    // afterRead - Collection\n    // /////////////////////////////////////\n\n    if (collectionConfig.hooks?.afterRead?.length) {\n      for (const hook of collectionConfig.hooks.afterRead) {\n        result =\n          (await hook({\n            collection: collectionConfig,\n            context: req.context,\n            doc: result,\n            overrideAccess,\n            req,\n          })) || result\n      }\n    }\n\n    // /////////////////////////////////////\n    // afterChange - Fields\n    // /////////////////////////////////////\n\n    result = await afterChange({\n      collection: collectionConfig,\n      context: req.context,\n      data: result,\n      doc: result,\n      global: null,\n      operation: 'update',\n      previousDoc: prevDocWithLocales,\n      req,\n    })\n\n    // /////////////////////////////////////\n    // afterChange - Collection\n    // /////////////////////////////////////\n\n    if (collectionConfig.hooks?.afterChange?.length) {\n      for (const hook of collectionConfig.hooks.afterChange) {\n        result =\n          (await hook({\n            collection: collectionConfig,\n            context: req.context,\n            data: result,\n            doc: result,\n            operation: 'update',\n            overrideAccess,\n            previousDoc: prevDocWithLocales,\n            req,\n          })) || result\n      }\n    }\n\n    // /////////////////////////////////////\n    // afterOperation - Collection\n    // /////////////////////////////////////\n\n    result = await buildAfterOperation({\n      args,\n      collection: collectionConfig,\n      operation: 'restoreVersion',\n      overrideAccess,\n      result,\n    })\n\n    if (shouldCommit) {\n      await commitTransaction(req)\n    }\n\n    return result\n  } catch (error: unknown) {\n    await killTransaction(req)\n    throw error\n  }\n}\n"],"names":["status","httpStatus","executeAccess","hasWhereAccessResult","combineQueries","APIError","Forbidden","NotFound","afterChange","afterRead","beforeChange","beforeValidate","commitTransaction","deepCopyObjectSimple","hasDraftValidationEnabled","initTransaction","killTransaction","sanitizeSelect","getLatestCollectionVersion","saveVersion","buildAfterOperation","buildBeforeOperation","restoreVersionOperation","args","id","collection","config","collectionConfig","depth","draft","draftArg","overrideAccess","populate","req","fallbackLocale","locale","payload","select","incomingSelect","showHiddenFields","shouldCommit","disableTransaction","operation","BAD_REQUEST","docs","versionDocs","db","findVersions","slug","limit","pagination","where","equals","rawVersionToRestore","t","parent","parentDocID","version","versionToRestoreWithLocales","accessResults","access","update","hasWherePolicy","findOneArgs","doc","findOne","trash","deletedAt","FORBIDDEN","prevDocWithLocales","query","originalDoc","context","global","prevVersionDoc","data","hooks","length","hook","result","docWithLocales","skipValidation","fields","flattenedFields","forceSelect","updatedAt","Date","toISOString","_status","updateOne","autosave","undefined","previousDoc","error"],"mappings":"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"}},
    {"offset": {"line": 3139, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/collections/operations/local/restoreVersion.ts"],"sourcesContent":["import type {\n  CollectionSlug,\n  FindOptions,\n  Payload,\n  RequestContext,\n  TypedLocale,\n} from '../../../index.js'\nimport type { Document, PayloadRequest, PopulateType, SelectType } from '../../../types/index.js'\nimport type { CreateLocalReqOptions } from '../../../utilities/createLocalReq.js'\nimport type {\n  DataFromCollectionSlug,\n  DraftFlagFromCollectionSlug,\n} from '../../config/types.js'\n\nimport { APIError } from '../../../errors/index.js'\nimport { createLocalReq } from '../../../utilities/createLocalReq.js'\nimport { restoreVersionOperation } from '../restoreVersion.js'\n\ntype BaseOptions<TSlug extends CollectionSlug> = {\n  /**\n   * the Collection slug to operate against.\n   */\n  collection: TSlug\n  /**\n   * [Context](https://payloadcms.com/docs/hooks/context), which will then be passed to `context` and `req.context`,\n   * which can be read by hooks. Useful if you want to pass additional information to the hooks which\n   * shouldn't be necessarily part of the document, for example a `triggerBeforeChange` option which can be read by the BeforeChange hook\n   * to determine if it should run or not.\n   */\n  context?: RequestContext\n  /**\n   * [Control auto-population](https://payloadcms.com/docs/queries/depth) of nested relationship and upload fields.\n   */\n  depth?: number\n  /**\n   * Specify a [fallback locale](https://payloadcms.com/docs/configuration/localization) to use for any returned documents.\n   */\n  fallbackLocale?: false | TypedLocale\n  /**\n   * The ID of the version to restore.\n   */\n  id: string\n  /**\n   * Specify [locale](https://payloadcms.com/docs/configuration/localization) for any returned documents.\n   */\n  locale?: TypedLocale\n  /**\n   * Skip access control.\n   * Set to `false` if you want to respect Access Control for the operation, for example when fetching data for the front-end.\n   * @default true\n   */\n  overrideAccess?: boolean\n  /**\n   * Specify [populate](https://payloadcms.com/docs/queries/select#populate) to control which fields to include to the result from populated documents.\n   */\n  populate?: PopulateType\n  /**\n   * The `PayloadRequest` object. You can pass it to thread the current [transaction](https://payloadcms.com/docs/database/transactions), user and locale to the operation.\n   * Recommended to pass when using the Local API from hooks, as usually you want to execute the operation within the current transaction.\n   */\n  req?: Partial<PayloadRequest>\n  /**\n   * Opt-in to receiving hidden fields. By default, they are hidden from returned documents in accordance to your config.\n   * @default false\n   */\n  showHiddenFields?: boolean\n  /**\n   * If you set `overrideAccess` to `false`, you can pass a user to use against the access control checks.\n   */\n  user?: Document\n} & Pick<FindOptions<TSlug, SelectType>, 'select'>\n\nexport type Options<TSlug extends CollectionSlug> =\n  BaseOptions<TSlug> & DraftFlagFromCollectionSlug<TSlug>\n\nexport async function restoreVersionLocal<TSlug extends CollectionSlug>(\n  payload: Payload,\n  options: Options<TSlug>,\n): Promise<DataFromCollectionSlug<TSlug>> {\n  const {\n    id,\n    collection: collectionSlug,\n    depth,\n    overrideAccess = true,\n    populate,\n    select,\n    showHiddenFields,\n  } = options\n\n  const collection = payload.collections[collectionSlug]\n\n  if (!collection) {\n    throw new APIError(\n      `The collection with slug ${String(\n        collectionSlug,\n      )} can't be found. Restore Version Operation.`,\n    )\n  }\n\n  const args = {\n    id,\n    collection,\n    depth,\n    overrideAccess,\n    payload,\n    populate,\n    req: await createLocalReq(options as CreateLocalReqOptions, payload),\n    select,\n    showHiddenFields,\n  }\n\n  return restoreVersionOperation(args)\n}\n"],"names":["APIError","createLocalReq","restoreVersionOperation","restoreVersionLocal","payload","options","id","collection","collectionSlug","depth","overrideAccess","populate","select","showHiddenFields","collections","String","args","req"],"mappings":";;;;AAcA,SAASA,QAAQ,QAAQ,2BAA0B;AACnD,SAASC,cAAc,QAAQ,uCAAsC;AACrE,SAASC,uBAAuB,QAAQ,uBAAsB;;;;AA2DvD,eAAeC,oBACpBC,OAAgB,EAChBC,OAAuB;IAEvB,MAAM,EACJC,EAAE,EACFC,YAAYC,cAAc,EAC1BC,KAAK,EACLC,iBAAiB,IAAI,EACrBC,QAAQ,EACRC,MAAM,EACNC,gBAAgB,EACjB,GAAGR;IAEJ,MAAME,aAAaH,QAAQU,WAAW,CAACN,eAAe;IAEtD,IAAI,CAACD,YAAY;QACf,MAAM,IAAIP,mKAAAA,CACR,CAAC,yBAAyB,EAAEe,OAC1BP,gBACA,2CAA2C,CAAC;IAElD;IAEA,MAAMQ,OAAO;QACXV;QACAC;QACAE;QACAC;QACAN;QACAO;QACAM,KAAK,UAAMhB,kLAAAA,EAAeI,SAAkCD;QAC5DQ;QACAC;IACF;IAEA,WAAOX,2MAAAA,EAAwBc;AACjC"}},
    {"offset": {"line": 3172, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/collections/operations/utilities/update.ts"],"sourcesContent":["import type { DeepPartial } from 'ts-essentials'\n\nimport type { Args } from '../../../fields/hooks/beforeChange/index.js'\nimport type {\n  CollectionSlug,\n  FileToSave,\n  SanitizedConfig,\n  TypedFallbackLocale,\n} from '../../../index.js'\nimport type {\n  JsonObject,\n  Payload,\n  PayloadRequest,\n  PopulateType,\n  SelectType,\n  TransformCollectionWithSelect,\n} from '../../../types/index.js'\nimport type {\n  DataFromCollectionSlug,\n  SanitizedCollectionConfig,\n  SelectFromCollectionSlug,\n  TypeWithID,\n} from '../../config/types.js'\n\nimport { ensureUsernameOrEmail } from '../../../auth/ensureUsernameOrEmail.js'\nimport { generatePasswordSaltHash } from '../../../auth/strategies/local/generatePasswordSaltHash.js'\nimport { afterChange } from '../../../fields/hooks/afterChange/index.js'\nimport { afterRead } from '../../../fields/hooks/afterRead/index.js'\nimport { beforeChange } from '../../../fields/hooks/beforeChange/index.js'\nimport { beforeValidate } from '../../../fields/hooks/beforeValidate/index.js'\nimport { deepCopyObjectSimple, getLatestCollectionVersion, saveVersion } from '../../../index.js'\nimport { deleteAssociatedFiles } from '../../../uploads/deleteAssociatedFiles.js'\nimport { uploadFiles } from '../../../uploads/uploadFiles.js'\nimport { checkDocumentLockStatus } from '../../../utilities/checkDocumentLockStatus.js'\nimport {\n  hasDraftsEnabled,\n  hasDraftValidationEnabled,\n  hasLocalizeStatusEnabled,\n} from '../../../utilities/getVersionsConfig.js'\nimport { mergeLocalizedData } from '../../../utilities/mergeLocalizedData.js'\nexport type SharedUpdateDocumentArgs<TSlug extends CollectionSlug> = {\n  autosave: boolean\n  collectionConfig: SanitizedCollectionConfig\n  config: SanitizedConfig\n  data: DeepPartial<DataFromCollectionSlug<TSlug>>\n  depth: number\n  docWithLocales: JsonObject & TypeWithID\n  draftArg: boolean\n  fallbackLocale: TypedFallbackLocale\n  filesToUpload: FileToSave[]\n  id: number | string\n  locale: string\n  overrideAccess: boolean\n  overrideLock: boolean\n  payload: Payload\n  populate?: PopulateType\n  publishAllLocales?: boolean\n  publishSpecificLocale?: string\n  req: PayloadRequest\n  select: SelectType\n  showHiddenFields: boolean\n  unpublishAllLocales?: boolean\n}\n\n/**\n * This function is used to update a document in the DB and return the result.\n *\n * It runs the following hooks in order:\n * - beforeValidate - Fields\n * - beforeValidate - Collection\n * - beforeChange - Collection\n * - beforeChange - Fields\n * - afterRead - Fields\n * - afterRead - Collection\n * - afterChange - Fields\n * - afterChange - Collection\n */\nexport const updateDocument = async <\n  TSlug extends CollectionSlug,\n  TSelect extends SelectFromCollectionSlug<TSlug> = SelectType,\n>({\n  id,\n  autosave,\n  collectionConfig,\n  config,\n  data,\n  depth,\n  docWithLocales,\n  draftArg,\n  fallbackLocale,\n  filesToUpload,\n  locale,\n  overrideAccess,\n  overrideLock,\n  payload,\n  populate,\n  publishAllLocales: publishAllLocalesArg,\n  publishSpecificLocale,\n  req,\n  select,\n  showHiddenFields,\n  unpublishAllLocales: unpublishAllLocalesArg,\n}: SharedUpdateDocumentArgs<TSlug>): Promise<TransformCollectionWithSelect<TSlug, TSelect>> => {\n  const password = data?.password\n  const publishAllLocales =\n    !draftArg &&\n    (publishAllLocalesArg ?? (hasLocalizeStatusEnabled(collectionConfig) ? false : true))\n  const unpublishAllLocales =\n    typeof unpublishAllLocalesArg === 'string'\n      ? unpublishAllLocalesArg === 'true'\n      : !!unpublishAllLocalesArg\n  const isSavingDraft =\n    Boolean(draftArg && hasDraftsEnabled(collectionConfig)) &&\n    data._status !== 'published' &&\n    !publishAllLocales\n  const shouldSavePassword = Boolean(\n    password &&\n      collectionConfig.auth &&\n      (!collectionConfig.auth.disableLocalStrategy ||\n        (typeof collectionConfig.auth.disableLocalStrategy === 'object' &&\n          collectionConfig.auth.disableLocalStrategy.enableFields)) &&\n      !isSavingDraft,\n  )\n\n  if (isSavingDraft) {\n    data._status = 'draft'\n  }\n\n  // /////////////////////////////////////\n  // Handle potentially locked documents\n  // /////////////////////////////////////\n\n  await checkDocumentLockStatus({\n    id,\n    collectionSlug: collectionConfig.slug,\n    lockErrorMessage: `Document with ID ${id} is currently locked by another user and cannot be updated.`,\n    overrideLock,\n    req,\n  })\n\n  const originalDoc = await afterRead({\n    collection: collectionConfig,\n    context: req.context,\n    depth: 0,\n    doc: deepCopyObjectSimple(docWithLocales),\n    draft: draftArg,\n    fallbackLocale: id ? null : fallbackLocale,\n    global: null,\n    locale,\n    overrideAccess: true,\n    req,\n    showHiddenFields: true,\n  })\n\n  const isRestoringDraftFromTrash = Boolean(originalDoc?.deletedAt) && data?._status !== 'published'\n\n  if (collectionConfig.auth) {\n    ensureUsernameOrEmail<TSlug>({\n      authOptions: collectionConfig.auth,\n      collectionSlug: collectionConfig.slug,\n      data,\n      operation: 'update',\n      originalDoc,\n      req,\n    })\n  }\n\n  // /////////////////////////////////////\n  // Delete any associated files\n  // /////////////////////////////////////\n\n  await deleteAssociatedFiles({\n    collectionConfig,\n    config,\n    doc: docWithLocales,\n    files: filesToUpload,\n    overrideDelete: false,\n    req,\n  })\n\n  // /////////////////////////////////////\n  // beforeValidate - Fields\n  // /////////////////////////////////////\n\n  data = await beforeValidate<DeepPartial<DataFromCollectionSlug<TSlug>>>({\n    id,\n    collection: collectionConfig,\n    context: req.context,\n    data,\n    doc: originalDoc,\n    global: null,\n    operation: 'update',\n    overrideAccess,\n    req,\n  })\n\n  // /////////////////////////////////////\n  // beforeValidate - Collection\n  // /////////////////////////////////////\n\n  if (collectionConfig.hooks?.beforeValidate?.length) {\n    for (const hook of collectionConfig.hooks.beforeValidate) {\n      data =\n        (await hook({\n          collection: collectionConfig,\n          context: req.context,\n          data,\n          operation: 'update',\n          originalDoc,\n          req,\n        })) || data\n    }\n  }\n\n  // /////////////////////////////////////\n  // Write files to local storage\n  // /////////////////////////////////////\n\n  if (!collectionConfig.upload.disableLocalStorage) {\n    await uploadFiles(payload, filesToUpload, req)\n  }\n\n  // /////////////////////////////////////\n  // beforeChange - Collection\n  // /////////////////////////////////////\n\n  if (collectionConfig.hooks?.beforeChange?.length) {\n    for (const hook of collectionConfig.hooks.beforeChange) {\n      data =\n        (await hook({\n          collection: collectionConfig,\n          context: req.context,\n          data,\n          operation: 'update',\n          originalDoc,\n          req,\n        })) || data\n    }\n  }\n\n  // /////////////////////////////////////\n  // beforeChange - Fields\n  // /////////////////////////////////////\n\n  const beforeChangeArgs: Args<DataFromCollectionSlug<TSlug>> = {\n    id,\n    collection: collectionConfig,\n    context: req.context,\n    data: { ...data, id },\n    doc: originalDoc,\n    docWithLocales,\n    global: null,\n    operation: 'update',\n    overrideAccess,\n    req,\n    skipValidation:\n      // only skip validation for drafts when draft validation is false\n      (isSavingDraft && !hasDraftValidationEnabled(collectionConfig)) ||\n      // Skip validation for trash operations since they're just metadata updates\n      (collectionConfig.trash && (Boolean(data?.deletedAt) || isRestoringDraftFromTrash)),\n  }\n\n  // /////////////////////////////////////\n  // Handle Localized Data Merging\n  // /////////////////////////////////////\n\n  let result: JsonObject = await beforeChange(beforeChangeArgs)\n  let snapshotToSave: JsonObject | undefined\n\n  if (config.localization && collectionConfig.versions) {\n    let snapshotData: JsonObject | undefined\n    let currentDoc\n\n    if (collectionConfig.versions.drafts && collectionConfig.versions.drafts.localizeStatus) {\n      if (publishAllLocales || unpublishAllLocales) {\n        let accessibleLocaleCodes = config.localization.localeCodes\n\n        if (config.localization.filterAvailableLocales) {\n          const filteredLocales = await config.localization.filterAvailableLocales({\n            locales: config.localization.locales,\n            req,\n          })\n          accessibleLocaleCodes = filteredLocales.map((locale) =>\n            typeof locale === 'string' ? locale : locale.code,\n          )\n        }\n\n        if (typeof result._status !== 'object' || result._status === null) {\n          result._status = {}\n        }\n\n        for (const localeCode of accessibleLocaleCodes) {\n          result._status[localeCode] = unpublishAllLocales ? 'draft' : 'published'\n        }\n      } else if (!isSavingDraft) {\n        // publishing a single locale\n        currentDoc = await payload.db.findOne<DataFromCollectionSlug<TSlug>>({\n          collection: collectionConfig.slug,\n          req,\n          where: { id: { equals: id } },\n        })\n        snapshotData = result\n      }\n    } else if (publishSpecificLocale) {\n      // previous way of publishing a single locale\n      currentDoc = await getLatestCollectionVersion({\n        id,\n        config: collectionConfig,\n        payload,\n        published: true,\n        query: {\n          collection: collectionConfig.slug,\n          locale: 'all',\n          req,\n          where: { id: { equals: id } },\n        },\n        req,\n      })\n      snapshotData = {\n        ...result,\n        _status: 'draft',\n      }\n    }\n\n    if (snapshotData) {\n      snapshotToSave = deepCopyObjectSimple(snapshotData || {})\n\n      result = mergeLocalizedData({\n        configBlockReferences: config.blocks,\n        dataWithLocales: result || {},\n        docWithLocales: currentDoc || {},\n        fields: collectionConfig.fields,\n        selectedLocales: [locale],\n      })\n    }\n  }\n\n  const dataToUpdate: JsonObject = { ...result }\n\n  // /////////////////////////////////////\n  // Handle potential password update\n  // /////////////////////////////////////\n\n  if (shouldSavePassword && typeof password === 'string') {\n    const { hash, salt } = await generatePasswordSaltHash({\n      collection: collectionConfig,\n      password,\n      req,\n    })\n    dataToUpdate.salt = salt\n    dataToUpdate.hash = hash\n    delete dataToUpdate.password\n    delete data.password\n  }\n\n  // /////////////////////////////////////\n  // Update\n  // /////////////////////////////////////\n\n  if (!isSavingDraft) {\n    // Ensure updatedAt date is always updated\n    dataToUpdate.updatedAt = new Date().toISOString()\n    result = await req.payload.db.updateOne({\n      id,\n      collection: collectionConfig.slug,\n      data: dataToUpdate,\n      locale,\n      req,\n    })\n  }\n\n  // /////////////////////////////////////\n  // Create version\n  // /////////////////////////////////////\n\n  if (collectionConfig.versions) {\n    result = await saveVersion({\n      id,\n      autosave,\n      collection: collectionConfig,\n      docWithLocales: result,\n      draft: isSavingDraft,\n      operation: 'update',\n      payload,\n      publishSpecificLocale,\n      req,\n      snapshot: snapshotToSave,\n    })\n  }\n\n  // /////////////////////////////////////\n  // afterRead - Fields\n  // /////////////////////////////////////\n\n  result = await afterRead({\n    collection: collectionConfig,\n    context: req.context,\n    depth,\n    doc: result,\n    draft: draftArg,\n    fallbackLocale,\n    global: null,\n    locale,\n    overrideAccess,\n    populate,\n    req,\n    select,\n    showHiddenFields,\n  })\n\n  // /////////////////////////////////////\n  // afterRead - Collection\n  // /////////////////////////////////////\n\n  if (collectionConfig.hooks?.afterRead?.length) {\n    for (const hook of collectionConfig.hooks.afterRead) {\n      result =\n        (await hook({\n          collection: collectionConfig,\n          context: req.context,\n          doc: result,\n          overrideAccess,\n          req,\n        })) || result\n    }\n  }\n\n  // /////////////////////////////////////\n  // afterChange - Fields\n  // /////////////////////////////////////\n\n  result = await afterChange({\n    collection: collectionConfig,\n    context: req.context,\n    data,\n    doc: result,\n    global: null,\n    operation: 'update',\n    previousDoc: originalDoc,\n    req,\n  })\n\n  // /////////////////////////////////////\n  // afterChange - Collection\n  // /////////////////////////////////////\n\n  if (collectionConfig.hooks?.afterChange?.length) {\n    for (const hook of collectionConfig.hooks.afterChange) {\n      result =\n        (await hook({\n          collection: collectionConfig,\n          context: req.context,\n          data,\n          doc: result,\n          operation: 'update',\n          overrideAccess,\n          previousDoc: originalDoc,\n          req,\n        })) || result\n    }\n  }\n\n  return result as TransformCollectionWithSelect<TSlug, TSelect>\n}\n"],"names":["ensureUsernameOrEmail","generatePasswordSaltHash","afterChange","afterRead","beforeChange","beforeValidate","deepCopyObjectSimple","getLatestCollectionVersion","saveVersion","deleteAssociatedFiles","uploadFiles","checkDocumentLockStatus","hasDraftsEnabled","hasDraftValidationEnabled","hasLocalizeStatusEnabled","mergeLocalizedData","updateDocument","id","autosave","collectionConfig","config","data","depth","docWithLocales","draftArg","fallbackLocale","filesToUpload","locale","overrideAccess","overrideLock","payload","populate","publishAllLocales","publishAllLocalesArg","publishSpecificLocale","req","select","showHiddenFields","unpublishAllLocales","unpublishAllLocalesArg","password","isSavingDraft","Boolean","_status","shouldSavePassword","auth","disableLocalStrategy","enableFields","collectionSlug","slug","lockErrorMessage","originalDoc","collection","context","doc","draft","global","isRestoringDraftFromTrash","deletedAt","authOptions","operation","files","overrideDelete","hooks","length","hook","upload","disableLocalStorage","beforeChangeArgs","skipValidation","trash","result","snapshotToSave","localization","versions","snapshotData","currentDoc","drafts","localizeStatus","accessibleLocaleCodes","localeCodes","filterAvailableLocales","filteredLocales","locales","map","code","localeCode","db","findOne","where","equals","published","query","configBlockReferences","blocks","dataWithLocales","fields","selectedLocales","dataToUpdate","hash","salt","updatedAt","Date","toISOString","updateOne","snapshot","previousDoc"],"mappings":"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"}},
    {"offset": {"line": 3516, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/collections/operations/update.ts"],"sourcesContent":["import type { DeepPartial } from 'ts-essentials'\n\nimport { status as httpStatus } from 'http-status'\n\nimport type { AccessResult } from '../../config/types.js'\nimport type { PayloadRequest, PopulateType, SelectType, Sort, Where } from '../../types/index.js'\nimport type {\n  BulkOperationResult,\n  Collection,\n  DataFromCollectionSlug,\n  RequiredDataFromCollectionSlug,\n  SelectFromCollectionSlug,\n} from '../config/types.js'\n\nimport { executeAccess } from '../../auth/executeAccess.js'\nimport { combineQueries } from '../../database/combineQueries.js'\nimport { validateQueryPaths } from '../../database/queryValidation/validateQueryPaths.js'\nimport { sanitizeWhereQuery } from '../../database/sanitizeWhereQuery.js'\nimport { APIError } from '../../errors/index.js'\nimport { type CollectionSlug, deepCopyObjectSimple, type FindOptions } from '../../index.js'\nimport { generateFileData } from '../../uploads/generateFileData.js'\nimport { unlinkTempFiles } from '../../uploads/unlinkTempFiles.js'\nimport { appendNonTrashedFilter } from '../../utilities/appendNonTrashedFilter.js'\nimport { commitTransaction } from '../../utilities/commitTransaction.js'\nimport { hasDraftsEnabled } from '../../utilities/getVersionsConfig.js'\nimport { initTransaction } from '../../utilities/initTransaction.js'\nimport { isErrorPublic } from '../../utilities/isErrorPublic.js'\nimport { killTransaction } from '../../utilities/killTransaction.js'\nimport { sanitizeSelect } from '../../utilities/sanitizeSelect.js'\nimport { buildVersionCollectionFields } from '../../versions/buildCollectionFields.js'\nimport { appendVersionToQueryKey } from '../../versions/drafts/appendVersionToQueryKey.js'\nimport { getQueryDraftsSort } from '../../versions/drafts/getQueryDraftsSort.js'\nimport { buildAfterOperation } from './utilities/buildAfterOperation.js'\nimport { buildBeforeOperation } from './utilities/buildBeforeOperation.js'\nimport { sanitizeSortQuery } from './utilities/sanitizeSortQuery.js'\nimport { updateDocument } from './utilities/update.js'\n\nexport type Arguments<TSlug extends CollectionSlug> = {\n  autosave?: boolean\n  collection: Collection\n  data: DeepPartial<RequiredDataFromCollectionSlug<TSlug>>\n  depth?: number\n  disableTransaction?: boolean\n  disableVerificationEmail?: boolean\n  draft?: boolean\n  limit?: number\n  overrideAccess?: boolean\n  overrideLock?: boolean\n  overwriteExistingFiles?: boolean\n  populate?: PopulateType\n  publishAllLocales?: boolean\n  publishSpecificLocale?: string\n  req: PayloadRequest\n  showHiddenFields?: boolean\n  /**\n   * Sort the documents, can be a string or an array of strings\n   * @example '-createdAt' // Sort DESC by createdAt\n   * @example ['group', '-createdAt'] // sort by 2 fields, ASC group and DESC createdAt\n   */\n  sort?: Sort\n  trash?: boolean\n  unpublishAllLocales?: boolean\n  where: Where\n} & Pick<FindOptions<TSlug, SelectType>, 'select'>\n\nexport const updateOperation = async <\n  TSlug extends CollectionSlug,\n  TSelect extends SelectFromCollectionSlug<TSlug>,\n>(\n  incomingArgs: Arguments<TSlug>,\n): Promise<BulkOperationResult<TSlug, TSelect>> => {\n  let args = incomingArgs\n\n  if (args.collection.config.disableBulkEdit && !args.overrideAccess) {\n    throw new APIError(`Collection ${args.collection.config.slug} has disabled bulk edit`, 403)\n  }\n\n  try {\n    const shouldCommit = !args.disableTransaction && (await initTransaction(args.req))\n\n    // /////////////////////////////////////\n    // beforeOperation - Collection\n    // /////////////////////////////////////\n\n    args = await buildBeforeOperation({\n      args,\n      collection: args.collection.config,\n      operation: 'update',\n      overrideAccess: args.overrideAccess!,\n    })\n\n    const {\n      autosave = false,\n      collection: { config: collectionConfig },\n      collection,\n      depth,\n      draft: draftArg = false,\n      limit = 0,\n      overrideAccess,\n      overrideLock,\n      overwriteExistingFiles = false,\n      populate,\n      publishAllLocales,\n      publishSpecificLocale,\n      req: {\n        fallbackLocale,\n        locale,\n        payload: { config },\n        payload,\n      },\n      req,\n      select: incomingSelect,\n      showHiddenFields,\n      sort: incomingSort,\n      trash = false,\n      unpublishAllLocales,\n      where,\n    } = args\n\n    if (!where) {\n      throw new APIError(\"Missing 'where' query of documents to update.\", httpStatus.BAD_REQUEST)\n    }\n\n    const { data: bulkUpdateData } = args\n    const shouldSaveDraft = Boolean(draftArg && hasDraftsEnabled(collectionConfig))\n\n    // /////////////////////////////////////\n    // Access\n    // /////////////////////////////////////\n\n    let accessResult: AccessResult\n    if (!overrideAccess) {\n      accessResult = await executeAccess({ req }, collectionConfig.access.update)\n    }\n\n    await validateQueryPaths({\n      collectionConfig,\n      overrideAccess: overrideAccess!,\n      req,\n      where,\n    })\n\n    // /////////////////////////////////////\n    // Retrieve documents\n    // /////////////////////////////////////\n\n    let fullWhere = combineQueries(where, accessResult!)\n\n    const isTrashAttempt =\n      collectionConfig.trash &&\n      typeof bulkUpdateData === 'object' &&\n      bulkUpdateData !== null &&\n      'deletedAt' in bulkUpdateData &&\n      bulkUpdateData.deletedAt != null\n\n    // Enforce delete access if performing a soft-delete (trash)\n    if (isTrashAttempt && !overrideAccess) {\n      const deleteAccessResult = await executeAccess({ req }, collectionConfig.access.delete)\n      fullWhere = combineQueries(fullWhere, deleteAccessResult)\n    }\n\n    // Exclude trashed documents when trash: false\n    fullWhere = appendNonTrashedFilter({\n      enableTrash: collectionConfig.trash,\n      trash,\n      where: fullWhere,\n    })\n\n    sanitizeWhereQuery({ fields: collectionConfig.flattenedFields, payload, where: fullWhere })\n\n    const sort = sanitizeSortQuery({\n      fields: collection.config.flattenedFields,\n      sort: incomingSort,\n    })\n\n    let docs\n\n    if (hasDraftsEnabled(collectionConfig) && shouldSaveDraft) {\n      const versionsWhere = appendVersionToQueryKey(fullWhere)\n\n      await validateQueryPaths({\n        collectionConfig: collection.config,\n        overrideAccess: overrideAccess!,\n        req,\n        versionFields: buildVersionCollectionFields(payload.config, collection.config, true),\n        where: appendVersionToQueryKey(where),\n      })\n\n      const query = await payload.db.queryDrafts<DataFromCollectionSlug<TSlug>>({\n        collection: collectionConfig.slug,\n        limit,\n        locale: locale!,\n        pagination: false,\n        req,\n        sort: getQueryDraftsSort({ collectionConfig, sort }),\n        where: versionsWhere,\n      })\n\n      docs = query.docs\n    } else {\n      const query = await payload.db.find({\n        collection: collectionConfig.slug,\n        limit,\n        locale: locale!,\n        pagination: false,\n        req,\n        sort,\n        where: fullWhere,\n      })\n\n      docs = query.docs\n    }\n\n    // /////////////////////////////////////\n    // Generate data for all files and sizes\n    // /////////////////////////////////////\n\n    const { data, files: filesToUpload } = await generateFileData({\n      collection,\n      config,\n      data: bulkUpdateData,\n      operation: 'update',\n      overwriteExistingFiles,\n      req,\n      throwOnMissingFile: false,\n    })\n\n    const errors: BulkOperationResult<TSlug, TSelect>['errors'] = []\n\n    const promises = docs.map(async (docWithLocales) => {\n      const { id } = docWithLocales\n\n      try {\n        // Each document gets its own transaction when singleTransaction is enabled\n        let docShouldCommit = false\n        if (req.payload.db.bulkOperationsSingleTransaction) {\n          docShouldCommit = await initTransaction(req)\n        }\n\n        const select = sanitizeSelect({\n          fields: collectionConfig.flattenedFields,\n          forceSelect: collectionConfig.forceSelect,\n          select: incomingSelect,\n        })\n\n        // ///////////////////////////////////////////////\n        // Update document, runs all document level hooks\n        // ///////////////////////////////////////////////\n        const updatedDoc = await updateDocument({\n          id,\n          autosave,\n          collectionConfig,\n          config,\n          data: deepCopyObjectSimple(data),\n          depth: depth!,\n          docWithLocales,\n          draftArg,\n          fallbackLocale: fallbackLocale!,\n          filesToUpload,\n          locale: locale!,\n          overrideAccess: overrideAccess!,\n          overrideLock: overrideLock!,\n          payload,\n          populate,\n          publishAllLocales,\n          publishSpecificLocale,\n          req,\n          select: select!,\n          showHiddenFields: showHiddenFields!,\n          unpublishAllLocales,\n        })\n\n        if (docShouldCommit) {\n          await commitTransaction(req)\n        }\n\n        return updatedDoc\n      } catch (error) {\n        const isPublic = error instanceof Error ? isErrorPublic(error, config) : false\n\n        if (req.payload.db.bulkOperationsSingleTransaction) {\n          await killTransaction(req)\n        }\n        errors.push({\n          id,\n          isPublic,\n          message: error instanceof Error ? error.message : 'Unknown error',\n        })\n      }\n      return null\n    })\n\n    await unlinkTempFiles({\n      collectionConfig,\n      config,\n      req,\n    })\n\n    // Process sequentially when using single transaction mode to avoid shared state issues\n    // Process in parallel when using one transaction for better performance\n    let awaitedDocs: (DataFromCollectionSlug<TSlug> | null)[]\n    if (req.payload.db.bulkOperationsSingleTransaction) {\n      awaitedDocs = []\n      for (const promise of promises) {\n        awaitedDocs.push(await promise)\n      }\n    } else {\n      awaitedDocs = await Promise.all(promises)\n    }\n\n    let result = {\n      docs: awaitedDocs.filter(Boolean),\n      errors,\n    }\n\n    // /////////////////////////////////////\n    // afterOperation - Collection\n    // /////////////////////////////////////\n\n    result = await buildAfterOperation({\n      args,\n      collection: collectionConfig,\n      operation: 'update',\n      overrideAccess,\n      // @ts-expect-error - vestiges of when tsconfig was not strict. Feel free to improve\n      result,\n    })\n\n    if (shouldCommit) {\n      await commitTransaction(req)\n    }\n\n    // @ts-expect-error - vestiges of when tsconfig was not strict. Feel free to improve\n    return result\n  } catch (error: unknown) {\n    await killTransaction(args.req)\n    throw error\n  }\n}\n"],"names":["status","httpStatus","executeAccess","combineQueries","validateQueryPaths","sanitizeWhereQuery","APIError","deepCopyObjectSimple","generateFileData","unlinkTempFiles","appendNonTrashedFilter","commitTransaction","hasDraftsEnabled","initTransaction","isErrorPublic","killTransaction","sanitizeSelect","buildVersionCollectionFields","appendVersionToQueryKey","getQueryDraftsSort","buildAfterOperation","buildBeforeOperation","sanitizeSortQuery","updateDocument","updateOperation","incomingArgs","args","collection","config","disableBulkEdit","overrideAccess","slug","shouldCommit","disableTransaction","req","operation","autosave","collectionConfig","depth","draft","draftArg","limit","overrideLock","overwriteExistingFiles","populate","publishAllLocales","publishSpecificLocale","fallbackLocale","locale","payload","select","incomingSelect","showHiddenFields","sort","incomingSort","trash","unpublishAllLocales","where","BAD_REQUEST","data","bulkUpdateData","shouldSaveDraft","Boolean","accessResult","access","update","fullWhere","isTrashAttempt","deletedAt","deleteAccessResult","delete","enableTrash","fields","flattenedFields","docs","versionsWhere","versionFields","query","db","queryDrafts","pagination","find","files","filesToUpload","throwOnMissingFile","errors","promises","map","docWithLocales","id","docShouldCommit","bulkOperationsSingleTransaction","forceSelect","updatedDoc","error","isPublic","Error","push","message","awaitedDocs","promise","Promise","all","result","filter"],"mappings":"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"}},
    {"offset": {"line": 3780, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/collections/operations/updateByID.ts"],"sourcesContent":["import type { DeepPartial } from 'ts-essentials'\n\nimport { status as httpStatus } from 'http-status'\n\nimport type { FindOneArgs } from '../../database/types.js'\nimport type {\n  PayloadRequest,\n  PopulateType,\n  SelectType,\n  TransformCollectionWithSelect,\n} from '../../types/index.js'\nimport type {\n  Collection,\n  RequiredDataFromCollectionSlug,\n  SelectFromCollectionSlug,\n  TypeWithID,\n} from '../config/types.js'\n\nimport { executeAccess } from '../../auth/executeAccess.js'\nimport { hasWhereAccessResult } from '../../auth/types.js'\nimport { combineQueries } from '../../database/combineQueries.js'\nimport { APIError, Forbidden, NotFound } from '../../errors/index.js'\nimport { type CollectionSlug, deepCopyObjectSimple, type FindOptions } from '../../index.js'\nimport { generateFileData } from '../../uploads/generateFileData.js'\nimport { unlinkTempFiles } from '../../uploads/unlinkTempFiles.js'\nimport { appendNonTrashedFilter } from '../../utilities/appendNonTrashedFilter.js'\nimport { commitTransaction } from '../../utilities/commitTransaction.js'\nimport { initTransaction } from '../../utilities/initTransaction.js'\nimport { killTransaction } from '../../utilities/killTransaction.js'\nimport { sanitizeSelect } from '../../utilities/sanitizeSelect.js'\nimport { getLatestCollectionVersion } from '../../versions/getLatestCollectionVersion.js'\nimport { buildAfterOperation } from './utilities/buildAfterOperation.js'\nimport { buildBeforeOperation } from './utilities/buildBeforeOperation.js'\nimport { updateDocument } from './utilities/update.js'\n\nexport type Arguments<TSlug extends CollectionSlug> = {\n  autosave?: boolean\n  collection: Collection\n  data: DeepPartial<RequiredDataFromCollectionSlug<TSlug>>\n  depth?: number\n  disableTransaction?: boolean\n  disableVerificationEmail?: boolean\n  draft?: boolean\n  id: number | string\n  overrideAccess?: boolean\n  overrideLock?: boolean\n  overwriteExistingFiles?: boolean\n  populate?: PopulateType\n  publishAllLocales?: boolean\n  publishSpecificLocale?: string\n  req: PayloadRequest\n  showHiddenFields?: boolean\n  trash?: boolean\n  unpublishAllLocales?: boolean\n} & Pick<FindOptions<TSlug, SelectType>, 'select'>\n\nexport const updateByIDOperation = async <\n  TSlug extends CollectionSlug,\n  TSelect extends SelectFromCollectionSlug<TSlug> = SelectType,\n>(\n  incomingArgs: Arguments<TSlug>,\n): Promise<TransformCollectionWithSelect<TSlug, TSelect>> => {\n  let args = incomingArgs\n\n  try {\n    const shouldCommit = !args.disableTransaction && (await initTransaction(args.req))\n\n    // /////////////////////////////////////\n    // beforeOperation - Collection\n    // /////////////////////////////////////\n\n    args = await buildBeforeOperation({\n      args,\n      collection: args.collection.config,\n      operation: 'update',\n      overrideAccess: args.overrideAccess!,\n    })\n\n    if (args.publishSpecificLocale) {\n      args.req.locale = args.publishSpecificLocale\n    }\n\n    const {\n      id,\n      autosave = false,\n      collection: { config: collectionConfig },\n      collection,\n      depth,\n      draft: draftArg = false,\n      overrideAccess,\n      overrideLock,\n      overwriteExistingFiles = false,\n      populate,\n      publishAllLocales,\n      publishSpecificLocale,\n      req: {\n        fallbackLocale,\n        locale,\n        payload: { config },\n        payload,\n      },\n      req,\n      select: incomingSelect,\n      showHiddenFields,\n      trash = false,\n      unpublishAllLocales,\n    } = args\n\n    if (!id) {\n      throw new APIError('Missing ID of document to update.', httpStatus.BAD_REQUEST)\n    }\n\n    const { data } = args\n\n    // /////////////////////////////////////\n    // Access\n    // /////////////////////////////////////\n\n    const accessResults = !overrideAccess\n      ? await executeAccess({ id, data, req }, collectionConfig.access.update)\n      : true\n    const hasWherePolicy = hasWhereAccessResult(accessResults)\n\n    // /////////////////////////////////////\n    // Retrieve document\n    // /////////////////////////////////////\n\n    const where = { id: { equals: id } }\n\n    let fullWhere = combineQueries(where, accessResults)\n\n    const isTrashAttempt =\n      collectionConfig.trash &&\n      typeof data === 'object' &&\n      data !== null &&\n      'deletedAt' in data &&\n      data.deletedAt != null\n\n    if (isTrashAttempt && !overrideAccess) {\n      const deleteAccessResult = await executeAccess({ req }, collectionConfig.access.delete)\n      fullWhere = combineQueries(fullWhere, deleteAccessResult)\n    }\n\n    // Exclude trashed documents when trash: false\n    fullWhere = appendNonTrashedFilter({\n      enableTrash: collectionConfig.trash,\n      trash,\n      where: fullWhere,\n    })\n\n    const findOneArgs: FindOneArgs = {\n      collection: collectionConfig.slug,\n      locale: locale!,\n      req,\n      where: fullWhere,\n    }\n\n    const docWithLocales = await getLatestCollectionVersion<\n      RequiredDataFromCollectionSlug<TSlug> & TypeWithID\n    >({\n      id,\n      config: collectionConfig,\n      payload,\n      query: findOneArgs,\n      req,\n    })\n\n    if (!docWithLocales && !hasWherePolicy) {\n      throw new NotFound(req.t)\n    }\n    if (!docWithLocales && hasWherePolicy) {\n      throw new Forbidden(req.t)\n    }\n    if (!docWithLocales) {\n      throw new NotFound(req.t)\n    }\n\n    // /////////////////////////////////////\n    // Generate data for all files and sizes\n    // /////////////////////////////////////\n\n    const { data: newFileData, files: filesToUpload } = await generateFileData({\n      collection,\n      config,\n      data,\n      operation: 'update',\n      overwriteExistingFiles,\n      req,\n      throwOnMissingFile: false,\n    })\n\n    const select = sanitizeSelect({\n      fields: collectionConfig.flattenedFields,\n      forceSelect: collectionConfig.forceSelect,\n      select: incomingSelect,\n    })\n\n    // ///////////////////////////////////////////////\n    // Update document, runs all document level hooks\n    // ///////////////////////////////////////////////\n\n    let result = await updateDocument<TSlug, TSelect>({\n      id,\n      autosave,\n      collectionConfig,\n      config,\n      data: deepCopyObjectSimple(newFileData),\n      depth: depth!,\n      docWithLocales,\n      draftArg,\n      fallbackLocale: fallbackLocale!,\n      filesToUpload,\n      locale: locale!,\n      overrideAccess: overrideAccess!,\n      overrideLock: overrideLock!,\n      payload,\n      populate,\n      publishAllLocales,\n      publishSpecificLocale,\n      req,\n      select: select!,\n      showHiddenFields: showHiddenFields!,\n      unpublishAllLocales,\n    })\n\n    await unlinkTempFiles({\n      collectionConfig,\n      config,\n      req,\n    })\n\n    // /////////////////////////////////////\n    // afterOperation - Collection\n    // /////////////////////////////////////\n\n    result = (await buildAfterOperation({\n      args,\n      collection: collectionConfig,\n      operation: 'updateByID',\n      overrideAccess,\n      result,\n    })) as TransformCollectionWithSelect<TSlug, TSelect>\n\n    // /////////////////////////////////////\n    // Return results\n    // /////////////////////////////////////\n\n    if (shouldCommit) {\n      await commitTransaction(req)\n    }\n\n    return result\n  } catch (error: unknown) {\n    await killTransaction(args.req)\n    throw error\n  }\n}\n"],"names":["status","httpStatus","executeAccess","hasWhereAccessResult","combineQueries","APIError","Forbidden","NotFound","deepCopyObjectSimple","generateFileData","unlinkTempFiles","appendNonTrashedFilter","commitTransaction","initTransaction","killTransaction","sanitizeSelect","getLatestCollectionVersion","buildAfterOperation","buildBeforeOperation","updateDocument","updateByIDOperation","incomingArgs","args","shouldCommit","disableTransaction","req","collection","config","operation","overrideAccess","publishSpecificLocale","locale","id","autosave","collectionConfig","depth","draft","draftArg","overrideLock","overwriteExistingFiles","populate","publishAllLocales","fallbackLocale","payload","select","incomingSelect","showHiddenFields","trash","unpublishAllLocales","BAD_REQUEST","data","accessResults","access","update","hasWherePolicy","where","equals","fullWhere","isTrashAttempt","deletedAt","deleteAccessResult","delete","enableTrash","findOneArgs","slug","docWithLocales","query","t","newFileData","files","filesToUpload","throwOnMissingFile","fields","flattenedFields","forceSelect","result","error"],"mappings":"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"}},
    {"offset": {"line": 3969, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/collections/operations/local/update.ts"],"sourcesContent":["import type { DeepPartial } from 'ts-essentials'\n\nimport type {\n  CollectionSlug,\n  FindOptions,\n  Payload,\n  RequestContext,\n  TypedLocale,\n} from '../../../index.js'\nimport type {\n  Document,\n  PayloadRequest,\n  PopulateType,\n  SelectType,\n  Sort,\n  TransformCollectionWithSelect,\n  Where,\n} from '../../../types/index.js'\nimport type { File } from '../../../uploads/types.js'\nimport type { CreateLocalReqOptions } from '../../../utilities/createLocalReq.js'\nimport type {\n  BulkOperationResult,\n  DraftFlagFromCollectionSlug,\n  RequiredDataFromCollectionSlug,\n  SelectFromCollectionSlug,\n} from '../../config/types.js'\n\nimport { APIError } from '../../../errors/index.js'\nimport { getFileByPath } from '../../../uploads/getFileByPath.js'\nimport { createLocalReq } from '../../../utilities/createLocalReq.js'\nimport { updateOperation } from '../update.js'\nimport { updateByIDOperation } from '../updateByID.js'\n\nexport type BaseOptions<TSlug extends CollectionSlug, TSelect extends SelectType> = {\n  /**\n   * Whether the current update should be marked as from autosave.\n   * `versions.drafts.autosave` should be specified.\n   */\n  autosave?: boolean\n  /**\n   * the Collection slug to operate against.\n   */\n  collection: TSlug\n  /**\n   * [Context](https://payloadcms.com/docs/hooks/context), which will then be passed to `context` and `req.context`,\n   * which can be read by hooks. Useful if you want to pass additional information to the hooks which\n   * shouldn't be necessarily part of the document, for example a `triggerBeforeChange` option which can be read by the BeforeChange hook\n   * to determine if it should run or not.\n   */\n  context?: RequestContext\n  /**\n   * The document / documents data to update.\n   */\n  data: DeepPartial<RequiredDataFromCollectionSlug<TSlug>>\n  /**\n   * [Control auto-population](https://payloadcms.com/docs/queries/depth) of nested relationship and upload fields.\n   */\n  depth?: number\n  /**\n   * When set to `true`, a [database transactions](https://payloadcms.com/docs/database/transactions) will not be initialized.\n   * @default false\n   */\n  disableTransaction?: boolean\n  /**\n   * Specify a [fallback locale](https://payloadcms.com/docs/configuration/localization) to use for any returned documents.\n   */\n  fallbackLocale?: false | TypedLocale\n  /**\n   * A `File` object when updating a collection with `upload: true`.\n   */\n  file?: File\n  /**\n   * A file path when creating a collection with `upload: true`.\n   */\n  filePath?: string\n  /**\n   * Specify [locale](https://payloadcms.com/docs/configuration/localization) for any returned documents.\n   */\n  locale?: TypedLocale\n  /**\n   * Skip access control.\n   * Set to `false` if you want to respect Access Control for the operation, for example when fetching data for the front-end.\n   * @default true\n   */\n  overrideAccess?: boolean\n  /**\n   * By default, document locks are ignored (`true`). Set to `false` to enforce locks and prevent operations when a document is locked by another user. [More details](https://payloadcms.com/docs/admin/locked-documents).\n   * @default true\n   */\n  overrideLock?: boolean\n  /**\n   * If you are uploading a file and would like to replace\n   * the existing file instead of generating a new filename,\n   * you can set the following property to `true`\n   */\n  overwriteExistingFiles?: boolean\n  /**\n   * Specify [populate](https://payloadcms.com/docs/queries/select#populate) to control which fields to include to the result from populated documents.\n   */\n  populate?: PopulateType\n  /**\n   * Publish the document / documents in all locales. Requires `versions.drafts.localizeStatus` to be enabled.\n   *\n   * @default undefined\n   */\n  publishAllLocales?: boolean\n  /**\n   * Publish the document / documents with a specific locale.\n   *\n   * @default undefined\n   */\n  publishSpecificLocale?: string\n  /**\n   * The `PayloadRequest` object. You can pass it to thread the current [transaction](https://payloadcms.com/docs/database/transactions), user and locale to the operation.\n   * Recommended to pass when using the Local API from hooks, as usually you want to execute the operation within the current transaction.\n   */\n  req?: Partial<PayloadRequest>\n\n  /**\n   * Opt-in to receiving hidden fields. By default, they are hidden from returned documents in accordance to your config.\n   * @default false\n   */\n  showHiddenFields?: boolean\n  /**\n   * When set to `true`, the operation will update both normal and trashed (soft-deleted) documents.\n   * To update only trashed documents, pass `trash: true` and combine with a `where` clause filtering by `deletedAt`.\n   * By default (`false`), the update will only include normal documents and exclude those with a `deletedAt` field.\n   * @default false\n   */\n  trash?: boolean\n  /**\n   * Unpublish the document / documents in all locales. Requires `versions.drafts.localizeStatus` to be enabled.\n   */\n  unpublishAllLocales?: boolean\n  /**\n   * If you set `overrideAccess` to `false`, you can pass a user to use against the access control checks.\n   */\n  user?: Document\n} & Pick<FindOptions<TSlug, TSelect>, 'select'>\n\nexport type ByIDOptions<\n  TSlug extends CollectionSlug,\n  TSelect extends SelectFromCollectionSlug<TSlug>,\n> = {\n  /**\n   * The ID of the document to update.\n   */\n  id: number | string\n  /**\n   * Limit documents to update\n   */\n  limit?: never\n  /**\n   * Sort the documents, can be a string or an array of strings\n   * @example '-createdAt' // Sort DESC by createdAt\n   * @example ['group', '-createdAt'] // sort by 2 fields, ASC group and DESC createdAt\n   */\n  sort?: never\n  /**\n   * A filter [query](https://payloadcms.com/docs/queries/overview)\n   */\n  where?: never\n} & BaseOptions<TSlug, TSelect> &\n  DraftFlagFromCollectionSlug<TSlug>\n\nexport type ManyOptions<\n  TSlug extends CollectionSlug,\n  TSelect extends SelectFromCollectionSlug<TSlug>,\n> = {\n  /**\n   * The ID of the document to update.\n   */\n  id?: never\n  /**\n   * Limit documents to update\n   */\n  limit?: number\n  /**\n   * Sort the documents, can be a string or an array of strings\n   * @example '-createdAt' // Sort DESC by createdAt\n   * @example ['group', '-createdAt'] // sort by 2 fields, ASC group and DESC createdAt\n   */\n  sort?: Sort\n  /**\n   * A filter [query](https://payloadcms.com/docs/queries/overview)\n   */\n  where: Where\n} & BaseOptions<TSlug, TSelect> &\n  DraftFlagFromCollectionSlug<TSlug>\n\nexport type Options<\n  TSlug extends CollectionSlug,\n  TSelect extends SelectFromCollectionSlug<TSlug>,\n> = ByIDOptions<TSlug, TSelect> | ManyOptions<TSlug, TSelect>\n\nasync function updateLocal<\n  TSlug extends CollectionSlug,\n  TSelect extends SelectFromCollectionSlug<TSlug>,\n>(\n  payload: Payload,\n  options: ByIDOptions<TSlug, TSelect>,\n): Promise<TransformCollectionWithSelect<TSlug, TSelect>>\nasync function updateLocal<\n  TSlug extends CollectionSlug,\n  TSelect extends SelectFromCollectionSlug<TSlug>,\n>(\n  payload: Payload,\n  options: ManyOptions<TSlug, TSelect>,\n): Promise<BulkOperationResult<TSlug, TSelect>>\nasync function updateLocal<\n  TSlug extends CollectionSlug,\n  TSelect extends SelectFromCollectionSlug<TSlug>,\n>(\n  payload: Payload,\n  options: Options<TSlug, TSelect>,\n): Promise<BulkOperationResult<TSlug, TSelect> | TransformCollectionWithSelect<TSlug, TSelect>>\nasync function updateLocal<\n  TSlug extends CollectionSlug,\n  TSelect extends SelectFromCollectionSlug<TSlug>,\n>(\n  payload: Payload,\n  options: Options<TSlug, TSelect>,\n): Promise<BulkOperationResult<TSlug, TSelect> | TransformCollectionWithSelect<TSlug, TSelect>> {\n  const {\n    id,\n    autosave,\n    collection: collectionSlug,\n    data,\n    depth,\n    disableTransaction,\n    draft,\n    file,\n    filePath,\n    limit,\n    overrideAccess = true,\n    overrideLock,\n    overwriteExistingFiles = false,\n    populate,\n    publishAllLocales,\n    publishSpecificLocale,\n    select,\n    showHiddenFields,\n    sort,\n    trash = false,\n    unpublishAllLocales,\n    where,\n  } = options\n\n  const collection = payload.collections[collectionSlug]\n\n  if (!collection) {\n    throw new APIError(\n      `The collection with slug ${String(collectionSlug)} can't be found. Update Operation.`,\n    )\n  }\n\n  const req = await createLocalReq(options as CreateLocalReqOptions, payload)\n  req.file = file ?? (await getFileByPath(filePath!))\n\n  const args = {\n    id,\n    autosave,\n    collection,\n    data,\n    depth,\n    disableTransaction,\n    draft,\n    limit,\n    overrideAccess,\n    overrideLock,\n    overwriteExistingFiles,\n    payload,\n    populate,\n    publishAllLocales,\n    publishSpecificLocale,\n    req,\n    select,\n    showHiddenFields,\n    sort,\n    trash,\n    unpublishAllLocales,\n    where,\n  }\n\n  if (options.id) {\n    // @ts-expect-error - vestiges of when tsconfig was not strict. Feel free to improve\n    return updateByIDOperation<TSlug, TSelect>(args)\n  }\n  // @ts-expect-error - vestiges of when tsconfig was not strict. Feel free to improve\n  return updateOperation<TSlug, TSelect>(args)\n}\n\nexport { updateLocal }\n"],"names":["APIError","getFileByPath","createLocalReq","updateOperation","updateByIDOperation","updateLocal","payload","options","id","autosave","collection","collectionSlug","data","depth","disableTransaction","draft","file","filePath","limit","overrideAccess","overrideLock","overwriteExistingFiles","populate","publishAllLocales","publishSpecificLocale","select","showHiddenFields","sort","trash","unpublishAllLocales","where","collections","String","req","args"],"mappings":";;;;AA2BA,SAASA,QAAQ,QAAQ,2BAA0B;AACnD,SAASC,aAAa,QAAQ,oCAAmC;AACjE,SAASC,cAAc,QAAQ,uCAAsC;AACrE,SAASC,eAAe,QAAQ,eAAc;AAC9C,SAASC,mBAAmB,QAAQ,mBAAkB;;;;;;AAyLtD,eAAeC,YAIbC,OAAgB,EAChBC,OAAgC;IAEhC,MAAM,EACJC,EAAE,EACFC,QAAQ,EACRC,YAAYC,cAAc,EAC1BC,IAAI,EACJC,KAAK,EACLC,kBAAkB,EAClBC,KAAK,EACLC,IAAI,EACJC,QAAQ,EACRC,KAAK,EACLC,iBAAiB,IAAI,EACrBC,YAAY,EACZC,yBAAyB,KAAK,EAC9BC,QAAQ,EACRC,iBAAiB,EACjBC,qBAAqB,EACrBC,MAAM,EACNC,gBAAgB,EAChBC,IAAI,EACJC,QAAQ,KAAK,EACbC,mBAAmB,EACnBC,KAAK,EACN,GAAGvB;IAEJ,MAAMG,aAAaJ,QAAQyB,WAAW,CAACpB,eAAe;IAEtD,IAAI,CAACD,YAAY;QACf,MAAM,IAAIV,mKAAAA,CACR,CAAC,yBAAyB,EAAEgC,OAAOrB,gBAAgB,kCAAkC,CAAC;IAE1F;IAEA,MAAMsB,MAAM,UAAM/B,kLAAAA,EAAeK,SAAkCD;IACnE2B,IAAIjB,IAAI,GAAGA,QAAS,UAAMf,8KAAAA,EAAcgB;IAExC,MAAMiB,OAAO;QACX1B;QACAC;QACAC;QACAE;QACAC;QACAC;QACAC;QACAG;QACAC;QACAC;QACAC;QACAf;QACAgB;QACAC;QACAC;QACAS;QACAR;QACAC;QACAC;QACAC;QACAC;QACAC;IACF;IAEA,IAAIvB,QAAQC,EAAE,EAAE;QACd,oFAAoF;QACpF,WAAOJ,mMAAAA,EAAoC8B;IAC7C;IACA,oFAAoF;IACpF,WAAO/B,2LAAAA,EAAgC+B;AACzC"}},
    {"offset": {"line": 4028, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/collections/operations/countVersions.ts"],"sourcesContent":["import type { AccessResult } from '../../config/types.js'\nimport type { PayloadRequest, Where } from '../../types/index.js'\nimport type { Collection } from '../config/types.js'\n\nimport { executeAccess } from '../../auth/executeAccess.js'\nimport { combineQueries } from '../../database/combineQueries.js'\nimport { validateQueryPaths } from '../../database/queryValidation/validateQueryPaths.js'\nimport { sanitizeWhereQuery } from '../../database/sanitizeWhereQuery.js'\nimport { buildVersionCollectionFields, type CollectionSlug } from '../../index.js'\nimport { killTransaction } from '../../utilities/killTransaction.js'\nimport { buildAfterOperation } from './utilities/buildAfterOperation.js'\nimport { buildBeforeOperation } from './utilities/buildBeforeOperation.js'\n\nexport type Arguments = {\n  collection: Collection\n  disableErrors?: boolean\n  overrideAccess?: boolean\n  req?: PayloadRequest\n  where?: Where\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport const countVersionsOperation = async <TSlug extends CollectionSlug>(\n  incomingArgs: Arguments,\n): Promise<{ totalDocs: number }> => {\n  let args = incomingArgs\n\n  try {\n    // /////////////////////////////////////\n    // beforeOperation - Collection\n    // /////////////////////////////////////\n\n    args = await buildBeforeOperation({\n      args,\n      collection: args.collection.config,\n      operation: 'countVersions',\n      overrideAccess: args.overrideAccess!,\n    })\n\n    const {\n      collection: { config: collectionConfig },\n      disableErrors,\n      overrideAccess,\n      req,\n      where,\n    } = args\n\n    const { locale, payload } = req!\n\n    // /////////////////////////////////////\n    // Access\n    // /////////////////////////////////////\n\n    let accessResult: AccessResult\n\n    if (!overrideAccess) {\n      accessResult = await executeAccess(\n        { disableErrors, req: req! },\n        collectionConfig.access.readVersions,\n      )\n\n      // If errors are disabled, and access returns false, return empty results\n      if (accessResult === false) {\n        return {\n          totalDocs: 0,\n        }\n      }\n    }\n\n    let result: { totalDocs: number }\n\n    const fullWhere = combineQueries(where!, accessResult!)\n\n    const versionFields = buildVersionCollectionFields(payload.config, collectionConfig, true)\n\n    sanitizeWhereQuery({ fields: versionFields, payload, where: fullWhere })\n\n    await validateQueryPaths({\n      collectionConfig,\n      overrideAccess: overrideAccess!,\n      req: req!,\n      versionFields,\n      where: where!,\n    })\n\n    result = await payload.db.countVersions({\n      collection: collectionConfig.slug,\n      locale: locale!,\n      req,\n      where: fullWhere,\n    })\n\n    // /////////////////////////////////////\n    // afterOperation - Collection\n    // /////////////////////////////////////\n\n    result = await buildAfterOperation({\n      args,\n      collection: collectionConfig,\n      operation: 'countVersions',\n      overrideAccess,\n      result,\n    })\n\n    // /////////////////////////////////////\n    // Return results\n    // /////////////////////////////////////\n\n    return result\n  } catch (error: unknown) {\n    await killTransaction(args.req!)\n    throw error\n  }\n}\n"],"names":["executeAccess","combineQueries","validateQueryPaths","sanitizeWhereQuery","buildVersionCollectionFields","killTransaction","buildAfterOperation","buildBeforeOperation","countVersionsOperation","incomingArgs","args","collection","config","operation","overrideAccess","collectionConfig","disableErrors","req","where","locale","payload","accessResult","access","readVersions","totalDocs","result","fullWhere","versionFields","fields","db","countVersions","slug","error"],"mappings":";;;;AAIA,SAASA,aAAa,QAAQ,8BAA6B;AAC3D,SAASC,cAAc,QAAQ,mCAAkC;AACjE,SAASC,kBAAkB,QAAQ,uDAAsD;AACzF,SAASC,kBAAkB,QAAQ,uCAAsC;AACzE,SAASC,4BAA4B,QAA6B,iBAAgB;AAClF,SAASC,eAAe,QAAQ,qCAAoC;AACpE,SAASC,mBAAmB,QAAQ,qCAAoC;AACxE,SAASC,oBAAoB,QAAQ,sCAAqC;;;;;;;;;AAWnE,MAAMC,yBAAyB,OACpCC;IAEA,IAAIC,OAAOD;IAEX,IAAI;QACF,wCAAwC;QACxC,+BAA+B;QAC/B,wCAAwC;QAExCC,OAAO,UAAMH,2NAAAA,EAAqB;YAChCG;YACAC,YAAYD,KAAKC,UAAU,CAACC,MAAM;YAClCC,WAAW;YACXC,gBAAgBJ,KAAKI,cAAc;QACrC;QAEA,MAAM,EACJH,YAAY,EAAEC,QAAQG,gBAAgB,EAAE,EACxCC,aAAa,EACbF,cAAc,EACdG,GAAG,EACHC,KAAK,EACN,GAAGR;QAEJ,MAAM,EAAES,MAAM,EAAEC,OAAO,EAAE,GAAGH;QAE5B,wCAAwC;QACxC,SAAS;QACT,wCAAwC;QAExC,IAAII;QAEJ,IAAI,CAACP,gBAAgB;YACnBO,eAAe,UAAMrB,2KAAAA,EACnB;gBAAEgB;gBAAeC,KAAKA;YAAK,GAC3BF,iBAAiBO,MAAM,CAACC,YAAY;YAGtC,yEAAyE;YACzE,IAAIF,iBAAiB,OAAO;gBAC1B,OAAO;oBACLG,WAAW;gBACb;YACF;QACF;QAEA,IAAIC;QAEJ,MAAMC,gBAAYzB,iLAAAA,EAAeiB,OAAQG;QAEzC,MAAMM,oBAAgBvB,sMAAAA,EAA6BgB,QAAQR,MAAM,EAAEG,kBAAkB;YAErFZ,yLAAAA,EAAmB;YAAEyB,QAAQD;YAAeP;YAASF,OAAOQ;QAAU;QAEtE,UAAMxB,4MAAAA,EAAmB;YACvBa;YACAD,gBAAgBA;YAChBG,KAAKA;YACLU;YACAT,OAAOA;QACT;QAEAO,SAAS,MAAML,QAAQS,EAAE,CAACC,aAAa,CAAC;YACtCnB,YAAYI,iBAAiBgB,IAAI;YACjCZ,QAAQA;YACRF;YACAC,OAAOQ;QACT;QAEA,wCAAwC;QACxC,8BAA8B;QAC9B,wCAAwC;QAExCD,SAAS,UAAMnB,yNAAAA,EAAoB;YACjCI;YACAC,YAAYI;YACZF,WAAW;YACXC;YACAW;QACF;QAEA,wCAAwC;QACxC,iBAAiB;QACjB,wCAAwC;QAExC,OAAOA;IACT,EAAE,OAAOO,OAAgB;QACvB,UAAM3B,oLAAAA,EAAgBK,KAAKO,GAAG;QAC9B,MAAMe;IACR;AACF,EAAC"}},
    {"offset": {"line": 4122, "column": 0}, "map": {"version":3,"sources":["file:///Users/atamanov/Documents/Projects/ways2spain-landing/node_modules/payload/src/collections/operations/local/countVersions.ts"],"sourcesContent":["import type { CollectionSlug, Payload, RequestContext, TypedLocale } from '../../../index.js'\nimport type { Document, PayloadRequest, Where } from '../../../types/index.js'\nimport type { CreateLocalReqOptions } from '../../../utilities/createLocalReq.js'\n\nimport { APIError } from '../../../errors/index.js'\nimport { createLocalReq } from '../../../utilities/createLocalReq.js'\nimport { countVersionsOperation } from '../countVersions.js'\n\nexport type CountVersionsOptions<TSlug extends CollectionSlug> = {\n  /**\n   * the Collection slug to operate against.\n   */\n  collection: TSlug\n  /**\n   * [Context](https://payloadcms.com/docs/hooks/context), which will then be passed to `context` and `req.context`,\n   * which can be read by hooks. Useful if you want to pass additional information to the hooks which\n   * shouldn't be necessarily part of the document, for example a `triggerBeforeChange` option which can be read by the BeforeChange hook\n   * to determine if it should run or not.\n   */\n  context?: RequestContext\n  /**\n   * When set to `true`, errors will not be thrown.\n   */\n  disableErrors?: boolean\n  /**\n   * Specify [locale](https://payloadcms.com/docs/configuration/localization) for any returned documents.\n   */\n  locale?: TypedLocale\n  /**\n   * Skip access control.\n   * Set to `false` if you want to respect Access Control for the operation, for example when fetching data for the front-end.\n   * @default true\n   */\n  overrideAccess?: boolean\n  /**\n   * The `PayloadRequest` object. You can pass it to thread the current [transaction](https://payloadcms.com/docs/database/transactions), user and locale to the operation.\n   * Recommended to pass when using the Local API from hooks, as usually you want to execute the operation within the current transaction.\n   */\n  req?: Partial<PayloadRequest>\n  /**\n   * If you set `overrideAccess` to `false`, you can pass a user to use against the access control checks.\n   */\n  user?: Document\n  /**\n   * A filter [query](https://payloadcms.com/docs/queries/overview)\n   */\n  where?: Where\n}\n\nexport async function countVersionsLocal<TSlug extends CollectionSlug>(\n  payload: Payload,\n  options: CountVersionsOptions<TSlug>,\n): Promise<{ totalDocs: number }> {\n  const { collection: collectionSlug, disableErrors, overrideAccess = true, where } = options\n\n  const collection = payload.collections[collectionSlug]\n\n  if (!collection) {\n    throw new APIError(\n      `The collection with slug ${String(collectionSlug)} can't be found. Count Versions Operation.`,\n    )\n  }\n\n  return countVersionsOperation<TSlug>({\n    collection,\n    disableErrors,\n    overrideAccess,\n    req: await createLocalReq(options as CreateLocalReqOptions, payload),\n    where,\n  })\n}\n"],"names":["APIError","createLocalReq","countVersionsOperation","countVersionsLocal","payload","options","collection","collectionSlug","disableErrors","overrideAccess","where","collections","String","req"],"mappings":";;;;AAIA,SAASA,QAAQ,QAAQ,2BAA0B;AACnD,SAASC,cAAc,QAAQ,uCAAsC;AACrE,SAASC,sBAAsB,QAAQ,sBAAqB;;;;AA2CrD,eAAeC,mBACpBC,OAAgB,EAChBC,OAAoC;IAEpC,MAAM,EAAEC,YAAYC,cAAc,EAAEC,aAAa,EAAEC,iBAAiB,IAAI,EAAEC,KAAK,EAAE,GAAGL;IAEpF,MAAMC,aAAaF,QAAQO,WAAW,CAACJ,eAAe;IAEtD,IAAI,CAACD,YAAY;QACf,MAAM,IAAIN,mKAAAA,CACR,CAAC,yBAAyB,EAAEY,OAAOL,gBAAgB,0CAA0C,CAAC;IAElG;IAEA,WAAOL,yMAAAA,EAA8B;QACnCI;QACAE;QACAC;QACAI,KAAK,UAAMZ,kLAAAA,EAAeI,SAAkCD;QAC5DM;IACF;AACF"}}]
}